[
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (based on normalized objective scores) and applies a hybrid local search combining 3-opt moves with adaptive perturbations to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower combined normalized objectives and uses random edge selections and segment reversals to explore the search space. The adaptive perturbation (30% chance) adds diversity by occasionally reversing random segments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)  # Select the most balanced solution\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with adaptive perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Reconstruct with different orderings\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_order)) == n:\n        new_solution[i:] = new_order\n\n    # Adaptive perturbation: sometimes reverse a random segment\n    if np.random.rand() < 0.3:  # 30% chance\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.928347725901247,
            5.863588582794563
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by normalizing and summing the objective values, then applies a hybrid local search combining 3-opt with an objective-aware swap prioritizing nodes with high combined distances in both objective spaces. It systematically evaluates potential swaps to improve both objectives simultaneously, ensuring feasibility through structured node selection and cost calculations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with structured objective-aware selection\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[b:c+1] = np.flip(new_solution[b:c+1])\n\n    # Objective-aware worst-node targeting\n    total_distances = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_ = new_solution[(i+1)%n]\n        total_distances[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_] + \\\n                             distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n    worst_node = np.argmax(total_distances)\n\n    # Find the best swap candidate (node that improves both objectives)\n    best_swap = worst_node\n    for i in range(n):\n        if i != worst_node:\n            prev = new_solution[(worst_node-1)%n]\n            curr = new_solution[worst_node]\n            next_ = new_solution[(worst_node+1)%n]\n            new_prev = new_solution[(i-1)%n]\n            new_curr = new_solution[i]\n            new_next = new_solution[(i+1)%n]\n\n            old_cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n            new_cost1 = distance_matrix_1[prev, new_curr] + distance_matrix_1[new_curr, next_] + \\\n                        distance_matrix_1[new_prev, curr] + distance_matrix_1[curr, new_next]\n            delta1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n            new_cost2 = distance_matrix_2[prev, new_curr] + distance_matrix_2[new_curr, next_] + \\\n                        distance_matrix_2[new_prev, curr] + distance_matrix_2[curr, new_next]\n            delta2 = new_cost2 - old_cost2\n\n            if delta1 < 0 and delta2 < 0:\n                best_swap = i\n                break\n\n    if best_swap != worst_node:\n        new_solution[worst_node], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            6.166820109168404,
            5.767610019830773
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined objective values from the archive, then applies a hybrid local search combining 3-opt with a biased random swap. It first performs a 3-opt move by reversing a randomly selected segment of the tour, and with 50% probability, it identifies the worst node (based on total distance in both objectives) and attempts to swap it with a node that improves both objectives. The method ensures feasibility by maintaining a valid TSP tour throughout the process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a biased random swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices for 3-opt\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt: reverse the segment between b and c\n    new_solution[b:c+1] = np.flip(new_solution[b:c+1])\n\n    # With 50% probability, perform a biased random swap to explore further\n    if np.random.rand() < 0.5:\n        # Find the node with the highest total distance in both spaces\n        total_distances = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_ = new_solution[(i+1)%n]\n            total_distances[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_] + \\\n                                 distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n        worst_node = np.argmax(total_distances)\n        best_swap = worst_node\n\n        # Find the best swap candidate (node that improves both objectives)\n        for i in range(n):\n            if i != worst_node:\n                # Calculate the change in both objectives for this swap\n                prev = new_solution[(worst_node-1)%n]\n                curr = new_solution[worst_node]\n                next_ = new_solution[(worst_node+1)%n]\n                new_prev = new_solution[(i-1)%n]\n                new_curr = new_solution[i]\n                new_next = new_solution[(i+1)%n]\n\n                old_cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n                new_cost1 = distance_matrix_1[prev, new_curr] + distance_matrix_1[new_curr, next_] + \\\n                            distance_matrix_1[new_prev, curr] + distance_matrix_1[curr, new_next]\n                delta1 = new_cost1 - old_cost1\n\n                old_cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n                new_cost2 = distance_matrix_2[prev, new_curr] + distance_matrix_2[new_curr, next_] + \\\n                            distance_matrix_2[new_prev, curr] + distance_matrix_2[curr, new_next]\n                delta2 = new_cost2 - old_cost2\n\n                if delta1 < 0 and delta2 < 0:\n                    best_swap = i\n                    break\n\n        # Perform the swap if beneficial\n        if best_swap != worst_node:\n            new_solution[worst_node], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            6.234115045215999,
            5.848944090331401
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined normalized objective values, then applies a hybrid local search combining objective-aware edge insertion (targeting the worst-performing edges in both objectives) and a controlled 2.5-opt move (with 40% probability) to generate a neighbor solution while ensuring feasibility. The edge insertion step focuses on improving both objectives simultaneously, while the 2.5-opt move adds diversity by reversing segments and reinserting nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: objective-aware edge insertion + 2.5-opt\n    # Step 1: Identify the worst edge in both objectives\n    worst_edge = None\n    max_total_cost = -1\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_ = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n        total_cost = cost1 + cost2\n        if total_cost > max_total_cost:\n            max_total_cost = total_cost\n            worst_edge = i\n\n    # Step 2: Objective-aware edge insertion\n    if worst_edge is not None:\n        # Remove the worst edge's node\n        node_to_insert = new_solution[worst_edge]\n        new_solution = np.delete(new_solution, worst_edge)\n\n        # Find the best insertion point for the removed node to improve both objectives\n        best_pos = -1\n        min_total_delta = float('inf')\n        for i in range(n-1):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_ = new_solution[(i+1)%(n-1)]\n\n            # Calculate delta for first insertion (before curr)\n            delta1 = distance_matrix_1[prev, node_to_insert] + distance_matrix_1[node_to_insert, curr] - distance_matrix_1[prev, curr]\n            delta2 = distance_matrix_2[prev, node_to_insert] + distance_matrix_2[node_to_insert, curr] - distance_matrix_2[prev, curr]\n            total_delta = delta1 + delta2\n\n            if total_delta < min_total_delta:\n                min_total_delta = total_delta\n                best_pos = i\n\n            # Calculate delta for second insertion (after curr)\n            delta1 = distance_matrix_1[curr, node_to_insert] + distance_matrix_1[node_to_insert, next_] - distance_matrix_1[curr, next_]\n            delta2 = distance_matrix_2[curr, node_to_insert] + distance_matrix_2[node_to_insert, next_] - distance_matrix_2[curr, next_]\n            total_delta = delta1 + delta2\n\n            if total_delta < min_total_delta:\n                min_total_delta = total_delta\n                best_pos = i+1\n\n        # Insert the node at the best position\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Step 3: 2.5-opt move (reverse a segment and reinsert a node)\n    if np.random.rand() < 0.4:  # 40% chance\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        # Reverse segment between a and b\n        new_solution[a:b] = new_solution[a:b][::-1]\n        # Remove node at c and reinsert it at a random position\n        node_to_move = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            6.7565940626884,
            5.849808967680021
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive using a weighted sum of normalized objectives, then applies either a 3-opt or segment relocation operator to generate a neighbor, ensuring feasibility while prioritizing exploration of the solution space. For small instances, it defaults to simple swaps, balancing diversification and intensification through random selection and hybrid local search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives and select based on weighted sum\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        weights = np.random.dirichlet(np.ones(2))\n        scores = (normalized * weights).sum(axis=1)\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n >= 5:\n        # Randomly choose between 3-opt and segment relocation\n        if np.random.rand() < 0.5:\n            # 3-opt: randomly select 3 edges and reconnect them\n            a, b, c = sorted(np.random.choice(n, 3, replace=False))\n            # Reconnect the three segments\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n            new_solution[a:c] = new_solution[a:c][::-1]\n        else:\n            # Segment relocation: move a random segment to a different position\n            seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n            new_pos = np.random.randint(0, n)\n            segment = new_solution[seg_start:seg_end]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_end:new_pos],\n                segment,\n                new_solution[new_pos:seg_start],\n                new_solution[seg_end:]\n            ])\n    else:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.762951606074603,
            6.548032432704561
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive by prioritizing those with lower total costs in either objective space, then applies a hybrid local search combining random segment reordering and occasional node swaps to generate a neighbor solution while ensuring feasibility. The algorithm balances exploration (random segment shuffling) and exploitation (targeting lower-cost solutions) while maintaining tour validity through duplicate checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower total cost in either objective space\n    archive_sorted = sorted(archive, key=lambda x: min(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge insertion + node reordering\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reorder\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 2, n)\n\n    # Extract the segment and reverse it\n    segment = new_solution[seg_start:seg_end]\n    np.random.shuffle(segment)\n    new_solution[seg_start:seg_end] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original segment\n        new_solution[seg_start:seg_end] = selected_solution[seg_start:seg_end]\n\n    # Additional: randomly swap two nodes to further explore\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.920911418166373,
            7.983830444680792
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of objectives) and applies a hybrid local search combining random swaps and segment reversals to explore diverse neighborhoods while ensuring feasibility. The selected solution is copied, and then 10 iterations of random swaps and segment reversals are performed to generate a neighbor solution. The algorithm prioritizes solutions with lower combined objective values and uses stochastic local search to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: random swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            8.721355880941434,
            8.525583452943698
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest objective diversity (maximizing the absolute difference between the two objectives) and applies a hybrid local search combining 4-opt moves and targeted segment reversals, prioritizing nodes with high combined costs in both objective spaces to improve both objectives while ensuring feasibility. It first identifies the top 4 high-cost nodes, applies a 4-opt move on them, and then reverses segments between these nodes with a 40% probability.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    diversity_scores = []\n    for _, obj in archive:\n        diversity_scores.append(np.abs(obj[0] - obj[1]))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 4-opt with targeted segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify nodes with high combined cost\n    total_costs = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        total_costs.append(cost1 + cost2)\n    high_cost_nodes = np.argsort(total_costs)[-4:]  # Select top 4 high-cost nodes\n\n    # Apply 4-opt move on selected nodes\n    i, j, k, l = sorted(np.random.choice(high_cost_nodes, 4, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:l]\n    segment4 = new_solution[l:]\n\n    # Reconstruct with different orderings\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3, segment4[::-1]])\n    else:\n        new_order = np.concatenate([segment1[::-1], segment2, segment3[::-1], segment4])\n\n    # Ensure feasibility\n    if len(np.unique(new_order)) == n:\n        new_solution[i:] = new_order\n\n    # Targeted segment reversal: reverse segments between high-cost nodes\n    for idx in high_cost_nodes:\n        if np.random.rand() < 0.4:  # 40% chance for each high-cost node\n            start = idx\n            end = (idx + np.random.randint(2, 5)) % n\n            if start > end:\n                start, end = end, start\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            8.857040099528474,
            9.71578239849925
        ]
    },
    {
        "algorithm": "The algorithm selects the most diverse solution from the archive (based on objective variance) and applies a hybrid local search combining 4-opt moves with adaptive node insertion and worst-node targeting. It prioritizes improving high-cost nodes while maintaining feasibility through random segment reversals and intelligent segment reordering. The method balances exploration (randomness) and exploitation (targeted improvements) to navigate the bi-objective TSP landscape effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    scores = np.sum(diversity * objectives, axis=1)\n    selected_idx = np.argmax(scores)  # Select the most diverse solution\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with adaptive node insertion\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Apply 4-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:l]\n    segment5 = new_solution[l:]\n\n    # Reconstruct with different orderings\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment3, segment2, segment4, segment5])\n    else:\n        new_order = np.concatenate([segment1, segment2[::-1], segment4[::-1], segment3, segment5])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    # Worst-node targeting: identify and improve the worst node\n    total_costs = np.zeros(n)\n    for idx in range(n):\n        prev = new_solution[idx-1]\n        curr = new_solution[idx]\n        next_node = new_solution[(idx+1)%n]\n        total_costs[idx] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                          distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n    worst_node_idx = np.argmax(total_costs)\n    worst_node = new_solution[worst_node_idx]\n\n    # Insert worst node in a better position\n    possible_insertions = [i for i in range(n) if i != worst_node_idx and (i-1) != worst_node_idx and (i+1)%n != worst_node_idx]\n    if possible_insertions:\n        best_insert_pos = np.random.choice(possible_insertions)\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            np.array([worst_node]),\n            new_solution[best_insert_pos:worst_node_idx],\n            new_solution[worst_node_idx+1:]\n        ])\n\n    # Adaptive perturbation: sometimes reverse a random segment\n    if np.random.rand() < 0.2:  # 20% chance\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.083428288030387,
            10.128783782420232
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from an archive based on their normalized objective scores, prioritizing those with higher potential for improvement, then applies a hybrid local search that targets worst-performing segments (identified by cost differences) with operations like reversal or relocation, balancing exploitation of underperforming regions with adaptive perturbations to maintain exploration. The method ensures feasibility by structured segment manipulations while dynamically adapting operator selection based on segment characteristics and solution dominance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives and select based on worst-performing segments\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        scores = np.sum(normalized, axis=1)\n        selected_idx = np.argmax(scores)  # Select the solution with highest potential for improvement\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify worst-performing segments based on objective contributions\n    def calculate_segment_cost(solution, distance_matrix):\n        total_cost = 0\n        for i in range(n):\n            total_cost += distance_matrix[solution[i-1], solution[i]]\n        return total_cost\n\n    cost1 = calculate_segment_cost(new_solution, distance_matrix_1)\n    cost2 = calculate_segment_cost(new_solution, distance_matrix_2)\n\n    # Find the segment with highest normalized cost difference\n    max_diff = -1\n    worst_segment = None\n    for i in range(n):\n        for j in range(i+2, min(i+5, n)):  # Check segments of length 2-4\n            segment = new_solution[i:j]\n            segment_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(len(segment)))\n            segment_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(len(segment)))\n            norm_diff = abs(segment_cost1/cost1 - segment_cost2/cost2)\n            if norm_diff > max_diff:\n                max_diff = norm_diff\n                worst_segment = (i, j)\n\n    if worst_segment:\n        i, j = worst_segment\n        segment = new_solution[i:j]\n\n        # Apply hybrid operator: either reverse or relocate the worst segment\n        if np.random.rand() < 0.7:  # 70% chance for targeted operation\n            if np.random.rand() < 0.5:\n                # Reverse the worst segment\n                new_solution[i:j] = segment[::-1]\n            else:\n                # Relocate the worst segment to a new position\n                new_pos = np.random.randint(0, n)\n                new_solution = np.concatenate([\n                    new_solution[:i],\n                    new_solution[j:new_pos],\n                    segment,\n                    new_solution[new_pos:i],\n                    new_solution[j:]\n                ])\n        else:\n            # Adaptive perturbation: reverse a random segment\n            start, end = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.486231874015179,
            10.65104977855049
        ]
    }
]