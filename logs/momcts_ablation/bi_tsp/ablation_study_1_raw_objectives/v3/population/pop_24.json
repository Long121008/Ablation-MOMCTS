[
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing those with lower combined objective scores) and applies a hybrid local search combining edge insertion and segment reversal to generate neighbor solutions, ensuring feasibility by maintaining valid TSP tours. The selection process focuses on high-quality solutions, while the local search operator introduces diverse modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined score (lower is better)\n    def combined_score(solution, objectives):\n        return objectives[0] + objectives[1]\n\n    # Sort archive by combined score and select the best 10% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Remove edge between i and j\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert segment at a random new position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7847710985497653,
            0.17851996421813965
        ],
        "raw_score": [
            6.337478923049993,
            6.463198668542717
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive (prioritizing non-dominated or diverse solutions) and applies a hybrid local search combining edge exchange and segment reordering to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes and falling back to simpler swaps if needed. The selection is random but could be enhanced to prioritize solutions with lower costs or higher diversity, while the local search focuses on both edge-level and segment-level modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange followed by segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange (swap two edges)\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reordering (reverse a random segment)\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9622793977855487,
            0.20448201894760132
        ],
        "raw_score": [
            7.30701335952615,
            7.020446555862451
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those with lower weighted combined scores (70% weight on the first objective, 30% on the second), then applies a hybrid local search combining segment rotation and non-adjacent node swaps to generate feasible neighbor solutions while ensuring validity. The weighted scoring balances both objectives, and the local search operators introduce diversity through segment rotation and targeted node swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best weighted combined score (lower is better)\n    def weighted_score(solution, objectives):\n        return 0.7 * objectives[0] + 0.3 * objectives[1]\n\n    # Sort archive by weighted score and select the best 15% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: weighted_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 7)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Segment rotation (rotate a random segment by a random amount)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Step 2: Node swap (swap two nodes that are not adjacent)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i - j) == 1:  # Ensure nodes are not adjacent\n            i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9024818063105666,
            0.17928367853164673
        ],
        "raw_score": [
            6.0682416639386965,
            8.263773747526876
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid approach combining Pareto dominance and dynamic objective weighting, then applies a multi-stage local search involving adaptive segment reversal, non-sequential node insertion, and objective-aware edge swaps to generate high-quality neighbors while ensuring feasibility. The selection prioritizes Pareto-dominant solutions but falls back to weighted scoring if none exist, with weights dynamically adjusted based on archive diversity. The local search stages progressively refine the solution by manipulating segments and edges, with the edge swap stage specifically considering both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: Pareto-dominant solutions first, then dynamic weighted scoring\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Dynamic weighting based on current archive diversity\n        obj1_avg = np.mean([obj[0] for _, obj in archive])\n        obj2_avg = np.mean([obj[1] for _, obj in archive])\n        weight = 0.5 + 0.5 * (obj1_avg / (obj1_avg + obj2_avg + 1e-6))  # Bias toward first objective if more diverse\n\n        selected = sorted(pareto_front, key=lambda x: weight * x[1][0] + (1-weight) * x[1][1])[0][0]\n    else:\n        # Fallback to best weighted solution\n        weight = 0.6\n        selected = sorted(archive, key=lambda x: weight * x[1][0] + (1-weight) * x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-stage local search\n    # Stage 1: Adaptive segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    if random.random() < 0.7:  # Higher chance for reversal\n        new_solution[a:b+1] = segment[::-1]\n\n    # Stage 2: Non-sequential node insertion\n    if n >= 5:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i-j) <= 1:\n            i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Stage 3: Objective-aware edge swap\n    if n >= 4:\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.998267486701493,
            0.3527350425720215
        ],
        "raw_score": [
            10.47269543601011,
            10.578669860567175
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a novel \"cross-space segment relocation\" operator that dynamically adapts segment lengths based on objective trade-offs, prioritizing high-potential regions while ensuring feasibility through a two-phase validation process. It selects solutions intelligently (favoring Pareto fronts but exploring dominated solutions probabilistically) and applies a weighted objective scoring to balance improvement across both spaces, with a fallback to simple swaps if feasibility is compromised. The critical design ideas are the dynamic segment relocation, weighted objective prioritization, and the hybrid selection strategy that balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection with dynamic exploration\n    objectives = np.array([obj for _, obj in archive])\n    is_pareto_efficient = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                is_pareto_efficient[i] = False\n    pareto_indices = np.where(is_pareto_efficient)[0]\n\n    if len(pareto_indices) > 0:\n        candidates = pareto_indices\n    else:\n        # Explore dominated solutions with probability based on archive size\n        exploration_prob = min(0.3, 1.0 / (len(archive) + 1))\n        if np.random.rand() < exploration_prob:\n            candidates = np.random.choice(len(archive), size=max(1, len(archive) // 5), replace=False)\n        else:\n            candidates = np.array([np.argmin(objectives[:, 0] + objectives[:, 1])])\n\n    # Dynamic weighted selection\n    weight = 0.5 + 0.5 * np.random.rand()  # Random weight between 0.5 and 1.0\n    scores = weight * objectives[:, 0] + (1 - weight) * objectives[:, 1]\n    selected_idx = candidates[np.argmin(scores[candidates])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Cross-space segment relocation\n    segment_length = min(n // 3, max(2, int(np.random.normal(n // 4, n // 6))))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1, cost2\n\n    # Try different insertion points\n    best_improvement = 0\n    best_insert_pos = -1\n    original_cost1, original_cost2 = calculate_improvement(new_solution)\n\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos + segment_length:]\n        ])\n        # Calculate improvement\n        new_cost1, new_cost2 = calculate_improvement(candidate)\n        improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos + segment_length:]\n        ])\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0246042744516743,
            5.167974233627319
        ],
        "raw_score": [
            10.47992649312583,
            10.62714912616767
        ]
    },
    {
        "algorithm": "The algorithm selects top 20% Pareto-efficient solutions from the archive (using hypervolume) and applies a hybrid local search with dynamic operator weighting (alternating between edge swaps and segment rotations) to generate neighbors, ensuring feasibility by validating tours and recalculating objectives. It also includes a 10% chance to reintroduce dominated solutions for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% Pareto-efficient solutions\n    def hypervolume(obj):\n        return obj[0] + obj[1]\n\n    sorted_archive = sorted(archive, key=lambda x: hypervolume(x[1]))\n    top_k = max(1, len(sorted_archive) // 5)\n    selected = sorted_archive[:top_k]\n\n    # 10% chance to reintroduce dominated solutions\n    if random.random() < 0.1 and len(archive) > top_k:\n        selected = archive[top_k:]\n\n    base_solution, base_obj = random.choice(selected)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator weighting (alternates between 70/30 and 30/70 every 10 iterations)\n    iteration = random.randint(0, 19)\n    if iteration < 10:\n        operator_weight = 0.7\n    else:\n        operator_weight = 0.3\n\n    # Edge swaps (dynamic weight)\n    if random.random() < operator_weight:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotations (remaining weight)\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.choice([1, -1])\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = rotated_segment\n\n    # Cross-space validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9147664508158446,
            0.1948050856590271
        ],
        "raw_score": [
            6.161033810958136,
            6.307287034984366
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution from the archive (based on the sum of both objectives) and applies a hybrid local search operator: reversing a random segment of the tour and performing a random node swap, while ensuring the solution remains valid by checking for duplicates. The method prioritizes diversification by randomly modifying the tour structure, with fallback to the original solution if invalidity occurs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Apply a hybrid local search operator: a combination of edge insertion and node swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n    segment = new_solution[start:end]\n\n    # Reverse the segment to create a new tour\n    new_segment = segment[::-1]\n    new_solution[start:end] = new_segment\n\n    # Perform a random swap between two nodes\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9581710917107531,
            0.20549225807189941
        ],
        "raw_score": [
            10.422623819898265,
            10.398352035590081
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by combining their objective scores, then applies a hybrid local search combining objective-biased edge swaps, edge insertions, and segment reversals to generate feasible neighbor solutions while prioritizing edges with higher costs in the less favorable objective. The method ensures validity by maintaining valid TSP tours through careful segment manipulation and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined score (lower is better)\n    def combined_score(solution, objectives):\n        return objectives[0] + objectives[1]\n\n    # Sort archive by combined score and select the best 10% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Objective-biased edge swap (swap edges based on which objective they belong to)\n    def get_edge_objective(i, j, matrix):\n        return matrix[i, j]\n\n    # Choose a random edge to swap\n    i = random.randint(0, n-1)\n    j = (i + 1) % n\n\n    # Decide which objective to prioritize for the swap\n    obj1_cost = get_edge_objective(new_solution[i], new_solution[j], distance_matrix_1)\n    obj2_cost = get_edge_objective(new_solution[i], new_solution[j], distance_matrix_2)\n\n    if obj1_cost > obj2_cost:\n        # Swap edges based on objective 1\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n    else:\n        # Swap edges based on objective 2\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Step 2: Edge insertion (move a random edge to a new position)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 3: Segment reversal (reverse a random segment)\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8789912793056229,
            0.17964571714401245
        ],
        "raw_score": [
            6.999801024342688,
            6.553088726449999
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid criterion that prioritizes non-dominated solutions (70% weight) while balancing diversity (30%) and randomness (10% noise). It then applies a novel segment-based path relinking operator, where a random segment of the tour is extracted and reinserted elsewhere, with a fallback to segment reversal if feasibility is violated. The method ensures valid TSP tours by checking for duplicate nodes and maintains exploration by varying segment lengths and positions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion: prioritize non-dominated solutions with diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.array([not any((objectives[:, 0] < obj[0]) & (objectives[:, 1] < obj[1])) for obj in objectives])\n\n    # Normalize objectives and compute diversity\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.linalg.norm(obj - norm_objectives.mean(axis=0)) for obj in norm_objectives])\n\n    # Combine scores: pareto dominance, diversity, and randomness\n    selection_scores = (1 - pareto_front.astype(float)) * 0.7 + 0.3 * diversity + np.random.uniform(0, 0.1)\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel local search: segment-based path relinking\n    segment_length = max(2, np.random.randint(2, min(5, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract and relink segments\n    segment = new_solution[start:end]\n    remaining = np.setdiff1d(new_solution, segment)\n    new_solution = np.concatenate([remaining[:start], segment, remaining[start:]])\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9784415896557843,
            1.3190977573394775
        ],
        "raw_score": [
            9.983089833292196,
            9.77177705950199
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by first identifying top 20% Pareto-efficient solutions (or 10% dominated if insufficient), then dynamically balances objectives with alternating weights (0.6/0.4 or 0.4/0.6) to prioritize solutions with lower combined cost. It applies a hybrid local search (70% cross-space-aware edge swaps prioritizing high-improvement edges and 30% segment rotations) while ensuring feasibility through validation and fallback to simpler swaps if needed. The method intelligently balances exploration and exploitation by focusing on high-potential edges and segments while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(archive)\n    top_k = max(1, int(0.2 * n_solutions))\n\n    # Find Pareto front\n    pareto_indices = []\n    for i in range(n_solutions):\n        dominated = False\n        for j in range(n_solutions):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_indices.append(i)\n\n    if len(pareto_indices) >= top_k:\n        selected_indices = np.random.choice(pareto_indices, top_k, replace=False)\n    else:\n        # If not enough Pareto solutions, select from dominated (10%)\n        dominated_indices = [i for i in range(n_solutions) if i not in pareto_indices]\n        top_k_dominated = max(1, int(0.1 * n_solutions))\n        selected_indices = np.random.choice(dominated_indices, top_k_dominated, replace=False)\n\n    # Dynamic weighting (alternate between 0.6/0.4 and 0.4/0.6)\n    if np.random.random() < 0.5:\n        weights = np.array([0.6, 0.4])\n    else:\n        weights = np.array([0.4, 0.6])\n\n    # Select solution with lowest weighted objective\n    weighted_scores = np.array([np.dot(obj, weights) for obj in objectives[selected_indices]])\n    selected_idx = selected_indices[np.argmin(weighted_scores)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search\n    if np.random.random() < 0.7:  # 70% edge swaps\n        # Cross-space aware edge selection\n        def edge_cost(i, j):\n            a, b = new_solution[i], new_solution[j]\n            cost1 = distance_matrix_1[a, b] + distance_matrix_1[new_solution[(i-1)%n], a] + distance_matrix_1[b, new_solution[(j+1)%n]]\n            cost2 = distance_matrix_2[a, b] + distance_matrix_2[new_solution[(i-1)%n], a] + distance_matrix_2[b, new_solution[(j+1)%n]]\n            return cost1 + cost2\n\n        # Find edges with highest potential improvement\n        edge_scores = []\n        for i in range(n):\n            for j in range(i+1, n):\n                edge_scores.append((edge_cost(i, j), (i, j)))\n        edge_scores.sort(reverse=True)\n\n        # Select top 10% edges to consider\n        top_edges = min(10, len(edge_scores))\n        selected_edges = [edge for _, edge in edge_scores[:top_edges]]\n\n        if selected_edges:\n            i, j = selected_edges[np.random.randint(0, len(selected_edges))]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% segment rotations\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9599053893645675,
            0.8774240016937256
        ],
        "raw_score": [
            6.490273181538934,
            6.6575132093112686
        ]
    }
]