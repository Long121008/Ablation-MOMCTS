[
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing those with lower combined objective scores) and applies a hybrid local search combining edge insertion and segment reversal to generate neighbor solutions, ensuring feasibility by maintaining valid TSP tours. The selection process focuses on high-quality solutions, while the local search operator introduces diverse modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined score (lower is better)\n    def combined_score(solution, objectives):\n        return objectives[0] + objectives[1]\n\n    # Sort archive by combined score and select the best 10% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Remove edge between i and j\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert segment at a random new position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7847710985497653,
            0.17851996421813965
        ],
        "raw_score": [
            6.337478923049993,
            6.463198668542717
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive (prioritizing non-dominated or diverse solutions) and applies a hybrid local search combining edge exchange and segment reordering to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes and falling back to simpler swaps if needed. The selection is random but could be enhanced to prioritize solutions with lower costs or higher diversity, while the local search focuses on both edge-level and segment-level modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange followed by segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange (swap two edges)\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reordering (reverse a random segment)\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9622793977855487,
            0.20448201894760132
        ],
        "raw_score": [
            7.30701335952615,
            7.020446555862451
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those with lower weighted combined scores (70% weight on the first objective, 30% on the second), then applies a hybrid local search combining segment rotation and non-adjacent node swaps to generate feasible neighbor solutions while ensuring validity. The weighted scoring balances both objectives, and the local search operators introduce diversity through segment rotation and targeted node swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best weighted combined score (lower is better)\n    def weighted_score(solution, objectives):\n        return 0.7 * objectives[0] + 0.3 * objectives[1]\n\n    # Sort archive by weighted score and select the best 15% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: weighted_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 7)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Segment rotation (rotate a random segment by a random amount)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Step 2: Node swap (swap two nodes that are not adjacent)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i - j) == 1:  # Ensure nodes are not adjacent\n            i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9024818063105666,
            0.17928367853164673
        ],
        "raw_score": [
            6.0682416639386965,
            8.263773747526876
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution from the archive (based on the sum of both objectives) and applies a hybrid local search operator: reversing a random segment of the tour and performing a random node swap, while ensuring the solution remains valid by checking for duplicates. The method prioritizes diversification by randomly modifying the tour structure, with fallback to the original solution if invalidity occurs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Apply a hybrid local search operator: a combination of edge insertion and node swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n    segment = new_solution[start:end]\n\n    # Reverse the segment to create a new tour\n    new_segment = segment[::-1]\n    new_solution[start:end] = new_segment\n\n    # Perform a random swap between two nodes\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9581710917107531,
            0.20549225807189941
        ],
        "raw_score": [
            10.422623819898265,
            10.398352035590081
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by combining their objective scores, then applies a hybrid local search combining objective-biased edge swaps, edge insertions, and segment reversals to generate feasible neighbor solutions while prioritizing edges with higher costs in the less favorable objective. The method ensures validity by maintaining valid TSP tours through careful segment manipulation and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined score (lower is better)\n    def combined_score(solution, objectives):\n        return objectives[0] + objectives[1]\n\n    # Sort archive by combined score and select the best 10% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Objective-biased edge swap (swap edges based on which objective they belong to)\n    def get_edge_objective(i, j, matrix):\n        return matrix[i, j]\n\n    # Choose a random edge to swap\n    i = random.randint(0, n-1)\n    j = (i + 1) % n\n\n    # Decide which objective to prioritize for the swap\n    obj1_cost = get_edge_objective(new_solution[i], new_solution[j], distance_matrix_1)\n    obj2_cost = get_edge_objective(new_solution[i], new_solution[j], distance_matrix_2)\n\n    if obj1_cost > obj2_cost:\n        # Swap edges based on objective 1\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n    else:\n        # Swap edges based on objective 2\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Step 2: Edge insertion (move a random edge to a new position)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 3: Segment reversal (reverse a random segment)\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8789912793056229,
            0.17964571714401245
        ],
        "raw_score": [
            6.999801024342688,
            6.553088726449999
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using Pareto-aware selection (top 20% by hypervolume) and applies a hybrid local search combining cross-space segment rotations (prioritizing segments with high distance differences) and weighted edge exchanges to generate high-quality neighbor solutions while ensuring feasibility through adaptive validation. It prioritizes edges with significant distance differences in the weighted exchange step and falls back to simple swaps if feasibility is violated. The method balances exploration and exploitation by leveraging both segment rotations and edge exchanges in a structured way.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection (top 20% by hypervolume)\n    def hypervolume(solution, objectives):\n        return objectives[0] * objectives[1]\n\n    sorted_archive = sorted(archive, key=lambda x: hypervolume(x[0], x[1]), reverse=True)\n    top_k = max(1, len(sorted_archive) // 5)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: cross-space segment rotation + weighted edge exchange\n    # Step 1: Cross-space segment rotation (rotate based on distance matrix differences)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Step 2: Weighted edge exchange (prioritize edges with higher distance differences)\n    i, j = sorted(random.sample(range(n), 2))\n    dist_diff = abs(distance_matrix_1[i, j] - distance_matrix_2[i, j])\n    if random.random() < dist_diff / (distance_matrix_1.max() + distance_matrix_2.max()):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive feasibility check\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9289421128908506,
            0.23179084062576294
        ],
        "raw_score": [
            10.394375627953004,
            10.650151287256591
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing those with lowest combined objectives) and applies a hybrid local search by reversing a random segment and swapping two non-consecutive edges, ensuring feasibility while exploring diverse neighborhoods. It balances exploitation (focusing on high-quality solutions) with exploration (perturbing the tour structure) to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n - 1)\n\n    # Reverse the segment (similar to 2-opt but more disruptive)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Additional perturbation: swap two random non-consecutive edges\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 2, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8639804524653872,
            0.1826513409614563
        ],
        "raw_score": [
            6.89278661553577,
            6.192611657749408
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest variance between its two objectives (indicating potential for improvement) and applies a hybrid local search combining edge insertion (removing and reinserting a segment of nodes) and segment reversal (flipping a random segment of nodes). The method ensures feasibility by maintaining a valid TSP tour structure, and the randomness in segment selection promotes exploration of the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (promising for improvement)\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Edge insertion - remove a random edge and reinsert it\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    if i > j:\n        i, j = j, i\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment reversal - reverse a random segment\n    k = np.random.randint(2, n-1)\n    l = np.random.randint(0, n-k)\n    new_solution[l:l+k] = new_solution[l:l+k][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5630424389731795,
            0.1928430199623108
        ],
        "raw_score": [
            7.230773789000227,
            7.233761085866266
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive using a weighted combination of objectives (60% first objective, 40% second) and applies a hybrid local search combining multi-segment reversal and edge rotation. It first reverses non-overlapping segments of the tour and then rotates edges between segments to explore diverse neighborhoods while maintaining feasibility. The approach prioritizes exploitation of good solutions through weighted selection and exploration through disruptive perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted objective score\n    def weighted_score(solution, objectives):\n        # Weighted combination of objectives (can be adjusted)\n        return 0.6 * objectives[0] + 0.4 * objectives[1]\n\n    archive_sorted = sorted(archive, key=lambda x: weighted_score(x[0], x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # Too small for meaningful changes\n\n    # Hybrid local search: multi-segment reversal and edge rotation\n    # Step 1: Select multiple non-overlapping segments to reverse\n    num_segments = min(3, n // 4)\n    segments = []\n    for _ in range(num_segments):\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 1, min(start + 5, n - 1))\n        segments.append((start, end))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    for seg in segments:\n        if not merged_segments:\n            merged_segments.append(seg)\n        else:\n            last_start, last_end = merged_segments[-1]\n            if seg[0] <= last_end:\n                # Merge overlapping segments\n                new_start = last_start\n                new_end = max(last_end, seg[1])\n                merged_segments[-1] = (new_start, new_end)\n            else:\n                merged_segments.append(seg)\n\n    # Reverse each segment\n    for start, end in merged_segments:\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Rotate edges between segments\n    if len(merged_segments) > 1:\n        # Select two random segments\n        seg1, seg2 = random.sample(merged_segments, 2)\n\n        # Select random edges from each segment\n        edge1_start = np.random.randint(seg1[0], seg1[1])\n        edge1_end = edge1_start + 1 if edge1_start < seg1[1] else seg1[0]\n\n        edge2_start = np.random.randint(seg2[0], seg2[1])\n        edge2_end = edge2_start + 1 if edge2_start < seg2[1] else seg2[0]\n\n        # Rotate the edges (swap their positions)\n        temp = new_solution[edge1_start:edge1_end+1].copy()\n        new_solution[edge1_start:edge1_end+1] = new_solution[edge2_start:edge2_end+1]\n        new_solution[edge2_start:edge2_end+1] = temp\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8597885201267437,
            0.2027444839477539
        ],
        "raw_score": [
            6.225715493858557,
            7.019182439935018
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with the best hypervolume contribution (approximating Pareto dominance) and applies a novel local search combining edge insertion with probabilistic segment reversal, ensuring feasibility while balancing exploitation and exploration. The critical design idea is the hybrid local search that intelligently modifies the tour by removing and reinserting edges while occasionally reversing segments to escape local optima, all while maintaining solution validity. The selection prioritizes solutions with lower combined objective values and higher hypervolume contributions, guiding the search toward promising regions of the Pareto front.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best hypervolume contribution (approximation of Pareto dominance)\n    def hypervolume(sol):\n        obj1, obj2 = sol[1]\n        # Approximate hypervolume contribution (simplified)\n        return -(obj1 + obj2) * (1 + abs(obj1 - obj2))\n\n    archive_sorted = sorted(archive, key=hypervolume)\n    base_solution = archive_sorted[0][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Novel local search: Edge insertion with probabilistic segment reversal\n    if n > 3:\n        # Select a random edge to remove\n        i = np.random.randint(0, n - 1)\n        j = (i + 1) % n\n\n        # Remove edge (i,j) and insert it between (k,k+1)\n        k = np.random.randint(0, n - 1)\n        while k == i or k == j or (k + 1) % n == i or (k + 1) % n == j:\n            k = np.random.randint(0, n - 1)\n\n        # Perform insertion\n        if i < j:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        else:\n            segment = np.concatenate([new_solution[i:], new_solution[:j+1]])\n            new_solution = new_solution[j+1:i]\n\n        # Insert segment between k and k+1\n        if k < len(new_solution) - 1:\n            new_solution = np.concatenate([new_solution[:k+1], segment, new_solution[k+1:]])\n        else:\n            new_solution = np.concatenate([segment, new_solution])\n\n        # Probabilistic segment reversal (50% chance)\n        if np.random.rand() < 0.5:\n            seg_start = np.random.randint(0, len(new_solution) - 2)\n            seg_end = np.random.randint(seg_start + 1, len(new_solution) - 1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6076374188509813,
            0.19740360975265503
        ],
        "raw_score": [
            8.187363726515736,
            6.744613235473025
        ]
    }
]