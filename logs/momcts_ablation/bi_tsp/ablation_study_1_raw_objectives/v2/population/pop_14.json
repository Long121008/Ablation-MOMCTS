[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the highest sum of normalized objectives) and applies a hybrid local search: either a random edge swap or node reinsertion to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with higher combined costs, while the local search explores neighborhoods through randomized edge swaps or node reinsertions. The approach balances exploration and exploitation by combining simple but effective perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -1\n    selected_solution = None\n    for sol, obj in archive:\n        normalized_obj = (obj[0] + obj[1]) / 2  # Simple normalization\n        if normalized_obj > max_sum:\n            max_sum = normalized_obj\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random edge swap or node reinsertion\n    n = len(new_solution)\n    if np.random.rand() < 0.5:  # Edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Node reinsertion\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9263534306788621,
            0.2028200626373291
        ],
        "raw_score": [
            10.527134484715972,
            10.564929956806642
        ]
    },
    {
        "algorithm": "The algorithm selects a Pareto-dominated solution from the archive (prioritizing non-dominated or randomly choosing from dominated solutions) and applies a hybrid local search: it first attempts a segment reversal (2-opt-like) if it improves either objective, otherwise performs a random node reinsertion to maintain feasibility. The method ensures solution validity by checking node uniqueness and preserves the tour structure while exploring multi-objective improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a Pareto-dominated solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_index = random.choice(non_dominated_indices)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal if beneficial, else node reinsertion\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, l, node)\n    else:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0259954099517012,
            0.38352054357528687
        ],
        "raw_score": [
            5.699175348104417,
            7.028717067597253
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining 3-opt edge exchanges with adaptive node reinsertion to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with better combined objective performance and intelligently balances exploration (random selection) and exploitation (targeted improvements) through weighted edge exchanges and adaptive insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        return np.random.permutation(len(instance))\n\n    # Calculate normalized objective scores for selection\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        weights = [0.5, 0.5]\n    else:\n        weights = [1/max_obj1, 1/max_obj2]\n    scores = [weights[0]*obj[0] + weights[1]*obj[1] for _, obj in archive]\n\n    # Select solution with highest combined score (higher score = better potential)\n    selected_index = np.argmax(scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        # For small instances, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search: 3-opt edge exchange with adaptive insertion\n        # Step 1: Select three edges to exchange (3-opt)\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Step 2: Calculate potential improvement\n        a, b, c, d, e, f = base_solution[i], base_solution[(i+1)%n], base_solution[j], base_solution[(j+1)%n], base_solution[k], base_solution[(k+1)%n]\n\n        # Calculate changes for both objectives\n        delta1 = (distance_matrix_1[a,d] + distance_matrix_1[b,e] + distance_matrix_1[c,f]) - \\\n                 (distance_matrix_1[a,b] + distance_matrix_1[c,d] + distance_matrix_1[e,f])\n        delta2 = (distance_matrix_2[a,d] + distance_matrix_2[b,e] + distance_matrix_2[c,f]) - \\\n                 (distance_matrix_2[a,b] + distance_matrix_2[c,d] + distance_matrix_2[e,f])\n\n        if delta1 < 0 or delta2 < 0:\n            # If 3-opt improves at least one objective, perform it\n            new_solution[(i+1):(j+1)] = np.flip(new_solution[(i+1):(j+1)])\n            new_solution[(j+1):(k+1)] = np.flip(new_solution[(j+1):(k+1)])\n        else:\n            # Adaptive node reinsertion\n            # Select a node to remove and reinsert\n            remove_pos = random.randint(0, n-1)\n            node = new_solution[remove_pos]\n\n            # Calculate insertion positions based on both objectives\n            obj1_costs = [distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[(i+1)%n]] for i in range(n-1)]\n            obj2_costs = [distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[(i+1)%n]] for i in range(n-1)]\n\n            # Weighted insertion score\n            insertion_scores = [weights[0]*obj1_costs[i] + weights[1]*obj2_costs[i] for i in range(n-1)]\n            insert_pos = np.argmin(insertion_scores)\n\n            # Perform insertion\n            new_solution = np.concatenate([new_solution[:remove_pos], new_solution[remove_pos+1:]])\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0082527092395177,
            0.22302573919296265
        ],
        "raw_score": [
            10.40473316868271,
            10.656387013563487
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution from the archive (based on the maximum objective value) and applies a hybrid local search combining random segment reversal and 2-opt moves to generate a neighbor solution. It prioritizes exploration of less-explored regions by focusing on the worst-performing solution and ensures feasibility by maintaining valid TSP tours. The approach balances diversity and local improvement while avoiding standard 2-opt-only strategies.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: combine random 2-opt with a novel segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (novel segment reversal)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a random 2-opt move to ensure diversity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7627709071663467,
            0.20366013050079346
        ],
        "raw_score": [
            9.049800417335923,
            10.417538166894719
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-front selection with a novel hybrid move that inverts a segment of the tour while intelligently reallocating nodes based on their combined contribution to both objectives, prioritizing balanced improvements through a weighted scoring system while ensuring feasibility through rigorous validation. It selects non-dominated solutions with equal probability and applies segment inversion followed by node reallocation based on a weighted combination of distance improvements in both objective spaces. For small instances, it falls back to a conditional random swap that improves at least one objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto selection: choose a non-dominated solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_index = random.choice(non_dominated_indices)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid segment inversion and node reallocation\n    if n >= 4:\n        # Select a segment to invert\n        segment_size = random.randint(2, min(5, n - 2))\n        start_pos = random.randint(0, n - segment_size)\n        end_pos = start_pos + segment_size\n\n        # Invert the segment\n        new_solution[start_pos:end_pos] = np.flip(new_solution[start_pos:end_pos])\n\n        # Reallocate nodes based on their contribution to both objectives\n        for i in range(start_pos, end_pos):\n            node = new_solution[i]\n            # Calculate insertion scores for each possible position\n            insertion_scores = []\n            for j in range(n):\n                if j >= start_pos and j < end_pos:\n                    continue  # Skip current segment\n                prev_node = new_solution[j - 1]\n                next_node = new_solution[j % n]\n                # Weighted score for both objectives\n                score = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) * 0.5 + \\\n                        (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]) * 0.5\n                insertion_scores.append(score)\n\n            # Find best insertion position outside the current segment\n            best_pos = np.argmin(insertion_scores)\n            if best_pos >= start_pos:\n                best_pos += segment_size  # Adjust for removed segment\n\n            # Remove node and insert at best position\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # For small instances, perform a random swap if it improves at least one objective\n        i, j = random.sample(range(n), 2)\n        a, b = base_solution[i], base_solution[j]\n        delta1 = (distance_matrix_1[a, base_solution[i-1]] + distance_matrix_1[a, base_solution[(i+1)%n]] +\n                  distance_matrix_1[b, base_solution[j-1]] + distance_matrix_1[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[b, base_solution[i-1]] + distance_matrix_1[b, base_solution[(i+1)%n]] +\n                  distance_matrix_1[a, base_solution[j-1]] + distance_matrix_1[a, base_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[a, base_solution[i-1]] + distance_matrix_2[a, base_solution[(i+1)%n]] +\n                  distance_matrix_2[b, base_solution[j-1]] + distance_matrix_2[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[b, base_solution[i-1]] + distance_matrix_2[b, base_solution[(j+1)%n]] +\n                  distance_matrix_2[a, base_solution[j-1]] + distance_matrix_2[a, base_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0118871919742838,
            3.170640230178833
        ],
        "raw_score": [
            6.400236137840049,
            5.927239624244716
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objective values and random diversity, then applies a hybrid local search combining 2.5-opt (a segment reversal) and node insertion to generate a neighbor, ensuring feasibility by validating no duplicates or missing nodes. The selection prioritizes lower objectives with added randomness, while the local search focuses on segment reversal and node repositioning for potential multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    def selection_score(solution, objective):\n        # Prefer solutions with lower objectives but also consider diversity\n        return (objective[0] + objective[1]) * (1 + np.random.uniform(0.5, 1.5))\n\n    scored_solutions = [(solution, objective, selection_score(solution, objective))\n                       for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: x[2])\n    selected_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: 2.5-opt + node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt (generalized 2-opt)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion (move a random node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure solution remains feasible (no duplicates and all nodes visited)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(selected_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9672586246322147,
            0.250504732131958
        ],
        "raw_score": [
            6.691336365610633,
            6.575647727482992
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (prioritizing Pareto fronts) and applies a hybrid local search strategy: segment reversal for Pareto-improving moves in larger instances, or node swaps for smaller instances, while always ensuring feasibility. The method intelligently balances exploration (random selection) and exploitation (Pareto-aware improvements) to generate high-quality neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto selection: choose a non-dominated solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_index = random.choice(non_dominated_indices)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal if Pareto-improving, else node reinsertion\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, l, node)\n    else:\n        # For small instances, swap nodes if Pareto-improving\n        i, j = random.sample(range(n), 2)\n        a, b = base_solution[i], base_solution[j]\n        delta1 = (distance_matrix_1[a, base_solution[i-1]] + distance_matrix_1[a, base_solution[(i+1)%n]] +\n                  distance_matrix_1[b, base_solution[j-1]] + distance_matrix_1[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[b, base_solution[i-1]] + distance_matrix_1[b, base_solution[(i+1)%n]] +\n                  distance_matrix_1[a, base_solution[j-1]] + distance_matrix_1[a, base_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[a, base_solution[i-1]] + distance_matrix_2[a, base_solution[(i+1)%n]] +\n                  distance_matrix_2[b, base_solution[j-1]] + distance_matrix_2[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[b, base_solution[i-1]] + distance_matrix_2[b, base_solution[(i+1)%n]] +\n                  distance_matrix_2[a, base_solution[j-1]] + distance_matrix_2[a, base_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9752425011617248,
            0.35219669342041016
        ],
        "raw_score": [
            5.9635449044178905,
            6.735768041691197
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated solutions) and applies a hybrid local search combining edge exchange and node insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. It intelligently balances exploration (random selection) and exploitation (local improvement) while considering both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        return np.random.permutation(len(instance))\n\n    # Calculate the Pareto dominance rank for each solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    # Select non-dominated solutions (rank 0)\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if non_dominated_indices:\n        selected_index = random.choice(non_dominated_indices)\n    else:\n        # If no non-dominated solutions, select randomly\n        selected_index = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a full swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more sophisticated local search\n        # Step 1: Select two edges to exchange (similar to 2-opt but with additional checks)\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Step 2: Check if exchanging these edges improves both objectives\n        # Calculate the change in cost for both objectives\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            # If the exchange improves at least one objective, perform it\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            # If not, try a node insertion move\n            k = random.randint(0, n - 1)\n            l = random.randint(0, n - 1)\n            if k != l:\n                # Remove node at position k and insert it after position l\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = (l + 1) % (n - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9793278915524335,
            0.41966134309768677
        ],
        "raw_score": [
            6.099593653768952,
            6.610992634938869
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using crowding distance in Pareto fronts, then applies a hybrid local search combining 3-opt moves for larger instances (n \u2265 6) and adaptive node insertion for smaller ones, while ensuring feasibility by validating constraints. The selection prioritizes solutions with higher crowding distance, and the local search optimizes both objectives simultaneously by evaluating all possible reconnections in 3-opt or finding the best insertion point in adaptive insertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n_fronts = len(solutions)\n\n    # Calculate crowding distance for each front\n    crowding_dist = [0] * n_fronts\n    for m in range(2):  # For each objective\n        sorted_indices = sorted(range(n_fronts), key=lambda i: objectives[i][m])\n        crowding_dist[sorted_indices[0]] = float('inf')\n        crowding_dist[sorted_indices[-1]] = float('inf')\n        min_obj = objectives[sorted_indices[0]][m]\n        max_obj = objectives[sorted_indices[-1]][m]\n        if max_obj == min_obj:\n            continue\n        for i in range(1, n_fronts-1):\n            crowding_dist[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (max_obj - min_obj)\n\n    selected_index = max(range(n_fronts), key=lambda i: crowding_dist[i])\n    base_solution = solutions[selected_index].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search\n    if n >= 6:\n        # 3-opt move for larger instances\n        i, j, k = sorted(random.sample(range(n), 3))\n        a, b, c = base_solution[i], base_solution[j], base_solution[k]\n\n        # Calculate all possible reconnections\n        options = [\n            (a, b, c),  # Original order\n            (a, c, b),  # Swap b and c\n            (b, a, c),  # Rotate left\n            (b, c, a),  # Rotate right\n            (c, a, b),  # Reverse and swap\n            (c, b, a)   # Reverse order\n        ]\n\n        best_option = None\n        min_delta = float('inf')\n\n        for opt in options:\n            x, y, z = opt\n            # Calculate change in both objectives\n            delta1 = (distance_matrix_1[base_solution[i-1], x] + distance_matrix_1[y, z] + distance_matrix_1[z, base_solution[(k+1)%n]]) - \\\n                    (distance_matrix_1[base_solution[i-1], a] + distance_matrix_1[a, b] + distance_matrix_1[b, c] + distance_matrix_1[c, base_solution[(k+1)%n]])\n            delta2 = (distance_matrix_2[base_solution[i-1], x] + distance_matrix_2[y, z] + distance_matrix_2[z, base_solution[(k+1)%n]]) - \\\n                    (distance_matrix_2[base_solution[i-1], a] + distance_matrix_2[a, b] + distance_matrix_2[b, c] + distance_matrix_2[c, base_solution[(k+1)%n]])\n\n            if abs(delta1) + abs(delta2) < min_delta:\n                min_delta = abs(delta1) + abs(delta2)\n                best_option = opt\n\n        if best_option is not None and min_delta < 0:\n            x, y, z = best_option\n            new_solution[i:k+1] = [x, y, z]\n    else:\n        # Adaptive node insertion for smaller instances\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find best insertion point based on both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n-1):\n            cost1 = distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[(pos+1)%(n-1)]] - distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            cost2 = distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[(pos+1)%(n-1)]] - distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n\n            if abs(cost1) + abs(cost2) < min_cost:\n                min_cost = abs(cost1) + abs(cost2)\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9847559452067524,
            2.3894295692443848
        ],
        "raw_score": [
            9.51724587542918,
            10.649374987648983
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive using Pareto dominance, then applies a hybrid local search combining segment reversal (if beneficial) and node reinsertion (otherwise), ensuring feasibility by validating node uniqueness and tour completeness. It prioritizes solutions that improve at least one objective while maintaining feasibility, with special handling for small instances via simple swaps. The method intelligently balances exploration and exploitation by leveraging both structural changes (segment reversal) and fine-grained adjustments (node reinsertion).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto selection: choose a non-dominated solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_index = random.choice(non_dominated_indices)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal if beneficial, else node reinsertion\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, l, node)\n    else:\n        # For small instances, perform a simple swap if beneficial\n        i, j = random.sample(range(n), 2)\n        a, b = base_solution[i], base_solution[j]\n        delta1 = (distance_matrix_1[a, base_solution[i-1]] + distance_matrix_1[a, base_solution[(i+1)%n]] +\n                  distance_matrix_1[b, base_solution[j-1]] + distance_matrix_1[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[b, base_solution[i-1]] + distance_matrix_1[b, base_solution[(i+1)%n]] +\n                  distance_matrix_1[a, base_solution[j-1]] + distance_matrix_1[a, base_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[a, base_solution[i-1]] + distance_matrix_2[a, base_solution[(i+1)%n]] +\n                  distance_matrix_2[b, base_solution[j-1]] + distance_matrix_2[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[b, base_solution[i-1]] + distance_matrix_2[b, base_solution[(j+1)%n]] +\n                  distance_matrix_2[a, base_solution[j-1]] + distance_matrix_2[a, base_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9305258598815458,
            0.3310345411300659
        ],
        "raw_score": [
            6.750994222682744,
            6.196014517473082
        ]
    }
]