[
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining edge exchange and segment inversion to explore diverse neighborhoods while ensuring feasibility. The selection prioritizes randomness for exploration, while the hybrid search balances edge-wise and segment-wise modifications to escape local optima. The feasibility check ensures valid TSP tours by reverting to simpler operations if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two random edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion (reverse a random segment)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8790760004126856,
            0.47520631551742554
        ],
        "raw_score": [
            7.31569362287178,
            7.144871037754502
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution (highest sum of objectives) from the archive and applies a hybrid local search combining segment reversal and edge insertion. It randomly reverses segments and inserts edges while ensuring feasibility, falling back to a simple 2-opt if invalid. The focus is on diversity and exploration of the solution space.\n\n(Note: The original code selects the worst solution, which may not be ideal for improvement. A better approach would prioritize solutions with high potential for improvement, e.g., those near the Pareto front or with high variance in objectives.)",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        # Insert edge (a, b) by reversing the segment between them\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the hybrid approach fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9185087722772078,
            0.5027542114257812
        ],
        "raw_score": [
            10.45220321439054,
            10.552246178094743
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower total distance in either objective space, then applies a hybrid local search combining random edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility. The selection is biased toward better-performing solutions (top 3 in either objective), and the local search randomly chooses between edge swaps or segment reversals to explore the solution space. The solution is validated to ensure no duplicates or missing nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential (lowest total distance in either space)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1][0], x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap and segment reversal\n    if np.random.random() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: randomly select a segment and reverse it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5336246797501336,
            0.5794582962989807
        ],
        "raw_score": [
            9.160038133875737,
            5.586881988188598
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining edge-swapping (a modified 2-opt) and path-relinking (introducing edges from another solution), ensuring feasibility by maintaining valid TSP tours. It prioritizes exploration by randomly selecting segments to reverse and inserting nodes from other solutions, balancing exploitation and exploration for multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost but not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge-swapping and path-relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping (similar to 2-opt but more flexible)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Path-relinking (introduce edges from another solution)\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find edges in the other solution that could improve the current one\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                # Insert the missing node at a random position\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8595613224930644,
            0.7343329787254333
        ],
        "raw_score": [
            6.9014245420425,
            6.095714066481012
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest objective variance (indicating potential for improvement) and applies a hybrid local search combining edge exchange (swapping two random nodes) and segment reversal (reversing a random segment), ensuring feasibility by validating uniqueness of nodes. If this fails, it falls back to a simpler edge exchange. The selection prioritizes solutions with higher objective variance, while the hybrid search innovatively combines two operations to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance (potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (swap two random edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal (reverse a random segment)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Feasibility check: ensure no duplicates or skips\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n\n    # Fallback: simple edge exchange if hybrid search fails\n    new_solution = base_solution.copy()\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.628430131798555,
            0.5967089533805847
        ],
        "raw_score": [
            7.47799082163341,
            7.578283264318682
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized objective values and randomness, then applies a hybrid local search combining 3-opt with an insertion heuristic to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with higher combined normalized costs (70%) and adds randomness (30%) to avoid local optima. The local search first performs a 3-opt move on three randomly selected segments and then refines the solution by reinserting nodes at positions optimized for both objectives, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def selection_criteria(sol_obj):\n        # Combine normalized objectives and diversity (simplified for this example)\n        norm_obj1 = sol_obj[1][0] / (sum(o[1][0] for o in archive) / len(archive) + 1e-6)\n        norm_obj2 = sol_obj[1][1] / (sum(o[1][1] for o in archive) / len(archive) + 1e-6)\n        return 0.7 * (norm_obj1 + norm_obj2) + 0.3 * np.random.random()\n\n    selected = max(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: 3-opt with insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    new_segment = np.concatenate([\n        new_solution[i:j],\n        new_solution[k:],\n        new_solution[j:k],\n        new_solution[:i]\n    ])\n    new_solution[:] = new_segment\n\n    # Apply insertion heuristic to refine the solution\n    for _ in range(2):  # Number of insertion attempts\n        # Select a random node to reinsert\n        idx = np.random.randint(0, n)\n        node = new_solution[idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, idx)\n\n        # Find the best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n):\n            # Insert the node at position pos\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2  # Simple combination\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8558078839365527,
            4.305092513561249
        ],
        "raw_score": [
            6.642006530499136,
            6.384819747921993
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive, applies a hybrid local search combining adaptive segment reversal (prioritizing multi-objective improvement) and node insertion (evaluating edges based on both objectives), and ensures feasibility by maintaining a valid TSP tour. It emphasizes balanced improvements in both objectives, with segment reversal favoring simultaneous gains and node insertion focusing on significant multi-objective gains. The method dynamically adapts to the archive's diversity, leveraging both intra-solution and inter-solution information for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost but not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_obj = archive[selected_idx][1]\n\n    # Hybrid local search: combine segment reversal and node insertion with edge prioritization\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal based on multi-objective improvement potential\n    for _ in range(2):  # Apply multiple times for better exploration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            # Evaluate the new segment's contribution to both objectives\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n\n    # Step 2: Node insertion with multi-objective edge evaluation\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find the best node to insert based on both objectives\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    # Calculate new costs\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    # Calculate improvement (normalized by current costs)\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8548189874057143,
            2.3624120354652405
        ],
        "raw_score": [
            6.354018849051151,
            6.271922735363284
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined cost from the archive, applies a hybrid local search combining segment reversal (with a larger segment size for more substantial changes) and node insertion from a diverse solution, ensuring feasibility and exploration of the solution space. It prioritizes low-cost solutions while using randomness to escape local optima and maintain diversity. The hybrid approach balances exploration (via segment reversal) and exploitation (via node insertion from other solutions).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined cost\n    costs = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment reversal and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with larger segments\n    segment_size = max(2, n // 4)\n    i = np.random.randint(0, n - segment_size)\n    j = i + segment_size\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion from a diverse solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                pos = np.random.randint(0, n - 1)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7928775992519711,
            1.2936017513275146
        ],
        "raw_score": [
            8.492194473116495,
            8.499638229304852
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high objective variance, then applies a hybrid local search combining probabilistic segment reversal (70% chance) and multi-objective edge insertion (50% chance), prioritizing edges based on a weighted sum of distances from both objective spaces. It validates feasibility by checking node uniqueness and falls back to segment reversal if invalid, ensuring the solution remains a valid TSP tour. The weighted sum of distances (averaging both objectives) guides edge selection toward balanced improvement across both spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (potential for improvement)\n    variances = [max(costs) - min(costs) for _, costs in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: probabilistic segment reversal + multi-objective edge insertion\n    for _ in range(2):  # Perform multiple attempts for better exploration\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Probabilistic segment reversal\n        if random.random() < 0.7:  # Higher probability to try reversal first\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective edge insertion\n        if random.random() < 0.5:\n            a, b = sorted(random.sample(range(n), 2))\n            node_a, node_b = new_solution[a], new_solution[b]\n\n            # Calculate weighted sum of distances for potential edges\n            def edge_score(u, v):\n                return (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / 2\n\n            # Find the best edge to insert\n            best_score = float('inf')\n            best_pos = -1\n            for pos in range(n):\n                if pos != a and pos != b:\n                    score = edge_score(new_solution[pos], node_a) + edge_score(node_a, new_solution[(pos+1)%n]) + \\\n                            edge_score(new_solution[pos], node_b) + edge_score(node_b, new_solution[(pos+1)%n])\n                    if score < best_score:\n                        best_score = score\n                        best_pos = pos\n\n            if best_pos != -1:\n                # Insert node_a after best_pos\n                new_solution = np.insert(new_solution, best_pos + 1, node_a)\n                # Remove duplicate (original position of node_a)\n                new_solution = np.delete(new_solution, np.where(new_solution == node_a)[0][0])\n\n        # Validate solution\n        if len(set(new_solution)) != n:\n            # Fallback to randomized segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5554444383257799,
            0.7723526954650879
        ],
        "raw_score": [
            7.285501988806554,
            7.942159964663272
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a promising solution from the archive (prioritizing those with lower total distance in either objective space) and applies a hybrid local search: segment reversal for the first objective and edge insertion for the second, dynamically adapting based on the relative improvement potential. It ensures feasibility by validating node uniqueness and tour completeness, balancing exploitation and exploration through adaptive strategy selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential (lowest total distance in either space)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1][0], x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine the objective with higher potential for improvement\n    obj1_improvement = archive_sorted[selected_idx][1][0] / distance_matrix_1.sum()\n    obj2_improvement = archive_sorted[selected_idx][1][1] / distance_matrix_2.sum()\n\n    # Hybrid local search: adaptively choose between segment reversal and edge insertion\n    if obj1_improvement > obj2_improvement:\n        # Focus on improving the first objective: segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Focus on improving the second objective: edge insertion\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n\n            # Find edges in the other solution that could improve the current one\n            for k in range(n):\n                node = other_solution[k]\n                if node not in new_solution:\n                    pos = np.random.randint(0, n)\n                    new_solution = np.insert(new_solution, pos, node)\n                    new_solution = new_solution[:n]  # Ensure length remains the same\n                    break\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5360677092074698,
            3.6022661328315735
        ],
        "raw_score": [
            9.217090900382313,
            6.58573312624353
        ]
    }
]