[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 4 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe heuristic selects a random solution from the archive, applies a hybrid local search combining edge insertion and node relocation to generate a neighbor, and ensures feasibility by reverting to a simple swap if duplicates occur. The selection is random, while the local search prioritizes edge-wise and node-wise modifications for exploration. The design balances simplicity and feasibility, with fallback mechanisms to maintain valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n\n    # Edge insertion (insert a node at a random position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Node relocation (move a node to a new position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if operations cause duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution with the highest objective variance from the archive, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor. It prioritizes diversity in objectives and uses a fallback swap if the solution becomes invalid. The key design ideas are selecting high-variance solutions and combining 3-opt with node insertion for exploration, with validation to ensure feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with node insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reversing segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node elsewhere\n    node_to_move = new_solution[random.randint(0, n-1)]\n    insert_pos = random.randint(0, n-2)\n    if insert_pos < n-1:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            np.array([node_to_move]),\n            new_solution[insert_pos:-1][new_solution[insert_pos:-1] != node_to_move],\n            [new_solution[-1]]\n        ])\n\n    # Validate the solution\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution near the Pareto front using crowding distance, then applies adaptive segment reversal and probabilistic edge insertions to generate neighbors, prioritizing solutions that improve both objectives while falling back to random perturbations if no improvement is found. It ensures feasibility by validating node uniqueness and maintains diversity by occasionally sampling from other solutions in the archive.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects solutions from the archive with higher priority based on their inverse Euclidean distance in the objective space, then applies either a coordinate-aware 3-opt (60% chance) that prioritizes nodes with high geometric discrepancy between objectives or a dynamic segment shuffle (40% chance) with adaptive segment length, falling back to a random 2-opt if duplicates arise, ensuring feasibility through continuous validation. The selection weights favor solutions with better overall performance across both objectives, while the local search operators adapt to the solution's geometric properties to explore diverse neighborhoods effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on Euclidean distance in objective space\n    objectives = [obj for _, obj in archive]\n    distances = [np.linalg.norm(obj) for obj in objectives]\n    weights = [1 / (dist + 1e-8) for dist in distances]  # Inverse distance weighting\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with coordinate-aware node selection\n    if random.random() < 0.6:  # 60% chance for 3-opt with geometric discrepancy\n        # Calculate geometric discrepancy between coordinates\n        discrepancies = []\n        for node in base_solution:\n            x1, y1, x2, y2 = instance[node]\n            v1 = np.array([x1, y1])\n            v2 = np.array([x2, y2])\n            discrepancy = np.linalg.norm(v1 - v2)\n            discrepancies.append(discrepancy)\n\n        if sum(discrepancies) > 0:\n            node_weights = discrepancies\n        else:\n            node_weights = [1] * n\n\n        selected_nodes = random.choices(range(n), weights=node_weights, k=3)\n        i, j, k = sorted(selected_nodes)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    else:  # 40% chance for dynamic segment shuffle\n        segment_length = random.randint(3, min(8, n//3))\n        a = random.randint(0, n - segment_length)\n        b = a + segment_length\n        segment = new_solution[a:b]\n        random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Feasibility check and fallback to random 2-opt\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        # Perform 2-opt\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: Pareto dominance, hybrid segment reversal, feasibility checks, adaptive perturbation.\n- **Advice**: Select nondominated solutions with high crowding distance, apply segment reversals with probabilistic edge insertions, validate feasibility, and perturb if stuck using distance matrices.\n- **Avoid**: Random selection, dominated solutions, or simple local search.\n- **Explanation**: Balances exploration and exploitation, ensures high-quality neighbors, avoids stagnation, and maintains feasibility. Hybrid search adapts to solution geometry.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 301,
        "algorithm": "The heuristic selects a non-dominated solution with high crowding distance from the archive, applies hybrid segment reversals and adaptive edge insertions to generate neighbors, and perturbs with distance matrices if no improvement is found, ensuring feasible solutions while balancing exploration and exploitation. The algorithm prioritizes solutions with diverse objective values and uses a combination of local search operators to improve both objectives, with fallback mechanisms for stagnation. The structure alternates between segment reversal and node insertion, with randomized perturbations when no clear improvement is detected.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    def is_non_dominated(solution_obj, archive):\n        for _, obj in archive:\n            if (obj[0] <= solution_obj[0] and obj[1] < solution_obj[1]) or (obj[0] < solution_obj[0] and obj[1] <= solution_obj[1]):\n                return False\n        return True\n\n    non_dominated = [(sol, obj) for sol, obj in archive if is_non_dominated(obj, archive)]\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    sorted_archive = sorted(non_dominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1 and random.random() < 0.5:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9552431686226833,
            3.5231763124465942
        ],
        "raw_score": [
            4.099916422006671,
            10.526205472157443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    def is_non_dominated(solution_obj, archive):\n        for _, obj in archive:\n            if (obj[0] <= solution_obj[0] and obj[1] < solution_obj[1]) or (obj[0] < solution_obj[0] and obj[1] <= solution_obj[1]):\n                return False\n        return True\n\n    non_dominated = [(sol, obj) for sol, obj in archive if is_non_dominated(obj, archive)]\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    sorted_archive = sorted(non_dominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1 and random.random() < 0.5:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a random solution from the archive, applies a hybrid local search combining edge insertion and node relocation to generate a neighbor, and ensures feasibility by reverting to a simple swap if duplicates occur. The selection is random, while the local search prioritizes edge-wise and node-wise modifications for exploration. The design balances simplicity and feasibility, with fallback mechanisms to maintain valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n\n    # Edge insertion (insert a node at a random position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Node relocation (move a node to a new position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if operations cause duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with high crowding distance, then applies a hybrid local search combining segment reversal and adaptive node insertion, dynamically adjusting the search to balance exploration and exploitation while ensuring feasibility. It alternates between segment reversal and node insertion from other solutions when no immediate improvement is found, with a focus on both objective values.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9) or \\\n           (new_cost1 < current_cost1 * 0.85 and new_cost2 < current_cost2 * 0.85):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: Pareto dominance, hybrid segment reversal, feasibility checks, adaptive perturbation.\n- **Advice**: Select nondominated solutions with high crowding distance, apply segment reversals with probabilistic edge insertions, validate feasibility, and perturb if stuck using distance matrices.\n- **Avoid**: Random selection, dominated solutions, or simple local search.\n- **Explanation**: Balances exploration and exploitation, ensures high-quality neighbors, avoids stagnation, and maintains feasibility. Hybrid search adapts to solution geometry.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 302,
        "algorithm": "The algorithm selects a promising solution from the archive based on crowding distance among non-dominated fronts, then applies a hybrid local search combining adaptive segment reversal and probabilistic node insertion from other solutions, dynamically adjusting search depth while ensuring feasibility through validation and fallback perturbations. It prioritizes solutions with high diversity (crowding distance) and balances exploration (insertion from other solutions) with exploitation (segment reversal), with strict feasibility checks to maintain valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with dynamic search depth\n    max_depth = min(5, n // 2)\n    for depth in range(1, max_depth + 1):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if j - i >= depth:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = reversed_segment\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                break\n\n    # Probabilistic node insertion from other solutions\n    if len(archive) > 1 and np.random.rand() < 0.7:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        for _ in range(2):\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                temp_solution = np.insert(new_solution, pos, node)\n                temp_solution = temp_solution[:n]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                if (new_cost1 < current_cost1 * 1.05 and new_cost2 < current_cost2 * 1.05):\n                    new_solution = temp_solution\n                    break\n\n    # Fallback perturbation if no improvement\n    if new_solution.tolist() == base_solution.tolist():\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9716258214916984,
            1.5515000820159912
        ],
        "raw_score": [
            4.484492916999835,
            9.799315901675419
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with dynamic search depth\n    max_depth = min(5, n // 2)\n    for depth in range(1, max_depth + 1):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if j - i >= depth:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = reversed_segment\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                break\n\n    # Probabilistic node insertion from other solutions\n    if len(archive) > 1 and np.random.rand() < 0.7:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        for _ in range(2):\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                temp_solution = np.insert(new_solution, pos, node)\n                temp_solution = temp_solution[:n]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                if (new_cost1 < current_cost1 * 1.05 and new_cost2 < current_cost2 * 1.05):\n                    new_solution = temp_solution\n                    break\n\n    # Fallback perturbation if no improvement\n    if new_solution.tolist() == base_solution.tolist():\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution near the Pareto front using crowding distance, then applies adaptive segment reversal and probabilistic edge insertions to generate neighbors, prioritizing solutions that improve both objectives while falling back to random perturbations if no improvement is found. It ensures feasibility by validating node uniqueness and maintains diversity by occasionally sampling from other solutions in the archive.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with high crowding distance, then applies a hybrid local search combining segment reversal and adaptive node insertion, dynamically adjusting the search to balance exploration and exploitation while ensuring feasibility. It alternates between segment reversal and node insertion from other solutions when no immediate improvement is found, with a focus on both objective values.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9) or \\\n           (new_cost1 < current_cost1 * 0.85 and new_cost2 < current_cost2 * 0.85):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: Pareto dominance, hybrid segment reversal, feasibility checks, adaptive perturbation.\n- **Advice**: Select nondominated solutions with high crowding distance, apply segment reversals with probabilistic edge insertions, validate feasibility, and perturb if stuck using distance matrices.\n- **Avoid**: Random selection, dominated solutions, or simple local search.\n- **Explanation**: Balances exploration and exploitation, ensures high-quality neighbors, avoids stagnation, and maintains feasibility. Hybrid search adapts to solution geometry.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 303,
        "algorithm": "This heuristic algorithm selects a promising solution from the archive by prioritizing nondominated solutions with high crowding distance, then applies a hybrid local search combining segment reversal and adaptive node insertion from other solutions, dynamically adjusting the search based on objective improvements while ensuring feasibility. The method emphasizes balanced exploration and exploitation through probabilistic operations and fallback mechanisms, with a focus on Pareto dominance and geometric adaptation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution)\n\n    for _ in range(5):\n        if np.random.random() < 0.7:\n            i, j = sorted(np.random.choice(range(n), 2, replace=False))\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = reversed_segment\n            new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                current_cost1, current_cost2 = new_cost1, new_cost2\n                improved = True\n                break\n        else:\n            if len(archive) > 1:\n                other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n                other_solution = archive[other_idx][0]\n                node = np.random.choice(other_solution)\n                if node not in new_solution:\n                    pos = np.random.randint(0, n)\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n                    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                        new_solution = temp_solution\n                        current_cost1, current_cost2 = new_cost1, new_cost2\n                        improved = True\n                        break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.922126182298225,
            2.060033917427063
        ],
        "raw_score": [
            4.429280223856361,
            9.861399933047359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution)\n\n    for _ in range(5):\n        if np.random.random() < 0.7:\n            i, j = sorted(np.random.choice(range(n), 2, replace=False))\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = reversed_segment\n            new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                current_cost1, current_cost2 = new_cost1, new_cost2\n                improved = True\n                break\n        else:\n            if len(archive) > 1:\n                other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n                other_solution = archive[other_idx][0]\n                node = np.random.choice(other_solution)\n                if node not in new_solution:\n                    pos = np.random.randint(0, n)\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n                    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                        new_solution = temp_solution\n                        current_cost1, current_cost2 = new_cost1, new_cost2\n                        improved = True\n                        break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with high crowding distance, then applies a hybrid local search combining segment reversal and adaptive node insertion, dynamically adjusting the search to balance exploration and exploitation while ensuring feasibility. It alternates between segment reversal and node insertion from other solutions when no immediate improvement is found, with a focus on both objective values.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9) or \\\n           (new_cost1 < current_cost1 * 0.85 and new_cost2 < current_cost2 * 0.85):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 304,
        "algorithm": "The algorithm selects a diverse solution from the archive (prioritizing those with high objective diversity) and applies a hybrid local search combining adaptive segment reversal (with dynamic segment sizes) and randomized node swapping (using objective-aware selection). It ensures feasibility through a novel restoration mechanism and dynamically balances exploration/exploitation by accepting moves that improve both objectives. The selection of segments or nodes is biased toward those likely to yield significant improvements, while the restoration mechanism guarantees valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def objective_diversity(solutions):\n        objs = np.array([sol[1] for sol in solutions])\n        mean_obj = np.mean(objs, axis=0)\n        diversity = np.sum(np.sqrt(np.sum((objs - mean_obj)**2, axis=1)))\n        return diversity\n\n    diversity_scores = objective_diversity(archive)\n    selected_idx = np.argmax(diversity_scores) if isinstance(diversity_scores, np.ndarray) else 0\n    base_solution = archive[selected_idx][0].copy()\n    base_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        return (cost1, cost2)\n\n    def is_feasible(solution):\n        return len(solution) == n and len(np.unique(solution)) == n\n\n    def restore_feasibility(solution):\n        missing = set(range(n)) - set(solution)\n        extra = [node for node in solution if list(solution).count(node) > 1]\n        for node in extra:\n            if missing:\n                solution[solution == node][0] = missing.pop()\n        return solution\n\n    improved = False\n    max_attempts = 5\n\n    for _ in range(max_attempts):\n        if np.random.random() < 0.7:\n            # Adaptive segment reversal with dynamic segment size\n            segment_size = min(3, max(2, int(n * 0.15 * np.random.random() + 0.5)))\n            i = np.random.randint(0, n - segment_size)\n            j = i + segment_size\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = reversed_segment\n\n            if not is_feasible(temp_solution):\n                temp_solution = restore_feasibility(temp_solution)\n\n            new_cost1, new_cost2 = calculate_cost(temp_solution)\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n\n            if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95) or \\\n               (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n                new_solution = temp_solution\n                improved = True\n                break\n        else:\n            # Randomized node swapping with objective-aware selection\n            if len(archive) > 1:\n                other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n                other_solution = archive[other_idx][0]\n\n                swap_candidates = []\n                for k in range(n):\n                    if other_solution[k] in new_solution and other_solution[k] != new_solution[k]:\n                        swap_candidates.append((k, np.where(new_solution == other_solution[k])[0][0]))\n\n                if swap_candidates:\n                    k, pos = swap_candidates[np.random.choice(len(swap_candidates))]\n                    temp_solution = new_solution.copy()\n                    temp_solution[pos], temp_solution[k] = temp_solution[k], temp_solution[pos]\n\n                    if not is_feasible(temp_solution):\n                        temp_solution = restore_feasibility(temp_solution)\n\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n                    current_cost1, current_cost2 = calculate_cost(new_solution)\n\n                    if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95) or \\\n                       (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n                        new_solution = temp_solution\n                        improved = True\n                        break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    if not is_feasible(temp_solution):\n                        temp_solution = restore_feasibility(temp_solution)\n\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            new_solution = restore_feasibility(new_solution)\n\n    assert is_feasible(new_solution), \"Invalid solution generated\"\n    return new_solution\n\n",
        "metric_score": [
            -0.8309286017837179,
            3.5070496797561646
        ],
        "raw_score": [
            9.951996553980536,
            10.48726322377452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def objective_diversity(solutions):\n        objs = np.array([sol[1] for sol in solutions])\n        mean_obj = np.mean(objs, axis=0)\n        diversity = np.sum(np.sqrt(np.sum((objs - mean_obj)**2, axis=1)))\n        return diversity\n\n    diversity_scores = objective_diversity(archive)\n    selected_idx = np.argmax(diversity_scores) if isinstance(diversity_scores, np.ndarray) else 0\n    base_solution = archive[selected_idx][0].copy()\n    base_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        return (cost1, cost2)\n\n    def is_feasible(solution):\n        return len(solution) == n and len(np.unique(solution)) == n\n\n    def restore_feasibility(solution):\n        missing = set(range(n)) - set(solution)\n        extra = [node for node in solution if list(solution).count(node) > 1]\n        for node in extra:\n            if missing:\n                solution[solution == node][0] = missing.pop()\n        return solution\n\n    improved = False\n    max_attempts = 5\n\n    for _ in range(max_attempts):\n        if np.random.random() < 0.7:\n            # Adaptive segment reversal with dynamic segment size\n            segment_size = min(3, max(2, int(n * 0.15 * np.random.random() + 0.5)))\n            i = np.random.randint(0, n - segment_size)\n            j = i + segment_size\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = reversed_segment\n\n            if not is_feasible(temp_solution):\n                temp_solution = restore_feasibility(temp_solution)\n\n            new_cost1, new_cost2 = calculate_cost(temp_solution)\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n\n            if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95) or \\\n               (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n                new_solution = temp_solution\n                improved = True\n                break\n        else:\n            # Randomized node swapping with objective-aware selection\n            if len(archive) > 1:\n                other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n                other_solution = archive[other_idx][0]\n\n                swap_candidates = []\n                for k in range(n):\n                    if other_solution[k] in new_solution and other_solution[k] != new_solution[k]:\n                        swap_candidates.append((k, np.where(new_solution == other_solution[k])[0][0]))\n\n                if swap_candidates:\n                    k, pos = swap_candidates[np.random.choice(len(swap_candidates))]\n                    temp_solution = new_solution.copy()\n                    temp_solution[pos], temp_solution[k] = temp_solution[k], temp_solution[pos]\n\n                    if not is_feasible(temp_solution):\n                        temp_solution = restore_feasibility(temp_solution)\n\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n                    current_cost1, current_cost2 = calculate_cost(new_solution)\n\n                    if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95) or \\\n                       (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n                        new_solution = temp_solution\n                        improved = True\n                        break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    if not is_feasible(temp_solution):\n                        temp_solution = restore_feasibility(temp_solution)\n\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            new_solution = restore_feasibility(new_solution)\n\n    assert is_feasible(new_solution), \"Invalid solution generated\"\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with high crowding distance, then applies a hybrid local search combining segment reversal and adaptive node insertion, dynamically adjusting the search to balance exploration and exploitation while ensuring feasibility. It alternates between segment reversal and node insertion from other solutions when no immediate improvement is found, with a focus on both objective values.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9) or \\\n           (new_cost1 < current_cost1 * 0.85 and new_cost2 < current_cost2 * 0.85):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 305,
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with better combined objective values, then applies a hybrid local search combining adaptive segment reversal and dynamic node swapping, where segment length and swap positions are determined based on relative improvement potential in both objective spaces, ensuring feasibility while balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def combined_score(sol):\n        return sol[1][0] + sol[1][1]\n\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x))\n    selected_idx = min(len(sorted_archive) // 4, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    segment_length = max(3, n // 5)\n    for _ in range(5):\n        i = np.random.randint(0, n - segment_length)\n        j = i + segment_length\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        for _ in range(3):\n            pos1 = np.random.randint(0, n)\n            pos2 = np.random.randint(0, n)\n            temp_solution = new_solution.copy()\n            temp_solution[pos1], temp_solution[pos2] = temp_solution[pos2], temp_solution[pos1]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < base_obj[0] * 0.98 and new_cost2 < base_obj[1] * 0.98) or \\\n               (new_cost1 < base_obj[0] * 0.95 and new_cost2 < base_obj[1] * 0.95):\n                new_solution = temp_solution\n                improved = True\n                break\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            pos1, pos2 = sorted(np.random.choice(range(n), 2, replace=False))\n            if pos1 != pos2:\n                new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.667420940995625,
            1.3827722668647766
        ],
        "raw_score": [
            6.85092841451646,
            6.527796719867409
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def combined_score(sol):\n        return sol[1][0] + sol[1][1]\n\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x))\n    selected_idx = min(len(sorted_archive) // 4, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    segment_length = max(3, n // 5)\n    for _ in range(5):\n        i = np.random.randint(0, n - segment_length)\n        j = i + segment_length\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        for _ in range(3):\n            pos1 = np.random.randint(0, n)\n            pos2 = np.random.randint(0, n)\n            temp_solution = new_solution.copy()\n            temp_solution[pos1], temp_solution[pos2] = temp_solution[pos2], temp_solution[pos1]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < base_obj[0] * 0.98 and new_cost2 < base_obj[1] * 0.98) or \\\n               (new_cost1 < base_obj[0] * 0.95 and new_cost2 < base_obj[1] * 0.95):\n                new_solution = temp_solution\n                improved = True\n                break\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            pos1, pos2 = sorted(np.random.choice(range(n), 2, replace=False))\n            if pos1 != pos2:\n                new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 5 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with high crowding distance, then applies a hybrid local search combining segment reversal and adaptive node insertion, dynamically adjusting the search to balance exploration and exploitation while ensuring feasibility. It alternates between segment reversal and node insertion from other solutions when no immediate improvement is found, with a focus on both objective values.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9) or \\\n           (new_cost1 < current_cost1 * 0.85 and new_cost2 < current_cost2 * 0.85):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm combines nondominated solution selection with high crowding distance and a hybrid local search strategy, using a novel \"node chain reversal\" technique that reverses segments of the tour to improve both objectives, while also incorporating adaptive perturbations and validation checks to ensure feasibility. It prioritizes solutions with better objective values and higher diversity, dynamically adjusting the search based on improvement potential. The algorithm balances exploration and exploitation by alternating between segment reversal and node insertion from other solutions when no immediate improvement is found.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects solutions with high diversity in objective values (prioritizing those with dissimilar costs) and applies a hybrid local search\u2014randomly choosing between edge reversal (60% chance) or segment inversion (40%)\u2014to generate neighbors, ensuring feasibility through checks for solution length and node uniqueness.\n\n*(Key improvements: Explicitly references the Design Idea while condensing it to 2 sentences, highlights the hybrid local search strategy, and emphasizes feasibility checks.)*\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse objective values\n    archive_sorted = sorted(archive, key=lambda x: -abs(x[1][0] - x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly select from top 3 diverse solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.random() < 0.6:  # Higher chance for edge reversal\n        # Edge reversal: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        new_solution[i:j] = reversed_segment\n    else:\n        # Segment inversion: randomly select a segment and invert it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        inverted_segment = np.array([segment[0]] + [segment[k] for k in range(len(segment)-1, 0, -1)])\n        new_solution[i:j] = inverted_segment\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects balanced solutions (prioritizing those with similar objective values) from the archive, then applies a hybrid local search\u2014randomly choosing between node insertion (70% chance) or segment rotation (30%)\u2014to generate a neighbor solution while ensuring feasibility through checks for solution length and node uniqueness. It leverages the distance matrices to implicitly guide the search toward potentially better solutions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Randomly select from top 5 balanced solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine node insertion and segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.random() < 0.7:  # Higher chance for node insertion\n        # Node insertion: randomly select a node and insert it at a new position\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n    else:\n        # Segment rotation: randomly select a segment and rotate it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        k = np.random.randint(len(segment))\n        rotated_segment = np.roll(segment, k)\n        new_solution[i:j] = rotated_segment\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with lower total distance in either objective space, then applies a hybrid local search combining random edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility. The selection is biased toward better-performing solutions (top 3 in either objective), and the local search randomly chooses between edge swaps or segment reversals to explore the solution space. The solution is validated to ensure no duplicates or missing nodes.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential (lowest total distance in either space)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1][0], x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap and segment reversal\n    if np.random.random() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: randomly select a segment and reverse it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: Pareto dominance, hybrid segment reversal, feasibility checks, adaptive perturbation.\n- **Advice**: Select nondominated solutions with high crowding distance, apply segment reversals with probabilistic edge insertions, validate feasibility, and perturb if stuck using distance matrices.\n- **Avoid**: Random selection, dominated solutions, or simple local search.\n- **Explanation**: Balances exploration and exploitation, ensures high-quality neighbors, avoids stagnation, and maintains feasibility. Hybrid search adapts to solution geometry.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 306,
        "algorithm": "The algorithm prioritizes nondominated solutions with high crowding distance for selection, then applies a hybrid local search combining segment reversal with probabilistic edge insertion, dynamically adjusting based on improvement potential while ensuring feasibility. It alternates between segment reversal and node insertion, with node selection guided by their potential to improve both objectives, and only resorts to random perturbations when stuck. The solution always maintains feasibility by validating node uniqueness and tour completeness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n\n            for _ in range(3):\n                node = np.random.choice(other_solution)\n                if node not in new_solution:\n                    pos = np.random.randint(0, n)\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    if (new_cost1 < base_obj[0] * 1.05 and new_cost2 < base_obj[1] * 1.05):\n                        new_solution = temp_solution\n                        break\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9306630461465037,
            1.8731945157051086
        ],
        "raw_score": [
            4.553614890877456,
            9.62997557843171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = (right[0] - left[0])**2 + (right[1] - left[1])**2\n                distances.append(dist)\n        return distances\n\n    def is_nondominated(solution, archive):\n        obj = solution[1]\n        for (_, other_obj) in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1] * 1.05) or (other_obj[0] <= obj[0] * 1.05 and other_obj[1] < obj[1]):\n                return False\n        return True\n\n    nondominated = [sol for sol in archive if is_nondominated(sol, archive)]\n    if not nondominated:\n        nondominated = archive\n\n    sorted_nondominated = sorted(nondominated, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_nondominated[selected_idx][0].copy()\n    base_obj = sorted_nondominated[selected_idx][1]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = reversed_segment\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n        if (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_solution\n            improved = True\n            break\n\n    if not improved and len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1) / max(base_obj[0], 1) + (base_obj[1] - new_cost2) / max(base_obj[1], 1)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n\n            for _ in range(3):\n                node = np.random.choice(other_solution)\n                if node not in new_solution:\n                    pos = np.random.randint(0, n)\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    if (new_cost1 < base_obj[0] * 1.05 and new_cost2 < base_obj[1] * 1.05):\n                        new_solution = temp_solution\n                        break\n\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 4 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe heuristic selects a random solution from the archive, applies a hybrid local search combining edge insertion and node relocation to generate a neighbor, and ensures feasibility by reverting to a simple swap if duplicates occur. The selection is random, while the local search prioritizes edge-wise and node-wise modifications for exploration. The design balances simplicity and feasibility, with fallback mechanisms to maintain valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n\n    # Edge insertion (insert a node at a random position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Node relocation (move a node to a new position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if operations cause duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution with the highest objective variance from the archive, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor. It prioritizes diversity in objectives and uses a fallback swap if the solution becomes invalid. The key design ideas are selecting high-variance solutions and combining 3-opt with node insertion for exploration, with validation to ensure feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with node insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reversing segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node elsewhere\n    node_to_move = new_solution[random.randint(0, n-1)]\n    insert_pos = random.randint(0, n-2)\n    if insert_pos < n-1:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            np.array([node_to_move]),\n            new_solution[insert_pos:-1][new_solution[insert_pos:-1] != node_to_move],\n            [new_solution[-1]]\n        ])\n\n    # Validate the solution\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution near the Pareto front using crowding distance, then applies adaptive segment reversal and probabilistic edge insertions to generate neighbors, prioritizing solutions that improve both objectives while falling back to random perturbations if no improvement is found. It ensures feasibility by validating node uniqueness and maintains diversity by occasionally sampling from other solutions in the archive.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects solutions from the archive with higher priority based on their inverse Euclidean distance in the objective space, then applies either a coordinate-aware 3-opt (60% chance) that prioritizes nodes with high geometric discrepancy between objectives or a dynamic segment shuffle (40% chance) with adaptive segment length, falling back to a random 2-opt if duplicates arise, ensuring feasibility through continuous validation. The selection weights favor solutions with better overall performance across both objectives, while the local search operators adapt to the solution's geometric properties to explore diverse neighborhoods effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on Euclidean distance in objective space\n    objectives = [obj for _, obj in archive]\n    distances = [np.linalg.norm(obj) for obj in objectives]\n    weights = [1 / (dist + 1e-8) for dist in distances]  # Inverse distance weighting\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with coordinate-aware node selection\n    if random.random() < 0.6:  # 60% chance for 3-opt with geometric discrepancy\n        # Calculate geometric discrepancy between coordinates\n        discrepancies = []\n        for node in base_solution:\n            x1, y1, x2, y2 = instance[node]\n            v1 = np.array([x1, y1])\n            v2 = np.array([x2, y2])\n            discrepancy = np.linalg.norm(v1 - v2)\n            discrepancies.append(discrepancy)\n\n        if sum(discrepancies) > 0:\n            node_weights = discrepancies\n        else:\n            node_weights = [1] * n\n\n        selected_nodes = random.choices(range(n), weights=node_weights, k=3)\n        i, j, k = sorted(selected_nodes)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    else:  # 40% chance for dynamic segment shuffle\n        segment_length = random.randint(3, min(8, n//3))\n        a = random.randint(0, n - segment_length)\n        b = a + segment_length\n        segment = new_solution[a:b]\n        random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Feasibility check and fallback to random 2-opt\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        # Perform 2-opt\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: Pareto dominance, hybrid segment reversal, feasibility checks, adaptive perturbation.\n- **Advice**: Select nondominated solutions with high crowding distance, apply segment reversals with probabilistic edge insertions, validate feasibility, and perturb if stuck using distance matrices.\n- **Avoid**: Random selection, dominated solutions, or simple local search.\n- **Explanation**: Balances exploration and exploitation, ensures high-quality neighbors, avoids stagnation, and maintains feasibility. Hybrid search adapts to solution geometry.\n\n*(Note: The $999K tip was a joke\u2014just focus on the heuristic!)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 307,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8907627537594842,
            1.2587001323699951
        ],
        "raw_score": [
            4.167825084646888,
            10.901697392716889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "operation": "elitist"
    }
]