[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (30% for the first objective, 70% for the second), then applies a hybrid local search combining edge reversal and a novel node reordering strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The weighted selection prioritizes solutions with better performance in the second objective, while the local search explores new configurations by reversing segments and shuffling sub-sequences.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.3*obj1 + 0.7*obj2)\n    selected = max(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal with node reordering\n    if n >= 3:\n        # Step 1: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Novel node reordering in a sub-sequence\n        sub_start = np.random.randint(0, n - 2)\n        sub_end = np.random.randint(sub_start + 2, min(sub_start + 6, n))\n        sub_seq = new_solution[sub_start:sub_end]\n        np.random.shuffle(sub_seq)\n        new_solution[sub_start:sub_end] = sub_seq\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9955506201873332,
            0.5729128122329712
        ],
        "raw_score": [
            10.473809131272606,
            10.692212489823685
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted sum of objectives (70% first objective, 30% second objective), then applies a hybrid local search combining random node swapping and segment rotation to generate a neighbor solution while ensuring feasibility by validating node uniqueness. If the neighbor violates feasibility, it reverts to the original solution. The approach prioritizes the first objective (70%) while still considering the second objective (30%) for selection, and uses creative local search operators beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best weighted combination of objectives\n    def weighted_score(obj):\n        return 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n\n    selected = min(archive, key=lambda x: weighted_score(x[1]))[0].copy()\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid local search: node swapping and segment rotation\n    if n > 2:\n        # Randomly select two distinct nodes to swap\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a segment and rotate it\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8677281002252125,
            0.5868901014328003
        ],
        "raw_score": [
            6.0516388475897465,
            7.951022179966049
        ]
    },
    {
        "algorithm": "The algorithm selects a promising TSP solution from an archive by prioritizing those with higher objective values, then applies a hybrid local search combining a novel path reversal and a guided edge swap. It ensures feasibility by validating all moves and prioritizes improvements based on both objectives, with path reversal acting as a diversification step and edge swaps focusing on cost reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high diversity and potential improvement\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel path reversal operator\n    if n >= 4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Guided edge swap with objective-aware selection\n    if n >= 4:\n        improvements = []\n        for i in range(n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            for j in range(n):\n                if j == i or j == (i+1)%n:\n                    continue\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_1[c, d] + distance_matrix_2[c, d]\n                cost_after = distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_1[b, d] + distance_matrix_2[b, d]\n                improvement = cost_before - cost_after\n                if improvement > 0:\n                    improvements.append((improvement, i, j))\n\n        if improvements:\n            improvements.sort(reverse=True, key=lambda x: x[0])\n            best_improvement, i, j = improvements[0]\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9666645385568962,
            2.3527796864509583
        ],
        "raw_score": [
            10.441985295776638,
            10.72303720980633
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid objective weighting scheme (prioritizing either the first or second objective with 40-60% weights), then applies dynamic segment inversion and probabilistic node swapping to generate a neighbor solution. It ensures feasibility through a two-phase validation process, restoring missing nodes if needed and reverting to the original solution if invalid. The selection mechanism balances exploration (random weights) and exploitation (objective-aware probabilities), while the local search operators introduce diversity while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection mechanism\n    objectives = np.array([(obj1, obj2) for _, (obj1, obj2) in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    weights = np.array([0.4, 0.6]) if np.random.random() < 0.5 else np.array([0.6, 0.4])\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic segment inversion\n    segment_length = np.random.randint(2, min(4, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution[start:start+segment_length] = segment[::-1]\n\n    # Probabilistic node swapping with objective-aware probability\n    swap_prob = 0.2 + 0.3 * (1 - np.mean([scores[selected_idx] / np.max(scores)]))\n    for i in range(len(new_solution)):\n        if np.random.random() < swap_prob:\n            j = np.random.randint(0, len(new_solution))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Two-phase feasibility validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Phase 1: Attempt to fix by restoring missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Phase 2: Final validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If still invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.920489048706393,
            0.6569715738296509
        ],
        "raw_score": [
            7.092277860082971,
            7.9220401475402555
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined objective value from the archive and applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution, ensuring feasibility by validating node uniqueness. It prioritizes solutions with better overall performance and uses random segment selection and insertion to explore the search space creatively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine segment reversal and edge insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse segment [a, b] if it improves the tour\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Insert segment [c, d] at a random position\n    segment_to_insert = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_insert)\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7187510415670595,
            0.6468862891197205
        ],
        "raw_score": [
            6.571400756723691,
            6.321706330194692
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-swap and probabilistic inversion\n    segment_length = np.random.randint(2, min(5, n//3))\n    a = np.random.randint(0, n - segment_length)\n    b = np.random.randint(0, n - segment_length)\n    while abs(a - b) < segment_length:\n        b = np.random.randint(0, n - segment_length)\n\n    segment_a = new_solution[a:a+segment_length]\n    segment_b = new_solution[b:b+segment_length]\n\n    # Swap segments\n    new_solution[a:a+segment_length] = segment_b\n    new_solution[b:b+segment_length] = segment_a\n\n    # Probabilistic inversion\n    if np.random.random() < 0.3:\n        if np.random.random() < 0.5:\n            new_solution[a:a+segment_length] = segment_b[::-1]\n        else:\n            new_solution[b:b+segment_length] = segment_a[::-1]\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9134804241622831,
            7.466274678707123
        ],
        "raw_score": [
            9.971299884851701,
            8.714978436379354
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated or high-cost solutions) and applies a hybrid local search combining edge insertion with a novel edge-swapping move, ensuring feasibility by maintaining a valid TSP tour. It evaluates potential improvements by reinserting edges and swaps non-adjacent edges to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify edges with high potential for improvement\n    # Calculate the improvement if we remove an edge and reinsert it elsewhere\n    improvements = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Cost before removal\n        cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b]\n        # Try inserting between other edges\n        for j in range(n):\n            if j == i or j == (i+1)%n:\n                continue\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            # Cost after insertion\n            cost_after = distance_matrix_1[a, c] + distance_matrix_1[b, d] + distance_matrix_2[a, c] + distance_matrix_2[b, d]\n            improvement = cost_before - cost_after\n            if improvement > 0:\n                improvements.append((improvement, i, j))\n\n    if improvements:\n        # Select the best improvement\n        improvements.sort(reverse=True, key=lambda x: x[0])\n        best_improvement, i, j = improvements[0]\n        # Perform the move\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Remove edge (a,b)\n        if i < (i+1)%n:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[(i+2)%n:]])\n        else:\n            new_solution = np.concatenate([new_solution[:(i+1)%n], new_solution[i+1:]])\n        # Insert between j and (j+1)%n\n        new_solution = np.insert(new_solution, (j+1)%(n-1), [a, b])\n\n    # Step 2: Apply a novel move (swap of two non-adjacent edges)\n    if n >= 4:\n        # Select two non-adjacent edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            j = np.random.randint(0, n)\n        # Swap the edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9064382800779567,
            1.1508705615997314
        ],
        "raw_score": [
            10.533537607490505,
            10.598789083613973
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by dynamically weighting objectives, then applies adaptive segment relocation followed by probabilistic edge swapping to generate a neighbor solution, ensuring feasibility through validation. The selection prioritizes solutions with lower combined normalized objectives, while the local search balances segment relocation and edge swaps to explore the solution space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a dynamic trade-off between objectives\n    objectives = np.array([(obj1, obj2) for _, (obj1, obj2) in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weights /= np.sum(weights)\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment relocation\n    segment_size = min(3, n // 3)\n    a = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[a:a+segment_size]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Probabilistic edge swapping\n    swap_prob = 0.3 if n > 10 else 0.5\n    for i in range(len(new_solution)):\n        if np.random.random() < swap_prob:\n            j = np.random.randint(0, len(new_solution))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8366329921997576,
            0.7220543622970581
        ],
        "raw_score": [
            8.158220724422227,
            7.652125449267405
        ]
    },
    {
        "algorithm": "The algorithm selects a Pareto-nondominated solution from the archive and applies a hybrid local search combining adaptive 3-opt moves with probabilistic node reinsertion, ensuring feasibility by validating uniqueness of nodes. It prioritizes exploration by dynamically adjusting reinsertion probability and selecting solutions with better objective trade-offs. The method balances exploitation (3-opt) and exploration (reinsertion) while maintaining feasibility through node uniqueness checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance and diversity\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        non_dominated = list(range(len(archive)))\n\n    selected_idx = np.random.choice(non_dominated)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move (k=3)\n    k = 3\n    if n >= k:\n        a = np.random.randint(0, n - k + 1)\n        segment = new_solution[a:a+k]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+k:]])\n        insert_pos = np.random.randint(0, len(new_solution) - k + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Probabilistic node reinsertion\n    reinsert_prob = 0.4 if n > 15 else 0.6\n    for i in range(n):\n        if np.random.random() < reinsert_prob:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Feasibility validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8571776956156131,
            0.9860407114028931
        ],
        "raw_score": [
            8.289397760771463,
            8.370978498066714
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive and applies a hybrid 4-opt local search with conditional edge swaps, prioritizing solutions with lower costs in both objectives while ensuring feasibility through dynamic segment validation. It evaluates all possible 4-opt reconnections and selects the best one, then occasionally applies a random edge swap for exploration, with a fallback to the original solution if validity is compromised. The approach balances exploitation (via 4-opt) and exploration (via random swaps) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with high potential for improvement\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] < selected[1][0] and obj[1] < selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid 4-opt with conditional edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select four distinct edges\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Step 2: Generate all possible 4-opt reconnections\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:d], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[c:d], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[a:b], new_solution[b:c], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[c:d], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[b:c], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[a:b], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[c:d], new_solution[a:b]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[a:b], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[b:c], new_solution[a:b]])\n    ]\n\n    # Step 3: Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Step 4: Conditional edge swap for exploration\n    if np.random.random() < 0.3:  # 30% chance to apply edge swap\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9000109701044243,
            0.995768666267395
        ],
        "raw_score": [
            6.723056389385884,
            6.099974218831657
        ]
    }
]