[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (30% for the first objective, 70% for the second), then applies a hybrid local search combining edge reversal and a novel node reordering strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The weighted selection prioritizes solutions with better performance in the second objective, while the local search explores new configurations by reversing segments and shuffling sub-sequences.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.3*obj1 + 0.7*obj2)\n    selected = max(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal with node reordering\n    if n >= 3:\n        # Step 1: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Novel node reordering in a sub-sequence\n        sub_start = np.random.randint(0, n - 2)\n        sub_end = np.random.randint(sub_start + 2, min(sub_start + 6, n))\n        sub_seq = new_solution[sub_start:sub_end]\n        np.random.shuffle(sub_seq)\n        new_solution[sub_start:sub_end] = sub_seq\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9955506201873332,
            0.5729128122329712
        ],
        "raw_score": [
            10.473809131272606,
            10.692212489823685
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on its quality relative to the average cost, then applies a hybrid local search combining probabilistic edge reversal and adaptive segment relocation to generate a neighbor solution while maintaining feasibility through constrained segment manipulation. The selection prioritizes solutions near the average cost with slight randomness, while the local search focuses on small-scale perturbations (edges and segments) with adaptive segment sizes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on solution quality\n    total_costs = [sum(obj) for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    selected = min(archive, key=lambda x: abs(sum(x[1]) - avg_cost) * (1 + np.random.random()))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation\n    if n >= 5:\n        # Step 1: Probabilistic edge reversal\n        for i in range(n - 1):\n            if np.random.random() < 0.2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Step 2: Adaptive segment relocation\n        seg_size = min(3, max(2, int(np.random.normal(2.5, 0.5))))\n        seg_start = np.random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n        insert_pos = np.random.randint(0, n - seg_size)\n        if insert_pos >= seg_start:\n            insert_pos += seg_size\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_size:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7401874502706116,
            0.32838261127471924
        ],
        "raw_score": [
            7.617947148898726,
            8.118519850301334
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted objective (60% second objective, 40% first objective) and applies a hybrid local search combining random node insertion and segment reversal to generate a neighbor solution while ensuring feasibility. The method prioritizes diversification by favoring solutions with better performance in the second objective while still considering the first objective, and it explores the solution space through non-standard moves beyond typical 2-opt operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.6*obj2 + 0.4*obj1)\n    selected = max(archive, key=lambda x: 0.6 * x[1][1] + 0.4 * x[1][0])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with segment reversal\n    if n >= 4:\n        # Step 1: Random node insertion\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Segment reversal\n        seg_start = np.random.randint(0, n - 3)\n        seg_end = np.random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution[seg_start:seg_end] = segment[::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9187942615714717,
            0.5609147548675537
        ],
        "raw_score": [
            10.502911486257478,
            10.571506545395131
        ]
    },
    {
        "algorithm": "The algorithm combines **adaptive Pareto frontier sampling** (prioritizing solutions with high crowding distance) with a **segmented crossover operator** that dynamically blends segments from diverse archive solutions, using a **hybrid objective weighting scheme** to evaluate segment quality while ensuring feasibility through **multi-stage validation**. It balances exploration and exploitation by probabilistically selecting segments from multiple solutions, with segment sizes and positions determined by both objective-aware metrics and spatial proximity in the coordinate spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto frontier sampling with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select multiple diverse solutions for segment crossover\n    selected_indices = np.argsort(-crowding_dist)[:min(3, len(archive))]\n    base_solution = archive[selected_indices[0]][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented crossover operator\n    if len(selected_indices) > 1:\n        # Select random segments from diverse solutions\n        segment_length = np.random.randint(2, min(4, n // 2))\n        for idx in selected_indices[1:]:\n            donor = archive[idx][0]\n            start = np.random.randint(0, n - segment_length)\n            segment = donor[start:start+segment_length]\n\n            # Find insertion point in new_solution that maintains spatial proximity\n            best_pos = start\n            min_cost = float('inf')\n            for pos in range(n - segment_length + 1):\n                # Evaluate insertion using hybrid objective weights\n                weight1 = 0.5 + 0.3 * (np.std(objectives[:, 0]) / (np.mean(objectives[:, 0]) + 1e-10))\n                weight2 = 0.5 + 0.3 * (np.std(objectives[:, 1]) / (np.mean(objectives[:, 1]) + 1e-10))\n\n                # Calculate cost before and after insertion\n                cost_before = 0\n                cost_after = 0\n                for i in range(pos - 1, pos + segment_length + 1):\n                    i = i % n\n                    j = (i + 1) % n\n                    cost_before += weight1 * distance_matrix_1[new_solution[i], new_solution[j]] + weight2 * distance_matrix_2[new_solution[i], new_solution[j]]\n\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n                for i in range(pos - 1, pos + segment_length + 1):\n                    i = i % n\n                    j = (i + 1) % n\n                    cost_after += weight1 * distance_matrix_1[temp_solution[i], temp_solution[j]] + weight2 * distance_matrix_2[temp_solution[i], temp_solution[j]]\n\n                if cost_after < min_cost:\n                    min_cost = cost_after\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos+segment_length:]])\n\n    # Multi-stage validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair missing nodes by inserting them at positions that minimize cost\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(n + 1):\n                temp_solution = np.insert(new_solution, pos, node)\n                cost = 0\n                for i in range(n):\n                    j = (i + 1) % (n + 1)\n                    cost += distance_matrix_1[temp_solution[i], temp_solution[j]] + distance_matrix_2[temp_solution[i], temp_solution[j]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0218214740148481,
            12.304687201976776
        ],
        "raw_score": [
            10.455947482879868,
            10.654918945587069
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding-distance-based selection, then applies a hybrid 3-opt local search with adaptive node insertion, evaluating all possible 3-opt reconnections and occasionally inserting a random node for exploration while ensuring feasibility. It prioritizes solutions with high crowding distance in the objective space and balances exploitation (3-opt) with exploration (adaptive insertion), with a 25% chance of applying the latter. The final solution is validated to ensure it remains a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            left = archive[-1][1]\n            right = archive[1][1] if len(archive) > 1 else archive[0][1]\n        elif i == len(archive) - 1:\n            left = archive[i-1][1]\n            right = archive[0][1]\n        else:\n            left = archive[i-1][1]\n            right = archive[i+1][1]\n\n        dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid 3-opt with adaptive node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select three distinct nodes\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Step 2: Generate all possible 3-opt reconnections\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[c:], new_solution[b:c], new_solution[a:b]]),\n        np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:]]),\n        np.concatenate([new_solution[:b], new_solution[c:], new_solution[a:c], new_solution[b:a]])\n    ]\n\n    # Step 3: Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Step 4: Adaptive node insertion for exploration\n    if np.random.random() < 0.25:  # 25% chance to apply node insertion\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        while abs(i - j) <= 1:\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.694207543171247,
            0.38689321279525757
        ],
        "raw_score": [
            7.051319865362183,
            7.193925202037143
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on normalized objective values, then applies a hybrid local search combining a novel 5-opt move and adaptive edge swaps to generate a neighbor solution. The 5-opt reconnects five non-adjacent edges to reduce cost in both objective spaces, while adaptive swaps dynamically adjust the acceptance threshold based on the current solution's quality. The algorithm prioritizes solutions with higher normalized objective sums and ensures feasibility by maintaining a valid TSP tour throughout the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high normalized objective sum\n    normalized_objects = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / max(o[0] for _, o in archive), obj[1] / max(o[1] for _, o in archive))\n        normalized_objects.append(sum(norm_obj))\n    selected_idx = np.argmax(normalized_objects)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 5-opt with adaptive edge swaps\n    if n >= 8:\n        # Select 5 non-adjacent edges\n        points = sorted(np.random.choice(n, 5, replace=False))\n        while any(abs(points[i] - points[i+1]) <= 1 for i in range(4)):\n            points = sorted(np.random.choice(n, 5, replace=False))\n\n        # Reconnect edges to form a new cycle\n        for i in range(2):\n            new_solution[points[i]+1:points[i+1]+1] = new_solution[points[i]+1:points[i+1]+1][::-1]\n\n        # Adaptive edge swaps\n        current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        threshold = current_cost * 0.95  # 5% improvement threshold\n\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            while abs(a - b) <= 1:\n                a, b = sorted(np.random.choice(n, 2, replace=False))\n\n            cost_after = (current_cost -\n                          distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] -\n                          distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] -\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                          distance_matrix_1[new_solution[a], new_solution[b]] +\n                          distance_matrix_2[new_solution[a], new_solution[b]] +\n                          distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]] +\n                          distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n\n            if cost_after < threshold:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                current_cost = cost_after\n                threshold = current_cost * 0.95\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9901043979175816,
            3.6194695830345154
        ],
        "raw_score": [
            10.452823570295662,
            10.580843633434633
        ]
    },
    {
        "algorithm": "The algorithm selects a promising TSP solution from an archive by prioritizing those with higher objective values, then applies a hybrid local search combining a novel path reversal and a guided edge swap. It ensures feasibility by validating all moves and prioritizes improvements based on both objectives, with path reversal acting as a diversification step and edge swaps focusing on cost reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high diversity and potential improvement\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel path reversal operator\n    if n >= 4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Guided edge swap with objective-aware selection\n    if n >= 4:\n        improvements = []\n        for i in range(n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            for j in range(n):\n                if j == i or j == (i+1)%n:\n                    continue\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_1[c, d] + distance_matrix_2[c, d]\n                cost_after = distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_1[b, d] + distance_matrix_2[b, d]\n                improvement = cost_before - cost_after\n                if improvement > 0:\n                    improvements.append((improvement, i, j))\n\n        if improvements:\n            improvements.sort(reverse=True, key=lambda x: x[0])\n            best_improvement, i, j = improvements[0]\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9666645385568962,
            2.3527796864509583
        ],
        "raw_score": [
            10.441985295776638,
            10.72303720980633
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted sum of objectives (70% first objective, 30% second objective), then applies a hybrid local search combining random node swapping and segment rotation to generate a neighbor solution while ensuring feasibility by validating node uniqueness. If the neighbor violates feasibility, it reverts to the original solution. The approach prioritizes the first objective (70%) while still considering the second objective (30%) for selection, and uses creative local search operators beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best weighted combination of objectives\n    def weighted_score(obj):\n        return 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n\n    selected = min(archive, key=lambda x: weighted_score(x[1]))[0].copy()\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid local search: node swapping and segment rotation\n    if n > 2:\n        # Randomly select two distinct nodes to swap\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a segment and rotate it\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8677281002252125,
            0.5868901014328003
        ],
        "raw_score": [
            6.0516388475897465,
            7.951022179966049
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-aware crowding distance, then applies a hybrid local search combining weighted 3-opt moves (prioritizing objectives based on their relative costs) and adaptive node insertion (placing unvisited nodes optimally while balancing both objectives). The method ensures feasibility by maintaining valid TSP tours through constrained segment manipulation and multi-objective cost validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        left_obj = archive[i-1][1] if i > 0 else None\n        right_obj = archive[(i+1)%len(archive)][1] if len(archive) > 1 else None\n        if left_obj is None or right_obj is None:\n            crowding_distances.append(float('inf'))\n        else:\n            dist = sum(abs(obj[j] - left_obj[j]) + abs(obj[j] - right_obj[j]) for j in range(2))\n            crowding_distances.append(dist)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: weighted 3-opt with adaptive node insertion\n    if n >= 5:\n        # Weighted 3-opt move\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n        while abs(i-j) <= 1 or abs(i-k) <= 1 or abs(j-k) <= 1:\n            j = np.random.randint(0, n)\n            k = np.random.randint(0, n)\n        i, j, k = sorted([i, j, k])\n\n        # Calculate objective-weighted probabilities\n        total_cost = sum(archive[selected_idx][1])\n        weights = [archive[selected_idx][1][0]/total_cost, archive[selected_idx][1][1]/total_cost]\n        if np.random.random() < weights[0]:\n            # Reconnect edges based on first objective\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n        else:\n            # Reconnect edges based on second objective\n            new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n\n        # Adaptive node insertion\n        unvisited = set(range(n)) - set(new_solution)\n        if unvisited:\n            node = np.random.choice(list(unvisited))\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n):\n                temp_solution = np.insert(new_solution, pos, node)\n                cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n+1)]] * weights[0] +\n                           distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n+1)]] * weights[1]\n                           for i in range(n+1))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9492685259941069,
            0.7019399404525757
        ],
        "raw_score": [
            10.403098974678334,
            10.06264526392853
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive by clustering solutions based on their objectives and prioritizing clusters with high diversity (measured by crowding distance), then applies a guided segment insertion operator to move a random segment of the tour to a position that maximizes Pareto dominance, while ensuring feasibility through validation and repair. The operator adaptively balances objectives by occasionally accepting non-improving moves to escape local optima, combining clustering and segment-based exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Objective-aware clustering and selection\n    clusters = {}\n    for sol, obj in archive:\n        key = (round(obj[0], 2), round(obj[1], 2))\n        if key not in clusters:\n            clusters[key] = []\n        clusters[key].append((sol, obj))\n\n    selected = None\n    max_diversity = -1\n    for key in clusters:\n        cluster = clusters[key]\n        if len(cluster) < 2:\n            continue\n        diversity = np.std([obj[0] for sol, obj in cluster]) + np.std([obj[1] for sol, obj in cluster])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected = max(cluster, key=lambda x: crowding_distance(x, cluster))\n\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Step 2: Guided segment insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 3:\n        # Randomly select a segment to move\n        seg_start = np.random.randint(0, n)\n        seg_length = np.random.randint(2, min(5, n))\n        seg_end = (seg_start + seg_length) % n\n        segment = new_solution[seg_start:seg_end] if seg_start < seg_end else np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n\n        # Find best insertion position to maximize Pareto dominance\n        best_pos = -1\n        best_cost = (float('inf'), float('inf'))\n\n        for pos in range(n):\n            if pos in range(seg_start, seg_end) if seg_start < seg_end else (pos in range(seg_start, n) or pos in range(0, seg_end)):\n                continue  # Skip positions within the segment\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, [i % n for i in range(seg_start, seg_end)])\n            ])\n\n            # Compute objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Check Pareto dominance\n            if (cost1 <= best_cost[0] and cost2 < best_cost[1]) or (cost1 < best_cost[0] and cost2 <= best_cost[1]):\n                best_cost = (cost1, cost2)\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                np.delete(new_solution, [i % n for i in range(seg_start, seg_end)])\n            ])\n\n    # Step 3: Validate feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        new_solution = repair_tour(new_solution, n)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9705350154326292,
            3.216228723526001
        ],
        "raw_score": [
            10.541311543414118,
            10.564977281792306
        ]
    }
]