[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (30% for the first objective, 70% for the second), then applies a hybrid local search combining edge reversal and a novel node reordering strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The weighted selection prioritizes solutions with better performance in the second objective, while the local search explores new configurations by reversing segments and shuffling sub-sequences.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.3*obj1 + 0.7*obj2)\n    selected = max(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal with node reordering\n    if n >= 3:\n        # Step 1: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Novel node reordering in a sub-sequence\n        sub_start = np.random.randint(0, n - 2)\n        sub_end = np.random.randint(sub_start + 2, min(sub_start + 6, n))\n        sub_seq = new_solution[sub_start:sub_end]\n        np.random.shuffle(sub_seq)\n        new_solution[sub_start:sub_end] = sub_seq\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9955506201873332,
            0.5729128122329712
        ],
        "raw_score": [
            10.473809131272606,
            10.692212489823685
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted objective (60% second objective, 40% first objective) and applies a hybrid local search combining random node insertion and segment reversal to generate a neighbor solution while ensuring feasibility. The method prioritizes diversification by favoring solutions with better performance in the second objective while still considering the first objective, and it explores the solution space through non-standard moves beyond typical 2-opt operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.6*obj2 + 0.4*obj1)\n    selected = max(archive, key=lambda x: 0.6 * x[1][1] + 0.4 * x[1][0])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with segment reversal\n    if n >= 4:\n        # Step 1: Random node insertion\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Segment reversal\n        seg_start = np.random.randint(0, n - 3)\n        seg_end = np.random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution[seg_start:seg_end] = segment[::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9187942615714717,
            0.5609147548675537
        ],
        "raw_score": [
            10.502911486257478,
            10.571506545395131
        ]
    },
    {
        "algorithm": "The algorithm combines **adaptive Pareto frontier sampling** (prioritizing solutions with high crowding distance) with a **segmented crossover operator** that dynamically blends segments from diverse archive solutions, using a **hybrid objective weighting scheme** to evaluate segment quality while ensuring feasibility through **multi-stage validation**. It balances exploration and exploitation by probabilistically selecting segments from multiple solutions, with segment sizes and positions determined by both objective-aware metrics and spatial proximity in the coordinate spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto frontier sampling with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select multiple diverse solutions for segment crossover\n    selected_indices = np.argsort(-crowding_dist)[:min(3, len(archive))]\n    base_solution = archive[selected_indices[0]][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented crossover operator\n    if len(selected_indices) > 1:\n        # Select random segments from diverse solutions\n        segment_length = np.random.randint(2, min(4, n // 2))\n        for idx in selected_indices[1:]:\n            donor = archive[idx][0]\n            start = np.random.randint(0, n - segment_length)\n            segment = donor[start:start+segment_length]\n\n            # Find insertion point in new_solution that maintains spatial proximity\n            best_pos = start\n            min_cost = float('inf')\n            for pos in range(n - segment_length + 1):\n                # Evaluate insertion using hybrid objective weights\n                weight1 = 0.5 + 0.3 * (np.std(objectives[:, 0]) / (np.mean(objectives[:, 0]) + 1e-10))\n                weight2 = 0.5 + 0.3 * (np.std(objectives[:, 1]) / (np.mean(objectives[:, 1]) + 1e-10))\n\n                # Calculate cost before and after insertion\n                cost_before = 0\n                cost_after = 0\n                for i in range(pos - 1, pos + segment_length + 1):\n                    i = i % n\n                    j = (i + 1) % n\n                    cost_before += weight1 * distance_matrix_1[new_solution[i], new_solution[j]] + weight2 * distance_matrix_2[new_solution[i], new_solution[j]]\n\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n                for i in range(pos - 1, pos + segment_length + 1):\n                    i = i % n\n                    j = (i + 1) % n\n                    cost_after += weight1 * distance_matrix_1[temp_solution[i], temp_solution[j]] + weight2 * distance_matrix_2[temp_solution[i], temp_solution[j]]\n\n                if cost_after < min_cost:\n                    min_cost = cost_after\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos+segment_length:]])\n\n    # Multi-stage validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair missing nodes by inserting them at positions that minimize cost\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(n + 1):\n                temp_solution = np.insert(new_solution, pos, node)\n                cost = 0\n                for i in range(n):\n                    j = (i + 1) % (n + 1)\n                    cost += distance_matrix_1[temp_solution[i], temp_solution[j]] + distance_matrix_2[temp_solution[i], temp_solution[j]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0218214740148481,
            12.304687201976776
        ],
        "raw_score": [
            10.455947482879868,
            10.654918945587069
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto frontier selection with a novel 3-segment inversion and dynamic edge insertion strategy. It prioritizes solutions near the Pareto frontier using a weighted combination of normalized objectives and crowding distance, then applies a local search operator that dynamically partitions the tour, inverts a middle segment, and inserts a strategically chosen edge to maintain feasibility while improving both objectives. The operator balances exploration and exploitation by adaptively adjusting segment lengths and insertion points based on the current solution's objective values.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution near Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    norm_sum = np.sum(normalized_obj, axis=1)\n\n    # Calculate crowding distances\n    sorted_indices = np.argsort(norm_sum)\n    crowding_dist = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_indices[i]] = norm_sum[sorted_indices[i+1]] - norm_sum[sorted_indices[i-1]]\n\n    # Combine normalized sum and crowding distance\n    selection_score = 0.7 * norm_sum + 0.3 * crowding_dist\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 6:\n        # Dynamic segment selection\n        seg_points = sorted(np.random.choice(n, 3, replace=False))\n        a, b, c = seg_points\n\n        # Invert middle segment\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Dynamic edge insertion\n        remaining_edges = [i for i in range(n) if i not in seg_points]\n        if remaining_edges:\n            insert_pos = np.random.choice(remaining_edges)\n            insert_val = new_solution[insert_pos]\n\n            # Find best insertion point\n            best_pos = -1\n            best_cost = float('inf')\n            for i in range(n):\n                if i not in seg_points:\n                    # Calculate cost for both objectives\n                    cost1 = distance_matrix_1[new_solution[i-1], insert_val] + distance_matrix_1[insert_val, new_solution[i]]\n                    cost2 = distance_matrix_2[new_solution[i-1], insert_val] + distance_matrix_2[insert_val, new_solution[i]]\n                    total_cost = cost1 + cost2\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = i\n\n            if best_pos != -1:\n                # Insert the edge\n                new_solution = np.concatenate([new_solution[:best_pos], [insert_val], new_solution[best_pos:]])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9135442071875497,
            0.5328848361968994
        ],
        "raw_score": [
            10.582306014371891,
            10.582789636114658
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest crowding distance (indicating potential for improvement), applies an objective-aware segment insertion to modify the tour, and with 50% probability performs a cross-dimensional edge swap that exchanges edges between the two objective spaces while ensuring feasibility through nearest-neighbor repair. The method prioritizes solutions with higher crowding distances and dynamically adapts the search by considering both objectives, with a focus on edge swaps that balance improvements in both cost spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            left = archive[-1][1]\n            right = archive[1][1] if len(archive) > 1 else archive[0][1]\n        elif i == len(archive) - 1:\n            left = archive[i-1][1]\n            right = archive[0][1]\n        else:\n            left = archive[i-1][1]\n            right = archive[i+1][1]\n\n        dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment insertion\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b]\n\n    # Insert segment at a new position\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    new_solution = np.concatenate([new_solution[:n], new_solution[n-len(segment):]])\n\n    # Adaptive edge swap with 50% probability\n    if np.random.random() < 0.5:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if abs(i - j) > 1:\n            # Cross-dimensional edge swap\n            old_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[i], new_solution[j-1]] + distance_matrix_2[new_solution[j], new_solution[i-1]]\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Nearest-neighbor repair\n        for i in range(n):\n            if new_solution[i] in new_solution[:i]:\n                nearest = None\n                min_cost = float('inf')\n                for j in range(n):\n                    if j not in new_solution[:i]:\n                        cost = distance_matrix_1[new_solution[i-1], j] + distance_matrix_2[new_solution[i-1], j]\n                        if cost < min_cost:\n                            min_cost = cost\n                            nearest = j\n                new_solution[i] = nearest\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9034967405709249,
            0.3372768759727478
        ],
        "raw_score": [
            10.56380391573143,
            10.631862969278057
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-frontier selection with an objective-aware hybrid local search strategy that alternates between merging segments of variable size and conditional node reinsertions, prioritizing the more dominated objective while ensuring feasibility through nearest-neighbor repair. It dynamically adjusts segment size and operation probabilities based on objective balance (larger segments for balanced objectives, smaller targeted reinsertions when one dominates), using adaptive weights (60/40) to guide segment selection. The method maintains feasibility by always checking for missing nodes and repairing with nearest-neighbor insertion when violations occur.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select non-dominated solutions using crowding distance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(non_dominated):\n        if i == 0:\n            left = non_dominated[-1][1]\n            right = non_dominated[1][1] if len(non_dominated) > 1 else non_dominated[0][1]\n        elif i == len(non_dominated) - 1:\n            left = non_dominated[i-1][1]\n            right = non_dominated[0][1]\n        else:\n            left = non_dominated[i-1][1]\n            right = non_dominated[i+1][1]\n\n        weight_obj1 = 0.6 if obj[0] < obj[1] else 0.4\n        weight_obj2 = 0.6 if obj[1] < obj[0] else 0.4\n        dist = (abs(obj[0] - left[0]) + abs(obj[0] - right[0])) * weight_obj1 + (abs(obj[1] - left[1]) + abs(obj[1] - right[1])) * weight_obj2\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment fusion\n    if n >= 4:\n        # Determine segment size based on objective balance\n        obj1, obj2 = non_dominated[selected_idx][1]\n        if abs(obj1 - obj2) < 0.1 * max(obj1, obj2):  # Objectives balanced\n            seg_size = np.random.randint(2, min(4, n//2))\n        else:  # One objective dominates\n            seg_size = np.random.randint(1, min(3, n//3))\n\n        # Select segments to merge\n        seg1_start = np.random.randint(0, n - seg_size)\n        seg1_end = seg1_start + seg_size\n        seg2_start = np.random.randint(seg1_end, n - seg_size) if seg1_end + seg_size < n else np.random.randint(0, seg1_start)\n        seg2_end = seg2_start + seg_size\n\n        # Merge segments with conditional reinsertion\n        merged = np.concatenate([new_solution[seg1_start:seg1_end], new_solution[seg2_start:seg2_end]])\n        if np.random.random() < 0.6 if obj1 < obj2 else 0.4:  # Higher probability for more dominated objective\n            np.random.shuffle(merged)\n\n        # Reinsert merged segment\n        insert_pos = np.random.randint(0, n - len(merged))\n        if insert_pos >= seg1_start:\n            insert_pos += len(merged)\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            new_solution[seg1_end:seg2_start],\n            new_solution[seg2_end:insert_pos],\n            merged,\n            new_solution[insert_pos:]\n        ])\n\n    # Conditional node reinsertion\n    if np.random.random() < 0.3:\n        node = np.random.randint(0, n)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(0, n)\n        if new_pos > old_pos:\n            new_pos -= 1\n        new_solution = np.concatenate([\n            new_solution[:old_pos],\n            new_solution[old_pos+1:new_pos+1],\n            [node],\n            new_solution[new_pos+1:]\n        ])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Nearest-neighbor repair\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n):\n                if i == 0:\n                    cost = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]]\n                    cost += distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]]\n                else:\n                    cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                    cost += distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7420485062130165,
            0.3179783225059509
        ],
        "raw_score": [
            8.420409256176796,
            7.4410171071776725
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-optimality-driven selection with adaptive segment relinking, using a dynamic 3-opt reconnection strategy weighted by objective-specific crowding distances, followed by probabilistic edge insertion and a novel diversification mechanism that occasionally replaces node segments with alternative paths, ensuring feasibility through validation checks. It prioritizes objectives based on their relative magnitudes (weighting them 1.2:0.8 or vice versa) and balances exploration (diversification) with exploitation (local improvement). The solution selection and local search are guided by both objective-specific distances and randomness to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-optimality driven selection\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Objective-specific crowding distance selection\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(non_dominated):\n        if i == 0:\n            left = non_dominated[-1][1]\n            right = non_dominated[1][1] if len(non_dominated) > 1 else non_dominated[0][1]\n        elif i == len(non_dominated) - 1:\n            left = non_dominated[i-1][1]\n            right = non_dominated[0][1]\n        else:\n            left = non_dominated[i-1][1]\n            right = non_dominated[i+1][1]\n\n        # Objective-specific weights\n        weight_obj1 = 1.2 if obj[0] < obj[1] else 0.8\n        weight_obj2 = 1.2 if obj[1] < obj[0] else 0.8\n        dist = (abs(obj[0] - left[0]) + abs(obj[0] - right[0])) * weight_obj1 + (abs(obj[1] - left[1]) + abs(obj[1] - right[1])) * weight_obj2\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic 3-opt reconnection\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        options = [\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[c:], new_solution[a:b], new_solution[b:c]])\n        ]\n\n        best_option = None\n        best_cost = float('inf')\n\n        for option in options:\n            total_cost = 0\n            for i in range(n):\n                j = (i + 1) % n\n                total_cost += distance_matrix_1[option[i], option[j]] * 0.6 + distance_matrix_2[option[i], option[j]] * 0.4\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_option = option.copy()\n\n        if best_option is not None:\n            new_solution = best_option\n\n    # Probabilistic edge insertion\n    if np.random.random() < 0.4:\n        for i in range(n - 2):\n            if np.random.random() < 0.3:\n                j = (i + 1) % n\n                k = (i + 2) % n\n                if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]] > distance_matrix_1[new_solution[i], new_solution[k]]:\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Novel diversification mechanism\n    if np.random.random() < 0.15:\n        seg_size = min(4, max(1, int(np.random.normal(3, 0.8))))\n        seg_start = np.random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n        insert_pos = np.random.randint(0, n - seg_size)\n        if insert_pos >= seg_start:\n            insert_pos += seg_size\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_size:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9288063740424989,
            0.5683112144470215
        ],
        "raw_score": [
            6.966562275506643,
            7.635669880475755
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid objective-diversity score (60% objective, 40% diversity), then applies a multi-segment relocation strategy that considers both objective spaces, with probabilistic segment inversion and adaptive segment merging to explore the solution space effectively. It prioritizes balanced exploration of both objectives (50% weight each) and uses segment-based operations to avoid standard 2-opt limitations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection mechanism combining objective values and solution diversity\n    objective_scores = np.array([(obj[0] + obj[1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2) + 1e-10)\n                                for _, obj in archive])\n    diversity_scores = np.array([np.sum(np.abs(np.diff(sol))) / len(sol) for sol, _ in archive])\n    combined_scores = 0.6 * objective_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-segment relocation strategy\n    if n >= 6:\n        segment_lengths = np.random.choice([2, 3], size=2)\n        start_positions = sorted(np.random.choice(n, size=2, replace=False))\n        segments = [new_solution[start_positions[i]:start_positions[i]+segment_lengths[i]] for i in range(2)]\n\n        # Evaluate insertion points considering both objectives\n        best_positions = []\n        for seg_idx, segment in enumerate(segments):\n            best_pos = -1\n            best_cost = float('inf')\n            for pos in range(n - len(segment) + 1):\n                if any(pos <= start_positions[i] < pos + len(segment) for i in range(2)):\n                    continue\n\n                temp_sol = new_solution.copy()\n                temp_sol = np.concatenate([\n                    temp_sol[:pos],\n                    segment,\n                    np.delete(temp_sol, [start_positions[seg_idx] + i for i in range(len(segment))])\n                ])\n\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                weighted_cost = 0.5 * cost1 + 0.5 * cost2\n\n                if weighted_cost < best_cost:\n                    best_cost = weighted_cost\n                    best_pos = pos\n            best_positions.append(best_pos if best_pos != -1 else np.random.randint(0, n - len(segment) + 1))\n\n        # Apply the best found insertions\n        for seg_idx, segment in enumerate(segments):\n            pos = best_positions[seg_idx]\n            new_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, [start_positions[seg_idx] + i for i in range(len(segment))])\n            ])\n\n    # Adaptive segment merging with probabilistic inversion\n    if n >= 4 and np.random.random() < 0.4:\n        merge_points = sorted(np.random.choice(n, size=2, replace=False))\n        a, b = merge_points\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Evaluate merging options\n        options = [\n            np.concatenate([segment1, segment2, segment3]),  # Original\n            np.concatenate([segment1, segment3, segment2]),  # Swap middle segments\n            np.concatenate([segment2, segment1, segment3]),  # Rotate\n            np.concatenate([segment3, segment1, segment2])   # Reverse rotate\n        ]\n\n        # Evaluate each option\n        best_option = options[0]\n        best_cost = float('inf')\n        for option in options:\n            cost1 = sum(distance_matrix_1[option[i], option[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_option = option\n\n        new_solution = best_option\n\n    # Final probabilistic inversion for diversity\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9954879138255571,
            5.736187040805817
        ],
        "raw_score": [
            10.521909240547783,
            10.633749038399056
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on its quality relative to the average cost, then applies a hybrid local search combining probabilistic edge reversal and adaptive segment relocation to generate a neighbor solution while maintaining feasibility through constrained segment manipulation. The selection prioritizes solutions near the average cost with slight randomness, while the local search focuses on small-scale perturbations (edges and segments) with adaptive segment sizes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on solution quality\n    total_costs = [sum(obj) for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    selected = min(archive, key=lambda x: abs(sum(x[1]) - avg_cost) * (1 + np.random.random()))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation\n    if n >= 5:\n        # Step 1: Probabilistic edge reversal\n        for i in range(n - 1):\n            if np.random.random() < 0.2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Step 2: Adaptive segment relocation\n        seg_size = min(3, max(2, int(np.random.normal(2.5, 0.5))))\n        seg_start = np.random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n        insert_pos = np.random.randint(0, n - seg_size)\n        if insert_pos >= seg_start:\n            insert_pos += seg_size\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_size:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7401874502706116,
            0.32838261127471924
        ],
        "raw_score": [
            7.617947148898726,
            8.118519850301334
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto filtering with a hybrid local search that adaptively applies weighted 3-opt and edge insertion moves, prioritizing solutions with high improvement potential while dynamically balancing between objectives using weights derived from their relative costs. It ensures feasibility through nearest-neighbor repair and selects solutions based on their position in the Pareto front relative to neighboring solutions. The hybrid approach balances exploration with exploitation by evaluating multiple 3-opt configurations and optionally inserting edges to improve solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto filtering\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with highest improvement potential\n    improvement_potentials = []\n    for i, (sol, obj) in enumerate(non_dominated):\n        if i == 0:\n            left = non_dominated[-1][1]\n            right = non_dominated[1][1] if len(non_dominated) > 1 else non_dominated[0][1]\n        elif i == len(non_dominated) - 1:\n            left = non_dominated[i-1][1]\n            right = non_dominated[0][1]\n        else:\n            left = non_dominated[i-1][1]\n            right = non_dominated[i+1][1]\n\n        # Calculate normalized improvement potential\n        norm_obj = (obj[0] / max(1, archive[-1][1][0]), obj[1] / max(1, archive[-1][1][1]))\n        norm_left = (left[0] / max(1, archive[-1][1][0]), left[1] / max(1, archive[-1][1][1]))\n        norm_right = (right[0] / max(1, archive[-1][1][0]), right[1] / max(1, archive[-1][1][1]))\n\n        potential = (abs(norm_obj[0] - norm_left[0]) + abs(norm_obj[1] - norm_left[1]) +\n                     abs(norm_obj[0] - norm_right[0]) + abs(norm_obj[1] - norm_right[1]))\n        improvement_potentials.append(potential)\n\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with adaptive edge insertion\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Generate 3-opt reconnections\n        options = [\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[c:], new_solution[b:a], new_solution[a:b], new_solution[b:c]])\n        ]\n\n        # Evaluate options with dynamic weights\n        best_option = None\n        best_cost = float('inf')\n        obj1_ratio = archive[-1][1][0] / (archive[-1][1][0] + archive[-1][1][1] + 1e-6)\n        obj2_ratio = 1 - obj1_ratio\n\n        for option in options:\n            total_cost = 0\n            for i in range(n):\n                j = (i + 1) % n\n                total_cost += obj1_ratio * distance_matrix_1[option[i], option[j]] + obj2_ratio * distance_matrix_2[option[i], option[j]]\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_option = option.copy()\n\n        if best_option is not None:\n            new_solution = best_option\n\n        # Adaptive edge insertion\n        if np.random.random() < 0.5:\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if abs(i - j) > 1:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                best_pos = 0\n                min_cost = float('inf')\n                for pos in range(n - 1):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    cost = 0\n                    for k in range(n - 1):\n                        l = (k + 1) % (n - 1)\n                        cost += obj1_ratio * distance_matrix_1[temp_solution[k], temp_solution[l]] + obj2_ratio * distance_matrix_2[temp_solution[k], temp_solution[l]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = pos\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate and repair solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(n + 1):\n                temp_solution = np.insert(new_solution, pos, node)\n                cost = 0\n                for i in range(n):\n                    j = (i + 1) % (n + 1)\n                    cost += distance_matrix_1[temp_solution[i], temp_solution[j]] + distance_matrix_2[temp_solution[i], temp_solution[j]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590435950643776,
            1.2287476062774658
        ],
        "raw_score": [
            6.300394739056873,
            6.456846305430978
        ]
    }
]