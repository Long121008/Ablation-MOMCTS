[
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated or high-cost solutions) and applies a hybrid local search combining edge insertion with a novel edge-swapping move, ensuring feasibility by maintaining a valid TSP tour. It evaluates potential improvements by reinserting edges and swaps non-adjacent edges to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify edges with high potential for improvement\n    # Calculate the improvement if we remove an edge and reinsert it elsewhere\n    improvements = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Cost before removal\n        cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b]\n        # Try inserting between other edges\n        for j in range(n):\n            if j == i or j == (i+1)%n:\n                continue\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            # Cost after insertion\n            cost_after = distance_matrix_1[a, c] + distance_matrix_1[b, d] + distance_matrix_2[a, c] + distance_matrix_2[b, d]\n            improvement = cost_before - cost_after\n            if improvement > 0:\n                improvements.append((improvement, i, j))\n\n    if improvements:\n        # Select the best improvement\n        improvements.sort(reverse=True, key=lambda x: x[0])\n        best_improvement, i, j = improvements[0]\n        # Perform the move\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Remove edge (a,b)\n        if i < (i+1)%n:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[(i+2)%n:]])\n        else:\n            new_solution = np.concatenate([new_solution[:(i+1)%n], new_solution[i+1:]])\n        # Insert between j and (j+1)%n\n        new_solution = np.insert(new_solution, (j+1)%(n-1), [a, b])\n\n    # Step 2: Apply a novel move (swap of two non-adjacent edges)\n    if n >= 4:\n        # Select two non-adjacent edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            j = np.random.randint(0, n)\n        # Swap the edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9064382800779567,
            1.1508705615997314
        ],
        "raw_score": [
            10.533537607490505,
            10.598789083613973
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined objective value from the archive and applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution, ensuring feasibility by validating node uniqueness. It prioritizes solutions with better overall performance and uses random segment selection and insertion to explore the search space creatively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine segment reversal and edge insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse segment [a, b] if it improves the tour\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Insert segment [c, d] at a random position\n    segment_to_insert = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_insert)\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7187510415670595,
            0.6468862891197205
        ],
        "raw_score": [
            6.571400756723691,
            6.321706330194692
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by dynamically weighting objectives, then applies adaptive segment relocation followed by probabilistic edge swapping to generate a neighbor solution, ensuring feasibility through validation. The selection prioritizes solutions with lower combined normalized objectives, while the local search balances segment relocation and edge swaps to explore the solution space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a dynamic trade-off between objectives\n    objectives = np.array([(obj1, obj2) for _, (obj1, obj2) in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weights /= np.sum(weights)\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment relocation\n    segment_size = min(3, n // 3)\n    a = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[a:a+segment_size]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Probabilistic edge swapping\n    swap_prob = 0.3 if n > 10 else 0.5\n    for i in range(len(new_solution)):\n        if np.random.random() < swap_prob:\n            j = np.random.randint(0, len(new_solution))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8366329921997576,
            0.7220543622970581
        ],
        "raw_score": [
            8.158220724422227,
            7.652125449267405
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive and applies a hybrid 4-opt local search with conditional edge swaps, prioritizing solutions with lower costs in both objectives while ensuring feasibility through dynamic segment validation. It evaluates all possible 4-opt reconnections and selects the best one, then occasionally applies a random edge swap for exploration, with a fallback to the original solution if validity is compromised. The approach balances exploitation (via 4-opt) and exploration (via random swaps) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with high potential for improvement\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] < selected[1][0] and obj[1] < selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid 4-opt with conditional edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select four distinct edges\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Step 2: Generate all possible 4-opt reconnections\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:d], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[c:d], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[a:b], new_solution[b:c], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[c:d], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[b:c], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[a:b], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[c:d], new_solution[a:b]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[a:b], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[b:c], new_solution[a:b]])\n    ]\n\n    # Step 3: Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Step 4: Conditional edge swap for exploration\n    if np.random.random() < 0.3:  # 30% chance to apply edge swap\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9000109701044243,
            0.995768666267395
        ],
        "raw_score": [
            6.723056389385884,
            6.099974218831657
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by choosing the one with the best combined objective (sum of both costs), then applies a hybrid local search combining 3-opt moves with segment inversions to generate improved neighbors while ensuring feasibility. It prioritizes solutions with lower total cost and uses probabilistic segment inversions to maintain diversity. The approach balances exploitation (via 3-opt) and exploration (via segment inversion) to improve solution quality across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Here we use a simple selection strategy: choose the solution with the best combined objective\n    selected_idx = np.argmin([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid 3-opt with segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:] if c != 0 else np.array([])\n\n    # There are 4 possible ways to reconnect the segments (excluding the original)\n    options = [\n        np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3]),\n        np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3[::-1]]),\n        np.concatenate([new_solution[:a], segment1, segment2[::-1], segment3[::-1]]),\n        np.concatenate([new_solution[:a], segment1, segment2, segment3[::-1]])\n    ]\n\n    # Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        # Calculate total cost for both objectives\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Additional segment inversion for diversity\n    if np.random.random() < 0.5:  # 50% chance to apply segment inversion\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7338904910350743,
            0.7760787606239319
        ],
        "raw_score": [
            5.757521071231495,
            6.190310024313944
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects promising solutions from the archive by balancing normalized objective costs and diversity, then generates neighbors through adaptive segment swapping prioritizing node clusters close in both objective spaces, with a probabilistic bias toward improving the higher-cost objective. It uses weighted cost evaluation to guide segment insertion and occasionally applies segment inversion for diversity, ensuring feasible TSP tours while exploring the solution space more effectively than standard 2-opt methods.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a dynamic combination of normalized objectives and diversity\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        norm_obj1 = obj[0] / (np.sum(distance_matrix_1) + 1e-10)\n        norm_obj2 = obj[1] / (np.sum(distance_matrix_2) + 1e-10)\n        diversity = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(weights[i] * (norm_obj1 + norm_obj2) + (1 - weights[i]) * diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment swapping with node clustering\n    if n >= 4:\n        # Identify clusters of nodes that are close in both objective spaces\n        cluster_size = np.random.randint(2, min(5, n//2))\n        start_pos = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[start_pos:start_pos + cluster_size]\n\n        # Find a position to insert the cluster that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n - cluster_size + 1):\n            if pos in range(start_pos, start_pos + cluster_size):\n                continue\n\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                cluster,\n                new_solution[pos:start_pos],\n                new_solution[start_pos + cluster_size:]\n            ])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n            # Bias towards improving the objective with higher current cost\n            current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n            if current_cost1 > current_cost2:\n                total_cost = cost1 * 0.6 + cost2 * 0.4\n            else:\n                total_cost = cost1 * 0.4 + cost2 * 0.6\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                cluster,\n                new_solution[best_pos:start_pos],\n                new_solution[start_pos + cluster_size:]\n            ])\n\n    # Probabilistic segment inversion for diversity\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8940415213035057,
            2.4321322441101074
        ],
        "raw_score": [
            6.294777593193928,
            6.308984515063971
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing the one with the best individual objective (either the first or second cost, chosen randomly), then applies a hybrid local search combining 4-opt moves with probabilistic segment reversals to generate improved neighbors while ensuring feasibility. It balances exploitation (via 4-opt) and exploration (via segment reversal) to improve solution quality across both objectives. The approach uses adaptive segment reversals (30% chance) to maintain diversity and evaluates all possible 4-opt reconnections to find the best neighbor.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Randomly choose between the two objectives\n    if np.random.random() < 0.5:\n        selected_idx = np.argmin([obj1 for _, (obj1, _) in archive])\n    else:\n        selected_idx = np.argmin([obj2 for _, (_, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid 4-opt with segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select four distinct indices\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Apply 4-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:] if d != 0 else np.array([])\n\n    # There are 8 possible ways to reconnect the segments (excluding the original)\n    options = [\n        np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3, segment4]),\n        np.concatenate([new_solution[:a], segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([new_solution[:a], segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([new_solution[:a], segment1, segment2, segment3, segment4[::-1]]),\n        np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3, segment4]),\n        np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3[::-1], segment4]),\n        np.concatenate([new_solution[:a], segment1, segment2[::-1], segment3[::-1], segment4]),\n        np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3[::-1], segment4])\n    ]\n\n    # Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        # Calculate total cost for both objectives\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Additional segment reversal for diversity\n    if np.random.random() < 0.3:  # 30% chance to apply segment reversal\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8681204754947743,
            1.2024641633033752
        ],
        "raw_score": [
            6.777398421663021,
            7.544656120481504
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using weighted random selection based on normalized objective values, applying a hybrid local search that combines probabilistic edge swaps and segment reversals, and accepts the new solution if it improves at least one objective or with a small random probability. The selection prioritizes solutions with better combined normalized objectives, while the local search explores neighborhoods through random edge swaps (70% chance) and segment reversals (50% chance), ensuring feasibility while balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on normalized objective values\n    objectives = [obj for _, obj in archive]\n    min1, max1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min2, max2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    weights = []\n    for obj in objectives:\n        norm1 = (obj[0] - min1) / (max1 - min1 + 1e-9) if max1 > min1 else 0.5\n        norm2 = (obj[1] - min2) / (max2 - min2 + 1e-9) if max2 > min2 else 0.5\n        weights.append(1 - (norm1 + norm2) / 2)  # Higher weight for better solutions\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probability-based acceptance\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    original_cost = calculate_cost(base_solution)\n\n    # Step 1: Probabilistic edge swap\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Probabilistic segment reversal\n    if random.random() < 0.5 and n > 4:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    new_cost = calculate_cost(new_solution)\n\n    # Accept if at least one objective improves, or with small probability if not\n    if (new_cost[0] < original_cost[0] or new_cost[1] < original_cost[1]) or random.random() < 0.1:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "metric_score": [
            -0.8822943365910475,
            1.4142873287200928
        ],
        "raw_score": [
            6.780280593382781,
            6.602262909472978
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding distance, then applies a hybrid local search combining 4-opt with adaptive edge swaps, dynamically adjusting objective weights to improve both objectives while ensuring feasibility through segment validation. It prioritizes solutions with higher crowding distance (more diverse) and uses weighted edge swaps to balance improvement across both objectives. The hybrid approach combines exhaustive 4-opt reconnections with targeted edge swaps, ensuring high-quality neighbors while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each solution\n    crowding = np.zeros(len(archive))\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select the solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: 4-opt with adaptive edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select four distinct edges\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Step 2: Generate all possible 4-opt reconnections\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:d], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[c:d], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[a:b], new_solution[b:c], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[c:d], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[b:c], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[a:b], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[c:d], new_solution[a:b]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[a:b], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[b:c], new_solution[a:b]])\n    ]\n\n    # Step 3: Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Step 4: Adaptive edge swaps based on objective weights\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weights /= np.sum(weights)\n\n    if np.random.random() < 0.5:  # 50% chance to apply edge swap\n        # Select edges based on weighted objectives\n        edge_costs = np.zeros(n)\n        for i in range(n):\n            j = (i + 1) % n\n            edge_costs[i] = weights[0] * distance_matrix_1[new_solution[i], new_solution[j]] + weights[1] * distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Select edges with highest cost (potential for improvement)\n        sorted_edges = np.argsort(edge_costs)[::-1]\n        i, j = sorted_edges[0], sorted_edges[1]\n\n        # Ensure we're not swapping adjacent edges\n        if abs(i - j) > 1 and not (i == 0 and j == n-1) and not (j == 0 and i == n-1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8159008347489287,
            1.4861345291137695
        ],
        "raw_score": [
            7.616063791760979,
            8.106893466256766
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive (prioritizing lower objective values) and applies a hybrid local search combining random edge swaps and segment reversals, ensuring feasibility by always returning a valid TSP tour. It evaluates the new solution and keeps it only if it improves at least one objective, otherwise reverting to the original. The design balances exploration (random selection) with exploitation (local improvement), focusing on multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower objective values preferred)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3 or fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Random edge swap\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Random segment reversal\n    if n > 4:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Step 3: Evaluate and accept if better in at least one objective\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    original_cost = calculate_cost(base_solution)\n    new_cost = calculate_cost(new_solution)\n\n    if new_cost[0] < original_cost[0] or new_cost[1] < original_cost[1]:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "metric_score": [
            -0.8746856930467543,
            1.9912161827087402
        ],
        "raw_score": [
            6.947712242225724,
            5.616870017867331
        ]
    }
]