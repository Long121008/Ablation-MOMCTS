[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (30% for the first objective, 70% for the second), then applies a hybrid local search combining edge reversal and a novel node reordering strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The weighted selection prioritizes solutions with better performance in the second objective, while the local search explores new configurations by reversing segments and shuffling sub-sequences.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.3*obj1 + 0.7*obj2)\n    selected = max(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal with node reordering\n    if n >= 3:\n        # Step 1: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Novel node reordering in a sub-sequence\n        sub_start = np.random.randint(0, n - 2)\n        sub_end = np.random.randint(sub_start + 2, min(sub_start + 6, n))\n        sub_seq = new_solution[sub_start:sub_end]\n        np.random.shuffle(sub_seq)\n        new_solution[sub_start:sub_end] = sub_seq\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9955506201873332,
            0.5729128122329712
        ],
        "raw_score": [
            10.473809131272606,
            10.692212489823685
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on its quality relative to the average cost, then applies a hybrid local search combining probabilistic edge reversal and adaptive segment relocation to generate a neighbor solution while maintaining feasibility through constrained segment manipulation. The selection prioritizes solutions near the average cost with slight randomness, while the local search focuses on small-scale perturbations (edges and segments) with adaptive segment sizes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on solution quality\n    total_costs = [sum(obj) for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    selected = min(archive, key=lambda x: abs(sum(x[1]) - avg_cost) * (1 + np.random.random()))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation\n    if n >= 5:\n        # Step 1: Probabilistic edge reversal\n        for i in range(n - 1):\n            if np.random.random() < 0.2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Step 2: Adaptive segment relocation\n        seg_size = min(3, max(2, int(np.random.normal(2.5, 0.5))))\n        seg_start = np.random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n        insert_pos = np.random.randint(0, n - seg_size)\n        if insert_pos >= seg_start:\n            insert_pos += seg_size\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_size:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7401874502706116,
            0.32838261127471924
        ],
        "raw_score": [
            7.617947148898726,
            8.118519850301334
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted objective (60% second objective, 40% first objective) and applies a hybrid local search combining random node insertion and segment reversal to generate a neighbor solution while ensuring feasibility. The method prioritizes diversification by favoring solutions with better performance in the second objective while still considering the first objective, and it explores the solution space through non-standard moves beyond typical 2-opt operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.6*obj2 + 0.4*obj1)\n    selected = max(archive, key=lambda x: 0.6 * x[1][1] + 0.4 * x[1][0])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with segment reversal\n    if n >= 4:\n        # Step 1: Random node insertion\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Segment reversal\n        seg_start = np.random.randint(0, n - 3)\n        seg_end = np.random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution[seg_start:seg_end] = segment[::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9187942615714717,
            0.5609147548675537
        ],
        "raw_score": [
            10.502911486257478,
            10.571506545395131
        ]
    },
    {
        "algorithm": "The algorithm combines **adaptive Pareto frontier sampling** (prioritizing solutions with high crowding distance) with a **segmented crossover operator** that dynamically blends segments from diverse archive solutions, using a **hybrid objective weighting scheme** to evaluate segment quality while ensuring feasibility through **multi-stage validation**. It balances exploration and exploitation by probabilistically selecting segments from multiple solutions, with segment sizes and positions determined by both objective-aware metrics and spatial proximity in the coordinate spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto frontier sampling with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select multiple diverse solutions for segment crossover\n    selected_indices = np.argsort(-crowding_dist)[:min(3, len(archive))]\n    base_solution = archive[selected_indices[0]][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented crossover operator\n    if len(selected_indices) > 1:\n        # Select random segments from diverse solutions\n        segment_length = np.random.randint(2, min(4, n // 2))\n        for idx in selected_indices[1:]:\n            donor = archive[idx][0]\n            start = np.random.randint(0, n - segment_length)\n            segment = donor[start:start+segment_length]\n\n            # Find insertion point in new_solution that maintains spatial proximity\n            best_pos = start\n            min_cost = float('inf')\n            for pos in range(n - segment_length + 1):\n                # Evaluate insertion using hybrid objective weights\n                weight1 = 0.5 + 0.3 * (np.std(objectives[:, 0]) / (np.mean(objectives[:, 0]) + 1e-10))\n                weight2 = 0.5 + 0.3 * (np.std(objectives[:, 1]) / (np.mean(objectives[:, 1]) + 1e-10))\n\n                # Calculate cost before and after insertion\n                cost_before = 0\n                cost_after = 0\n                for i in range(pos - 1, pos + segment_length + 1):\n                    i = i % n\n                    j = (i + 1) % n\n                    cost_before += weight1 * distance_matrix_1[new_solution[i], new_solution[j]] + weight2 * distance_matrix_2[new_solution[i], new_solution[j]]\n\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n                for i in range(pos - 1, pos + segment_length + 1):\n                    i = i % n\n                    j = (i + 1) % n\n                    cost_after += weight1 * distance_matrix_1[temp_solution[i], temp_solution[j]] + weight2 * distance_matrix_2[temp_solution[i], temp_solution[j]]\n\n                if cost_after < min_cost:\n                    min_cost = cost_after\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos+segment_length:]])\n\n    # Multi-stage validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair missing nodes by inserting them at positions that minimize cost\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(n + 1):\n                temp_solution = np.insert(new_solution, pos, node)\n                cost = 0\n                for i in range(n):\n                    j = (i + 1) % (n + 1)\n                    cost += distance_matrix_1[temp_solution[i], temp_solution[j]] + distance_matrix_2[temp_solution[i], temp_solution[j]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0218214740148481,
            12.304687201976776
        ],
        "raw_score": [
            10.455947482879868,
            10.654918945587069
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto frontier selection with a novel 3-segment inversion and dynamic edge insertion strategy. It prioritizes solutions near the Pareto frontier using a weighted combination of normalized objectives and crowding distance, then applies a local search operator that dynamically partitions the tour, inverts a middle segment, and inserts a strategically chosen edge to maintain feasibility while improving both objectives. The operator balances exploration and exploitation by adaptively adjusting segment lengths and insertion points based on the current solution's objective values.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution near Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    norm_sum = np.sum(normalized_obj, axis=1)\n\n    # Calculate crowding distances\n    sorted_indices = np.argsort(norm_sum)\n    crowding_dist = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_indices[i]] = norm_sum[sorted_indices[i+1]] - norm_sum[sorted_indices[i-1]]\n\n    # Combine normalized sum and crowding distance\n    selection_score = 0.7 * norm_sum + 0.3 * crowding_dist\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 6:\n        # Dynamic segment selection\n        seg_points = sorted(np.random.choice(n, 3, replace=False))\n        a, b, c = seg_points\n\n        # Invert middle segment\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Dynamic edge insertion\n        remaining_edges = [i for i in range(n) if i not in seg_points]\n        if remaining_edges:\n            insert_pos = np.random.choice(remaining_edges)\n            insert_val = new_solution[insert_pos]\n\n            # Find best insertion point\n            best_pos = -1\n            best_cost = float('inf')\n            for i in range(n):\n                if i not in seg_points:\n                    # Calculate cost for both objectives\n                    cost1 = distance_matrix_1[new_solution[i-1], insert_val] + distance_matrix_1[insert_val, new_solution[i]]\n                    cost2 = distance_matrix_2[new_solution[i-1], insert_val] + distance_matrix_2[insert_val, new_solution[i]]\n                    total_cost = cost1 + cost2\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = i\n\n            if best_pos != -1:\n                # Insert the edge\n                new_solution = np.concatenate([new_solution[:best_pos], [insert_val], new_solution[best_pos:]])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9135442071875497,
            0.5328848361968994
        ],
        "raw_score": [
            10.582306014371891,
            10.582789636114658
        ]
    },
    {
        "algorithm": "The algorithm combines dynamic Pareto-frontier selection with adaptive weight-based 3-opt local search, prioritizing solutions with high crowding distances on the Pareto frontier. It evaluates 3-opt reconnections using objective-specific weights and occasionally applies probabilistic edge reconnections for further improvement, while ensuring feasibility through validation. The weights are dynamically adjusted based on objective ranges to balance exploration of both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic Pareto-frontier selection\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Adaptive weight calculation based on objective range\n    objectives = np.array([obj for _, obj in pareto_front])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    if obj_range[0] == 0:\n        weight1 = 0.5\n    else:\n        weight1 = obj_range[1] / (obj_range[0] + obj_range[1])\n    weight2 = 1 - weight1\n\n    # Select solution with highest normalized crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(pareto_front):\n        if i == 0:\n            left = pareto_front[-1][1]\n            right = pareto_front[1][1] if len(pareto_front) > 1 else pareto_front[0][1]\n        elif i == len(pareto_front) - 1:\n            left = pareto_front[i-1][1]\n            right = pareto_front[0][1]\n        else:\n            left = pareto_front[i-1][1]\n            right = pareto_front[i+1][1]\n\n        dist = (abs(obj[0] - left[0]) + abs(obj[0] - right[0])) / obj_range[0] + (abs(obj[1] - left[1]) + abs(obj[1] - right[1])) / obj_range[1]\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = pareto_front[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt with adaptive weight-based evaluation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Generate all possible 3-opt reconnections\n        options = [\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:b], new_solution[a:c][::-1], new_solution[b:a], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:], new_solution[c:b][::-1], new_solution[a:c]]),\n            np.concatenate([new_solution[:b], new_solution[a:], new_solution[c:b][::-1], new_solution[a:c]])\n        ]\n\n        # Evaluate options with adaptive weights\n        best_option = None\n        best_cost = float('inf')\n\n        for option in options:\n            total_cost = 0\n            for i in range(n):\n                j = (i + 1) % n\n                total_cost += weight1 * distance_matrix_1[option[i], option[j]] + weight2 * distance_matrix_2[option[i], option[j]]\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_option = option.copy()\n\n        if best_option is not None:\n            new_solution = best_option\n\n        # Probabilistic edge reconnection\n        if np.random.random() < 0.4:\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            while abs(i - j) <= 1:\n                i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n            # Evaluate reconnection cost\n            cost_before = weight1 * (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) + weight2 * (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n            cost_after = weight1 * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]) + weight2 * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]])\n\n            if cost_after < cost_before:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8768038469211932,
            0.5148503184318542
        ],
        "raw_score": [
            6.926687944226577,
            6.695373888397226
        ]
    },
    {
        "algorithm": "The algorithm combines crowding-distance selection from the archive with an adaptive 4-opt local search that dynamically alternates between edge swaps and segment reversals, prioritizing solutions with high diversity (crowding distance) and using Pareto-dominance-inspired evaluation to guide multi-objective optimization while ensuring feasibility through nearest-neighbor repair. It balances exploration and exploitation through probabilistic operator selection, favoring 4-opt moves for diverse solutions and biased edge swaps when improvement opportunities are identified. The key variables are dynamically weighted based on solution quality and objective space contributions, with the distance matrices guiding the search toward Pareto-optimal regions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            left = archive[-1][1]\n            right = archive[1][1] if len(archive) > 1 else archive[0][1]\n        elif i == len(archive) - 1:\n            left = archive[i-1][1]\n            right = archive[0][1]\n        else:\n            left = archive[i-1][1]\n            right = archive[i+1][1]\n\n        dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 4-opt with dynamic operator selection\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Generate all possible 4-opt configurations\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:d], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:d], new_solution[d:]]),\n        np.concatenate([new_solution[:b], new_solution[c:d], new_solution[a:c], new_solution[b:a], new_solution[d:]])\n    ]\n\n    # Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = sum(distance_matrix_1[option[i], option[(i+1)%n]] + distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n))\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Dynamic operator selection based on solution quality\n    if np.random.random() < 0.3:  # 30% chance for biased edge swap\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Nearest-neighbor repair if invalid\n        for i in range(n):\n            if new_solution[i] in new_solution[:i]:\n                nearest = None\n                min_dist = float('inf')\n                for j in range(n):\n                    if j not in new_solution[:i]:\n                        dist = distance_matrix_1[new_solution[i-1], j] + distance_matrix_2[new_solution[i-1], j]\n                        if dist < min_dist:\n                            min_dist = dist\n                            nearest = j\n                new_solution[i] = nearest\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8134879837035757,
            0.45449936389923096
        ],
        "raw_score": [
            8.264798524421865,
            8.261356572416117
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-archive selection with a novel segmented 3-opt local search, prioritizing solutions with high crowding distance and using biased edge flips to improve both objectives while ensuring feasibility through nearest-neighbor repair. It dynamically alternates between segment reversals and edge swaps, with a 40% probability of applying edge flips based on combined distance improvements in both objective spaces. The method ensures validity by repairing duplicate nodes with the nearest neighbor prioritizing both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            left = archive[-1][1]\n            right = archive[1][1] if len(archive) > 1 else archive[0][1]\n        elif i == len(archive) - 1:\n            left = archive[i-1][1]\n            right = archive[0][1]\n        else:\n            left = archive[i-1][1]\n            right = archive[i+1][1]\n\n        dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented 3-opt with biased edge flips\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment = new_solution[a:b]\n\n    # Generate possible configurations\n    options = [\n        np.concatenate([new_solution[:a], segment[::-1], new_solution[b:c], segment, new_solution[c:]]),  # Reverse segment\n        np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]]),  # Shift segment\n        np.concatenate([new_solution[:a], segment, new_solution[b:c], segment[::-1], new_solution[c:]])  # Reverse and shift\n    ]\n\n    # Evaluate options\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = sum(distance_matrix_1[option[i], option[(i+1)%n]] + distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n))\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Biased edge flip based on objective improvement potential\n    if np.random.random() < 0.4:  # 40% chance for edge flip\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if abs(i - j) > 1:\n            # Calculate potential improvement\n            old_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Nearest-neighbor repair prioritizing both objectives\n        for i in range(n):\n            if new_solution[i] in new_solution[:i]:\n                nearest = None\n                min_cost = float('inf')\n                for j in range(n):\n                    if j not in new_solution[:i]:\n                        cost = distance_matrix_1[new_solution[i-1], j] + distance_matrix_2[new_solution[i-1], j]\n                        if cost < min_cost:\n                            min_cost = cost\n                            nearest = j\n                new_solution[i] = nearest\n\n    return new_solution\n\n",
        "metric_score": [
            -0.869487424807805,
            0.4796544313430786
        ],
        "raw_score": [
            7.664357742893139,
            8.26037512657801
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding-distance-based selection, then applies a hybrid 3-opt local search with adaptive node insertion, evaluating all possible 3-opt reconnections and occasionally inserting a random node for exploration while ensuring feasibility. It prioritizes solutions with high crowding distance in the objective space and balances exploitation (3-opt) with exploration (adaptive insertion), with a 25% chance of applying the latter. The final solution is validated to ensure it remains a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            left = archive[-1][1]\n            right = archive[1][1] if len(archive) > 1 else archive[0][1]\n        elif i == len(archive) - 1:\n            left = archive[i-1][1]\n            right = archive[0][1]\n        else:\n            left = archive[i-1][1]\n            right = archive[i+1][1]\n\n        dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid 3-opt with adaptive node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select three distinct nodes\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Step 2: Generate all possible 3-opt reconnections\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[c:], new_solution[b:c], new_solution[a:b]]),\n        np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:]]),\n        np.concatenate([new_solution[:b], new_solution[c:], new_solution[a:c], new_solution[b:a]])\n    ]\n\n    # Step 3: Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Step 4: Adaptive node insertion for exploration\n    if np.random.random() < 0.25:  # 25% chance to apply node insertion\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        while abs(i - j) <= 1:\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.694207543171247,
            0.38689321279525757
        ],
        "raw_score": [
            7.051319865362183,
            7.193925202037143
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid objective-diversity score (60% objective, 40% diversity), then applies a multi-segment relocation strategy that considers both objective spaces, with probabilistic segment inversion and adaptive segment merging to explore the solution space effectively. It prioritizes balanced exploration of both objectives (50% weight each) and uses segment-based operations to avoid standard 2-opt limitations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection mechanism combining objective values and solution diversity\n    objective_scores = np.array([(obj[0] + obj[1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2) + 1e-10)\n                                for _, obj in archive])\n    diversity_scores = np.array([np.sum(np.abs(np.diff(sol))) / len(sol) for sol, _ in archive])\n    combined_scores = 0.6 * objective_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-segment relocation strategy\n    if n >= 6:\n        segment_lengths = np.random.choice([2, 3], size=2)\n        start_positions = sorted(np.random.choice(n, size=2, replace=False))\n        segments = [new_solution[start_positions[i]:start_positions[i]+segment_lengths[i]] for i in range(2)]\n\n        # Evaluate insertion points considering both objectives\n        best_positions = []\n        for seg_idx, segment in enumerate(segments):\n            best_pos = -1\n            best_cost = float('inf')\n            for pos in range(n - len(segment) + 1):\n                if any(pos <= start_positions[i] < pos + len(segment) for i in range(2)):\n                    continue\n\n                temp_sol = new_solution.copy()\n                temp_sol = np.concatenate([\n                    temp_sol[:pos],\n                    segment,\n                    np.delete(temp_sol, [start_positions[seg_idx] + i for i in range(len(segment))])\n                ])\n\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                weighted_cost = 0.5 * cost1 + 0.5 * cost2\n\n                if weighted_cost < best_cost:\n                    best_cost = weighted_cost\n                    best_pos = pos\n            best_positions.append(best_pos if best_pos != -1 else np.random.randint(0, n - len(segment) + 1))\n\n        # Apply the best found insertions\n        for seg_idx, segment in enumerate(segments):\n            pos = best_positions[seg_idx]\n            new_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, [start_positions[seg_idx] + i for i in range(len(segment))])\n            ])\n\n    # Adaptive segment merging with probabilistic inversion\n    if n >= 4 and np.random.random() < 0.4:\n        merge_points = sorted(np.random.choice(n, size=2, replace=False))\n        a, b = merge_points\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Evaluate merging options\n        options = [\n            np.concatenate([segment1, segment2, segment3]),  # Original\n            np.concatenate([segment1, segment3, segment2]),  # Swap middle segments\n            np.concatenate([segment2, segment1, segment3]),  # Rotate\n            np.concatenate([segment3, segment1, segment2])   # Reverse rotate\n        ]\n\n        # Evaluate each option\n        best_option = options[0]\n        best_cost = float('inf')\n        for option in options:\n            cost1 = sum(distance_matrix_1[option[i], option[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_option = option\n\n        new_solution = best_option\n\n    # Final probabilistic inversion for diversity\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9954879138255571,
            5.736187040805817
        ],
        "raw_score": [
            10.521909240547783,
            10.633749038399056
        ]
    }
]