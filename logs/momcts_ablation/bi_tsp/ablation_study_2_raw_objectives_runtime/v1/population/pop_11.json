[
    {
        "algorithm": "The heuristic selects a non-dominated solution from the archive (or a random one if none exist) and applies a hybrid local search combining 3-opt and segment reversal to generate a neighbor, ensuring feasibility by reverting to 2-opt if duplicates arise. The selection prioritizes solutions with potential for improvement, while the local search balances exploration (via random edge selection) and exploitation (via segment reversal). The algorithm emphasizes diversity and non-dominated solutions while maintaining feasibility through fallback mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    # Select a candidate solution randomly (could be weighted by some metric)\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Apply segment reversal (novel operator)\n    if n > 4:\n        seg_start = np.random.randint(0, n-3)\n        seg_end = np.random.randint(seg_start+2, n)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if feasibility is violated\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9550238399732467,
            0.6674641966819763
        ],
        "raw_score": [
            6.816181892569201,
            7.370952145443657
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a promising solution from the archive (top 30% by combined objective cost) and applies a hybrid local search combining edge exchange (random segment reversal) and segment inversion (random segment reversal) to generate a neighbor, ensuring feasibility by validating node uniqueness. The selection prioritizes solutions with lower combined costs, while the hybrid search explores diverse neighborhoods to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., randomly among top 30% solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge exchange or segment inversion\n    if random.random() < 0.5:\n        # Edge exchange: swap two random edges\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8345781900692117,
            0.4724350571632385
        ],
        "raw_score": [
            5.996898896375873,
            5.873917783875781
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing those with lower combined weighted costs (60% first objective, 40% second), then applies a hybrid local search that randomly chooses between segment rotation (moving a random segment to a new position) or node swapping (exchanging two random nodes), ensuring feasibility by validating node uniqueness. The selected solution is copied to preserve the original, and invalid moves are reverted to the base solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using weighted objective costs\n    weights = [0.6, 0.4]  # Weight for first and second objective\n    sorted_archive = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation or node swapping\n    if random.random() < 0.5:\n        # Segment rotation: move a random segment to a new position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node swapping: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9002863287718409,
            0.5271852612495422
        ],
        "raw_score": [
            5.736626693824601,
            6.940447177988473
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing trade-offs between objectives (70% weight on first objective, 30% on second) and applies a hybrid local search combining random node insertion (60% chance) and segment reversal (40% chance), ensuring feasibility by validating node uniqueness. The selected solution is modified either by moving a random node to a new position or reversing a random segment, with a fallback to the original solution if feasibility is violated. The method balances exploration and exploitation to generate high-quality neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective costs (prioritize trade-offs)\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for (sol, obj) in archive]\n    sorted_archive = sorted(zip(archive, weighted_scores), key=lambda x: x[1])\n    selection_pool = [sol_obj[0] for sol_obj in sorted_archive[:max(1, len(archive) // 2)]]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search: combine random node insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:  # Higher chance for node insertion\n        # Random node insertion: remove a node and reinsert at a random position\n        node_to_move = random.randint(0, n - 1)\n        node_val = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node_val)\n    else:\n        # Segment reversal: reverse a random segment (excluding start/end)\n        a, b = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9538494038481506,
            0.5499681830406189
        ],
        "raw_score": [
            4.780338413724691,
            7.960434820523995
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (based on the sum of objectives) and applies a hybrid local search that combines random segment reversal with feasibility checks. It prioritizes solutions with lower combined costs while ensuring the generated neighbor remains a valid TSP tour by verifying no nodes are duplicated or skipped. The key design idea is to balance exploration (random segment selection) with exploitation (focusing on high-quality solutions) while maintaining solution feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by the sum of objectives to find a balanced solution\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = sorted_archive[0][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7319051504857423,
            0.48679596185684204
        ],
        "raw_score": [
            6.554423629591798,
            5.548693065616349
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a combined objective score (sum of both costs) and applies a hybrid local search combining random edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility through duplicate repair. It prioritizes solutions with lower combined costs and uses a 50/50 chance between edge swaps and segment reversals for exploration. The solution is repaired if duplicates arise, guaranteeing a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective score\n    def combined_score(obj):\n        return obj[0] + obj[1]\n\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates and visits all nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in missing_nodes:\n                continue\n            if np.sum(new_solution == new_solution[i]) > 1:\n                # Replace duplicate with a missing node\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9475139072145214,
            0.627363920211792
        ],
        "raw_score": [
            5.889327093649992,
            6.168270882268038
        ]
    },
    {
        "algorithm": "The algorithm selects a base solution from the archive using tournament selection based on objective diversity, then applies a hybrid local search combining adaptive segment reversal (with segment length determined by objective diversity) and constrained edge insertion (only if it improves objective balance). It ensures feasibility by validating the new solution, falling back to the base solution if necessary. The approach prioritizes solutions with diverse trade-offs and dynamically adjusts search based on objective diversity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse objective trade-offs (tournament selection)\n    def objective_diversity(sol):\n        obj1, obj2 = sol[1]\n        return abs(obj1 - obj2)\n\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    base_solution = max(selected, key=objective_diversity)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal based on objective diversity\n    obj1, obj2 = archive[0][1]\n    diversity = abs(obj1 - obj2)\n    segment_length = max(2, min(10, int(diversity / (sum(archive[0][1]) + 1e-6) * n)))\n\n    if random.random() < 0.7:  # Higher probability for segment reversal\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:  # Constrained edge insertion\n        a, b = sorted(random.sample(range(n), 2))\n        if a < b - 1:\n            # Check if insertion improves objective balance\n            original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            temp = new_solution.copy()\n            temp[a], temp[b] = temp[b], temp[a]\n            new_cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(n))\n\n            if abs(new_cost1 - new_cost2) <= abs(original_cost1 - original_cost2):\n                new_solution = temp\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5562289118876156,
            0.5577429533004761
        ],
        "raw_score": [
            6.953411780394888,
            7.5063451147569875
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on the sum of normalized objective values, then applies a hybrid local search combining edge exchange and segment inversion between randomly chosen positions to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential for improvement and uses a creative local search strategy to explore the solution space beyond standard 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion between i and j\n    if j - i > 1:\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9144808231840768,
            0.7708011269569397
        ],
        "raw_score": [
            10.487928841045688,
            10.625500105031113
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (based on objective ratio) and applies a hybrid local search: 50% of the time it reinserts a random node, and 50% of the time it rotates a random segment of the tour. It ensures feasibility by validating node uniqueness and reverting to the original solution if invalid. The selection prioritizes solutions with balanced objectives, while the operators explore diverse tour configurations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Evaluate trade-off and select solution with balanced ratio\n    def objective_ratio(obj):\n        return obj[0] / (obj[0] + obj[1]) if (obj[0] + obj[1]) > 0 else 0.5\n\n    archive_with_ratio = [(sol, obj, objective_ratio(obj)) for sol, obj in archive]\n    archive_with_ratio.sort(key=lambda x: abs(x[2] - 0.5))  # Prefer balanced solutions\n    base_solution = archive_with_ratio[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with dynamic operator selection\n    if random.random() < 0.5:\n        # Node insertion operator\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment rotation operator\n        a, b, k = sorted(random.sample(range(n), 3))[:3]\n        segment = new_solution[a:b+1]\n        rotated = np.roll(segment, k)\n        new_solution[a:b+1] = rotated\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7570808683699484,
            0.6556974649429321
        ],
        "raw_score": [
            8.663183694311689,
            8.928573659838056
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a Pareto-efficient solution from the archive (or a random one if none exist) and applies a hybrid local search combining adaptive edge swaps, segment inversions, and diversity-boosting operations, dynamically adjusting the search while ensuring feasibility through a guided repair mechanism. The method prioritizes objective diversity in selection and employs a probabilistic operator selection to balance exploration and exploitation, with a higher probability (40%) assigned to the diversity-boosting operator to enhance solution quality across both objectives. The repair mechanism ensures the generated neighbor remains a valid TSP tour by replacing duplicate nodes with missing ones.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a Pareto-efficient solution (or random if none)\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Select based on objective diversity\n    selected_idx = np.random.choice(len(pareto_front), p=[1/len(pareto_front)] * len(pareto_front))\n    base_solution = pareto_front[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid adaptive local search\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator selection\n    operator = np.random.choice(['edge_swap', 'segment_inversion', 'diversity_boost'], p=[0.3, 0.3, 0.4])\n\n    if operator == 'edge_swap':\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    elif operator == 'segment_inversion':\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:  # diversity_boost\n        # Split into segments and recombine\n        split_point = np.random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[split_point:], new_solution[:split_point]])\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Guided repair: replace duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in missing_nodes:\n                continue\n            if np.sum(new_solution == new_solution[i]) > 1:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.88717182984995,
            0.9937417507171631
        ],
        "raw_score": [
            6.7342978564801985,
            6.866621018377406
        ]
    }
]