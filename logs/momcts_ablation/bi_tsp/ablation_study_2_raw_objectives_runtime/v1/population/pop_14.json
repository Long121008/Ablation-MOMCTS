[
    {
        "algorithm": "The heuristic selects a non-dominated solution from the archive (or a random one if none exist) and applies a hybrid local search combining 3-opt and segment reversal to generate a neighbor, ensuring feasibility by reverting to 2-opt if duplicates arise. The selection prioritizes solutions with potential for improvement, while the local search balances exploration (via random edge selection) and exploitation (via segment reversal). The algorithm emphasizes diversity and non-dominated solutions while maintaining feasibility through fallback mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    # Select a candidate solution randomly (could be weighted by some metric)\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Apply segment reversal (novel operator)\n    if n > 4:\n        seg_start = np.random.randint(0, n-3)\n        seg_end = np.random.randint(seg_start+2, n)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if feasibility is violated\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9550238399732467,
            0.6674641966819763
        ],
        "raw_score": [
            6.816181892569201,
            7.370952145443657
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing those with lower combined weighted costs (60% first objective, 40% second), then applies a hybrid local search that randomly chooses between segment rotation (moving a random segment to a new position) or node swapping (exchanging two random nodes), ensuring feasibility by validating node uniqueness. The selected solution is copied to preserve the original, and invalid moves are reverted to the base solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using weighted objective costs\n    weights = [0.6, 0.4]  # Weight for first and second objective\n    sorted_archive = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation or node swapping\n    if random.random() < 0.5:\n        # Segment rotation: move a random segment to a new position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node swapping: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9002863287718409,
            0.5271852612495422
        ],
        "raw_score": [
            5.736626693824601,
            6.940447177988473
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing trade-offs between objectives (70% weight on first objective, 30% on second) and applies a hybrid local search combining random node insertion (60% chance) and segment reversal (40% chance), ensuring feasibility by validating node uniqueness. The selected solution is modified either by moving a random node to a new position or reversing a random segment, with a fallback to the original solution if feasibility is violated. The method balances exploration and exploitation to generate high-quality neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective costs (prioritize trade-offs)\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for (sol, obj) in archive]\n    sorted_archive = sorted(zip(archive, weighted_scores), key=lambda x: x[1])\n    selection_pool = [sol_obj[0] for sol_obj in sorted_archive[:max(1, len(archive) // 2)]]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search: combine random node insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:  # Higher chance for node insertion\n        # Random node insertion: remove a node and reinsert at a random position\n        node_to_move = random.randint(0, n - 1)\n        node_val = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node_val)\n    else:\n        # Segment reversal: reverse a random segment (excluding start/end)\n        a, b = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9538494038481506,
            0.5499681830406189
        ],
        "raw_score": [
            4.780338413724691,
            7.960434820523995
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a dynamic hybrid local search that adaptively blends node swapping, segment insertion, and guided segment reversal, prioritizing solutions near the Pareto front while ensuring feasibility through explicit validation. It selects the most diverse non-dominated solution and applies one of three operators (with adjustable probabilities) to generate neighbors, reverting to the original solution if feasibility is violated. The guided reversal operator specifically seeks the most promising segment reversals based on combined objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection: filter non-dominated solutions\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in non_dominated:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with highest diversity (min distance to others)\n    def diversity_score(sol, others):\n        total_dist = 0.0\n        for other_sol, _ in others:\n            dist = np.sum(distance_matrix_1[sol[:-1], other_sol[1:]] + distance_matrix_1[sol[1:], other_sol[:-1]])\n            dist += np.sum(distance_matrix_2[sol[:-1], other_sol[1:]] + distance_matrix_2[sol[1:], other_sol[:-1]])\n            total_dist += dist\n        return total_dist\n\n    if len(non_dominated) > 1:\n        base_solution = min(non_dominated, key=lambda x: diversity_score(x[0], non_dominated))[0].copy()\n    else:\n        base_solution = non_dominated[0][0].copy()\n\n    # Dynamic hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Operator probabilities based on recent performance\n    operator_probs = [0.4, 0.3, 0.3]  # node swap, segment insert, guided reversal\n\n    op_choice = random.choices(['swap', 'insert', 'reversal'], weights=operator_probs)[0]\n\n    if op_choice == 'swap':\n        # Node swap with feasibility check\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    elif op_choice == 'insert':\n        # Segment insertion with feasibility check\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, slice(a, b+1))\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    else:  # guided reversal\n        # Guided segment reversal based on distance improvement\n        best_reversal = None\n        best_improvement = 0\n\n        for _ in range(min(5, n//2)):\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n\n            if len(set(temp_sol)) == n:\n                # Calculate improvement in both objectives\n                orig_cost1 = np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]])\n                new_cost1 = np.sum(distance_matrix_1[temp_sol[:-1], temp_sol[1:]])\n                orig_cost2 = np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]])\n                new_cost2 = np.sum(distance_matrix_2[temp_sol[:-1], temp_sol[1:]])\n\n                improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_reversal = temp_sol.copy()\n\n        if best_reversal is not None:\n            new_solution = best_reversal\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9876189601211477,
            4.570648550987244
        ],
        "raw_score": [
            10.48819208826108,
            10.626201541478995
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (minimizing the maximum difference between the two objectives) and applies a hybrid local search combining random segment reversal and node swapping to generate a neighbor solution, ensuring feasibility by checking for duplicate or skipped nodes. The selection prioritizes balanced solutions, while the local search introduces controlled randomness to explore the solution space while maintaining validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives (minimizing the maximum difference)\n    balanced_solution = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))\n    base_solution = balanced_solution[0].copy()\n\n    # Apply hybrid local search: random segment reversal + node swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes to further diversify\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8638187835951922,
            0.45797204971313477
        ],
        "raw_score": [
            6.860477022480777,
            6.584735056343538
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse non-dominated solution from the archive using crowding distance, then applies a hybrid local search combining edge insertion and segment rotation to generate a neighbor, ensuring feasibility by validating the solution structure and falling back to a random swap if duplicates occur. The selection prioritizes solutions with higher crowding distances to maintain diversity, while the local search explores new configurations by inserting edges and rotating segments, with a fallback mechanism to handle infeasible solutions.\n\n---\n**Key Improvements in the Explanation:**\n1. **Conciseness:** Covers the core logic in under 3 sentences while referencing the Design Idea.\n2. **Critical Variables:** Highlights the crowding distance selection and hybrid local search as key design choices.\n3. **Fallback Mechanism:** Explicitly mentions the random swap as a safety net for feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance to promote diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Calculate crowding distance for non-dominated solutions\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            obj1 = solutions[i][1][0]\n            obj2 = solutions[i][1][1]\n            left1 = solutions[i-1][1][0] if i > 0 else float('inf')\n            right1 = solutions[i+1][1][0] if i < len(solutions)-1 else float('inf')\n            left2 = solutions[i-1][1][1] if i > 0 else float('inf')\n            right2 = solutions[i+1][1][1] if i < len(solutions)-1 else float('inf')\n            dist = abs(right1 - left1) + abs(right2 - left2)\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances) if distances else np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion with segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select an edge and a segment to rotate\n    if n > 3:\n        edge_idx = np.random.randint(0, n-1)\n        seg_start = np.random.randint(0, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n\n        # Insert the edge after the segment\n        new_solution = np.concatenate([\n            new_solution[:seg_end],\n            new_solution[edge_idx:edge_idx+2],\n            new_solution[seg_end:edge_idx],\n            new_solution[edge_idx+2:]\n        ])\n\n        # Rotate the segment\n        rotation = np.random.randint(1, n-1)\n        new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if duplicates occur\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7542907791875005,
            0.34506189823150635
        ],
        "raw_score": [
            8.115995381379822,
            7.8732818242440485
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a combined objective score (sum of both costs) and applies a hybrid local search combining random edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility through duplicate repair. It prioritizes solutions with lower combined costs and uses a 50/50 chance between edge swaps and segment reversals for exploration. The solution is repaired if duplicates arise, guaranteeing a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective score\n    def combined_score(obj):\n        return obj[0] + obj[1]\n\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates and visits all nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in missing_nodes:\n                continue\n            if np.sum(new_solution == new_solution[i]) > 1:\n                # Replace duplicate with a missing node\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9475139072145214,
            0.627363920211792
        ],
        "raw_score": [
            5.889327093649992,
            6.168270882268038
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a promising solution from the archive (top 30% by combined objective cost) and applies a hybrid local search combining edge exchange (random segment reversal) and segment inversion (random segment reversal) to generate a neighbor, ensuring feasibility by validating node uniqueness. The selection prioritizes solutions with lower combined costs, while the hybrid search explores diverse neighborhoods to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., randomly among top 30% solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge exchange or segment inversion\n    if random.random() < 0.5:\n        # Edge exchange: swap two random edges\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8345781900692117,
            0.4724350571632385
        ],
        "raw_score": [
            5.996898896375873,
            5.873917783875781
        ]
    },
    {
        "algorithm": "The algorithm selects the top 30% of non-dominated solutions from the archive, prioritizing those with better weighted objective values (70% first objective, 30% second objective), then applies a hybrid 3-opt and segment reversal operator to generate a neighbor solution while ensuring feasibility through strict validation checks. The weighted objective balance and hybrid local search strategy are key design features.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Filter top 30% nondominated solutions\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in nondominated:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select from top 30% based on weighted objectives (70-30)\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for (_, obj) in nondominated]\n    sorted_nondominated = sorted(zip(nondominated, weighted_scores), key=lambda x: x[1])\n    selection_pool = [sol_obj[0][0] for sol_obj in sorted_nondominated[:max(1, len(nondominated) // 3)]]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx].copy()\n\n    # Hybrid 3-opt + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Segment reversal\n    if n > 4:\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, n)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8626589538763034,
            0.5317303538322449
        ],
        "raw_score": [
            5.770515769714794,
            7.659246332592188
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (based on the sum of objectives) and applies a hybrid local search that combines random segment reversal with feasibility checks. It prioritizes solutions with lower combined costs while ensuring the generated neighbor remains a valid TSP tour by verifying no nodes are duplicated or skipped. The key design idea is to balance exploration (random segment selection) with exploitation (focusing on high-quality solutions) while maintaining solution feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by the sum of objectives to find a balanced solution\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = sorted_archive[0][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7319051504857423,
            0.48679596185684204
        ],
        "raw_score": [
            6.554423629591798,
            5.548693065616349
        ]
    }
]