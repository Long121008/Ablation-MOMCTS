[
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a dynamic hybrid local search that adaptively blends node swapping, segment insertion, and guided segment reversal, prioritizing solutions near the Pareto front while ensuring feasibility through explicit validation. It selects the most diverse non-dominated solution and applies one of three operators (with adjustable probabilities) to generate neighbors, reverting to the original solution if feasibility is violated. The guided reversal operator specifically seeks the most promising segment reversals based on combined objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection: filter non-dominated solutions\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in non_dominated:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with highest diversity (min distance to others)\n    def diversity_score(sol, others):\n        total_dist = 0.0\n        for other_sol, _ in others:\n            dist = np.sum(distance_matrix_1[sol[:-1], other_sol[1:]] + distance_matrix_1[sol[1:], other_sol[:-1]])\n            dist += np.sum(distance_matrix_2[sol[:-1], other_sol[1:]] + distance_matrix_2[sol[1:], other_sol[:-1]])\n            total_dist += dist\n        return total_dist\n\n    if len(non_dominated) > 1:\n        base_solution = min(non_dominated, key=lambda x: diversity_score(x[0], non_dominated))[0].copy()\n    else:\n        base_solution = non_dominated[0][0].copy()\n\n    # Dynamic hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Operator probabilities based on recent performance\n    operator_probs = [0.4, 0.3, 0.3]  # node swap, segment insert, guided reversal\n\n    op_choice = random.choices(['swap', 'insert', 'reversal'], weights=operator_probs)[0]\n\n    if op_choice == 'swap':\n        # Node swap with feasibility check\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    elif op_choice == 'insert':\n        # Segment insertion with feasibility check\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, slice(a, b+1))\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    else:  # guided reversal\n        # Guided segment reversal based on distance improvement\n        best_reversal = None\n        best_improvement = 0\n\n        for _ in range(min(5, n//2)):\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n\n            if len(set(temp_sol)) == n:\n                # Calculate improvement in both objectives\n                orig_cost1 = np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]])\n                new_cost1 = np.sum(distance_matrix_1[temp_sol[:-1], temp_sol[1:]])\n                orig_cost2 = np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]])\n                new_cost2 = np.sum(distance_matrix_2[temp_sol[:-1], temp_sol[1:]])\n\n                improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_reversal = temp_sol.copy()\n\n        if best_reversal is not None:\n            new_solution = best_reversal\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9876189601211477,
            4.570648550987244
        ],
        "raw_score": [
            10.48819208826108,
            10.626201541478995
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined costs (top 30% of sorted solutions) and applies a hybrid local search that reverses a random segment of the tour and reinserts it elsewhere, with a fallback to simple segment reversal if duplicates occur, ensuring feasibility. The selection emphasizes high-potential solutions, while the local search explores diverse neighborhood structures.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a combination of objective ranking and randomness\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to reverse and insert\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n        segment = new_solution[start:end+1]\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:start],\n            new_solution[end+1:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9031978600912173,
            0.3352429270744324
        ],
        "raw_score": [
            7.999878715084651,
            7.835523378695226
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient solution filtering (top 20%) with a dynamic operator selection that blends 5-opt segment reversals (weighted 70% by the first objective) and guided node relocations (weighted 30% by the second objective), ensuring feasibility through a minimal structural repair mechanism. It prioritizes solutions with better performance in the first objective while adaptively refining the tour based on both objectives, balancing exploration and exploitation through weighted probabilistic selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify top 20% non-dominated solutions\n    objectives = [obj for (sol, obj) in archive]\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    top_20_idx = np.random.choice(len(non_dominated), size=max(1, int(0.2 * len(non_dominated))), replace=False)\n    selected_sol, selected_obj = non_dominated[np.random.choice(top_20_idx)]\n\n    # Step 2: Dynamic operator selection based on weighted objectives\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Calculate weights for operator selection\n    total_cost = selected_obj[0] + selected_obj[1]\n    weight_obj1 = selected_obj[0] / total_cost\n    weight_obj2 = selected_obj[1] / total_cost\n\n    if random.random() < weight_obj1 * 0.7:  # 5-opt segment reversal (weighted by first objective)\n        i, j, k, l, m = sorted(np.random.choice(n, size=5, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        new_solution[m:] = new_solution[m:][::-1]\n    else:  # Guided node relocation (weighted by second objective)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if (distance_matrix_1[new_solution[i-1], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i+1]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = [x for x in new_solution if np.sum(new_solution == x) > 1]\n\n        for dup in duplicates:\n            if len(missing) == 0:\n                break\n            idx = np.where(new_solution == dup)[0][-1]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9872951015337044,
            0.7729083895683289
        ],
        "raw_score": [
            6.902974030513262,
            6.939651306937891
        ]
    },
    {
        "algorithm": "The algorithm prioritizes segment reversal (70%) over edge insertion (30%) in a hybrid local search, focusing on the bottom 40% of nondominated solutions (weighted 30-70% by objectives) to generate diverse, high-quality neighbors while ensuring feasibility through random swaps as a fallback. It dynamically balances exploration and exploitation by randomly perturbing segments in selected solutions, with validation to maintain tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify bottom 40% nondominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select bottom 40% based on weighted objectives (30% first, 70% second)\n    weighted_scores = [0.3 * obj[0] + 0.7 * obj[1] for _, obj in non_dominated]\n    sorted_solutions = sorted(zip(non_dominated, weighted_scores), key=lambda x: x[1], reverse=True)\n    bottom_n = max(1, int(0.4 * len(sorted_solutions)))\n    bottom_solutions = [sol_obj[0] for sol_obj in sorted_solutions[-bottom_n:]]\n\n    # Randomly select a solution from bottom solutions\n    selected_idx = np.random.randint(0, len(bottom_solutions))\n    base_solution = bottom_solutions[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search (segment reversal + edge insertion)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly perturb segments\n    for _ in range(3):  # Limit iterations for efficiency\n        if n <= 3:\n            break\n\n        seg_start = np.random.randint(0, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n\n        if np.random.rand() < 0.7:  # 70% chance for reversal\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        else:  # 30% chance for insertion\n            insert_pos = np.random.randint(0, n)\n            if insert_pos < seg_start:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    new_solution[seg_start:seg_end],\n                    new_solution[insert_pos:seg_start],\n                    new_solution[seg_end:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:seg_start],\n                    new_solution[seg_end:insert_pos],\n                    new_solution[seg_start:seg_end],\n                    new_solution[insert_pos:]\n                ])\n\n        # Validate feasibility\n        if len(np.unique(new_solution)) != n:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9714629590698599,
            0.5330855846405029
        ],
        "raw_score": [
            8.09775904054322,
            6.021372294159533
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from an archive using a hybrid dominance-ranking and objective-diversity-based selection, then applies a multi-phase segment rearrangement operator that adaptively transforms segments with complementary objective improvements, followed by a distance-aware feasibility repair to ensure validity while minimizing objective impact. The method prioritizes objective 1 (70% weight) over objective 2 (30%) when diversity is higher in objective 1, and vice versa, with segment transformations (inversion, rotation, permutation) evaluated based on their improvement potential.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hybrid selection mechanism\n    solutions = [s for s, _ in archive]\n    objectives = [o for _, o in archive]\n\n    # Calculate dominance ranks\n    dominance_ranks = []\n    for i in range(len(archive)):\n        rank = 0\n        for j in range(len(archive)):\n            if (objectives[j][0] <= objectives[i][0] and objectives[j][1] < objectives[i][1]) or \\\n               (objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                rank += 1\n        dominance_ranks.append(rank)\n\n    # Calculate objective diversity\n    obj1_div = np.std([o[0] for o in objectives])\n    obj2_div = np.std([o[1] for o in objectives])\n\n    # Combined score with adaptive weights\n    weights = [0.6, 0.4] if obj1_div > obj2_div else [0.4, 0.6]\n    selection_scores = [weights[0] * r + weights[1] * (0.3 * o[0] + 0.7 * o[1]) for r, o in zip(dominance_ranks, objectives)]\n    selected_idx = np.argmax(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Multi-phase segment rearrangement\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Phase 1: Adaptive segment selection\n        segment_size = min(4, max(2, int(np.sqrt(n))))\n        segment_starts = np.random.choice(range(n - segment_size), size=min(3, n//segment_size), replace=False)\n\n        for start in segment_starts:\n            end = start + segment_size\n            segment = new_solution[start:end]\n\n            # Calculate segment improvement potential\n            current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end+1))\n            current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end+1))\n\n            # Try different transformations\n            transformations = [\n                segment[::-1],  # Inversion\n                np.roll(segment, 1),  # Rotation\n                np.random.permutation(segment)  # Random permutation\n            ]\n\n            best_transformation = segment\n            best_improvement = 0\n\n            for trans in transformations:\n                # Calculate potential new costs\n                new_cost1 = (distance_matrix_1[new_solution[start-1], trans[0]] +\n                            distance_matrix_1[trans[-1], new_solution[end]] +\n                            sum(distance_matrix_1[trans[i], trans[i+1]] for i in range(len(trans)-1)))\n                new_cost2 = (distance_matrix_2[new_solution[start-1], trans[0]] +\n                            distance_matrix_2[trans[-1], new_solution[end]] +\n                            sum(distance_matrix_2[trans[i], trans[i+1]] for i in range(len(trans)-1)))\n\n                # Calculate improvement score\n                improvement = (0.7 * (current_cost1 - new_cost1) + 0.3 * (current_cost2 - new_cost2)) / (new_cost1 + new_cost2 + 1e-6)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_transformation = trans\n\n            if best_improvement > 0:\n                new_solution[start:end] = best_transformation\n\n        # Phase 2: Complementary segment reinsertion\n        for _ in range(2):\n            segment_size = np.random.randint(2, min(4, n//2))\n            start = np.random.randint(0, n - segment_size)\n            end = start + segment_size\n            segment = new_solution[start:end]\n\n            # Find best reinsertion position\n            best_pos = start\n            best_score = 0\n\n            for pos in range(n - segment_size):\n                if pos == start:\n                    continue\n\n                # Calculate connection costs\n                cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                        distance_matrix_1[segment[-1], new_solution[pos+segment_size]] +\n                        distance_matrix_1[new_solution[start-1], new_solution[end]] -\n                        distance_matrix_1[new_solution[start-1], new_solution[start]] -\n                        distance_matrix_1[new_solution[end-1], new_solution[end]])\n\n                cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                        distance_matrix_2[segment[-1], new_solution[pos+segment_size]] +\n                        distance_matrix_2[new_solution[start-1], new_solution[end]] -\n                        distance_matrix_2[new_solution[start-1], new_solution[start]] -\n                        distance_matrix_2[new_solution[end-1], new_solution[end]])\n\n                # Calculate objective alignment score\n                score = 0.7 * (current_cost1 - cost1) + 0.3 * (current_cost2 - cost2)\n\n                if score > best_score:\n                    best_score = score\n                    best_pos = pos\n\n            if best_pos != start and best_score > 0:\n                new_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[end:],\n                    new_solution[start:end]\n                ])\n                new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 3: Distance-aware feasibility repair\n    unique_nodes = np.unique(new_solution)\n    n_nodes = len(base_solution)\n\n    if len(unique_nodes) != n_nodes:\n        # Phase 1: Local distance-aware swaps\n        for i in range(n_nodes):\n            if new_solution[i] in unique_nodes:\n                continue\n\n            # Find closest valid node to swap\n            best_node = None\n            min_distance = float('inf')\n\n            for j in range(n_nodes):\n                if new_solution[j] in unique_nodes and new_solution[j] != new_solution[i]:\n                    dist = (distance_matrix_1[i, j] + distance_matrix_2[i, j])\n                    if dist < min_distance:\n                        min_distance = dist\n                        best_node = j\n\n            if best_node is not None:\n                new_solution[i], new_solution[best_node] = new_solution[best_node], new_solution[i]\n\n        # Phase 2: Insert missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n_nodes), unique_nodes)\n        for node in missing_nodes:\n            # Find best insertion position\n            best_pos = 0\n            min_cost = float('inf')\n\n            for i in range(n_nodes):\n                cost = (distance_matrix_1[new_solution[i-1], node] +\n                        distance_matrix_1[node, new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], node] +\n                        distance_matrix_2[node, new_solution[i]])\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9953360021987079,
            5.32690155506134
        ],
        "raw_score": [
            10.47021297220389,
            10.608378314554866
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with lower combined objective values (weighted 30% for the first objective and 70% for the second), then applies a hybrid local search combining segment reversals (70% chance) and node swaps (30% chance), ensuring feasibility through dynamic repair with edge balancing and random insertions if needed. It dynamically repairs infeasible solutions by replacing duplicates with missing nodes or performing random insertions, maintaining a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (weighted sum)\n    best_solution = min(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])[0].copy()\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with node swap\n    if np.random.rand() < 0.7:\n        # Segment reversal\n        seg_start = np.random.randint(0, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        segment = new_solution[seg_start:seg_end]\n        new_solution[seg_start:seg_end] = segment[::-1]\n    else:\n        # Node swap with edge balancing\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility: dynamic repair with edge balancing\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, unique_nodes)\n\n        # Replace duplicates with missing nodes or random insertions\n        for i in range(n):\n            if new_solution[i] in duplicates:\n                if len(missing_nodes) > 0:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n                else:\n                    # Random insertion if no missing nodes\n                    insert_pos = np.random.randint(0, n)\n                    new_solution = np.insert(new_solution, insert_pos, new_solution[i])\n                    new_solution = np.delete(new_solution, i if i < insert_pos else i+1)\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9801716303201369,
            0.6186606884002686
        ],
        "raw_score": [
            8.141982158332265,
            4.372845379120495
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing lower-cost solutions (weighted 70% for the first objective, 30% for the second) and applies a hybrid local search combining segment reversal and node-swap to generate a neighbor solution while ensuring feasibility through validation. It intelligently balances exploration and exploitation by focusing on high-potential solutions and using creative local search operators beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted combination of objectives\n    weighted_scores = [(x[1][0] * 0.7 + x[1][1] * 0.3, idx) for idx, x in enumerate(archive)]\n    weighted_scores.sort()\n    selected_idx = min(int(len(weighted_scores) * 0.25), len(weighted_scores) - 1)\n    base_solution = archive[weighted_scores[selected_idx][1]][0].copy()\n\n    # Hybrid local search: segment reversal with node-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomly select a segment to reverse\n        start = np.random.randint(0, n-3)\n        end = np.random.randint(start+2, n)\n        segment = new_solution[start:end+1]\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a different position\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= start and insert_pos <= end:\n            insert_pos = (insert_pos + 2) % n\n\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:start],\n            new_solution[end+1:]\n        ])\n\n        # Apply node-swap to further diversify\n        swap_pos1 = np.random.randint(0, n)\n        swap_pos2 = np.random.randint(0, n)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7994613763289273,
            0.3054323196411133
        ],
        "raw_score": [
            7.144948053359409,
            7.899575118357468
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by filtering the top 20% non-dominated solutions based on crowding distance, then applies a dynamic hybrid local search operator (80% 4-opt and 20% guided segment insertion) with adaptive objective weighting (70% for the first objective, 30% for the second), ensuring feasibility through minimal structural repair. The method prioritizes the first objective while maintaining diversity in the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Filter top 20% non-dominated solutions by crowding distance\n    def crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        objectives = np.array([obj for _, obj in pop])\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(pop)-1):\n                if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        return distances\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    crowding_dist = crowding_distance(non_dominated)\n    top_20_idx = np.argsort(crowding_dist)[-max(1, int(0.2 * len(non_dominated))):]\n    selected_sol = non_dominated[np.random.choice(top_20_idx)][0].copy()\n\n    # Step 2: Dynamic hybrid operator selection\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        if random.random() < 0.8:  # 80% chance for 4-opt\n            # Select 4 distinct indices\n            i, j, k, l = sorted(random.sample(range(1, n-1), 4))\n\n            # Reverse segments between selected points\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:  # 20% chance for guided segment insertion\n            # Select a segment to move\n            seg_size = random.randint(2, min(5, n//2))\n            seg_start = random.randint(1, n-seg_size-1)\n            segment = new_solution[seg_start:seg_start+seg_size]\n\n            # Calculate potential insertion points based on objective improvement\n            best_pos = seg_start\n            best_improvement = 0\n\n            for pos in range(1, n-seg_size):\n                if pos >= seg_start and pos < seg_start+seg_size:\n                    continue\n\n                # Calculate current and potential costs\n                current_cost1 = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] +\n                                distance_matrix_1[new_solution[seg_start+seg_size-1], new_solution[seg_start+seg_size]])\n                new_cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[pos]])\n\n                current_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] +\n                                distance_matrix_2[new_solution[seg_start+seg_size-1], new_solution[seg_start+seg_size]])\n                new_cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[pos]])\n\n                # Weighted improvement (70% obj1, 30% obj2)\n                improvement = 0.7*(current_cost1 - new_cost1) + 0.3*(current_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != seg_start:\n                # Remove segment and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:seg_start],\n                    new_solution[seg_start+seg_size:]\n                ])\n                new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Feasibility repair (minimal structural changes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = [x for x in new_solution if np.sum(new_solution == x) > 1]\n\n        for dup in duplicates:\n            if len(missing) == 0:\n                break\n            idx = np.where(new_solution == dup)[0][-1]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9749050489279787,
            2.0995542407035828
        ],
        "raw_score": [
            6.455861778093622,
            7.488138331918863
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse non-dominated solution from the archive using crowding distance, then applies a hybrid local search combining edge insertion and segment rotation to generate a neighbor, ensuring feasibility by validating the solution structure and falling back to a random swap if duplicates occur. The selection prioritizes solutions with higher crowding distances to maintain diversity, while the local search explores new configurations by inserting edges and rotating segments, with a fallback mechanism to handle infeasible solutions.\n\n---\n**Key Improvements in the Explanation:**\n1. **Conciseness:** Covers the core logic in under 3 sentences while referencing the Design Idea.\n2. **Critical Variables:** Highlights the crowding distance selection and hybrid local search as key design choices.\n3. **Fallback Mechanism:** Explicitly mentions the random swap as a safety net for feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance to promote diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Calculate crowding distance for non-dominated solutions\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            obj1 = solutions[i][1][0]\n            obj2 = solutions[i][1][1]\n            left1 = solutions[i-1][1][0] if i > 0 else float('inf')\n            right1 = solutions[i+1][1][0] if i < len(solutions)-1 else float('inf')\n            left2 = solutions[i-1][1][1] if i > 0 else float('inf')\n            right2 = solutions[i+1][1][1] if i < len(solutions)-1 else float('inf')\n            dist = abs(right1 - left1) + abs(right2 - left2)\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances) if distances else np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion with segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select an edge and a segment to rotate\n    if n > 3:\n        edge_idx = np.random.randint(0, n-1)\n        seg_start = np.random.randint(0, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n\n        # Insert the edge after the segment\n        new_solution = np.concatenate([\n            new_solution[:seg_end],\n            new_solution[edge_idx:edge_idx+2],\n            new_solution[seg_end:edge_idx],\n            new_solution[edge_idx+2:]\n        ])\n\n        # Rotate the segment\n        rotation = np.random.randint(1, n-1)\n        new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if duplicates occur\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7542907791875005,
            0.34506189823150635
        ],
        "raw_score": [
            8.115995381379822,
            7.8732818242440485
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solutions from the top 0.1% non-dominated solutions (filtered by crowding distance) and applies a hybrid local search operator that blends 25-opt moves (60% chance) with segment reversals (40% chance) every 5 iterations, while ensuring feasibility through minimal structural repair. It prioritizes solutions with higher crowding distance in the non-dominated front and dynamically alternates between large-scale (25-opt) and smaller-scale (segment reversal) perturbations to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify top 0.1% non-dominated solutions with crowding distance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    top_01_idx = np.random.choice(len(non_dominated), size=max(1, int(0.001 * len(non_dominated))), replace=False)\n    top_solutions = [non_dominated[i] for i in top_01_idx]\n\n    # Calculate crowding distance\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            obj1 = solutions[i][1][0]\n            obj2 = solutions[i][1][1]\n            left1 = solutions[i-1][1][0] if i > 0 else float('inf')\n            right1 = solutions[i+1][1][0] if i < len(solutions)-1 else float('inf')\n            left2 = solutions[i-1][1][1] if i > 0 else float('inf')\n            right2 = solutions[i+1][1][1] if i < len(solutions)-1 else float('inf')\n            dist = abs(right1 - left1) + abs(right2 - left2)\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(top_solutions)\n    selected_idx = np.argmax(distances) if distances else np.random.randint(0, len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Step 2: Hybrid 25-opt with dynamic segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Dynamic operator blending every 5 iterations\n    iteration = np.random.randint(0, 10)\n    if iteration % 5 == 0:\n        # 25-opt (60% chance)\n        if np.random.rand() < 0.6:\n            points = sorted(np.random.choice(n, size=5, replace=False))\n            for i in range(0, len(points), 2):\n                if i+1 < len(points):\n                    new_solution[points[i]:points[i+1]+1] = new_solution[points[i]:points[i+1]+1][::-1]\n        else:\n            # Segment reversal (40% chance)\n            seg_start = np.random.randint(0, n-3)\n            seg_end = np.random.randint(seg_start+2, n)\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n    else:\n        # Standard 25-opt\n        points = sorted(np.random.choice(n, size=5, replace=False))\n        for i in range(0, len(points), 2):\n            if i+1 < len(points):\n                new_solution[points[i]:points[i+1]+1] = new_solution[points[i]:points[i+1]+1][::-1]\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = [x for x in new_solution if np.sum(new_solution == x) > 1]\n\n        for dup in duplicates:\n            if len(missing) == 0:\n                break\n            idx = np.where(new_solution == dup)[0][-1]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9666094180546247,
            0.7731441855430603
        ],
        "raw_score": [
            7.029298376019258,
            6.7597505322916955
        ]
    }
]