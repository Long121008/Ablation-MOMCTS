[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of normalized distance and makespan objectives (60% distance, 40% makespan), then applies a hybrid local search combining route splitting, inter-route insertion, and modified 2-opt with capacity checks to generate an improved neighbor solution. It prioritizes distance reduction while balancing makespan optimization, and ensures feasibility through strict capacity validation at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives for selection\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Avoid division by zero\n    if max_dist == min_dist:\n        normalized_dist = np.ones_like(distances)\n    else:\n        normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n    if max_make == min_make:\n        normalized_make = np.ones_like(makespans)\n    else:\n        normalized_make = (makespans - min_make) / (max_make - min_make)\n\n    # Weighted sum (can be adjusted)\n    scores = 0.6 * normalized_dist + 0.4 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try route splitting\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # If split fails, try inter-route insertion\n        if len(base_solution) > 1:\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and not np.array_equal(r, route)])\n            if len(other_route) > 3:\n                # Find best insertion point\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(other_route)):\n                    new_route = np.insert(other_route, i, route[1:-1])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = (distance_matrix[new_route[i-1], route[1]] +\n                                distance_matrix[route[-2], new_route[i+len(route)-2]] -\n                                distance_matrix[new_route[i-1], new_route[i+len(route)-2]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    new_route = np.insert(other_route, best_pos, route[1:-1])\n                    new_solution.append(new_route)\n                    continue\n\n        # If all else fails, apply modified 2-opt\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Convert back to original format\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only include non-trivial routes\n            final_solution.append(route)\n\n    return np.array(final_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8948495283173388,
            0.5054986476898193
        ],
        "raw_score": [
            57.889668453293666,
            7.825081625352422
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a high-performing solution from the archive (those with larger total distance or makespan) and applies a hybrid local search that combines route splitting (to reduce makespan) and demand-aware node swapping (to improve distance) while ensuring vehicle capacity constraints are never violated. It first tries route splitting if the solution has multiple routes, otherwise performs node swaps between routes, always checking feasibility before accepting changes. The selection prioritizes solutions with worse objectives to focus improvement efforts where they matter most.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search operator\n    if n_routes > 1 and random.random() < 0.5:\n        # Option 1: Route splitting and merging\n        # Select a random route to split\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1]) <= capacity and\n                np.sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Option 2: Demand-aware node swapping and capacity-aware merging\n        # Select two random routes\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find nodes to swap\n            if len(route1) > 2 and len(route2) > 2:\n                # Select nodes excluding depot\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity constraints after swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (np.sum(demand[new_route1]) <= capacity and\n                    np.sum(demand[new_route2]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert np.sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7736218329232261,
            0.332954078912735
        ],
        "raw_score": [
            57.83281969568547,
            7.686027274006558
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route fragmentation (splitting long routes at optimal points) and cross-exchange (swapping segments between routes while maintaining capacity constraints). The method balances objectives by intelligently modifying routes to reduce the longest route while potentially improving total distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: route fragmentation + cross-exchange\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the increase in total distance\n        min_increase = float('inf')\n        best_split = None\n        for i in range(1, len(longest_route)-1):\n            dist_before = distance_matrix[longest_route[i-1]][longest_route[i]]\n            dist_after = distance_matrix[longest_route[i]][longest_route[i+1]]\n            dist_new = distance_matrix[longest_route[i-1]][0] + distance_matrix[0][longest_route[i]] + \\\n                       distance_matrix[longest_route[i]][0] + distance_matrix[0][longest_route[i+1]]\n\n            if dist_new - (dist_before + dist_after) < min_increase:\n                min_increase = dist_new - (dist_before + dist_after)\n                best_split = i\n\n        if best_split is not None:\n            # Split the route\n            new_route1 = np.concatenate([longest_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], longest_route[best_split:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Step 2: Cross-exchange between routes to balance makespan\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find feasible cross-exchange points\n            feasible_pairs = []\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:i]]) + sum(demand[route2[j:-1]]) <= capacity and\n                        sum(demand[route2[1:j]]) + sum(demand[route1[i:-1]]) <= capacity):\n                        feasible_pairs.append((i, j))\n\n            if feasible_pairs:\n                i, j = random.choice(feasible_pairs)\n                # Perform cross-exchange\n                new_route1 = np.concatenate([route1[:i], route2[j:], [0]])\n                new_route2 = np.concatenate([route2[:j], route1[i:], [0]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8851232325504997,
            1.6942464113235474
        ],
        "raw_score": [
            57.31227674884602,
            7.414957018161158
        ]
    },
    {
        "algorithm": "The algorithm selects high-performing solutions from the archive using a weighted combination of normalized distance (70%) and makespan (30%) objectives, then applies a hybrid local search combining route splitting, demand-aware node swapping, and capacity-constrained route merging to generate improved feasible neighbor solutions. It prioritizes balancing both objectives while ensuring vehicle capacity constraints are met, and includes a final step to guarantee all customers are served.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    normalized_dist = (distances - min_dist) / (max_dist - min_dist) if max_dist != min_dist else np.ones_like(distances)\n    normalized_make = (makespans - min_make) / (max_make - min_make) if max_make != min_make else np.ones_like(makespans)\n\n    scores = 0.7 * normalized_dist + 0.3 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    if n_routes > 1 and random.random() < 0.6:\n        # Try route splitting first\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Demand-aware node swapping\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Capacity-constrained route merging\n    if n_routes > 2 and random.random() < 0.4:\n        route1_idx, route2_idx = random.sample(range(n_routes), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 1 and len(route2) > 1:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n\n    if served != all_customers:\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.35132318656131806,
            0.39889419078826904
        ],
        "raw_score": [
            36.5634520631486,
            4.9371205685403226
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing lower makespan and total distance), then applies a hybrid local search: it merges two routes, checks capacity feasibility, splits them into new routes, and randomly inserts a customer from one route into another while ensuring capacity constraints are met. The approach balances exploration (random selection) and exploitation (merging/splitting) to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: merge two routes and split into new routes\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge the two routes (excluding depots)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Split the merged route into new routes\n            # Randomly split the merged route into two new routes\n            split_point = random.randint(1, len(merged_route) - 2)\n            new_route1 = np.concatenate([[0], merged_route[1:split_point + 1], [0]])\n            new_route2 = np.concatenate([[0], merged_route[split_point + 1:-1], [0]])\n\n            # Replace the old routes with the new ones\n            new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n            # Randomly insert a customer from another route into a new route\n            if len(new_solution) > 1:\n                other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx and i != route2_idx])\n                other_route = new_solution[other_route_idx]\n                if len(other_route) > 3:  # Ensure there's a customer to move\n                    customer_to_move = random.choice(other_route[1:-1])\n                    # Find a feasible insertion point in a random new route\n                    target_route_idx = random.choice([i for i in range(len(new_solution)) if i != other_route_idx])\n                    target_route = new_solution[target_route_idx]\n                    # Try inserting the customer at each possible position\n                    for pos in range(1, len(target_route)):\n                        temp_route = np.concatenate([target_route[:pos], [customer_to_move], target_route[pos:]])\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            new_solution[target_route_idx] = temp_route\n                            # Remove the customer from the original route\n                            new_solution[other_route_idx] = np.concatenate([other_route[:np.where(other_route == customer_to_move)[0][0]],\n                                                                             other_route[np.where(other_route == customer_to_move)[0][0] + 1:]])\n                            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6633539484283217,
            6.381673753261566
        ],
        "raw_score": [
            56.03719547065913,
            6.70091740447136
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that combines route fusion (merging nearby small routes), demand-based route segmentation (splitting long routes at capacity-sensitive points), and cross-route demand redistribution (rebalancing customer allocations between routes) to improve both total distance and makespan while maintaining feasibility. It prioritizes spatial proximity and demand balance, using weighted selection to focus on solutions with strong potential for multi-objective improvement. The method ensures feasibility through capacity checks at each transformation step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6))  # Weighted combination\n    selected_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Step 1: Route Fusion - Merge nearby small routes\n    if len(new_solution) > 2:\n        # Find routes with total distance below average\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        avg_length = sum(route_lengths) / len(route_lengths)\n        small_routes = [i for i, length in enumerate(route_lengths) if length < avg_length]\n\n        if len(small_routes) >= 2:\n            # Select two closest small routes\n            min_dist = float('inf')\n            best_pair = None\n            for i in range(len(small_routes)):\n                for j in range(i+1, len(small_routes)):\n                    route1 = new_solution[small_routes[i]]\n                    route2 = new_solution[small_routes[j]]\n                    # Calculate distance between last customer of first route and first customer of second route\n                    dist = distance_matrix[route1[-2]][route2[1]]\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pair = (small_routes[i], small_routes[j])\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Check capacity\n                if sum(demand[np.concatenate([route1[1:-1], route2[1:-1]])]) <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n\n    # Step 2: Demand-based Route Segmentation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        # Find demand-based critical points\n        cumulative_demand = np.cumsum(demand[route[1:-1]])\n        total_demand = cumulative_demand[-1]\n        split_pos = None\n\n        for i in range(1, len(cumulative_demand)):\n            if cumulative_demand[i] > capacity * 0.7 and cumulative_demand[i-1] <= capacity * 0.7:\n                split_pos = i + 1  # +1 to account for depot\n                break\n\n        if split_pos and split_pos < len(route)-1:\n            # Split route at critical point\n            new_route1 = np.concatenate([route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n    # Step 3: Cross-route Demand Redistribution\n    if len(new_solution) > 1:\n        # Select routes with demand imbalance\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n        imbalanced_routes = [i for i, d in enumerate(route_demands) if abs(d - avg_demand) > avg_demand * 0.3]\n\n        if len(imbalanced_routes) >= 2:\n            # Select two imbalanced routes\n            i, j = random.sample(imbalanced_routes, 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Find feasible transfer of customers\n            feasible_transfers = []\n            for pos1 in range(1, len(route1)-1):\n                for pos2 in range(1, len(route2)-1):\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:pos1]]) + sum(demand[route2[pos2:-1]]) <= capacity and\n                        sum(demand[route2[1:pos2]]) + sum(demand[route1[pos1:-1]]) <= capacity):\n                        feasible_transfers.append((pos1, pos2))\n\n            if feasible_transfers:\n                pos1, pos2 = random.choice(feasible_transfers)\n                # Perform transfer\n                transferred_customers = route1[pos1:-1]\n                route1 = np.concatenate([route1[:pos1], [0]])\n                route2 = np.concatenate([route2[:pos2], transferred_customers, route2[pos2:]])\n\n                new_solution[i] = route1\n                new_solution[j] = route2\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.6118462897314019,
            2.6555492281913757
        ],
        "raw_score": [
            56.81841530752432,
            6.138799414475786
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing makespan first, then distance) and applies a novel hybrid local search combining adaptive route clustering (based on spatial and demand proximity) with demand-aware segment merging to reduce both total distance and makespan while maintaining capacity constraints. It intelligently merges similar routes and optimizes segments within routes, with fallback mechanisms to ensure feasibility through route splitting when needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Adaptive route clustering based on spatial and demand proximity\n    if len(new_solution) > 1:\n        # Calculate route centroids and demand profiles\n        route_centroids = []\n        route_demands = []\n        for route in new_solution:\n            nodes = route[1:-1]\n            if len(nodes) > 0:\n                centroid = np.mean(coords[nodes], axis=0)\n                total_demand = sum(demand[nodes])\n                route_centroids.append(centroid)\n                route_demands.append(total_demand)\n            else:\n                route_centroids.append(np.zeros(2))\n                route_demands.append(0)\n\n        # Find most similar routes to merge\n        min_similarity = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if len(new_solution[i]) > 2 and len(new_solution[j]) > 2:\n                    # Spatial proximity + demand similarity\n                    spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demands[i] - route_demands[j])\n                    similarity = spatial_dist + 0.5 * demand_diff\n                    if similarity < min_similarity:\n                        min_similarity = similarity\n                        best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try to merge routes by finding the best connection point\n            best_merge_cost = float('inf')\n            best_merge_point = None\n            for k in range(1, len(route1)-1):\n                for l in range(1, len(route2)-1):\n                    # Calculate potential merge cost\n                    cost = (distance_matrix[route1[k-1]][route2[l]] +\n                            distance_matrix[route2[l-1]][route1[k]] -\n                            distance_matrix[route1[k-1]][route1[k]] -\n                            distance_matrix[route2[l-1]][route2[l]])\n\n                    # Check capacity constraint\n                    if (sum(demand[route1[1:k]]) + sum(demand[route2[l:-1]]) <= capacity and\n                        sum(demand[route2[1:l]]) + sum(demand[route1[k:-1]]) <= capacity):\n                        if cost < best_merge_cost:\n                            best_merge_cost = cost\n                            best_merge_point = (k, l)\n\n            if best_merge_point:\n                k, l = best_merge_point\n                # Create merged route\n                merged_route = np.concatenate([route1[:k], route2[l:], [0]])\n\n                # Update solution\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Demand-aware segment merging for makespan reduction\n    for route in new_solution:\n        if len(route) > 3:\n            # Find segments that can be merged while maintaining capacity\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    segment = route[i:j+1]\n                    segment_demand = sum(demand[segment])\n\n                    # Check if merging this segment with adjacent nodes is beneficial\n                    if segment_demand <= capacity:\n                        # Calculate potential savings\n                        original_cost = (distance_matrix[route[i-1]][route[i]] +\n                                       distance_matrix[route[j]][route[j+1]])\n                        merged_cost = distance_matrix[route[i-1]][route[j+1]]\n\n                        if merged_cost < original_cost:\n                            # Perform the merge\n                            route[i:j+1] = [route[i]]\n\n    # Ensure all routes are feasible and properly formatted\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            new_solution.append(remaining_route)\n            new_solution[i] = new_route\n\n    # Ensure depot constraints\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.877203836724664,
            7.606746464967728
        ],
        "raw_score": [
            58.234626343567996,
            7.8589417444011325
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower makespan from the archive, then applies a hybrid local search combining route merging (when feasible) and cross-route node reallocation (with capacity checks), followed by capacity-aware route splitting to ensure feasibility. It balances exploration (random selection) with exploitation (greedy insertion) while maintaining vehicle capacity constraints throughout. The structure iteratively refines routes by merging, reallocating nodes, and splitting overloaded routes, with a focus on demand-balanced configurations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n    routes = [route.copy() for route in new_solution]\n\n    # Step 1: Route merging (if possible)\n    if len(routes) > 1:\n        i, j = random.sample(range(len(routes)), 2)\n        merged_route = np.concatenate([routes[i][:-1], routes[j][1:]])\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            routes[i] = merged_route\n            routes.pop(j)\n\n    # Step 2: Cross-route node reallocation\n    for _ in range(min(3, len(routes))):  # Limit to 3 reallocations\n        if len(routes) < 2:\n            break\n        i, j = random.sample(range(len(routes)), 2)\n        if len(routes[i]) <= 3 or len(routes[j]) <= 3:\n            continue\n\n        # Select a random node from route i\n        remove_pos = random.randint(1, len(routes[i])-2)\n        removed_node = routes[i][remove_pos]\n        routes[i] = np.delete(routes[i], remove_pos)\n\n        # Find best position in route j\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(routes[j])):\n            inserted_route = np.insert(routes[j], pos, removed_node)\n            cost = sum(distance_matrix[inserted_route[k-1]][inserted_route[k]] for k in range(1, len(inserted_route)))\n            if cost < best_cost and sum(demand[inserted_route[1:-1]]) <= capacity:\n                best_cost = cost\n                best_pos = pos\n\n        # Insert at best position\n        routes[j] = np.insert(routes[j], best_pos, removed_node)\n\n    # Step 3: Capacity-aware route adjustment\n    for i in range(len(routes)):\n        if sum(demand[routes[i][1:-1]]) > capacity:\n            # Split route if capacity exceeded\n            split_pos = 1\n            current_load = 0\n            for k in range(1, len(routes[i])-1):\n                current_load += demand[routes[i][k]]\n                if current_load > capacity:\n                    split_pos = k\n                    break\n            new_route = np.concatenate([routes[i][:split_pos], [0]])\n            remaining_route = np.concatenate([[0], routes[i][split_pos:]])\n            routes.append(remaining_route)\n            routes[i] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(routes)):\n        if routes[i][0] != 0 or routes[i][-1] != 0:\n            routes[i] = np.concatenate([[0], routes[i][1:-1], [0]])\n\n    return np.array(routes, dtype=object)\n\n",
        "metric_score": [
            -0.5123539983291613,
            1.7466196417808533
        ],
        "raw_score": [
            29.957090114875697,
            2.5812567063451115
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective score (prioritizing lower total distance over shorter makespan), then applies a hybrid local search combining route merging (if feasible), demand-balanced node swapping, and dynamic capacity adjustment (splitting oversized routes) to generate a neighbor solution while ensuring feasibility. The weights (0.7 for distance, 0.3 for makespan) and random selection guide the search toward high-quality regions, while the local search operators balance both objectives through intelligent route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n    min_dist, max_dist = min(total_distances), max(total_distances)\n    min_span, max_span = min(makespans), max(makespans)\n\n    if max_dist == min_dist:\n        weights = [1.0 / len(archive) for _ in archive]\n    else:\n        weights = [(1 - (dist - min_dist) / (max_dist - min_dist)) * 0.7 +\n                  (1 - (span - min_span) / (max_span - min_span)) * 0.3\n                  for dist, span in zip(total_distances, makespans)]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + demand-balanced swapping\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if routes can be combined without exceeding capacity)\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n        combined_load = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n\n        if combined_load <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 2: Demand-balanced node swapping\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Select two random nodes (not depots)\n        pos1, pos2 = random.sample(range(1, len(route)-1), 2)\n        node1, node2 = route[pos1], route[pos2]\n\n        # Calculate potential load changes\n        load_without1 = sum(demand[route[1:-1]]) - demand[node1]\n        load_without2 = sum(demand[route[1:-1]]) - demand[node2]\n        load_with_swap = load_without1 + demand[node2]\n        load_with_swap2 = load_without2 + demand[node1]\n\n        # Check feasibility\n        if (load_with_swap <= capacity and load_with_swap2 <= capacity):\n            # Swap nodes if feasible\n            route[pos1], route[pos2] = route[pos2], route[pos1]\n\n    # Step 3: Dynamic capacity adjustment (split routes if needed)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        current_load = sum(demand[route[1:-1]])\n\n        if current_load > capacity:\n            # Find split position that balances demand\n            target_load = current_load / 2\n            cumulative_load = 0\n            split_pos = 1\n\n            for j in range(1, len(route)-1):\n                cumulative_load += demand[route[j]]\n                if cumulative_load >= target_load:\n                    split_pos = j\n                    break\n\n            # Create new route\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            new_solution[i] = new_route\n            new_solution.append(remaining_route)\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.3371877862953648,
            0.6585793793201447
        ],
        "raw_score": [
            44.26474876485225,
            5.375982897521441
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing lower total distance and makespan), then applies a hybrid local search combining route swapping and demand-aware node reinsertion to generate a feasible neighbor solution while balancing both objectives. It prioritizes routes with higher demand first and ensures feasibility by splitting routes that exceed capacity. The critical design ideas are prioritizing lower-objective solutions, combining route-level and node-level transformations, and demand-aware feasibility repair.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: route swapping + demand-aware reinsertion\n    new_solution = selected_solution.copy()\n    routes = [route.copy() for route in new_solution]\n\n    # Step 1: Route swapping (if multiple routes exist)\n    if len(routes) > 1:\n        i, j = random.sample(range(len(routes)), 2)\n        routes[i], routes[j] = routes[j], routes[i]\n\n    # Step 2: Demand-aware node reinsertion\n    for route_idx in range(len(routes)):\n        route = routes[route_idx]\n        if len(route) <= 3:  # Skip if route has only depot and one customer\n            continue\n\n        # Select a random node to remove (not depot)\n        remove_pos = random.randint(1, len(route)-2)\n        removed_node = route[remove_pos]\n        route = np.delete(route, remove_pos)\n\n        # Find the best insertion position in the same route\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(route)):\n            inserted_route = np.insert(route, pos, removed_node)\n            cost = sum(distance_matrix[inserted_route[i-1]][inserted_route[i]] for i in range(1, len(inserted_route)))\n            if cost < best_cost and sum(demand[inserted_route[1:-1]]) <= capacity:\n                best_cost = cost\n                best_pos = pos\n\n        # Insert at best position\n        route = np.insert(route, best_pos, removed_node)\n        routes[route_idx] = route\n\n    # Step 3: Check feasibility and repair if needed\n    for route in routes:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for i in range(1, len(route)-1):\n                current_load += demand[route[i]]\n                if current_load > capacity:\n                    split_pos = i\n                    break\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            routes.append(remaining_route)\n            route = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(routes)):\n        if routes[i][0] != 0 or routes[i][-1] != 0:\n            routes[i] = np.concatenate([[0], routes[i][1:-1], [0]])\n\n    return np.array(routes, dtype=object)\n\n",
        "metric_score": [
            -0.2724857901490463,
            7.709552347660065
        ],
        "raw_score": [
            31.963197931315836,
            3.7764190513355187
        ]
    }
]