[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of normalized distance and makespan objectives (60% distance, 40% makespan), then applies a hybrid local search combining route splitting, inter-route insertion, and modified 2-opt with capacity checks to generate an improved neighbor solution. It prioritizes distance reduction while balancing makespan optimization, and ensures feasibility through strict capacity validation at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives for selection\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Avoid division by zero\n    if max_dist == min_dist:\n        normalized_dist = np.ones_like(distances)\n    else:\n        normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n    if max_make == min_make:\n        normalized_make = np.ones_like(makespans)\n    else:\n        normalized_make = (makespans - min_make) / (max_make - min_make)\n\n    # Weighted sum (can be adjusted)\n    scores = 0.6 * normalized_dist + 0.4 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try route splitting\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # If split fails, try inter-route insertion\n        if len(base_solution) > 1:\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and not np.array_equal(r, route)])\n            if len(other_route) > 3:\n                # Find best insertion point\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(other_route)):\n                    new_route = np.insert(other_route, i, route[1:-1])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = (distance_matrix[new_route[i-1], route[1]] +\n                                distance_matrix[route[-2], new_route[i+len(route)-2]] -\n                                distance_matrix[new_route[i-1], new_route[i+len(route)-2]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    new_route = np.insert(other_route, best_pos, route[1:-1])\n                    new_solution.append(new_route)\n                    continue\n\n        # If all else fails, apply modified 2-opt\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Convert back to original format\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only include non-trivial routes\n            final_solution.append(route)\n\n    return np.array(final_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8948495283173388,
            0.5054986476898193
        ],
        "raw_score": [
            57.889668453293666,
            7.825081625352422
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a high-performing solution from the archive (those with larger total distance or makespan) and applies a hybrid local search that combines route splitting (to reduce makespan) and demand-aware node swapping (to improve distance) while ensuring vehicle capacity constraints are never violated. It first tries route splitting if the solution has multiple routes, otherwise performs node swaps between routes, always checking feasibility before accepting changes. The selection prioritizes solutions with worse objectives to focus improvement efforts where they matter most.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search operator\n    if n_routes > 1 and random.random() < 0.5:\n        # Option 1: Route splitting and merging\n        # Select a random route to split\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1]) <= capacity and\n                np.sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Option 2: Demand-aware node swapping and capacity-aware merging\n        # Select two random routes\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find nodes to swap\n            if len(route1) > 2 and len(route2) > 2:\n                # Select nodes excluding depot\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity constraints after swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (np.sum(demand[new_route1]) <= capacity and\n                    np.sum(demand[new_route2]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert np.sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7736218329232261,
            0.332954078912735
        ],
        "raw_score": [
            57.83281969568547,
            7.686027274006558
        ]
    },
    {
        "algorithm": "The algorithm combines elite solution selection with a hybrid local search that alternates between demand-balanced route restructuring and objective-aware node reallocation, prioritizing solutions with high potential for multi-objective improvement while maintaining feasibility through strict capacity checks. It selects promising solutions from the top 30% of the archive (sorted by combined objective values) and applies adaptive operators\u2014splitting routes to balance demand when feasible, or swapping nodes between routes to reduce total distance when beneficial\u2014but always ensures capacity constraints are met. The operator's aggressiveness is implicitly controlled by the solution's position in the archive, favoring exploration of high-potential regions while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Adaptive local search operator\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6255140612380136,
            0.18004998564720154
        ],
        "raw_score": [
            58.404306189036056,
            7.827867873817798
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route fragmentation (splitting long routes at optimal points) and cross-exchange (swapping segments between routes while maintaining capacity constraints). The method balances objectives by intelligently modifying routes to reduce the longest route while potentially improving total distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: route fragmentation + cross-exchange\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the increase in total distance\n        min_increase = float('inf')\n        best_split = None\n        for i in range(1, len(longest_route)-1):\n            dist_before = distance_matrix[longest_route[i-1]][longest_route[i]]\n            dist_after = distance_matrix[longest_route[i]][longest_route[i+1]]\n            dist_new = distance_matrix[longest_route[i-1]][0] + distance_matrix[0][longest_route[i]] + \\\n                       distance_matrix[longest_route[i]][0] + distance_matrix[0][longest_route[i+1]]\n\n            if dist_new - (dist_before + dist_after) < min_increase:\n                min_increase = dist_new - (dist_before + dist_after)\n                best_split = i\n\n        if best_split is not None:\n            # Split the route\n            new_route1 = np.concatenate([longest_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], longest_route[best_split:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Step 2: Cross-exchange between routes to balance makespan\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find feasible cross-exchange points\n            feasible_pairs = []\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:i]]) + sum(demand[route2[j:-1]]) <= capacity and\n                        sum(demand[route2[1:j]]) + sum(demand[route1[i:-1]]) <= capacity):\n                        feasible_pairs.append((i, j))\n\n            if feasible_pairs:\n                i, j = random.choice(feasible_pairs)\n                # Perform cross-exchange\n                new_route1 = np.concatenate([route1[:i], route2[j:], [0]])\n                new_route2 = np.concatenate([route2[:j], route1[i:], [0]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8851232325504997,
            1.6942464113235474
        ],
        "raw_score": [
            57.31227674884602,
            7.414957018161158
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a promising solution from the archive using a weighted combination of normalized distance and makespan objectives, where weights adapt based on archive diversity, and then applies a hybrid local search combining demand-aware route splitting, inter-route demand balancing, and a modified 2-opt with capacity checks to generate a feasible neighbor solution that improves both objectives while ensuring feasibility. The selection prioritizes solutions with balanced trade-offs between objectives, while the local search focuses on high-demand routes and demand-balanced transfers to improve efficiency.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted selection based on archive diversity\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Calculate diversity-based weights\n    dist_range = max_dist - min_dist if max_dist != min_dist else 1\n    make_range = max_make - min_make if max_make != min_make else 1\n    dist_weight = 1 - (dist_range / (dist_range + make_range)) if (dist_range + make_range) > 0 else 0.5\n    make_weight = 1 - dist_weight\n\n    # Normalize objectives\n    normalized_dist = (distances - min_dist) / dist_range if dist_range > 0 else np.ones_like(distances)\n    normalized_make = (makespans - min_make) / make_range if make_range > 0 else np.ones_like(makespans)\n\n    # Weighted sum with dynamic weights\n    scores = dist_weight * normalized_dist + make_weight * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try demand-aware route splitting\n        total_demand = np.sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Only split if demand is high\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n                continue\n\n        # Try inter-route demand balancing\n        if len(base_solution) > 1:\n            # Find route with similar demand\n            target_demand = np.sum(demand[route[1:-1]])\n            for other_route in base_solution:\n                if len(other_route) > 3 and not np.array_equal(other_route, route):\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if abs(other_demand - target_demand) < capacity * 0.3:\n                        # Try to transfer nodes\n                        for node in route[1:-1]:\n                            if demand[node] < capacity * 0.3:  # Only transfer small nodes\n                                new_other = np.insert(other_route, -1, node)\n                                new_route = np.delete(route, np.where(route == node)[0][0])\n                                if (np.sum(demand[new_other[1:-1]]) <= capacity and\n                                    np.sum(demand[new_route[1:-1]]) <= capacity):\n                                    new_solution.append(new_route)\n                                    other_route = new_other\n                                    break\n                        break\n\n        # Modified 2-opt with capacity checks\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8087014140793183,
            0.8795082271099091
        ],
        "raw_score": [
            57.945291588913435,
            7.622967802666784
        ]
    },
    {
        "algorithm": "The algorithm selects high-performing solutions from the archive using a weighted combination of normalized distance (70%) and makespan (30%) objectives, then applies a hybrid local search combining route splitting, demand-aware node swapping, and capacity-constrained route merging to generate improved feasible neighbor solutions. It prioritizes balancing both objectives while ensuring vehicle capacity constraints are met, and includes a final step to guarantee all customers are served.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    normalized_dist = (distances - min_dist) / (max_dist - min_dist) if max_dist != min_dist else np.ones_like(distances)\n    normalized_make = (makespans - min_make) / (max_make - min_make) if max_make != min_make else np.ones_like(makespans)\n\n    scores = 0.7 * normalized_dist + 0.3 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    if n_routes > 1 and random.random() < 0.6:\n        # Try route splitting first\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Demand-aware node swapping\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Capacity-constrained route merging\n    if n_routes > 2 and random.random() < 0.4:\n        route1_idx, route2_idx = random.sample(range(n_routes), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 1 and len(route2) > 1:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n\n    if served != all_customers:\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.35132318656131806,
            0.39889419078826904
        ],
        "raw_score": [
            36.5634520631486,
            4.9371205685403226
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing makespan first, then distance) and applies a novel hybrid local search combining adaptive route clustering (based on spatial and demand proximity) with demand-aware segment merging to reduce both total distance and makespan while maintaining capacity constraints. It intelligently merges similar routes and optimizes segments within routes, with fallback mechanisms to ensure feasibility through route splitting when needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Adaptive route clustering based on spatial and demand proximity\n    if len(new_solution) > 1:\n        # Calculate route centroids and demand profiles\n        route_centroids = []\n        route_demands = []\n        for route in new_solution:\n            nodes = route[1:-1]\n            if len(nodes) > 0:\n                centroid = np.mean(coords[nodes], axis=0)\n                total_demand = sum(demand[nodes])\n                route_centroids.append(centroid)\n                route_demands.append(total_demand)\n            else:\n                route_centroids.append(np.zeros(2))\n                route_demands.append(0)\n\n        # Find most similar routes to merge\n        min_similarity = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if len(new_solution[i]) > 2 and len(new_solution[j]) > 2:\n                    # Spatial proximity + demand similarity\n                    spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demands[i] - route_demands[j])\n                    similarity = spatial_dist + 0.5 * demand_diff\n                    if similarity < min_similarity:\n                        min_similarity = similarity\n                        best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try to merge routes by finding the best connection point\n            best_merge_cost = float('inf')\n            best_merge_point = None\n            for k in range(1, len(route1)-1):\n                for l in range(1, len(route2)-1):\n                    # Calculate potential merge cost\n                    cost = (distance_matrix[route1[k-1]][route2[l]] +\n                            distance_matrix[route2[l-1]][route1[k]] -\n                            distance_matrix[route1[k-1]][route1[k]] -\n                            distance_matrix[route2[l-1]][route2[l]])\n\n                    # Check capacity constraint\n                    if (sum(demand[route1[1:k]]) + sum(demand[route2[l:-1]]) <= capacity and\n                        sum(demand[route2[1:l]]) + sum(demand[route1[k:-1]]) <= capacity):\n                        if cost < best_merge_cost:\n                            best_merge_cost = cost\n                            best_merge_point = (k, l)\n\n            if best_merge_point:\n                k, l = best_merge_point\n                # Create merged route\n                merged_route = np.concatenate([route1[:k], route2[l:], [0]])\n\n                # Update solution\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Demand-aware segment merging for makespan reduction\n    for route in new_solution:\n        if len(route) > 3:\n            # Find segments that can be merged while maintaining capacity\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    segment = route[i:j+1]\n                    segment_demand = sum(demand[segment])\n\n                    # Check if merging this segment with adjacent nodes is beneficial\n                    if segment_demand <= capacity:\n                        # Calculate potential savings\n                        original_cost = (distance_matrix[route[i-1]][route[i]] +\n                                       distance_matrix[route[j]][route[j+1]])\n                        merged_cost = distance_matrix[route[i-1]][route[j+1]]\n\n                        if merged_cost < original_cost:\n                            # Perform the merge\n                            route[i:j+1] = [route[i]]\n\n    # Ensure all routes are feasible and properly formatted\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            new_solution.append(remaining_route)\n            new_solution[i] = new_route\n\n    # Ensure depot constraints\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.877203836724664,
            7.606746464967728
        ],
        "raw_score": [
            58.234626343567996,
            7.8589417444011325
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a combination of distance, makespan, and route diversity, then applies a hybrid local search that combines demand-balanced route clustering with adaptive node insertion to improve the solution while maintaining feasibility through dynamic capacity checks. It prioritizes transferring nodes between overloaded and underloaded routes, and balances capacity by strategically moving nodes between routes with optimal insertion points based on distance reduction. The selection score balances multiple objectives, while the local search operations focus on improving both distance and makespan metrics through intelligent node transfers.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def selection_score(sol):\n        dist, makespan = sol[1]\n        diversity = len(sol[0]) * (1 + 0.1 * (np.max([len(r) for r in sol[0]]) - np.min([len(r) for r in sol[0]])))\n        return dist + makespan + diversity\n\n    archive_sorted = sorted(archive, key=selection_score, reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive mechanisms\n    if n_routes > 1 and random.random() < 0.7:\n        # Demand-balanced route clustering\n        route_loads = [np.sum(demand[route]) for route in new_solution]\n        avg_load = np.mean(route_loads)\n\n        # Identify overloaded and underloaded routes\n        overloaded = [i for i, load in enumerate(route_loads) if load > avg_load * 1.1]\n        underloaded = [i for i, load in enumerate(route_loads) if load < avg_load * 0.9]\n\n        if overloaded and underloaded:\n            src_idx = random.choice(overloaded)\n            dest_idx = random.choice(underloaded)\n\n            # Find best node to transfer\n            src_route = new_solution[src_idx]\n            dest_route = new_solution[dest_idx]\n\n            best_node = None\n            best_reduction = 0\n\n            for i in range(1, len(src_route)-1):\n                node = src_route[i]\n                # Check capacity after transfer\n                if (np.sum(demand[dest_route]) + demand[node] <= capacity and\n                    np.sum(demand[src_route]) - demand[node] <= capacity):\n\n                    # Calculate potential distance reduction\n                    dist_before = (distance_matrix[src_route[i-1], node] +\n                                 distance_matrix[node, src_route[i+1]] +\n                                 distance_matrix[dest_route[-2], 0] +\n                                 distance_matrix[0, dest_route[1]])\n\n                    dist_after = (distance_matrix[src_route[i-1], src_route[i+1]] +\n                                 distance_matrix[dest_route[-2], node] +\n                                 distance_matrix[node, dest_route[1]] +\n                                 distance_matrix[0, 0])\n\n                    reduction = dist_before - dist_after\n                    if reduction > best_reduction:\n                        best_reduction = reduction\n                        best_node = node\n\n            if best_node is not None:\n                # Perform the transfer\n                node_pos = np.where(new_solution[src_idx] == best_node)[0][0]\n                new_solution[src_idx] = np.concatenate([\n                    new_solution[src_idx][:node_pos],\n                    new_solution[src_idx][node_pos+1:]\n                ])\n\n                # Insert into destination route\n                insert_pos = np.argmax([\n                    distance_matrix[dest_route[i], best_node] +\n                    distance_matrix[best_node, dest_route[i+1]]\n                    for i in range(len(dest_route)-1)\n                ])\n\n                new_solution[dest_idx] = np.concatenate([\n                    dest_route[:insert_pos+1],\n                    [best_node],\n                    dest_route[insert_pos+1:]\n                ])\n    else:\n        # Adaptive node insertion with capacity balancing\n        if n_routes >= 2:\n            # Select routes with potential for improvement\n            route_scores = [\n                np.sum(demand[route]) / capacity +\n                0.5 * (len(route) / np.mean([len(r) for r in new_solution]))\n                for route in new_solution\n            ]\n\n            route1_idx = np.argmax(route_scores)\n            route2_idx = np.argmin(route_scores)\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2:\n                # Find node to move\n                best_node = None\n                best_improvement = 0\n\n                for i in range(1, len(route1)-1):\n                    node = route1[i]\n                    # Check capacity after move\n                    if (np.sum(demand[route2]) + demand[node] <= capacity and\n                        np.sum(demand[route1]) - demand[node] <= capacity):\n\n                        # Calculate potential improvement\n                        dist_before = (distance_matrix[route1[i-1], node] +\n                                     distance_matrix[node, route1[i+1]] +\n                                     distance_matrix[route2[-2], 0] +\n                                     distance_matrix[0, route2[1]])\n\n                        dist_after = (distance_matrix[route1[i-1], route1[i+1]] +\n                                     distance_matrix[route2[-2], node] +\n                                     distance_matrix[node, route2[1]] +\n                                     distance_matrix[0, 0])\n\n                        improvement = dist_before - dist_after\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_node = node\n\n                if best_node is not None:\n                    # Perform the move\n                    node_pos = np.where(route1 == best_node)[0][0]\n                    new_solution[route1_idx] = np.concatenate([\n                        route1[:node_pos],\n                        route1[node_pos+1:]\n                    ])\n\n                    # Insert into route2 at optimal position\n                    insert_pos = np.argmax([\n                        distance_matrix[route2[i], best_node] +\n                        distance_matrix[best_node, route2[i+1]]\n                        for i in range(len(route2)-1)\n                    ])\n\n                    new_solution[route2_idx] = np.concatenate([\n                        route2[:insert_pos+1],\n                        [best_node],\n                        route2[insert_pos+1:]\n                    ])\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert np.sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6638624692022612,
            1.6575270593166351
        ],
        "raw_score": [
            58.041423997937244,
            7.7493932032422395
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective score (prioritizing lower total distance over shorter makespan), then applies a hybrid local search combining route merging (if feasible), demand-balanced node swapping, and dynamic capacity adjustment (splitting oversized routes) to generate a neighbor solution while ensuring feasibility. The weights (0.7 for distance, 0.3 for makespan) and random selection guide the search toward high-quality regions, while the local search operators balance both objectives through intelligent route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n    min_dist, max_dist = min(total_distances), max(total_distances)\n    min_span, max_span = min(makespans), max(makespans)\n\n    if max_dist == min_dist:\n        weights = [1.0 / len(archive) for _ in archive]\n    else:\n        weights = [(1 - (dist - min_dist) / (max_dist - min_dist)) * 0.7 +\n                  (1 - (span - min_span) / (max_span - min_span)) * 0.3\n                  for dist, span in zip(total_distances, makespans)]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + demand-balanced swapping\n    if len(new_solution) > 1:\n        # Step 1: Route merging (if routes can be combined without exceeding capacity)\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n        combined_load = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n\n        if combined_load <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 2: Demand-balanced node swapping\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Select two random nodes (not depots)\n        pos1, pos2 = random.sample(range(1, len(route)-1), 2)\n        node1, node2 = route[pos1], route[pos2]\n\n        # Calculate potential load changes\n        load_without1 = sum(demand[route[1:-1]]) - demand[node1]\n        load_without2 = sum(demand[route[1:-1]]) - demand[node2]\n        load_with_swap = load_without1 + demand[node2]\n        load_with_swap2 = load_without2 + demand[node1]\n\n        # Check feasibility\n        if (load_with_swap <= capacity and load_with_swap2 <= capacity):\n            # Swap nodes if feasible\n            route[pos1], route[pos2] = route[pos2], route[pos1]\n\n    # Step 3: Dynamic capacity adjustment (split routes if needed)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        current_load = sum(demand[route[1:-1]])\n\n        if current_load > capacity:\n            # Find split position that balances demand\n            target_load = current_load / 2\n            cumulative_load = 0\n            split_pos = 1\n\n            for j in range(1, len(route)-1):\n                cumulative_load += demand[route[j]]\n                if cumulative_load >= target_load:\n                    split_pos = j\n                    break\n\n            # Create new route\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            new_solution[i] = new_route\n            new_solution.append(remaining_route)\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.3371877862953648,
            0.6585793793201447
        ],
        "raw_score": [
            44.26474876485225,
            5.375982897521441
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower makespan from the archive, then applies a hybrid local search combining route merging (when feasible) and cross-route node reallocation (with capacity checks), followed by capacity-aware route splitting to ensure feasibility. It balances exploration (random selection) with exploitation (greedy insertion) while maintaining vehicle capacity constraints throughout. The structure iteratively refines routes by merging, reallocating nodes, and splitting overloaded routes, with a focus on demand-balanced configurations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n    routes = [route.copy() for route in new_solution]\n\n    # Step 1: Route merging (if possible)\n    if len(routes) > 1:\n        i, j = random.sample(range(len(routes)), 2)\n        merged_route = np.concatenate([routes[i][:-1], routes[j][1:]])\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            routes[i] = merged_route\n            routes.pop(j)\n\n    # Step 2: Cross-route node reallocation\n    for _ in range(min(3, len(routes))):  # Limit to 3 reallocations\n        if len(routes) < 2:\n            break\n        i, j = random.sample(range(len(routes)), 2)\n        if len(routes[i]) <= 3 or len(routes[j]) <= 3:\n            continue\n\n        # Select a random node from route i\n        remove_pos = random.randint(1, len(routes[i])-2)\n        removed_node = routes[i][remove_pos]\n        routes[i] = np.delete(routes[i], remove_pos)\n\n        # Find best position in route j\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(routes[j])):\n            inserted_route = np.insert(routes[j], pos, removed_node)\n            cost = sum(distance_matrix[inserted_route[k-1]][inserted_route[k]] for k in range(1, len(inserted_route)))\n            if cost < best_cost and sum(demand[inserted_route[1:-1]]) <= capacity:\n                best_cost = cost\n                best_pos = pos\n\n        # Insert at best position\n        routes[j] = np.insert(routes[j], best_pos, removed_node)\n\n    # Step 3: Capacity-aware route adjustment\n    for i in range(len(routes)):\n        if sum(demand[routes[i][1:-1]]) > capacity:\n            # Split route if capacity exceeded\n            split_pos = 1\n            current_load = 0\n            for k in range(1, len(routes[i])-1):\n                current_load += demand[routes[i][k]]\n                if current_load > capacity:\n                    split_pos = k\n                    break\n            new_route = np.concatenate([routes[i][:split_pos], [0]])\n            remaining_route = np.concatenate([[0], routes[i][split_pos:]])\n            routes.append(remaining_route)\n            routes[i] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(routes)):\n        if routes[i][0] != 0 or routes[i][-1] != 0:\n            routes[i] = np.concatenate([[0], routes[i][1:-1], [0]])\n\n    return np.array(routes, dtype=object)\n\n",
        "metric_score": [
            -0.5123539983291613,
            1.7466196417808533
        ],
        "raw_score": [
            29.957090114875697,
            2.5812567063451115
        ]
    }
]