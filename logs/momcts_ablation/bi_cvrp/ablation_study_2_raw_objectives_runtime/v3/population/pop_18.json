[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of normalized distance and makespan objectives (60% distance, 40% makespan), then applies a hybrid local search combining route splitting, inter-route insertion, and modified 2-opt with capacity checks to generate an improved neighbor solution. It prioritizes distance reduction while balancing makespan optimization, and ensures feasibility through strict capacity validation at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives for selection\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Avoid division by zero\n    if max_dist == min_dist:\n        normalized_dist = np.ones_like(distances)\n    else:\n        normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n    if max_make == min_make:\n        normalized_make = np.ones_like(makespans)\n    else:\n        normalized_make = (makespans - min_make) / (max_make - min_make)\n\n    # Weighted sum (can be adjusted)\n    scores = 0.6 * normalized_dist + 0.4 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try route splitting\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # If split fails, try inter-route insertion\n        if len(base_solution) > 1:\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and not np.array_equal(r, route)])\n            if len(other_route) > 3:\n                # Find best insertion point\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(other_route)):\n                    new_route = np.insert(other_route, i, route[1:-1])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = (distance_matrix[new_route[i-1], route[1]] +\n                                distance_matrix[route[-2], new_route[i+len(route)-2]] -\n                                distance_matrix[new_route[i-1], new_route[i+len(route)-2]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    new_route = np.insert(other_route, best_pos, route[1:-1])\n                    new_solution.append(new_route)\n                    continue\n\n        # If all else fails, apply modified 2-opt\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Convert back to original format\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only include non-trivial routes\n            final_solution.append(route)\n\n    return np.array(final_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8948495283173388,
            0.5054986476898193
        ],
        "raw_score": [
            57.889668453293666,
            7.825081625352422
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a high-performing solution from the archive (those with larger total distance or makespan) and applies a hybrid local search that combines route splitting (to reduce makespan) and demand-aware node swapping (to improve distance) while ensuring vehicle capacity constraints are never violated. It first tries route splitting if the solution has multiple routes, otherwise performs node swaps between routes, always checking feasibility before accepting changes. The selection prioritizes solutions with worse objectives to focus improvement efforts where they matter most.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search operator\n    if n_routes > 1 and random.random() < 0.5:\n        # Option 1: Route splitting and merging\n        # Select a random route to split\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1]) <= capacity and\n                np.sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Option 2: Demand-aware node swapping and capacity-aware merging\n        # Select two random routes\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find nodes to swap\n            if len(route1) > 2 and len(route2) > 2:\n                # Select nodes excluding depot\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity constraints after swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (np.sum(demand[new_route1]) <= capacity and\n                    np.sum(demand[new_route2]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert np.sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7736218329232261,
            0.332954078912735
        ],
        "raw_score": [
            57.83281969568547,
            7.686027274006558
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive (favoring top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route restructuring (splitting routes at capacity-balanced points) and objective-aware node swapping (exchanging nodes between routes when it improves distance). It ensures feasibility through adaptive capacity checks and prioritizes high-potential solutions for further improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7310293206497563,
            0.16164618730545044
        ],
        "raw_score": [
            58.10752915940811,
            7.61725505871078
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route fragmentation (splitting long routes at optimal points) and cross-exchange (swapping segments between routes while maintaining capacity constraints). The method balances objectives by intelligently modifying routes to reduce the longest route while potentially improving total distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: route fragmentation + cross-exchange\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the increase in total distance\n        min_increase = float('inf')\n        best_split = None\n        for i in range(1, len(longest_route)-1):\n            dist_before = distance_matrix[longest_route[i-1]][longest_route[i]]\n            dist_after = distance_matrix[longest_route[i]][longest_route[i+1]]\n            dist_new = distance_matrix[longest_route[i-1]][0] + distance_matrix[0][longest_route[i]] + \\\n                       distance_matrix[longest_route[i]][0] + distance_matrix[0][longest_route[i+1]]\n\n            if dist_new - (dist_before + dist_after) < min_increase:\n                min_increase = dist_new - (dist_before + dist_after)\n                best_split = i\n\n        if best_split is not None:\n            # Split the route\n            new_route1 = np.concatenate([longest_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], longest_route[best_split:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Step 2: Cross-exchange between routes to balance makespan\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find feasible cross-exchange points\n            feasible_pairs = []\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:i]]) + sum(demand[route2[j:-1]]) <= capacity and\n                        sum(demand[route2[1:j]]) + sum(demand[route1[i:-1]]) <= capacity):\n                        feasible_pairs.append((i, j))\n\n            if feasible_pairs:\n                i, j = random.choice(feasible_pairs)\n                # Perform cross-exchange\n                new_route1 = np.concatenate([route1[:i], route2[j:], [0]])\n                new_route2 = np.concatenate([route2[:j], route1[i:], [0]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8851232325504997,
            1.6942464113235474
        ],
        "raw_score": [
            57.31227674884602,
            7.414957018161158
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a promising solution from the archive using a weighted combination of normalized distance and makespan objectives, where weights adapt based on archive diversity, and then applies a hybrid local search combining demand-aware route splitting, inter-route demand balancing, and a modified 2-opt with capacity checks to generate a feasible neighbor solution that improves both objectives while ensuring feasibility. The selection prioritizes solutions with balanced trade-offs between objectives, while the local search focuses on high-demand routes and demand-balanced transfers to improve efficiency.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted selection based on archive diversity\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Calculate diversity-based weights\n    dist_range = max_dist - min_dist if max_dist != min_dist else 1\n    make_range = max_make - min_make if max_make != min_make else 1\n    dist_weight = 1 - (dist_range / (dist_range + make_range)) if (dist_range + make_range) > 0 else 0.5\n    make_weight = 1 - dist_weight\n\n    # Normalize objectives\n    normalized_dist = (distances - min_dist) / dist_range if dist_range > 0 else np.ones_like(distances)\n    normalized_make = (makespans - min_make) / make_range if make_range > 0 else np.ones_like(makespans)\n\n    # Weighted sum with dynamic weights\n    scores = dist_weight * normalized_dist + make_weight * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try demand-aware route splitting\n        total_demand = np.sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Only split if demand is high\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n                continue\n\n        # Try inter-route demand balancing\n        if len(base_solution) > 1:\n            # Find route with similar demand\n            target_demand = np.sum(demand[route[1:-1]])\n            for other_route in base_solution:\n                if len(other_route) > 3 and not np.array_equal(other_route, route):\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if abs(other_demand - target_demand) < capacity * 0.3:\n                        # Try to transfer nodes\n                        for node in route[1:-1]:\n                            if demand[node] < capacity * 0.3:  # Only transfer small nodes\n                                new_other = np.insert(other_route, -1, node)\n                                new_route = np.delete(route, np.where(route == node)[0][0])\n                                if (np.sum(demand[new_other[1:-1]]) <= capacity and\n                                    np.sum(demand[new_route[1:-1]]) <= capacity):\n                                    new_solution.append(new_route)\n                                    other_route = new_other\n                                    break\n                        break\n\n        # Modified 2-opt with capacity checks\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8087014140793183,
            0.8795082271099091
        ],
        "raw_score": [
            57.945291588913435,
            7.622967802666784
        ]
    },
    {
        "algorithm": "The algorithm combines elite solution selection with a hybrid local search that alternates between demand-balanced route restructuring and objective-aware node reallocation, prioritizing solutions with high potential for multi-objective improvement while maintaining feasibility through strict capacity checks. It selects promising solutions from the top 30% of the archive (sorted by combined objective values) and applies adaptive operators\u2014splitting routes to balance demand when feasible, or swapping nodes between routes to reduce total distance when beneficial\u2014but always ensures capacity constraints are met. The operator's aggressiveness is implicitly controlled by the solution's position in the archive, favoring exploration of high-potential regions while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Adaptive local search operator\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6255140612380136,
            0.18004998564720154
        ],
        "raw_score": [
            58.404306189036056,
            7.827867873817798
        ]
    },
    {
        "algorithm": "The algorithm combines cluster-based initialization with adaptive demand-aware segment swapping and cluster merging/splitting, prioritizing solutions with high objective values but maintaining diversity. It alternates between swapping demand-balanced segments between routes and merging/splitting clusters, while ensuring capacity constraints are satisfied and all customers are served. The solution selection balances exploitation (focusing on high-objective solutions) and exploration (random selection), with special handling for missing customers through demand-compatible insertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1 and random.random() < 0.6:\n        # Prioritize solutions with high objective values but maintain diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n        selected_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Cluster-based initialization (if solution has only one route)\n    if n_routes == 1 and len(new_solution[0]) > 3:\n        from sklearn.cluster import KMeans\n        customers = new_solution[0][1:-1]\n        n_clusters = min(5, len(customers) // 3 + 1)\n        kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n        clusters = kmeans.fit_predict(coords[customers])\n\n        new_solution = []\n        for cluster_id in range(n_clusters):\n            cluster_customers = customers[clusters == cluster_id]\n            if len(cluster_customers) == 0:\n                continue\n\n            # Sort customers in cluster by demand (descending)\n            sorted_customers = sorted(cluster_customers, key=lambda x: demand[x], reverse=True)\n\n            current_route = [0]\n            current_demand = 0\n            for customer in sorted_customers:\n                if current_demand + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_demand += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_demand = demand[customer]\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n        # Remove any empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Hybrid local search\n    if n_routes > 1:\n        # Adaptive segment swapping between clusters\n        if random.random() < 0.7:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Find segments with similar demand\n                segment1_start = random.randint(1, len(route1) - 3)\n                segment1_end = random.randint(segment1_start, len(route1) - 2)\n                segment1_demand = sum(demand[route1[segment1_start:segment1_end+1]])\n\n                best_pos = -1\n                best_similarity = float('inf')\n                for pos in range(1, len(route2) - 1):\n                    segment2_demand = sum(demand[route2[pos:pos+segment1_end-segment1_start+1]])\n                    similarity = abs(segment1_demand - segment2_demand)\n                    if similarity < best_similarity:\n                        best_similarity = similarity\n                        best_pos = pos\n\n                if best_pos != -1 and best_similarity < capacity * 0.4:\n                    segment_length = segment1_end - segment1_start + 1\n                    if best_pos + segment_length - 1 < len(route2) - 1:\n                        # Perform segment swap\n                        new_route1 = route1.copy()\n                        new_route2 = route2.copy()\n                        new_route1[segment1_start:segment1_end+1] = route2[best_pos:best_pos+segment_length]\n                        new_route2[best_pos:best_pos+segment_length] = route1[segment1_start:segment1_end+1]\n\n                        if (sum(demand[new_route1]) <= capacity and\n                            sum(demand[new_route2]) <= capacity):\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n        # Cluster merging/splitting\n        elif random.random() < 0.4:\n            if n_routes > 1 and random.random() < 0.6:\n                # Merge two clusters if demand is compatible\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if sum(demand[route1]) + sum(demand[route2]) <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n            else:\n                # Split a cluster if it's too large\n                route_idx = random.randint(0, len(new_solution) - 1)\n                route = new_solution[route_idx]\n\n                if len(route) > 5 and sum(demand[route]) > capacity * 0.7:\n                    split_pos = random.randint(2, len(route) - 3)\n                    new_route1 = route[:split_pos + 1]\n                    new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n                    if (sum(demand[new_route1]) <= capacity and\n                        sum(demand[new_route2]) <= capacity):\n                        new_solution[route_idx] = new_route1\n                        new_solution.append(new_route2)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n\n    if served != all_customers:\n        missing = list(all_customers - served)\n        for customer in missing:\n            # Insert into route with most compatible demand\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                if sum(demand[route]) + demand[customer] > capacity:\n                    continue\n\n                for pos in range(1, len(route)):\n                    new_route = np.insert(route, pos, customer)\n                    cost = (distance_matrix[route[pos-1]][customer] +\n                            distance_matrix[customer][route[pos]] -\n                            distance_matrix[route[pos-1]][route[pos]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route_idx = route_idx\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.7077840791394255,
            0.5567453503608704
        ],
        "raw_score": [
            34.80217028662338,
            4.019834271963303
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing makespan first, then distance) and applies a novel hybrid local search combining adaptive route clustering (based on spatial and demand proximity) with demand-aware segment merging to reduce both total distance and makespan while maintaining capacity constraints. It intelligently merges similar routes and optimizes segments within routes, with fallback mechanisms to ensure feasibility through route splitting when needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][1], -x[1][0]))\n    selected_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Adaptive route clustering based on spatial and demand proximity\n    if len(new_solution) > 1:\n        # Calculate route centroids and demand profiles\n        route_centroids = []\n        route_demands = []\n        for route in new_solution:\n            nodes = route[1:-1]\n            if len(nodes) > 0:\n                centroid = np.mean(coords[nodes], axis=0)\n                total_demand = sum(demand[nodes])\n                route_centroids.append(centroid)\n                route_demands.append(total_demand)\n            else:\n                route_centroids.append(np.zeros(2))\n                route_demands.append(0)\n\n        # Find most similar routes to merge\n        min_similarity = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if len(new_solution[i]) > 2 and len(new_solution[j]) > 2:\n                    # Spatial proximity + demand similarity\n                    spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demands[i] - route_demands[j])\n                    similarity = spatial_dist + 0.5 * demand_diff\n                    if similarity < min_similarity:\n                        min_similarity = similarity\n                        best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Try to merge routes by finding the best connection point\n            best_merge_cost = float('inf')\n            best_merge_point = None\n            for k in range(1, len(route1)-1):\n                for l in range(1, len(route2)-1):\n                    # Calculate potential merge cost\n                    cost = (distance_matrix[route1[k-1]][route2[l]] +\n                            distance_matrix[route2[l-1]][route1[k]] -\n                            distance_matrix[route1[k-1]][route1[k]] -\n                            distance_matrix[route2[l-1]][route2[l]])\n\n                    # Check capacity constraint\n                    if (sum(demand[route1[1:k]]) + sum(demand[route2[l:-1]]) <= capacity and\n                        sum(demand[route2[1:l]]) + sum(demand[route1[k:-1]]) <= capacity):\n                        if cost < best_merge_cost:\n                            best_merge_cost = cost\n                            best_merge_point = (k, l)\n\n            if best_merge_point:\n                k, l = best_merge_point\n                # Create merged route\n                merged_route = np.concatenate([route1[:k], route2[l:], [0]])\n\n                # Update solution\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Demand-aware segment merging for makespan reduction\n    for route in new_solution:\n        if len(route) > 3:\n            # Find segments that can be merged while maintaining capacity\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    segment = route[i:j+1]\n                    segment_demand = sum(demand[segment])\n\n                    # Check if merging this segment with adjacent nodes is beneficial\n                    if segment_demand <= capacity:\n                        # Calculate potential savings\n                        original_cost = (distance_matrix[route[i-1]][route[i]] +\n                                       distance_matrix[route[j]][route[j+1]])\n                        merged_cost = distance_matrix[route[i-1]][route[j+1]]\n\n                        if merged_cost < original_cost:\n                            # Perform the merge\n                            route[i:j+1] = [route[i]]\n\n    # Ensure all routes are feasible and properly formatted\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            new_solution.append(remaining_route)\n            new_solution[i] = new_route\n\n    # Ensure depot constraints\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.877203836724664,
            7.606746464967728
        ],
        "raw_score": [
            58.234626343567996,
            7.8589417444011325
        ]
    },
    {
        "algorithm": "The algorithm selects high-performing solutions from the archive using a weighted combination of normalized distance (70%) and makespan (30%) objectives, then applies a hybrid local search combining route splitting, demand-aware node swapping, and capacity-constrained route merging to generate improved feasible neighbor solutions. It prioritizes balancing both objectives while ensuring vehicle capacity constraints are met, and includes a final step to guarantee all customers are served.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    normalized_dist = (distances - min_dist) / (max_dist - min_dist) if max_dist != min_dist else np.ones_like(distances)\n    normalized_make = (makespans - min_make) / (max_make - min_make) if max_make != min_make else np.ones_like(makespans)\n\n    scores = 0.7 * normalized_dist + 0.3 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    if n_routes > 1 and random.random() < 0.6:\n        # Try route splitting first\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Demand-aware node swapping\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                    np.sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Capacity-constrained route merging\n    if n_routes > 2 and random.random() < 0.4:\n        route1_idx, route2_idx = random.sample(range(n_routes), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 1 and len(route2) > 1:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n\n    if served != all_customers:\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.35132318656131806,
            0.39889419078826904
        ],
        "raw_score": [
            36.5634520631486,
            4.9371205685403226
        ]
    },
    {
        "algorithm": "The algorithm implements an adaptive multi-objective local search for the Bi-CVRP, dynamically balancing distance and makespan optimization through weighted selection based on archive diversity. It employs a hybrid approach combining demand-aware route splitting and multi-objective 2-opt, with preemptive capacity checks and inter-route reallocation to maintain feasibility. The solution prioritizes high-demand nodes for splitting and selectively applies segment reversals to improve both objectives, while ensuring all customers are served through a final insertion step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity and adjust weights dynamically\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    # Calculate diversity metrics\n    dist_std = np.std(distances)\n    make_std = np.std(makespans)\n    diversity_ratio = dist_std / (make_std + 1e-10)\n\n    # Adjust weights based on diversity and solution quality\n    if diversity_ratio > 1.2:\n        dist_weight = 0.7\n        make_weight = 0.3\n    elif diversity_ratio < 0.8:\n        dist_weight = 0.3\n        make_weight = 0.7\n    else:\n        dist_weight = 0.5\n        make_weight = 0.5\n\n    # Normalize objectives\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    if max_dist == min_dist:\n        normalized_dist = np.ones_like(distances)\n    else:\n        normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n    if max_make == min_make:\n        normalized_make = np.ones_like(makespans)\n    else:\n        normalized_make = (makespans - min_make) / (max_make - min_make)\n\n    # Weighted sum for selection\n    scores = dist_weight * normalized_dist + make_weight * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:\n            new_solution.append(route)\n            continue\n\n        # Demand-aware route restructuring\n        total_demand = sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.8:  # High demand route\n            # Split at highest demand node\n            demands = demand[route[1:-1]]\n            split_pos = np.argmax(demands) + 1\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n                continue\n\n        # Multi-objective 2-opt\n        best_route = route.copy()\n        best_score = float('inf')\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n\n                if sum(demand[new_route[1:-1]]) > capacity:\n                    continue\n\n                # Calculate new distance\n                new_dist = sum(distance_matrix[new_route[k-1]][new_route[k]] for k in range(1, len(new_route)))\n\n                # Calculate new makespan contribution\n                new_route_dist = new_dist\n                current_route_dist = sum(distance_matrix[route[k-1]][route[k]] for k in range(1, len(route)))\n                if new_route_dist < current_route_dist:\n                    # Calculate combined score (distance + makespan)\n                    other_routes = [r for r in base_solution if not np.array_equal(r, route)]\n                    other_distances = [sum(distance_matrix[r[k-1]][r[k]] for k in range(1, len(r))) for r in other_routes]\n                    max_other_dist = max(other_distances) if other_routes else 0\n                    new_score = dist_weight * new_route_dist + make_weight * max(max_other_dist, new_route_dist)\n\n                    if new_score < best_score:\n                        best_score = new_score\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Convert to final solution format\n    final_solution = [r for r in new_solution if len(r) > 2]\n    return np.array(final_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8250982249977812,
            2.3853780329227448
        ],
        "raw_score": [
            58.406407127403725,
            7.698727654945839
        ]
    }
]