[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and a novel \"route reshuffling\" operator to balance the two objectives while ensuring feasibility. It intelligently selects customers for reinsertion and reshuffles routes to reduce makespan differences, focusing on capacity constraints and objective trade-offs. The process ensures feasibility at each step while targeting both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route merging (if possible) to reduce makespan\n    if len(selected_solution) > 1:\n        merged_routes = []\n        for route in selected_solution:\n            if not merged_routes or np.sum(demand[route[1:-1]]) + np.sum(demand[merged_routes[-1][1:-1]]) <= capacity:\n                if merged_routes:\n                    merged_route = np.concatenate((merged_routes[-1][:-1], route[1:]))\n                    merged_routes[-1] = merged_route\n                else:\n                    merged_routes.append(route)\n            else:\n                merged_routes.append(route)\n        selected_solution = merged_routes\n\n    # Step 2: Customer reinsertion with capacity constraints\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        candidates = route[1:-1]\n        if len(candidates) == 0:\n            new_solution.append(route)\n            continue\n\n        removed_customer = np.random.choice(candidates)\n        remaining_route = route[route != removed_customer]\n\n        # Find best insertion position in existing routes\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, r in enumerate(new_solution):\n            for pos in range(1, len(r)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate((r[1:pos], [removed_customer], r[pos:-1]))]) <= capacity:\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[r[pos-1], removed_customer] +\n                                   distance_matrix[removed_customer, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insertion = (i, pos)\n\n        if best_insertion:\n            i, pos = best_insertion\n            new_route = np.concatenate((new_solution[i][:pos], [removed_customer], new_solution[i][pos:]))\n            new_solution[i] = new_route\n        else:\n            # If no valid insertion found, create new route\n            new_solution.append(np.array([0, removed_customer, 0]))\n\n    # Step 3: Route reshuffling (novel operator) to balance objectives\n    if len(new_solution) > 1:\n        # Select two routes to reshuffle\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Find best split points for both routes\n        best_split = None\n        min_diff = float('inf')\n\n        for split1 in range(1, len(new_solution[idx1])-1):\n            for split2 in range(1, len(new_solution[idx2])-1):\n                # Check capacity constraints for both new routes\n                if (np.sum(demand[new_solution[idx1][1:split1]]) <= capacity and\n                    np.sum(demand[new_solution[idx1][split1:-1]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][1:split2]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][split2:-1]]) <= capacity):\n\n                    # Calculate makespan difference after reshuffling\n                    current_makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n                    new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n                    new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n                    new_makespan1 = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                    new_makespan2 = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n\n                    diff = abs(new_makespan1 - new_makespan2)\n                    if diff < min_diff:\n                        min_diff = diff\n                        best_split = (split1, split2)\n\n        if best_split:\n            split1, split2 = best_split\n            new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n            new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n            new_solution[idx1] = new_route1\n            new_solution[idx2] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8234625192972875,
            2.7163036167621613
        ],
        "raw_score": [
            58.1689844298665,
            7.7370092861205855
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (prioritizing makespan over distance) and applies a hybrid local search combining route splitting (for demand imbalance), customer relocation (to balance makespan), and demand-aware reshuffling (to swap route segments while maintaining capacity constraints). It focuses on reducing makespan by 10% and demand imbalance by 20% of capacity thresholds, ensuring feasibility through rigorous demand checks. The weighted selection (0.4 distance, 0.6 makespan) balances exploration of diverse solutions while the hybrid operators target both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Balance between distance and makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Try to split a route with high demand imbalance\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    second_part_demand = total_demand - first_part_demand\n                    if abs(first_part_demand - second_part_demand) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Relocate customers to balance makespan\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        longest_route = np.argmax(makespans)\n        shortest_route = np.argmin(makespans)\n\n        if makespans[longest_route] - makespans[shortest_route] > 0.1 * np.mean(makespans):\n            for customer_pos in range(1, len(new_solution[longest_route])-1):\n                customer = new_solution[longest_route][customer_pos]\n                if (np.sum(demand[new_solution[shortest_route][1:-1]]) + demand[customer] <= capacity and\n                    len(new_solution[shortest_route]) < len(new_solution[longest_route])):\n                    # Calculate potential makespan improvement\n                    old_dist = (distance_matrix[new_solution[longest_route][customer_pos-1], customer] +\n                               distance_matrix[customer, new_solution[longest_route][customer_pos+1]] -\n                               distance_matrix[new_solution[longest_route][customer_pos-1], new_solution[longest_route][customer_pos+1]])\n                    new_dist = (distance_matrix[new_solution[shortest_route][-2], customer] +\n                               distance_matrix[customer, 0] -\n                               distance_matrix[new_solution[shortest_route][-2], 0])\n                    if old_dist > new_dist:\n                        new_solution[shortest_route] = np.concatenate((new_solution[shortest_route][:-1], [customer], [0]))\n                        new_solution[longest_route] = np.concatenate((new_solution[longest_route][:customer_pos], new_solution[longest_route][customer_pos+1:]))\n                        break\n\n        # Step 3: Demand-aware reshuffling\n        if len(new_solution) > 2:\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n            demand1, demand2 = np.sum(demand[route1[1:-1]]), np.sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > 0.2 * capacity:\n                for split1 in range(1, len(route1)-1):\n                    for split2 in range(1, len(route2)-1):\n                        part1 = route1[1:split1]\n                        part2 = route2[1:split2]\n                        new_demand1 = demand1 - np.sum(demand[part1]) + np.sum(demand[part2])\n                        new_demand2 = demand2 - np.sum(demand[part2]) + np.sum(demand[part1])\n                        if (new_demand1 <= capacity and new_demand2 <= capacity and\n                            abs(new_demand1 - new_demand2) < abs(demand1 - demand2)):\n                            new_route1 = np.concatenate(([0], part1, route2[split2:-1], route1[split1:-1], [0]))\n                            new_route2 = np.concatenate(([0], part2, route1[split1:-1], route2[split2:-1], [0]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                    else:\n                        continue\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7904515528208966,
            0.8658688962459564
        ],
        "raw_score": [
            58.1234035683554,
            7.636296895092969
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7626046040934145,
            0.21666795015335083
        ],
        "raw_score": [
            57.38218004043512,
            7.516075889345629
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive with a weighted preference for lower total distance (50%) over makespan (50%), then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-adaptive swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations when standard improvements fail, always enforcing capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = (0.5, 0.5)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to split the route into two\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 2: If splitting fails, try to relocate a customer to another route\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_pos)\n\n                            new_solution[route_idx] = route\n                            new_solution[other_route_idx] = other_route\n                            break\n                else:\n                    # Step 3: If relocation fails, try a capacity-adaptive swap\n                    for i in range(1, len(route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[route[1:-1]]) + demand[route[i]]):\n                                        old_dist = (distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][other_route[j]] + distance_matrix[other_route[j]][other_route[j+1]])\n                                        new_dist = (distance_matrix[route[i-1]][other_route[j]] + distance_matrix[other_route[j]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][route[i]] + distance_matrix[route[i]][other_route[j+1]])\n\n                                        if new_dist < old_dist:\n                                            route[i], other_route[j] = other_route[j], route[i]\n                                            new_solution[route_idx] = route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7039234633235187,
            0.1366652548313141
        ],
        "raw_score": [
            58.0593097506559,
            7.644695851627934
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the best total distance from the archive and applies a hybrid local search combining route splitting (based on demand imbalance), a novel cluster-based 2-opt (optimizing spatial proximity), and demand-based customer relocation between routes (balancing vehicle loads). It prioritizes reducing makespan by splitting overloaded routes and improving total distance through spatial-aware optimizations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route Splitting based on demand imbalance\n    if len(new_solution) > 0:\n        # Find the route with the highest demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        target_route_idx = np.argmax(demands)\n        target_route = new_solution[target_route_idx]\n\n        # Find the customer with the highest demand in this route\n        customers = target_route[1:-1]\n        if len(customers) > 0:\n            customer_demands = [(c, demand[c]) for c in customers]\n            customer_demands.sort(key=lambda x: -x[1])\n            split_customer = customer_demands[0][0]\n\n            # Split the route at this customer\n            split_idx = np.where(target_route == split_customer)[0][0]\n            new_route1 = np.concatenate([target_route[:split_idx+1], [0]])\n            new_route2 = np.concatenate([[0], target_route[split_idx:]])\n\n            # Replace the original route with the two new routes\n            new_solution.pop(target_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    # Step 2: Cluster-based 2-opt (considering spatial proximity)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depots\n\n        if len(route) >= 2:\n            # Find two customers that are close in space but not necessarily adjacent\n            customer_coords = coords[route]\n            distances = np.linalg.norm(customer_coords[:, np.newaxis, :] - customer_coords[np.newaxis, :, :], axis=2)\n            np.fill_diagonal(distances, np.inf)\n            i, j = np.unravel_index(np.argmin(distances), distances.shape)\n\n            # Ensure i < j for proper segment reversal\n            if i > j:\n                i, j = j, i\n\n            # Reverse the segment between i and j\n            new_segment = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Step 3: Demand-based customer relocation between routes\n    if len(new_solution) > 1:\n        # Find the two most imbalanced routes\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = np.argsort(demands)\n        source_route_idx = sorted_indices[-1]  # Most loaded route\n        target_route_idx = sorted_indices[0]  # Least loaded route\n\n        source_route = new_solution[source_route_idx]\n        target_route = new_solution[target_route_idx]\n\n        # Find the customer with the highest demand in the source route\n        customers = source_route[1:-1]\n        if len(customers) > 0:\n            customer_demands = [(c, demand[c]) for c in customers]\n            customer_demands.sort(key=lambda x: -x[1])\n            customer_to_move = customer_demands[0][0]\n\n            # Check if moving this customer to the target route is feasible\n            source_demand = sum(demand[source_route[1:-1]])\n            target_demand = sum(demand[target_route[1:-1]])\n            if target_demand + demand[customer_to_move] <= capacity:\n                # Remove customer from source route\n                mask = source_route != customer_to_move\n                new_source_route = source_route[mask]\n\n                # Insert customer into target route at the best position\n                best_pos = -1\n                best_increase = float('inf')\n\n                for i in range(len(target_route) - 1):\n                    dist_increase = (distance_matrix[target_route[i], customer_to_move] +\n                                    distance_matrix[customer_to_move, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = i + 1\n\n                if best_pos != -1:\n                    new_target_route = np.insert(target_route, best_pos, customer_to_move)\n                    new_solution[source_route_idx] = new_source_route\n                    new_solution[target_route_idx] = new_target_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7196664685669433,
            0.6482102572917938
        ],
        "raw_score": [
            57.69770042862447,
            7.714377659263765
        ]
    },
    {
        "algorithm": "The algorithm dynamically alternates between distance-focused and makespan-focused selection from the archive, then applies a hybrid local search combining demand-aware route splitting, capacity-constrained segment swaps, and adaptive customer reinsertion, prioritizing solutions with balanced objectives while ensuring feasibility through incremental validation. It alternates between prioritizing total distance (first two iterations) and makespan (next two iterations) during selection, and uses a multi-step local search that first splits long routes with unbalanced demands, then performs segment swaps between routes to improve both distance and makespan, followed by adaptive customer reinsertion to further optimize the solution structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    iteration = len(archive) % 4\n    if iteration < 2:\n        weights = (0.8, 0.2)  # Distance-focused\n    else:\n        weights = (0.2, 0.8)  # Makespan-focused\n\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Demand-aware route splitting with makespan improvement\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        max_makespan = max(makespans)\n\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3 and makespans[route_idx] > 0.9 * max_makespan:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    if abs(first_part_demand - (total_demand - first_part_demand)) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Capacity-constrained segment swaps\n        for _ in range(2):  # Try multiple swaps\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n\n            for split1 in range(1, len(route1)-1):\n                for split2 in range(1, len(route2)-1):\n                    part1 = route1[1:split1]\n                    part2 = route2[1:split2]\n                    if (np.sum(demand[part1]) <= capacity - np.sum(demand[route2[1:-1]]) + np.sum(demand[part2]) and\n                        np.sum(demand[part2]) <= capacity - np.sum(demand[route1[1:-1]]) + np.sum(demand[part1])):\n                        # Calculate makespan improvement potential\n                        old_dist = (distance_matrix[route1[split1-1], route1[split1]] +\n                                   distance_matrix[route2[split2-1], route2[split2]])\n                        new_dist = (distance_matrix[route1[split1-1], route2[split2]] +\n                                   distance_matrix[route2[split2-1], route1[split1]])\n                        if new_dist < old_dist:\n                            new_route1 = np.concatenate((route1[:split1], route2[split2:-1], route1[split1:]))\n                            new_route2 = np.concatenate((route2[:split2], route1[split1:-1], route2[split2:]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                else:\n                    continue\n                break\n\n        # Step 3: Adaptive customer reinsertion\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                candidate_pos = random.randint(1, len(route)-2)\n                customer = route[candidate_pos]\n\n                # Try reinserting into other routes\n                for other_idx in range(len(new_solution)):\n                    if other_idx != route_idx:\n                        other_route = new_solution[other_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate potential improvement\n                            old_dist = (distance_matrix[route[candidate_pos-1], customer] +\n                                      distance_matrix[customer, route[candidate_pos+1]] -\n                                      distance_matrix[route[candidate_pos-1], route[candidate_pos+1]])\n                            new_dist = (distance_matrix[other_route[-2], customer] +\n                                      distance_matrix[customer, 0] -\n                                      distance_matrix[other_route[-2], 0])\n                            if new_dist < old_dist:\n                                new_solution[other_idx] = np.concatenate((other_route[:-1], [customer], [0]))\n                                new_solution[route_idx] = np.concatenate((route[:candidate_pos], route[candidate_pos+1:]))\n                                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.732739139460205,
            3.2730793952941895
        ],
        "raw_score": [
            58.31340533238172,
            7.84913809031286
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the best makespan from the archive and applies a hybrid local search combining route merging, 2-opt, and demand-based customer reinsertion to reduce both total distance and makespan while ensuring feasibility. It prioritizes high-demand customers and route merging when feasible, followed by 2-opt for local optimization, and finally reinserts unassigned customers into the longest route to balance makespan. The solution ensures capacity constraints are never violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge (if feasible)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible in terms of capacity\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes (excluding depots)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Step 2: Apply 2-opt on a randomly selected route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depots\n        if len(route) >= 2:\n            i, j = sorted(random.sample(range(len(route)), 2))\n            # Reverse the segment between i and j\n            new_segment = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Step 3: Reinsert high-demand customers to balance routes\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Find the route with the highest makespan\n        makespans = [sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution]\n        target_route_idx = np.argmax(makespans)\n        target_route = new_solution[target_route_idx]\n\n        # Try to insert unassigned customers with highest demand first\n        unassigned_customers.sort(key=lambda x: -demand[x])\n        for customer in unassigned_customers:\n            best_pos = -1\n            best_increase = float('inf')\n\n            # Find the best insertion position in the target route\n            for i in range(len(target_route) - 1):\n                # Check capacity constraint\n                current_demand = sum(demand[target_route[1:-1]])\n                if current_demand + demand[customer] <= capacity:\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[target_route[i], customer] +\n                                    distance_matrix[customer, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.2571794216643792,
            0.4204300045967102
        ],
        "raw_score": [
            31.856981161376098,
            3.5915282607247287
        ]
    },
    {
        "algorithm": "The algorithm implements a three-phase local search strategy for the Bi-CVRP, prioritizing balanced solutions (Phase 1), distance optimization (Phase 2), and novel route fusion (Phase 3). It dynamically selects customers to relocate between routes based on demand compatibility and spatial proximity, with a focus on reducing makespan and total distance while ensuring capacity constraints. The route fusion operator merges underutilized routes to improve solution quality, with careful validation of feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))  # Select solution with most balanced objectives\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-aware route reshaping (focus on makespan)\n    if len(new_solution) > 1:\n        # Select the longest route (potential makespan bottleneck)\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        route_idx = np.argmax(route_lengths)\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Identify customers that could reduce route length when relocated\n            for i in range(1, len(selected_route) - 1):\n                customer = selected_route[i]\n                # Find the best insertion position in any other route\n                best_route = -1\n                best_pos = -1\n                best_improvement = 0\n\n                for r in range(len(new_solution)):\n                    if r == route_idx:\n                        continue\n                    other_route = new_solution[r]\n                    current_demand = sum(demand[other_route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        for j in range(len(other_route) - 1):\n                            # Calculate potential improvement in distance\n                            improvement = (distance_matrix[other_route[j], customer] +\n                                          distance_matrix[customer, other_route[j+1]] -\n                                          distance_matrix[other_route[j], other_route[j+1]])\n\n                            if improvement < best_improvement:\n                                best_improvement = improvement\n                                best_route = r\n                                best_pos = j + 1\n\n                if best_route != -1:\n                    # Perform the move\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[route_idx] = np.delete(selected_route, i)\n                    break  # Only move one customer at a time\n\n    # Phase 2: Spatial-aware customer reallocation (focus on distance)\n    if len(new_solution) > 1:\n        # Select a random route to potentially improve\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Find the customer whose removal would most reduce route length\n            best_customer = -1\n            best_reduction = 0\n\n            for i in range(1, len(selected_route) - 1):\n                customer = selected_route[i]\n                reduction = (distance_matrix[selected_route[i-1], selected_route[i+1]] -\n                            distance_matrix[selected_route[i-1], customer] -\n                            distance_matrix[customer, selected_route[i+1]])\n\n                if reduction > best_reduction:\n                    best_reduction = reduction\n                    best_customer = i\n\n            if best_customer != -1:\n                customer = selected_route[best_customer]\n                # Try to reinsert this customer into another route\n                best_route = -1\n                best_pos = -1\n                best_improvement = 0\n\n                for r in range(len(new_solution)):\n                    if r == route_idx:\n                        continue\n                    other_route = new_solution[r]\n                    current_demand = sum(demand[other_route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        for j in range(len(other_route) - 1):\n                            # Calculate potential improvement in distance\n                            improvement = (distance_matrix[other_route[j], customer] +\n                                          distance_matrix[customer, other_route[j+1]] -\n                                          distance_matrix[other_route[j], other_route[j+1]])\n\n                            if improvement < best_improvement:\n                                best_improvement = improvement\n                                best_route = r\n                                best_pos = j + 1\n\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[route_idx] = np.delete(selected_route, best_customer)\n\n    # Phase 3: Route fusion (novel operator)\n    if len(new_solution) > 2:\n        # Identify the two most underutilized routes\n        utilization = [sum(demand[route[1:-1]]) / capacity for route in new_solution]\n        sorted_indices = sorted(range(len(utilization)), key=lambda i: utilization[i])\n\n        for i in range(min(2, len(sorted_indices))):\n            route_idx = sorted_indices[i]\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Try to merge this route with another\n                for other_idx in range(len(new_solution)):\n                    if other_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_idx]\n\n                    # Check if merging is feasible\n                    if sum(demand[route[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                        # Calculate the best merge point\n                        best_pos = -1\n                        best_distance = float('inf')\n\n                        for j in range(len(other_route) - 1):\n                            # Calculate the distance of the merged route\n                            merged_route = np.concatenate([\n                                other_route[:j+1],\n                                route[1:-1],\n                                other_route[j+1:]\n                            ])\n                            dist = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n\n                            if dist < best_distance:\n                                best_distance = dist\n                                best_pos = j\n\n                        if best_pos != -1:\n                            # Perform the merge\n                            merged_route = np.concatenate([\n                                other_route[:best_pos+1],\n                                route[1:-1],\n                                other_route[best_pos+1:]\n                            ])\n                            new_solution[other_idx] = merged_route\n                            del new_solution[route_idx]\n                            break\n\n    # Ensure the solution remains feasible\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7212838099716907,
            9.712263315916061
        ],
        "raw_score": [
            55.29715789056763,
            7.465192311468993
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined total distance and makespan from the archive, then applies a hybrid local search that fragments routes, shuffles customers, and rebuilds routes while respecting capacity constraints, prioritizing the most promising solutions for improvement. The key design ideas are: (1) intelligent solution selection based on aggregated objective values, and (2) a capacity-aware route reconstruction strategy that ensures feasibility while introducing randomness for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: route fragmentation + customer reinsertion\n    new_solution = []\n    all_customers = []\n\n    # Collect all customers from all routes\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])  # Exclude depot\n\n    # Shuffle customers for randomness\n    random.shuffle(all_customers)\n\n    # Rebuild routes with capacity checks\n    current_route = [0]\n    current_load = 0\n\n    for customer in all_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # If no routes were created (edge case), return original\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6697742146086336,
            0.45303669571876526
        ],
        "raw_score": [
            51.746525783600006,
            6.140857876814449
        ]
    }
]