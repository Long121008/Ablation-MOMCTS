[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and a novel \"route reshuffling\" operator to balance the two objectives while ensuring feasibility. It intelligently selects customers for reinsertion and reshuffles routes to reduce makespan differences, focusing on capacity constraints and objective trade-offs. The process ensures feasibility at each step while targeting both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route merging (if possible) to reduce makespan\n    if len(selected_solution) > 1:\n        merged_routes = []\n        for route in selected_solution:\n            if not merged_routes or np.sum(demand[route[1:-1]]) + np.sum(demand[merged_routes[-1][1:-1]]) <= capacity:\n                if merged_routes:\n                    merged_route = np.concatenate((merged_routes[-1][:-1], route[1:]))\n                    merged_routes[-1] = merged_route\n                else:\n                    merged_routes.append(route)\n            else:\n                merged_routes.append(route)\n        selected_solution = merged_routes\n\n    # Step 2: Customer reinsertion with capacity constraints\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        candidates = route[1:-1]\n        if len(candidates) == 0:\n            new_solution.append(route)\n            continue\n\n        removed_customer = np.random.choice(candidates)\n        remaining_route = route[route != removed_customer]\n\n        # Find best insertion position in existing routes\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, r in enumerate(new_solution):\n            for pos in range(1, len(r)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate((r[1:pos], [removed_customer], r[pos:-1]))]) <= capacity:\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[r[pos-1], removed_customer] +\n                                   distance_matrix[removed_customer, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insertion = (i, pos)\n\n        if best_insertion:\n            i, pos = best_insertion\n            new_route = np.concatenate((new_solution[i][:pos], [removed_customer], new_solution[i][pos:]))\n            new_solution[i] = new_route\n        else:\n            # If no valid insertion found, create new route\n            new_solution.append(np.array([0, removed_customer, 0]))\n\n    # Step 3: Route reshuffling (novel operator) to balance objectives\n    if len(new_solution) > 1:\n        # Select two routes to reshuffle\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Find best split points for both routes\n        best_split = None\n        min_diff = float('inf')\n\n        for split1 in range(1, len(new_solution[idx1])-1):\n            for split2 in range(1, len(new_solution[idx2])-1):\n                # Check capacity constraints for both new routes\n                if (np.sum(demand[new_solution[idx1][1:split1]]) <= capacity and\n                    np.sum(demand[new_solution[idx1][split1:-1]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][1:split2]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][split2:-1]]) <= capacity):\n\n                    # Calculate makespan difference after reshuffling\n                    current_makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n                    new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n                    new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n                    new_makespan1 = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                    new_makespan2 = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n\n                    diff = abs(new_makespan1 - new_makespan2)\n                    if diff < min_diff:\n                        min_diff = diff\n                        best_split = (split1, split2)\n\n        if best_split:\n            split1, split2 = best_split\n            new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n            new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n            new_solution[idx1] = new_route1\n            new_solution[idx2] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8234625192972875,
            2.7163036167621613
        ],
        "raw_score": [
            58.1689844298665,
            7.7370092861205855
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (prioritizing makespan over distance) and applies a hybrid local search combining route splitting (for demand imbalance), customer relocation (to balance makespan), and demand-aware reshuffling (to swap route segments while maintaining capacity constraints). It focuses on reducing makespan by 10% and demand imbalance by 20% of capacity thresholds, ensuring feasibility through rigorous demand checks. The weighted selection (0.4 distance, 0.6 makespan) balances exploration of diverse solutions while the hybrid operators target both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = (0.4, 0.6)  # Balance between distance and makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Try to split a route with high demand imbalance\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    second_part_demand = total_demand - first_part_demand\n                    if abs(first_part_demand - second_part_demand) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Relocate customers to balance makespan\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        longest_route = np.argmax(makespans)\n        shortest_route = np.argmin(makespans)\n\n        if makespans[longest_route] - makespans[shortest_route] > 0.1 * np.mean(makespans):\n            for customer_pos in range(1, len(new_solution[longest_route])-1):\n                customer = new_solution[longest_route][customer_pos]\n                if (np.sum(demand[new_solution[shortest_route][1:-1]]) + demand[customer] <= capacity and\n                    len(new_solution[shortest_route]) < len(new_solution[longest_route])):\n                    # Calculate potential makespan improvement\n                    old_dist = (distance_matrix[new_solution[longest_route][customer_pos-1], customer] +\n                               distance_matrix[customer, new_solution[longest_route][customer_pos+1]] -\n                               distance_matrix[new_solution[longest_route][customer_pos-1], new_solution[longest_route][customer_pos+1]])\n                    new_dist = (distance_matrix[new_solution[shortest_route][-2], customer] +\n                               distance_matrix[customer, 0] -\n                               distance_matrix[new_solution[shortest_route][-2], 0])\n                    if old_dist > new_dist:\n                        new_solution[shortest_route] = np.concatenate((new_solution[shortest_route][:-1], [customer], [0]))\n                        new_solution[longest_route] = np.concatenate((new_solution[longest_route][:customer_pos], new_solution[longest_route][customer_pos+1:]))\n                        break\n\n        # Step 3: Demand-aware reshuffling\n        if len(new_solution) > 2:\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n            demand1, demand2 = np.sum(demand[route1[1:-1]]), np.sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > 0.2 * capacity:\n                for split1 in range(1, len(route1)-1):\n                    for split2 in range(1, len(route2)-1):\n                        part1 = route1[1:split1]\n                        part2 = route2[1:split2]\n                        new_demand1 = demand1 - np.sum(demand[part1]) + np.sum(demand[part2])\n                        new_demand2 = demand2 - np.sum(demand[part2]) + np.sum(demand[part1])\n                        if (new_demand1 <= capacity and new_demand2 <= capacity and\n                            abs(new_demand1 - new_demand2) < abs(demand1 - demand2)):\n                            new_route1 = np.concatenate(([0], part1, route2[split2:-1], route1[split1:-1], [0]))\n                            new_route2 = np.concatenate(([0], part2, route1[split1:-1], route2[split2:-1], [0]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                    else:\n                        continue\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7904515528208966,
            0.8658688962459564
        ],
        "raw_score": [
            58.1234035683554,
            7.636296895092969
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the best makespan from the archive and applies a hybrid local search combining route merging, 2-opt, and demand-based customer reinsertion to reduce both total distance and makespan while ensuring feasibility. It prioritizes high-demand customers and route merging when feasible, followed by 2-opt for local optimization, and finally reinserts unassigned customers into the longest route to balance makespan. The solution ensures capacity constraints are never violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge (if feasible)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible in terms of capacity\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes (excluding depots)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Step 2: Apply 2-opt on a randomly selected route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depots\n        if len(route) >= 2:\n            i, j = sorted(random.sample(range(len(route)), 2))\n            # Reverse the segment between i and j\n            new_segment = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Step 3: Reinsert high-demand customers to balance routes\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Find the route with the highest makespan\n        makespans = [sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution]\n        target_route_idx = np.argmax(makespans)\n        target_route = new_solution[target_route_idx]\n\n        # Try to insert unassigned customers with highest demand first\n        unassigned_customers.sort(key=lambda x: -demand[x])\n        for customer in unassigned_customers:\n            best_pos = -1\n            best_increase = float('inf')\n\n            # Find the best insertion position in the target route\n            for i in range(len(target_route) - 1):\n                # Check capacity constraint\n                current_demand = sum(demand[target_route[1:-1]])\n                if current_demand + demand[customer] <= capacity:\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[target_route[i], customer] +\n                                    distance_matrix[customer, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.2571794216643792,
            0.4204300045967102
        ],
        "raw_score": [
            31.856981161376098,
            3.5915282607247287
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined total distance and makespan from the archive, then applies a hybrid local search that fragments routes, shuffles customers, and rebuilds routes while respecting capacity constraints, prioritizing the most promising solutions for improvement. The key design ideas are: (1) intelligent solution selection based on aggregated objective values, and (2) a capacity-aware route reconstruction strategy that ensures feasibility while introducing randomness for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: route fragmentation + customer reinsertion\n    new_solution = []\n    all_customers = []\n\n    # Collect all customers from all routes\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])  # Exclude depot\n\n    # Shuffle customers for randomness\n    random.shuffle(all_customers)\n\n    # Rebuild routes with capacity checks\n    current_route = [0]\n    current_load = 0\n\n    for customer in all_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # If no routes were created (edge case), return original\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6697742146086336,
            0.45303669571876526
        ],
        "raw_score": [
            51.746525783600006,
            6.140857876814449
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the best total distance from the archive and applies a hybrid local search combining route splitting (based on demand imbalance), a novel cluster-based 2-opt (optimizing spatial proximity), and demand-based customer relocation between routes (balancing vehicle loads). It prioritizes reducing makespan by splitting overloaded routes and improving total distance through spatial-aware optimizations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route Splitting based on demand imbalance\n    if len(new_solution) > 0:\n        # Find the route with the highest demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        target_route_idx = np.argmax(demands)\n        target_route = new_solution[target_route_idx]\n\n        # Find the customer with the highest demand in this route\n        customers = target_route[1:-1]\n        if len(customers) > 0:\n            customer_demands = [(c, demand[c]) for c in customers]\n            customer_demands.sort(key=lambda x: -x[1])\n            split_customer = customer_demands[0][0]\n\n            # Split the route at this customer\n            split_idx = np.where(target_route == split_customer)[0][0]\n            new_route1 = np.concatenate([target_route[:split_idx+1], [0]])\n            new_route2 = np.concatenate([[0], target_route[split_idx:]])\n\n            # Replace the original route with the two new routes\n            new_solution.pop(target_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    # Step 2: Cluster-based 2-opt (considering spatial proximity)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depots\n\n        if len(route) >= 2:\n            # Find two customers that are close in space but not necessarily adjacent\n            customer_coords = coords[route]\n            distances = np.linalg.norm(customer_coords[:, np.newaxis, :] - customer_coords[np.newaxis, :, :], axis=2)\n            np.fill_diagonal(distances, np.inf)\n            i, j = np.unravel_index(np.argmin(distances), distances.shape)\n\n            # Ensure i < j for proper segment reversal\n            if i > j:\n                i, j = j, i\n\n            # Reverse the segment between i and j\n            new_segment = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Step 3: Demand-based customer relocation between routes\n    if len(new_solution) > 1:\n        # Find the two most imbalanced routes\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = np.argsort(demands)\n        source_route_idx = sorted_indices[-1]  # Most loaded route\n        target_route_idx = sorted_indices[0]  # Least loaded route\n\n        source_route = new_solution[source_route_idx]\n        target_route = new_solution[target_route_idx]\n\n        # Find the customer with the highest demand in the source route\n        customers = source_route[1:-1]\n        if len(customers) > 0:\n            customer_demands = [(c, demand[c]) for c in customers]\n            customer_demands.sort(key=lambda x: -x[1])\n            customer_to_move = customer_demands[0][0]\n\n            # Check if moving this customer to the target route is feasible\n            source_demand = sum(demand[source_route[1:-1]])\n            target_demand = sum(demand[target_route[1:-1]])\n            if target_demand + demand[customer_to_move] <= capacity:\n                # Remove customer from source route\n                mask = source_route != customer_to_move\n                new_source_route = source_route[mask]\n\n                # Insert customer into target route at the best position\n                best_pos = -1\n                best_increase = float('inf')\n\n                for i in range(len(target_route) - 1):\n                    dist_increase = (distance_matrix[target_route[i], customer_to_move] +\n                                    distance_matrix[customer_to_move, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = i + 1\n\n                if best_pos != -1:\n                    new_target_route = np.insert(target_route, best_pos, customer_to_move)\n                    new_solution[source_route_idx] = new_source_route\n                    new_solution[target_route_idx] = new_target_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7196664685669433,
            0.6482102572917938
        ],
        "raw_score": [
            57.69770042862447,
            7.714377659263765
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = len(archive) // 2  # Select a middle solution to promote diversity\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route reshaping: dynamically reshape a route by removing and reinserting segments\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:  # Ensure the route has enough customers to reshape\n            # Randomly select a segment to remove and reinsert\n            start_pos = random.randint(1, len(selected_route) - 3)\n            end_pos = random.randint(start_pos + 1, len(selected_route) - 2)\n            removed_segment = selected_route[start_pos:end_pos + 1]\n            remaining_route = np.concatenate([selected_route[:start_pos], selected_route[end_pos + 1:]])\n\n            # Try to reinsert the segment into a different position in the same route\n            best_pos = -1\n            best_increase = float('inf')\n\n            for i in range(len(remaining_route) - 1):\n                # Calculate the increase in distance\n                dist_increase = (distance_matrix[remaining_route[i], removed_segment[0]] +\n                                distance_matrix[removed_segment[-1], remaining_route[i+1]] -\n                                distance_matrix[remaining_route[i], remaining_route[i+1]])\n                if dist_increase < best_increase:\n                    best_increase = dist_increase\n                    best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(remaining_route, best_pos, removed_segment)\n                new_solution[route_idx] = new_route\n\n    # Demand-aware customer reallocation: reassign customers based on demand and spatial proximity\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Sort customers by demand in descending order\n        unassigned_customers.sort(key=lambda x: -demand[x])\n\n        for customer in unassigned_customers:\n            best_route = -1\n            best_pos = -1\n            best_increase = float('inf')\n\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                current_demand = sum(demand[route[1:-1]])\n\n                if current_demand + demand[customer] <= capacity:\n                    for i in range(len(route) - 1):\n                        # Calculate the increase in distance\n                        dist_increase = (distance_matrix[route[i], customer] +\n                                        distance_matrix[customer, route[i+1]] -\n                                        distance_matrix[route[i], route[i+1]])\n                        if dist_increase < best_increase:\n                            best_increase = dist_increase\n                            best_route = route_idx\n                            best_pos = i + 1\n\n            if best_route != -1:\n                new_route = np.insert(new_solution[best_route], best_pos, customer)\n                new_solution[best_route] = new_route\n\n    # Ensure the solution remains feasible\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5508758633378769,
            0.6243339776992798
        ],
        "raw_score": [
            49.4207769627197,
            6.346335107487226
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower makespan and total distance for selection, then applies a hybrid local search combining route merging (to reduce makespan) and demand-aware 2-opt (to improve distance), ensuring feasibility by checking vehicle capacity constraints. It intelligently selects segments for merging and 2-opt operations while reverting infeasible moves to maintain solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive_sorted) // 4)])\n    base_solution = selected_solution[0].copy()\n\n    # Hybrid local search: route merging + demand-aware 2-opt\n    new_solution = base_solution.copy()\n\n    # Step 1: Try route merging if possible (reduce makespan)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by connecting them with shortest possible edges\n            best_merge = None\n            min_dist = float('inf')\n\n            for x in range(1, len(route1)):\n                for y in range(1, len(route2)):\n                    d = distance_matrix[route1[x-1], route2[y]] + distance_matrix[route2[y-1], route1[x]]\n                    if d < min_dist:\n                        min_dist = d\n                        best_merge = (x, y)\n\n            if best_merge:\n                x, y = best_merge\n                merged_route = np.concatenate((route1[:x], route2[y:], route2[:y], route1[x:]))\n                new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}]\n                new_solution.append(merged_route)\n\n    # Step 2: Demand-aware 2-opt within routes\n    for route in new_solution:\n        if len(route) > 4:  # Only apply if route has enough nodes\n            # Select two non-adjacent edges\n            a, b = sorted(random.sample(range(1, len(route)-1), 2))\n            # Ensure demand feasibility\n            segment_demand = np.sum(demand[route[a:b+1]])\n            if segment_demand <= capacity:\n                # Reverse the segment\n                new_segment = route[a:b+1][::-1]\n                new_route = np.concatenate((route[:a], new_segment, route[b+1:]))\n                # Update the route\n                route[:] = new_route\n\n    # Ensure solution is feasible (demand constraints)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route (simplistic repair)\n            route[:] = base_solution[new_solution.index(route)]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4524271597100099,
            0.6444624364376068
        ],
        "raw_score": [
            51.786903598656494,
            6.098746605742892
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution by total distance, then applies three sequential steps: adaptive route splitting to balance demand, demand-aware 2-opt with weighted segment selection to reduce distance, and adaptive customer reinsertion targeting high-demand-variance routes to improve both objectives while maintaining feasibility. The method prioritizes capacity-balanced adjustments and minimizes makespan by focusing on routes with demand imbalance, using demand-to-distance ratios for intelligent reinsertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Adaptive route splitting based on demand imbalance\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        customers = route[1:-1]\n        total_demand = sum(demand[customers])\n\n        if len(customers) > 2 and total_demand > capacity * 0.7:\n            # Split route at the point with minimal demand imbalance\n            best_split = 0\n            min_imbalance = float('inf')\n\n            for i in range(1, len(customers)):\n                demand_left = sum(demand[customers[:i]])\n                demand_right = sum(demand[customers[i:]])\n                imbalance = abs(demand_left - demand_right)\n\n                if imbalance < min_imbalance:\n                    min_imbalance = imbalance\n                    best_split = i\n\n            if best_split > 0:\n                route1 = np.concatenate([[0], customers[:best_split], [0]])\n                route2 = np.concatenate([[0], customers[best_split:], [0]])\n                new_solution[route_idx] = route1\n                new_solution.append(route2)\n\n    # Step 2: Demand-aware 2-opt with distance optimization\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        customers = route[1:-1]\n\n        if len(customers) >= 2:\n            # Select segments with high demand density\n            segment_lengths = [distance_matrix[customers[i], customers[i+1]] for i in range(len(customers)-1)]\n            segment_demands = [demand[customers[i]] for i in range(len(customers)-1)]\n            segment_scores = [segment_lengths[i] / (segment_demands[i] + 1e-6) for i in range(len(segment_lengths))]\n\n            if sum(segment_scores) > 0:\n                # Weighted selection of segments to reverse\n                i, j = sorted(random.choices(range(len(customers)-1), weights=segment_scores, k=2))\n                new_segment = np.concatenate([customers[:i], customers[i:j+1][::-1], customers[j+1:]])\n                new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Step 3: Adaptive customer reinsertion based on route balance\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Find routes with highest demand variance\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        mean_demand = sum(route_demands) / len(route_demands)\n        demand_variances = [(d - mean_demand)**2 for d in route_demands]\n        target_route_idx = np.argmax(demand_variances)\n        target_route = new_solution[target_route_idx]\n\n        # Sort customers by demand-to-distance ratio\n        customer_scores = []\n        for customer in unassigned_customers:\n            avg_dist = np.mean(distance_matrix[customer, target_route[1:-1]])\n            score = demand[customer] / (avg_dist + 1e-6)\n            customer_scores.append(score)\n\n        # Insert customers in order of highest score\n        sorted_customers = [x for _, x in sorted(zip(customer_scores, unassigned_customers), reverse=True)]\n        for customer in sorted_customers:\n            best_pos = -1\n            best_score = -float('inf')\n\n            for i in range(len(target_route) - 1):\n                current_demand = sum(demand[target_route[1:-1]])\n                if current_demand + demand[customer] <= capacity:\n                    dist_increase = (distance_matrix[target_route[i], customer] +\n                                    distance_matrix[customer, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n                    score = -dist_increase / (demand[customer] + 1e-6)  # Higher score is better\n\n                    if score > best_score:\n                        best_score = score\n                        best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4096794987410186,
            0.6887021064758301
        ],
        "raw_score": [
            41.40723710697507,
            3.9541774631603355
        ]
    }
]