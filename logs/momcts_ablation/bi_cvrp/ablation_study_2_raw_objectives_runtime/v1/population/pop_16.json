[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and a novel \"route reshuffling\" operator to balance the two objectives while ensuring feasibility. It intelligently selects customers for reinsertion and reshuffles routes to reduce makespan differences, focusing on capacity constraints and objective trade-offs. The process ensures feasibility at each step while targeting both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route merging (if possible) to reduce makespan\n    if len(selected_solution) > 1:\n        merged_routes = []\n        for route in selected_solution:\n            if not merged_routes or np.sum(demand[route[1:-1]]) + np.sum(demand[merged_routes[-1][1:-1]]) <= capacity:\n                if merged_routes:\n                    merged_route = np.concatenate((merged_routes[-1][:-1], route[1:]))\n                    merged_routes[-1] = merged_route\n                else:\n                    merged_routes.append(route)\n            else:\n                merged_routes.append(route)\n        selected_solution = merged_routes\n\n    # Step 2: Customer reinsertion with capacity constraints\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        candidates = route[1:-1]\n        if len(candidates) == 0:\n            new_solution.append(route)\n            continue\n\n        removed_customer = np.random.choice(candidates)\n        remaining_route = route[route != removed_customer]\n\n        # Find best insertion position in existing routes\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, r in enumerate(new_solution):\n            for pos in range(1, len(r)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate((r[1:pos], [removed_customer], r[pos:-1]))]) <= capacity:\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[r[pos-1], removed_customer] +\n                                   distance_matrix[removed_customer, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insertion = (i, pos)\n\n        if best_insertion:\n            i, pos = best_insertion\n            new_route = np.concatenate((new_solution[i][:pos], [removed_customer], new_solution[i][pos:]))\n            new_solution[i] = new_route\n        else:\n            # If no valid insertion found, create new route\n            new_solution.append(np.array([0, removed_customer, 0]))\n\n    # Step 3: Route reshuffling (novel operator) to balance objectives\n    if len(new_solution) > 1:\n        # Select two routes to reshuffle\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Find best split points for both routes\n        best_split = None\n        min_diff = float('inf')\n\n        for split1 in range(1, len(new_solution[idx1])-1):\n            for split2 in range(1, len(new_solution[idx2])-1):\n                # Check capacity constraints for both new routes\n                if (np.sum(demand[new_solution[idx1][1:split1]]) <= capacity and\n                    np.sum(demand[new_solution[idx1][split1:-1]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][1:split2]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][split2:-1]]) <= capacity):\n\n                    # Calculate makespan difference after reshuffling\n                    current_makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n                    new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n                    new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n                    new_makespan1 = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                    new_makespan2 = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n\n                    diff = abs(new_makespan1 - new_makespan2)\n                    if diff < min_diff:\n                        min_diff = diff\n                        best_split = (split1, split2)\n\n        if best_split:\n            split1, split2 = best_split\n            new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n            new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n            new_solution[idx1] = new_route1\n            new_solution[idx2] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8234625192972875,
            2.7163036167621613
        ],
        "raw_score": [
            58.1689844298665,
            7.7370092861205855
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (prioritizing makespan over distance) and applies a hybrid local search combining route splitting (for demand imbalance), customer relocation (to balance makespan), and demand-aware reshuffling (to swap route segments while maintaining capacity constraints). It focuses on reducing makespan by 10% and demand imbalance by 20% of capacity thresholds, ensuring feasibility through rigorous demand checks. The weighted selection (0.4 distance, 0.6 makespan) balances exploration of diverse solutions while the hybrid operators target both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Balance between distance and makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Try to split a route with high demand imbalance\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    second_part_demand = total_demand - first_part_demand\n                    if abs(first_part_demand - second_part_demand) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Relocate customers to balance makespan\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        longest_route = np.argmax(makespans)\n        shortest_route = np.argmin(makespans)\n\n        if makespans[longest_route] - makespans[shortest_route] > 0.1 * np.mean(makespans):\n            for customer_pos in range(1, len(new_solution[longest_route])-1):\n                customer = new_solution[longest_route][customer_pos]\n                if (np.sum(demand[new_solution[shortest_route][1:-1]]) + demand[customer] <= capacity and\n                    len(new_solution[shortest_route]) < len(new_solution[longest_route])):\n                    # Calculate potential makespan improvement\n                    old_dist = (distance_matrix[new_solution[longest_route][customer_pos-1], customer] +\n                               distance_matrix[customer, new_solution[longest_route][customer_pos+1]] -\n                               distance_matrix[new_solution[longest_route][customer_pos-1], new_solution[longest_route][customer_pos+1]])\n                    new_dist = (distance_matrix[new_solution[shortest_route][-2], customer] +\n                               distance_matrix[customer, 0] -\n                               distance_matrix[new_solution[shortest_route][-2], 0])\n                    if old_dist > new_dist:\n                        new_solution[shortest_route] = np.concatenate((new_solution[shortest_route][:-1], [customer], [0]))\n                        new_solution[longest_route] = np.concatenate((new_solution[longest_route][:customer_pos], new_solution[longest_route][customer_pos+1:]))\n                        break\n\n        # Step 3: Demand-aware reshuffling\n        if len(new_solution) > 2:\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n            demand1, demand2 = np.sum(demand[route1[1:-1]]), np.sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > 0.2 * capacity:\n                for split1 in range(1, len(route1)-1):\n                    for split2 in range(1, len(route2)-1):\n                        part1 = route1[1:split1]\n                        part2 = route2[1:split2]\n                        new_demand1 = demand1 - np.sum(demand[part1]) + np.sum(demand[part2])\n                        new_demand2 = demand2 - np.sum(demand[part2]) + np.sum(demand[part1])\n                        if (new_demand1 <= capacity and new_demand2 <= capacity and\n                            abs(new_demand1 - new_demand2) < abs(demand1 - demand2)):\n                            new_route1 = np.concatenate(([0], part1, route2[split2:-1], route1[split1:-1], [0]))\n                            new_route2 = np.concatenate(([0], part2, route1[split1:-1], route2[split2:-1], [0]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                    else:\n                        continue\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7904515528208966,
            0.8658688962459564
        ],
        "raw_score": [
            58.1234035683554,
            7.636296895092969
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7626046040934145,
            0.21666795015335083
        ],
        "raw_score": [
            57.38218004043512,
            7.516075889345629
        ]
    },
    {
        "algorithm": "This algorithm selects a solution from the archive based on a weighted combination of distance and makespan objectives, then applies a hybrid local search combining route reshaping (with demand-aware segment relocation), demand-aware customer reallocation (using spatial clustering), and route merging (for balanced demand pairs) to improve both objectives while maintaining feasibility. The method prioritizes distance reduction (60% weight) over balanced routes (40%) in reshaping and considers spatial proximity (50%) alongside distance in customer insertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])  # More weight on distance\n    selected_idx = min(len(archive) // 3, len(archive) - 1)  # Select a better solution\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route reshaping with demand consideration\n    if len(new_solution) > 1:\n        route_idx = random.choice(range(len(new_solution)))\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Select a segment based on demand density\n            demands = demand[selected_route[1:-1]]\n            segment_length = min(3, len(selected_route) - 2)\n            segment_start = random.randint(1, len(selected_route) - 1 - segment_length)\n            segment_end = segment_start + segment_length\n            removed_segment = selected_route[segment_start:segment_end]\n\n            # Calculate demand of the segment\n            segment_demand = sum(demands[segment_start - 1:segment_end - 1])\n\n            # Find best insertion point considering both distance and demand balance\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(selected_route) - 1):\n                if i not in range(segment_start - 1, segment_end):\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[selected_route[i], removed_segment[0]] +\n                                   distance_matrix[removed_segment[-1], selected_route[i+1]] -\n                                   distance_matrix[selected_route[i], selected_route[i+1]])\n\n                    # Calculate demand balance improvement\n                    current_demand = sum(demand[selected_route[1:-1]])\n                    new_demand = current_demand - segment_demand\n                    balance_score = abs(new_demand - capacity / 2)  # Prefer balanced routes\n\n                    # Combined score\n                    score = 0.6 * dist_increase + 0.4 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(selected_route, best_pos, removed_segment)\n                new_solution[route_idx] = new_route\n\n    # Demand-aware customer reallocation with spatial clustering\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Cluster customers based on spatial proximity and demand\n        clusters = []\n        for customer in unassigned_customers:\n            assigned = False\n            for cluster in clusters:\n                # Check if customer is close to any member of the cluster\n                for member in cluster:\n                    if distance_matrix[customer, member] < 1.5 * np.mean(distance_matrix):\n                        cluster.append(customer)\n                        assigned = True\n                        break\n                if assigned:\n                    break\n            if not assigned:\n                clusters.append([customer])\n\n        for cluster in clusters:\n            # Sort customers in cluster by demand (descending)\n            cluster.sort(key=lambda x: -demand[x])\n\n            for customer in cluster:\n                best_route = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for route_idx in range(len(new_solution)):\n                    route = new_solution[route_idx]\n                    current_demand = sum(demand[route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        for i in range(len(route) - 1):\n                            # Calculate distance increase\n                            dist_increase = (distance_matrix[route[i], customer] +\n                                           distance_matrix[customer, route[i+1]] -\n                                           distance_matrix[route[i], route[i+1]])\n\n                            # Calculate spatial proximity to existing customers\n                            spatial_score = np.mean([distance_matrix[customer, c] for c in route[1:-1]])\n\n                            # Combined score\n                            score = 0.5 * dist_increase + 0.5 * spatial_score\n\n                            if score < best_score:\n                                best_score = score\n                                best_route = route_idx\n                                best_pos = i + 1\n\n                if best_route != -1:\n                    new_route = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[best_route] = new_route\n\n    # Route merging to reduce makespan\n    if len(new_solution) > 2:\n        # Find two routes with similar demands\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        min_diff = float('inf')\n        merge_pair = (-1, -1)\n\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                diff = abs(route_demands[i] - route_demands[j])\n                if diff < min_diff and route_demands[i] + route_demands[j] <= capacity:\n                    min_diff = diff\n                    merge_pair = (i, j)\n\n        if merge_pair != (-1, -1):\n            route1, route2 = new_solution[merge_pair[0]], new_solution[merge_pair[1]]\n\n            # Calculate best merge point\n            best_pos = -1\n            best_increase = float('inf')\n\n            for i in range(len(route1) - 1):\n                for j in range(len(route2) - 1):\n                    # Calculate distance increase for merging at these points\n                    dist_increase = (distance_matrix[route1[i], route2[1]] +\n                                   distance_matrix[route2[-2], route1[i+1]] -\n                                   distance_matrix[route1[i], route1[i+1]] -\n                                   distance_matrix[route2[-2], route2[-1]])\n\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = (i, j)\n\n            if best_pos != -1:\n                # Merge the routes\n                merged_route = np.concatenate([\n                    route1[:best_pos[0] + 1],\n                    route2[1:-1],\n                    route1[best_pos[0] + 1:]\n                ])\n                new_solution = [route for idx, route in enumerate(new_solution)\n                              if idx not in merge_pair] + [merged_route]\n\n    # Ensure the solution remains feasible\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7688276850363361,
            0.5797156393527985
        ],
        "raw_score": [
            57.84734696647112,
            7.624469138800522
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using crowding distance to prioritize diverse solutions, then applies a hybrid local search with dynamic operator selection (angle-based reshuffling, demand swaps, route splitting, and customer relocation) to improve both total distance and makespan while maintaining feasibility. The operators are chosen probabilistically, with angle-based and demand-swap operations weighted higher for their balance between objectives, while route splitting and customer relocation serve as fallback strategies for more aggressive improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    crowding_distances = []\n    for i in range(len(archive)):\n        left = archive[i-1][1] if i > 0 else None\n        right = archive[(i+1)%len(archive)][1] if i < len(archive)-1 else None\n        if left and right:\n            dist = 0\n            for obj in range(2):\n                if left[obj] != right[obj]:\n                    dist += abs(archive[i][1][obj] - left[obj]) / (right[obj] - left[obj])\n            crowding_distances.append(dist)\n        else:\n            crowding_distances.append(float('inf'))\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search with dynamic operator selection\n    if len(new_solution) > 1:\n        # Calculate current objective values\n        current_distances = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        current_total = sum(current_distances)\n        current_makespan = max(current_distances)\n        avg_distance = np.mean(current_distances)\n\n        # Dynamic operator selection\n        operator = random.choices(\n            ['angle_based', 'demand_swap', 'route_split', 'customer_relocate'],\n            weights=[0.4, 0.4, 0.15, 0.05],\n            k=1\n        )[0]\n\n        if operator == 'angle_based':\n            # Angle-based route reshuffling to reduce makespan\n            longest_route = np.argmax(current_distances)\n            route = new_solution[longest_route]\n            if len(route) > 3:\n                # Calculate angles between consecutive segments\n                angles = []\n                for i in range(1, len(route)-2):\n                    vec1 = coords[route[i]] - coords[route[i-1]]\n                    vec2 = coords[route[i+1]] - coords[route[i]]\n                    angle = np.arctan2(vec2[1], vec2[0]) - np.arctan2(vec1[1], vec1[0])\n                    angle = np.abs(angle) if np.abs(angle) <= np.pi else 2*np.pi - np.abs(angle)\n                    angles.append(angle)\n\n                if angles:\n                    # Find segment with largest angle (potential for improvement)\n                    max_angle_idx = np.argmax(angles)\n                    customer = route[max_angle_idx+1]\n\n                    # Try to relocate this customer to another route\n                    for other_route_idx in range(len(new_solution)):\n                        if other_route_idx == longest_route:\n                            continue\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate potential makespan improvement\n                            old_length = current_distances[longest_route]\n                            new_length = (distance_matrix[route[max_angle_idx], route[max_angle_idx+2]] -\n                                         distance_matrix[route[max_angle_idx], route[max_angle_idx+1]] -\n                                         distance_matrix[route[max_angle_idx+1], route[max_angle_idx+2]])\n\n                            if new_length < old_length:\n                                # Perform the relocation\n                                new_solution[longest_route] = np.concatenate([\n                                    route[:max_angle_idx+1], route[max_angle_idx+2:]\n                                ])\n                                new_solution[other_route_idx] = np.concatenate([\n                                    other_route[:-1], [customer], [0]\n                                ])\n                                break\n\n        elif operator == 'demand_swap':\n            # Capacity-constrained demand swap to reduce total distance\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > 0.1 * capacity:\n                # Find best pair of customers to swap\n                best_swap = None\n                best_improvement = 0\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        if (demand[route1[i]] <= capacity - demand1 + demand[route2[j]] and\n                            demand[route2[j]] <= capacity - demand2 + demand[route1[i]]):\n                            # Calculate potential distance improvement\n                            improvement = (\n                                distance_matrix[route1[i-1], route1[i]] + distance_matrix[route1[i], route1[i+1]] +\n                                distance_matrix[route2[j-1], route2[j]] + distance_matrix[route2[j], route2[j+1]] -\n                                distance_matrix[route1[i-1], route2[j]] - distance_matrix[route2[j], route1[i+1]] -\n                                distance_matrix[route2[j-1], route1[i]] - distance_matrix[route1[i], route2[j+1]]\n                            )\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_swap = (i, j)\n\n                if best_swap and best_improvement > 0:\n                    i, j = best_swap\n                    # Perform the swap\n                    route1[i], route2[j] = route2[j], route1[i]\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n        elif operator == 'route_split':\n            # Route splitting to balance makespan\n            longest_route = np.argmax(current_distances)\n            route = new_solution[longest_route]\n            if len(route) > 4:\n                # Find split point that balances demands\n                total_demand = np.sum(demand[route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route)-1):\n                    current_demand += demand[route[i]]\n                    if abs(current_demand - target_demand) < abs(target_demand - np.sum(demand[route[1:split_pos]])):\n                        split_pos = i\n\n                if 1 < split_pos < len(route)-2:\n                    first_part = route[:split_pos+1]\n                    second_part = route[split_pos:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n                        new_solution[longest_route] = first_part\n                        new_solution.insert(longest_route+1, second_part)\n\n        elif operator == 'customer_relocate':\n            # Customer relocation to reduce makespan\n            longest_route = np.argmax(current_distances)\n            route = new_solution[longest_route]\n            if len(route) > 3:\n                # Find customer with largest angle\n                angles = []\n                for i in range(1, len(route)-2):\n                    vec1 = coords[route[i]] - coords[route[i-1]]\n                    vec2 = coords[route[i+1]] - coords[route[i]]\n                    angle = np.arctan2(vec2[1], vec2[0]) - np.arctan2(vec1[1], vec1[0])\n                    angle = np.abs(angle) if np.abs(angle) <= np.pi else 2*np.pi - np.abs(angle)\n                    angles.append(angle)\n\n                if angles:\n                    max_angle_idx = np.argmax(angles)\n                    customer = route[max_angle_idx+1]\n\n                    # Try to relocate to a new route\n                    new_route = np.array([0, customer, 0])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[longest_route] = np.concatenate([\n                            route[:max_angle_idx+1], route[max_angle_idx+2:]\n                        ])\n                        new_solution.append(new_route)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7957147801422388,
            0.9144929647445679
        ],
        "raw_score": [
            41.460641230193346,
            4.892238342966191
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive route merging (prioritizing shorter routes with dynamic thresholds) and demand-balanced customer reinsertion (targeting imbalanced routes) to improve both total distance and makespan, while respecting capacity constraints. It intelligently selects solutions from the archive based on diversity and applies capacity-aware transformations to generate neighbors. The method balances exploration (diversity-based selection) with exploitation (capacity-constrained improvements), making it effective for bi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity-aware selection probability\n        objectives = np.array([sol[1] for sol in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        diversity = np.mean(normalized, axis=1)\n        selection_probs = diversity / np.sum(diversity)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route merging with capacity constraints\n    if len(new_solution) > 1:\n        # Calculate route metrics\n        route_lengths = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        route_demands = [np.sum(demand[r[1:-1]]) for r in new_solution]\n\n        # Dynamic threshold for merging\n        avg_length = np.mean(route_lengths)\n        threshold = avg_length * 0.85\n\n        for i in range(len(new_solution)):\n            if route_lengths[i] < threshold:\n                continue\n\n            # Find best merge candidate\n            best_candidate = -1\n            best_improvement = 0\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                combined_demand = route_demands[i] + route_demands[j]\n                if combined_demand > capacity:\n                    continue\n\n                # Calculate potential improvement\n                direct_dist = distance_matrix[new_solution[i][-2], new_solution[j][1]]\n                current_dist = (distance_matrix[new_solution[i][-2], 0] +\n                               distance_matrix[0, new_solution[j][1]])\n                improvement = current_dist - direct_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_candidate = j\n\n            if best_candidate != -1 and best_improvement > 0:\n                # Perform merge\n                merged_route = np.concatenate((new_solution[i][:-1], new_solution[best_candidate][1:]))\n                new_solution[i] = merged_route\n                del new_solution[best_candidate]\n                break\n\n    # Demand-balanced customer reinsertion\n    if len(new_solution) > 1:\n        # Calculate route balance metrics\n        route_demands = [np.sum(demand[r[1:-1]]) for r in new_solution]\n        avg_demand = np.mean(route_demands)\n        imbalance = np.max(np.abs(route_demands - avg_demand)) / capacity\n\n        if imbalance > 0.3:\n            # Select route with highest imbalance\n            target_route = np.argmax(np.abs(route_demands - avg_demand))\n            route = new_solution[target_route]\n\n            # Find best customer to reinsert\n            best_improvement = 0\n            best_customer = -1\n            best_position = -1\n            best_target_route = -1\n\n            for customer_pos in range(1, len(route)-1):\n                customer = route[customer_pos]\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx == target_route:\n                        continue\n                    other_route = new_solution[other_route_idx]\n\n                    # Try inserting at different positions\n                    for insert_pos in range(1, len(other_route)):\n                        # Check capacity constraint\n                        if np.sum(demand[other_route[1:insert_pos]]) + demand[customer] > capacity:\n                            continue\n\n                        # Calculate improvement\n                        old_dist = (distance_matrix[route[customer_pos-1], customer] +\n                                  distance_matrix[customer, route[customer_pos+1]] -\n                                  distance_matrix[route[customer_pos-1], route[customer_pos+1]])\n                        new_dist = (distance_matrix[route[customer_pos-1], route[customer_pos+1]] +\n                                  distance_matrix[other_route[insert_pos-1], customer] +\n                                  distance_matrix[customer, other_route[insert_pos]] -\n                                  distance_matrix[other_route[insert_pos-1], other_route[insert_pos]])\n\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_customer = customer\n                            best_position = insert_pos\n                            best_target_route = other_route_idx\n\n            if best_customer != -1:\n                # Perform reinsertion\n                customer_pos = np.where(new_solution[target_route] == best_customer)[0][0]\n                new_solution[target_route] = np.concatenate((\n                    new_solution[target_route][:customer_pos],\n                    new_solution[target_route][customer_pos+1:]\n                ))\n                new_solution[best_target_route] = np.concatenate((\n                    new_solution[best_target_route][:best_position],\n                    [best_customer],\n                    new_solution[best_target_route][best_position:]\n                ))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7927766622914861,
            5.863483548164368
        ],
        "raw_score": [
            57.037891184942424,
            7.554004018567903
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive with a weighted preference for lower total distance (50%) over makespan (50%), then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-adaptive swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations when standard improvements fail, always enforcing capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.5, 0.5)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to split the route into two\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 2: If splitting fails, try to relocate a customer to another route\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_pos)\n\n                            new_solution[route_idx] = route\n                            new_solution[other_route_idx] = other_route\n                            break\n                else:\n                    # Step 3: If relocation fails, try a capacity-adaptive swap\n                    for i in range(1, len(route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[route[1:-1]]) + demand[route[i]]):\n                                        old_dist = (distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][other_route[j]] + distance_matrix[other_route[j]][other_route[j+1]])\n                                        new_dist = (distance_matrix[route[i-1]][other_route[j]] + distance_matrix[other_route[j]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][route[i]] + distance_matrix[route[i]][other_route[j+1]])\n\n                                        if new_dist < old_dist:\n                                            route[i], other_route[j] = other_route[j], route[i]\n                                            new_solution[route_idx] = route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7039234633235187,
            0.1366652548313141
        ],
        "raw_score": [
            58.0593097506559,
            7.644695851627934
        ]
    },
    {
        "algorithm": "The algorithm selects the most crowded solution from the archive (using Pareto dominance and crowding distance) and applies a hybrid local search combining angle-based route reshuffling, spatial-geometric clustering, and demand-aware customer reallocation to balance both distance and makespan objectives while ensuring feasibility through capacity-constrained transformations. It prioritizes geometric compatibility (angles and distances) over pure distance minimization and uses demand balancing to merge routes, with operators weighted to favor spatial coherence (0.6 angle, 0.4 distance) and merge compatibility (0.5 each). The solution is progressively refined by iteratively applying these operators to the most promising routes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def calculate_crowding_distance(pop):\n        distances = [0] * len(pop)\n        for obj in range(2):\n            sorted_pop = sorted(pop, key=lambda x: x[1][obj])\n            distances[0] = distances[-1] = float('inf')\n            for i in range(1, len(pop)-1):\n                if sorted_pop[-1][1][obj] == sorted_pop[0][1][obj]:\n                    continue\n                distances[i] += (sorted_pop[i+1][1][obj] - sorted_pop[i-1][1][obj]) / (sorted_pop[-1][1][obj] - sorted_pop[0][1][obj])\n        return distances\n\n    crowding = calculate_crowding_distance(archive)\n    selected_idx = max(range(len(archive)), key=lambda i: crowding[i])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search combining multiple operators\n    if len(new_solution) > 1:\n        # Operator 1: Angle-based route reshuffling\n        route_idx = np.random.choice(len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 4:\n            best_angle = -1\n            best_pos = -1\n\n            for i in range(1, len(selected_route)-2):\n                vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                vec2 = coords[selected_route[i+1]] - coords[selected_route[i]]\n                angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                if angle > best_angle:\n                    best_angle = angle\n                    best_pos = i\n\n            if best_pos != -1:\n                # Try to relocate the segment between best_pos and best_pos+1\n                segment = selected_route[best_pos:best_pos+2]\n                remaining_route = np.concatenate((selected_route[:best_pos], selected_route[best_pos+2:]))\n\n                # Find best insertion point in other routes\n                best_insertion = -1\n                best_score = float('inf')\n\n                for r_idx in range(len(new_solution)):\n                    if r_idx != route_idx:\n                        for pos in range(1, len(new_solution[r_idx])):\n                            if np.sum(demand[new_solution[r_idx][1:pos]]) + np.sum(demand[segment[1:-1]]) <= capacity:\n                                dist_increase = (distance_matrix[new_solution[r_idx][pos-1], segment[1]] +\n                                                distance_matrix[segment[-2], new_solution[r_idx][pos]] -\n                                                distance_matrix[new_solution[r_idx][pos-1], new_solution[r_idx][pos]])\n                                if dist_increase < best_score:\n                                    best_score = dist_increase\n                                    best_insertion = (r_idx, pos)\n\n                if best_insertion != -1:\n                    r_idx, pos = best_insertion\n                    new_route = np.concatenate((new_solution[r_idx][:pos], segment, new_solution[r_idx][pos:]))\n                    new_solution[r_idx] = new_route\n                    new_solution[route_idx] = remaining_route\n\n        # Operator 2: Spatial-geometric clustering for customer reallocation\n        all_customers = set()\n        for route in new_solution:\n            all_customers.update(route[1:-1])\n        unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n        if unassigned_customers:\n            clusters = []\n            for customer in unassigned_customers:\n                assigned = False\n                for cluster in clusters:\n                    centroid = np.mean(coords[cluster], axis=0)\n                    if np.linalg.norm(coords[customer] - centroid) < 1.5 * np.mean(distance_matrix):\n                        cluster.append(customer)\n                        assigned = True\n                        break\n                if not assigned:\n                    clusters.append([customer])\n\n            for cluster in clusters:\n                cluster.sort(key=lambda x: -demand[x])\n\n                for customer in cluster:\n                    best_route = -1\n                    best_pos = -1\n                    best_score = float('inf')\n\n                    for r_idx in range(len(new_solution)):\n                        route = new_solution[r_idx]\n                        if np.sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                            for pos in range(1, len(route)):\n                                # Calculate geometric score\n                                vec1 = coords[route[pos-1]] - coords[customer]\n                                vec2 = coords[customer] - coords[route[pos]]\n                                angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n                                dist_increase = (distance_matrix[route[pos-1], customer] +\n                                               distance_matrix[customer, route[pos]] -\n                                               distance_matrix[route[pos-1], route[pos]])\n\n                                score = 0.4 * dist_increase + 0.6 * angle\n\n                                if score < best_score:\n                                    best_score = score\n                                    best_route = r_idx\n                                    best_pos = pos\n\n                    if best_route != -1:\n                        new_route = np.insert(new_solution[best_route], best_pos, customer)\n                        new_solution[best_route] = new_route\n\n        # Operator 3: Demand-aware route merging\n        if len(new_solution) > 2:\n            route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            min_diff = float('inf')\n            merge_pair = (-1, -1)\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    if route_demands[i] + route_demands[j] <= capacity:\n                        diff = abs(route_demands[i] - route_demands[j])\n                        if diff < min_diff:\n                            min_diff = diff\n                            merge_pair = (i, j)\n\n            if merge_pair != (-1, -1):\n                i, j = merge_pair\n                route1, route2 = new_solution[i], new_solution[j]\n\n                # Find best merge point using geometric analysis\n                best_pos = -1\n                best_score = float('inf')\n\n                for pos1 in range(1, len(route1)):\n                    for pos2 in range(1, len(route2)):\n                        # Calculate geometric compatibility\n                        vec1 = coords[route1[pos1-1]] - coords[route2[pos2-1]]\n                        vec2 = coords[route1[pos1]] - coords[route2[pos2]]\n                        angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                        dist_increase = (distance_matrix[route1[pos1-1], route2[pos2]] +\n                                       distance_matrix[route2[pos2-1], route1[pos1]] -\n                                       distance_matrix[route1[pos1-1], route1[pos1]] -\n                                       distance_matrix[route2[pos2-1], route2[pos2]])\n\n                        score = 0.5 * dist_increase + 0.5 * angle\n\n                        if score < best_score:\n                            best_score = score\n                            best_pos = (pos1, pos2)\n\n                if best_pos != -1:\n                    pos1, pos2 = best_pos\n                    merged_route = np.concatenate([\n                        route1[:pos1],\n                        route2[pos2-1:-1],\n                        route1[pos1:]\n                    ])\n                    new_solution = [route for idx, route in enumerate(new_solution)\n                                  if idx not in merge_pair] + [merged_route]\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7663168258283108,
            3.609235018491745
        ],
        "raw_score": [
            58.36200325484635,
            7.84272048955932
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (top 1/3 by objective product), then applies a hybrid local search alternating between demand-aware relocation (prioritizing makespan balance), capacity-constrained segment swaps (for distance optimization), and route merging/splitting (to optimize both objectives). It dynamically adjusts operator weights based on success, reverting to the original solution if capacity constraints are violated. The method prioritizes high-demand customers for relocation and balances demands during splits, while segment swaps focus on distance reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] * x[1][1])  # Sort by product of objectives (trade-off)\n    selected_idx = min(len(archive) // 3, len(archive) - 1)  # Select from top 1/3 solutions\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with dynamic operator selection\n    operators = ['relocation', 'segment_swap', 'merge_split']\n    operator_weights = [0.4, 0.4, 0.2]  # Initial weights\n\n    for _ in range(3):  # Apply multiple operators\n        # Select operator based on weights\n        operator = random.choices(operators, weights=operator_weights, k=1)[0]\n\n        if operator == 'relocation' and len(new_solution) > 1:\n            # Demand-aware customer relocation to balance makespan\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            customers = route[1:-1]\n\n            if len(customers) > 1:\n                # Find customer with highest demand\n                customer = max(customers, key=lambda x: demand[x])\n                pos = np.where(route == customer)[0][0]\n\n                # Try to move to another route\n                for other_idx in range(len(new_solution)):\n                    if other_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_idx]\n                    current_demand = sum(demand[other_route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        # Find best insertion position\n                        best_pos = -1\n                        best_increase = float('inf')\n\n                        for i in range(len(other_route) - 1):\n                            dist_increase = (distance_matrix[other_route[i], customer] +\n                                           distance_matrix[customer, other_route[i+1]] -\n                                           distance_matrix[other_route[i], other_route[i+1]])\n                            if dist_increase < best_increase:\n                                best_increase = dist_increase\n                                best_pos = i + 1\n\n                        if best_pos != -1:\n                            # Perform relocation\n                            new_route = np.insert(other_route, best_pos, customer)\n                            new_solution[other_idx] = new_route\n                            new_solution[route_idx] = np.delete(route, pos)\n                            operator_weights = [0.5, 0.3, 0.2]  # Increase relocation weight\n                            break\n\n        elif operator == 'segment_swap' and len(new_solution) > 1:\n            # Capacity-constrained segment swap for distance optimization\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Select two segments\n                split1 = random.randint(1, len(route) - 3)\n                split2 = random.randint(split1 + 1, len(route) - 2)\n                segment1 = route[split1:split2]\n                segment2 = route[split2:]\n\n                # Check capacity constraints\n                demand1 = sum(demand[segment1])\n                demand2 = sum(demand[segment2])\n\n                if demand1 + demand2 <= capacity:\n                    # Swap segments\n                    new_route = np.concatenate([route[:split1], segment2, segment1, route[:split1]])\n                    new_solution[route_idx] = new_route\n                    operator_weights = [0.3, 0.5, 0.2]  # Increase segment swap weight\n\n        elif operator == 'merge_split':\n            # Route merging/splitting for both objectives\n            if len(new_solution) > 1:\n                # Try to merge two routes\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution.pop(max(route1_idx, route2_idx))\n                    new_solution.pop(min(route1_idx, route2_idx))\n                    new_solution.append(merged_route)\n                    operator_weights = [0.3, 0.2, 0.5]  # Increase merge/split weight\n            else:\n                # Try to split a long route\n                for route_idx in range(len(new_solution)):\n                    route = new_solution[route_idx]\n                    if len(route) > 6:  # Arbitrary threshold for \"long\" route\n                        # Find best split point\n                        best_split = -1\n                        best_balance = float('inf')\n\n                        for i in range(2, len(route) - 2):\n                            demand1 = sum(demand[route[1:i]])\n                            demand2 = sum(demand[route[i:-1]])\n                            balance = abs(demand1 - demand2)\n\n                            if balance < best_balance and demand1 <= capacity and demand2 <= capacity:\n                                best_balance = balance\n                                best_split = i\n\n                        if best_split != -1:\n                            # Split route\n                            new_route1 = np.concatenate([[0], route[1:best_split], [0]])\n                            new_route2 = np.concatenate([[0], route[best_split:-1], [0]])\n                            new_solution[route_idx] = new_route1\n                            new_solution.insert(route_idx + 1, new_route2)\n                            operator_weights = [0.3, 0.2, 0.5]  # Increase merge/split weight\n                            break\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution  # Revert to original if infeasible\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7370865569403737,
            1.2501406967639923
        ],
        "raw_score": [
            50.02551667656539,
            6.201089234807016
        ]
    }
]