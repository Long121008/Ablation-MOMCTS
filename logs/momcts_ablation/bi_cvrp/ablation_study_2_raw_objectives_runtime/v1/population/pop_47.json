[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7626046040934145,
            0.21666795015335083
        ],
        "raw_score": [
            57.38218004043512,
            7.516075889345629
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest makespan from the archive, then reconstructs routes by prioritizing high-demand customers (sorted in descending order) and reinserting them into new routes while respecting vehicle capacity constraints. This strategy aims to balance capacity utilization and reduce makespan by focusing on customers with larger demands first. The overall structure involves route fragmentation and a demand-weighted reinsertion heuristic.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    all_customers = []\n\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n\n    # Sort customers by demand in descending order to prioritize high-demand customers\n    all_customers.sort(key=lambda x: -demand[x])\n\n    current_route = [0]\n    current_load = 0\n\n    for customer in all_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.816960311744704,
            0.4819713830947876
        ],
        "raw_score": [
            58.1186865918592,
            7.76925883811885
        ]
    },
    {
        "algorithm": "This algorithm selects a solution from the archive using a weighted combination of distance (30%) and makespan (70%), then applies a hybrid local search that includes route merging, demand-balanced splitting, and customer reallocation (triggered 60% of the time) to balance makespan while improving total distance. It prioritizes reducing the longest routes and reallocating customers to better utilize vehicle capacity, ensuring feasibility by strictly enforcing capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.3, 0.7)  # 30% distance, 70% makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Identify routes for targeted operations\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        shortest_route_idx = np.argmin(route_lengths)\n\n        # Step 2: Try route merging if feasible\n        if len(new_solution) > 2:\n            # Select two shortest routes for potential merging\n            route1_idx, route2_idx = sorted(range(len(new_solution)), key=lambda i: len(new_solution[i]))[:2]\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n        # Step 3: Demand-balanced route splitting\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand * 0.6  # Target 60% of demand in first part\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(longest_route) - 1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            first_part = longest_route[:split_pos + 1]\n            second_part = longest_route[split_pos:]\n\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = first_part\n                new_solution.insert(longest_route_idx + 1, second_part)\n\n        # Step 4: Customer reallocation with demand balancing\n        if random.random() < 0.6:  # 60% chance to try reallocation\n            # Find route with most excess capacity\n            route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            excess_capacities = [capacity - d for d in route_demands]\n            donor_idx = np.argmax(excess_capacities)\n\n            if excess_capacities[donor_idx] > 0:\n                donor_route = new_solution[donor_idx]\n                # Find customers that can be moved to other routes\n                for i in reversed(range(1, len(donor_route) - 1)):\n                    customer = donor_route[i]\n                    if demand[customer] <= excess_capacities[donor_idx]:\n                        # Find best route to insert this customer\n                        best_route = -1\n                        best_pos = -1\n                        best_improvement = 0\n\n                        for r in range(len(new_solution)):\n                            if r == donor_idx:\n                                continue\n                            route = new_solution[r]\n                            if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                                continue\n\n                            for pos in range(1, len(route)):\n                                # Calculate potential improvement\n                                improvement = (distance_matrix[route[pos-1]][customer] + distance_matrix[customer][route[pos]] -\n                                             distance_matrix[route[pos-1]][route[pos]] +\n                                             distance_matrix[donor_route[i-1]][donor_route[i+1]] -\n                                             distance_matrix[donor_route[i-1]][customer] -\n                                             distance_matrix[customer][donor_route[i+1]])\n\n                                if improvement < best_improvement:\n                                    best_improvement = improvement\n                                    best_route = r\n                                    best_pos = pos\n\n                        if best_route != -1:\n                            # Perform the move\n                            route = new_solution[best_route]\n                            route = np.insert(route, best_pos, customer)\n                            new_solution[best_route] = route\n                            donor_route = np.delete(donor_route, i)\n                            new_solution[donor_idx] = donor_route\n                            break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.8248165757709953,
            0.7335710227489471
        ],
        "raw_score": [
            58.64121823162057,
            7.814322992703525
        ]
    },
    {
        "algorithm": "The algorithm first selects a solution from the archive with high crowding distance (indicating potential for improvement), then applies a hybrid local search combining demand-weighted route splitting to balance makespan and adaptive angle-based edge insertion to optimize distance while maintaining feasibility. The method prioritizes routes with high demand concentration for splitting and evaluates insertion positions based on angular alignment to minimize detours, dynamically adjusting the search based on route length and capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([s[1] for s in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]\n\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Demand-weighted clustering for makespan balancing\n            demand_weights = demand[route[1:-1]]\n            split_pos = np.argmax(demand_weights) + 1\n\n            route1 = np.concatenate((route[:split_pos+1], [0]))\n            route2 = np.concatenate(([0], route[split_pos+1:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Adaptive angle-based edge insertion\n                for i in range(1, len(route)-1):\n                    best_insertion = None\n                    best_angle = -np.inf\n                    for other_route_idx in range(len(new_solution)):\n                        if other_route_idx != route_idx:\n                            other_route = new_solution[other_route_idx]\n                            for j in range(1, len(other_route)):\n                                if j == len(other_route)-1:\n                                    vec1 = coords[other_route[j]] - coords[other_route[j-1]]\n                                    vec2 = coords[route[i]] - coords[other_route[j-1]]\n                                else:\n                                    vec1 = coords[other_route[j]] - coords[other_route[j-1]]\n                                    vec2 = coords[route[i]] - coords[other_route[j-1]]\n                                angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2) + 1e-10))\n\n                                if angle > best_angle and (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] if j < len(other_route)-1 else True):\n                                    best_angle = angle\n                                    best_insertion = (other_route_idx, j)\n\n                    if best_insertion is not None:\n                        other_route_idx, j = best_insertion\n                        other_route = new_solution[other_route_idx]\n                        if j == len(other_route)-1:\n                            other_route = np.concatenate((other_route[:-1], [route[i]], [0]))\n                        else:\n                            other_route = np.concatenate((other_route[:j+1], [route[i]], other_route[j+1:]))\n                        new_solution[other_route_idx] = other_route\n                        route = np.concatenate((route[:i], route[i+1:]))\n                        new_solution[route_idx] = route\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.8229435262529914,
            0.6118530929088593
        ],
        "raw_score": [
            57.01996069181728,
            7.531724241765126
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted preference (70% distance, 30% makespan) and applies a hybrid local search that first tries to split the longest route, then performs demand-aware relocations, and finally attempts capacity-balancing swaps to improve both objectives while maintaining feasibility. It prioritizes reducing the longest routes and intelligently handles failed operations by exploring alternative transformations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Identify the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Step 1: Try to split the longest route into two\n        if len(longest_route) > 4:\n            for split_pos in range(2, len(longest_route) - 2):\n                first_part = longest_route[:split_pos + 1]\n                second_part = np.concatenate(([0], longest_route[split_pos:]))\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = first_part\n                    new_solution.insert(longest_route_idx + 1, second_part)\n                    break\n            else:\n                # Step 2: Try demand-aware relocation\n                for i in range(1, len(longest_route) - 1):\n                    for other_route_idx in range(len(new_solution)):\n                        if other_route_idx != longest_route_idx:\n                            other_route = new_solution[other_route_idx]\n                            for j in range(1, len(other_route)):\n                                if np.sum(demand[other_route[1:-1]]) + demand[longest_route[i]] <= capacity:\n                                    old_dist = (distance_matrix[longest_route[i-1]][longest_route[i]] +\n                                                distance_matrix[longest_route[i]][longest_route[i+1]] +\n                                                distance_matrix[other_route[j-1]][other_route[j]])\n                                    new_dist = (distance_matrix[longest_route[i-1]][longest_route[i+1]] +\n                                                distance_matrix[other_route[j-1]][longest_route[i]] +\n                                                distance_matrix[longest_route[i]][other_route[j]])\n\n                                    if new_dist < old_dist:\n                                        customer = longest_route[i]\n                                        other_route = np.insert(other_route, j, customer)\n                                        longest_route = np.delete(longest_route, i)\n                                        new_solution[longest_route_idx] = longest_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                            else:\n                                continue\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    # Step 3: Try capacity-balancing swap\n                    for i in range(1, len(longest_route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != longest_route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[longest_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[longest_route[1:-1]]) + demand[longest_route[i]]):\n                                        longest_load = np.sum(demand[longest_route[1:-1]])\n                                        other_load = np.sum(demand[other_route[1:-1]])\n\n                                        if (abs((longest_load - demand[longest_route[i]] + demand[other_route[j]]) -\n                                               (other_load - demand[other_route[j]] + demand[longest_route[i]])) <\n                                            abs(longest_load - other_load)):\n                                            longest_route[i], other_route[j] = other_route[j], longest_route[i]\n                                            new_solution[longest_route_idx] = longest_route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7263679129522422,
            0.09538960456848145
        ],
        "raw_score": [
            58.073021304032586,
            7.709346749425358
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding-distance-based selection, then applies a hybrid local search that alternates between angle-based route reshuffling (prioritizing makespan optimization) and demand-aware swaps (focusing on distance optimization), while ensuring feasibility through capacity checks and spatial constraints. It dynamically switches between spatial and demand-based improvements, with higher priority given to spatial clustering for makespan reduction and proximity-based swaps for distance optimization. The method includes a fallback mechanism for large-scale route restructuring when standard operations fail.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        objectives = np.array([sol[1] for sol in archive])\n        crowding_dist = np.zeros(len(archive))\n        for obj_idx in range(2):\n            sorted_idx = np.argsort(objectives[:, obj_idx])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        if random.random() < 0.5:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n        else:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    dist = np.linalg.norm(coords[route1[i]] - coords[route2[j]])\n                    if dist < np.mean(distance_matrix) * 0.5:\n                        if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                            demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                            route1[i], route2[j] = route2[j], route1[i]\n                            new_solution[route1_idx] = route1\n                            new_solution[route2_idx] = route2\n                            break\n                else:\n                    continue\n                break\n\n        if random.random() < 0.2:\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n            if len(longest_route) > 5:\n                split_pos = len(longest_route) // 2\n                part1 = np.concatenate((longest_route[:split_pos], [0]))\n                part2 = np.concatenate(([0], longest_route[split_pos:-1]))\n                if (np.sum(demand[part1[1:-1]]) <= capacity and\n                    np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = part1\n                    new_solution.insert(longest_route_idx + 1, part2)\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.9054501706044695,
            0.9856365919113159
        ],
        "raw_score": [
            37.090405698652646,
            4.497442763435139
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-10)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 2: Alternate between angle-based reshuffling and demand-aware swaps\n        if random.random() < 0.5:\n            # Angle-based reshuffling for makespan reduction\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                vectors = customer_coords - depot_coords\n                angles = np.arctan2(vectors[:, 1], vectors[:, 0])\n                sorted_customers = route[1:-1][np.argsort(angles)]\n\n                # Try to split into balanced routes\n                split_pos = len(sorted_customers) // 2\n                first_part = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                second_part = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n                if (np.sum(demand[sorted_customers[:split_pos]]) <= capacity and\n                    np.sum(demand[sorted_customers[split_pos:]]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n        else:\n            # Demand-aware swaps for distance optimization\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            for i in range(1, len(route1) - 1):\n                for j in range(1, len(route2) - 1):\n                    if abs(demand[route1[i]] - demand[route2[j]]) < 0.2 * capacity:\n                        if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                            demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                            # Calculate distance change\n                            old_dist = (distance_matrix[route1[i-1]][route1[i]] + distance_matrix[route1[i]][route1[i+1]] +\n                                       distance_matrix[route2[j-1]][route2[j]] + distance_matrix[route2[j]][route2[j+1]])\n                            new_dist = (distance_matrix[route1[i-1]][route2[j]] + distance_matrix[route2[j]][route1[i+1]] +\n                                       distance_matrix[route2[j-1]][route1[i]] + distance_matrix[route1[i]][route2[j+1]])\n\n                            if new_dist < old_dist:\n                                route1[i], route2[j] = route2[j], route1[i]\n                                new_solution[route1_idx] = route1\n                                new_solution[route2_idx] = route2\n                                break\n                else:\n                    continue\n                break\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Additional improvement: Try merging routes if possible\n    if len(new_solution) > 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if np.sum(demand[np.concatenate((route1[1:-1], route2[1:-1]))]) <= capacity:\n            old_dist = (distance_matrix[route1[-2]][route1[-1]] + distance_matrix[route2[-2]][route2[-1]] +\n                       distance_matrix[0][route1[1]] + distance_matrix[0][route2[1]])\n            new_dist = (distance_matrix[route1[-2]][route2[1]] + distance_matrix[0][route1[1]] +\n                       distance_matrix[route2[-2]][0] + distance_matrix[0][route2[1]])\n\n            if new_dist < old_dist:\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.951164473300762,
            1.1109510660171509
        ],
        "raw_score": [
            28.750155665724307,
            3.081532572080215
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([s[1] for s in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Dynamic hybrid operator: combine spatial clustering with demand-aware relocations\n        # First, identify the longest route and attempt to split it into two clusters based on spatial proximity\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:\n            # Cluster customers using k-means (simplified with centroids)\n            customers = longest_route[1:-1]\n            customer_coords = coords[customers]\n            centroid1 = np.mean(customer_coords[:len(customer_coords)//2], axis=0)\n            centroid2 = np.mean(customer_coords[len(customer_coords)//2:], axis=0)\n\n            cluster1 = []\n            cluster2 = []\n            for i, customer in enumerate(customers):\n                if np.linalg.norm(customer_coords[i] - centroid1) < np.linalg.norm(customer_coords[i] - centroid2):\n                    cluster1.append(customer)\n                else:\n                    cluster2.append(customer)\n\n            # Create new routes from clusters\n            if len(cluster1) > 0 and np.sum(demand[cluster1]) <= capacity:\n                new_route1 = np.concatenate(([0], cluster1, [0]))\n                new_solution[longest_route_idx] = new_route1\n            if len(cluster2) > 0 and np.sum(demand[cluster2]) <= capacity:\n                new_route2 = np.concatenate(([0], cluster2, [0]))\n                new_solution.insert(longest_route_idx + 1, new_route2)\n\n        # Then perform demand-aware relocations between routes\n        for i in range(1, len(longest_route)-1):\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx != longest_route_idx:\n                    other_route = new_solution[other_route_idx]\n                    for j in range(1, len(other_route)):\n                        if np.sum(demand[other_route[1:-1]]) + demand[longest_route[i]] <= capacity:\n                            # Check if relocation improves both distance and makespan\n                            old_dist = (distance_matrix[longest_route[i-1]][longest_route[i]] +\n                                        distance_matrix[longest_route[i]][longest_route[i+1]] +\n                                        distance_matrix[other_route[j-1]][other_route[j]])\n                            new_dist = (distance_matrix[longest_route[i-1]][longest_route[i+1]] +\n                                        distance_matrix[other_route[j-1]][longest_route[i]] +\n                                        distance_matrix[longest_route[i]][other_route[j]])\n\n                            if new_dist < old_dist:\n                                # Perform relocation\n                                customer = longest_route[i]\n                                other_route = np.insert(other_route, j, customer)\n                                longest_route = np.delete(longest_route, i)\n                                new_solution[longest_route_idx] = longest_route\n                                new_solution[other_route_idx] = other_route\n                                break\n                    else:\n                        continue\n                    break\n            else:\n                continue\n            break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8306444231864898,
            0.9625223875045776
        ],
        "raw_score": [
            58.412142987179735,
            7.807109591296484
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive with a weighted preference for lower total distance (50%) over makespan (50%), then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-adaptive swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations when standard improvements fail, always enforcing capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.5, 0.5)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to split the route into two\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 2: If splitting fails, try to relocate a customer to another route\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_pos)\n\n                            new_solution[route_idx] = route\n                            new_solution[other_route_idx] = other_route\n                            break\n                else:\n                    # Step 3: If relocation fails, try a capacity-adaptive swap\n                    for i in range(1, len(route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[route[1:-1]]) + demand[route[i]]):\n                                        old_dist = (distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][other_route[j]] + distance_matrix[other_route[j]][other_route[j+1]])\n                                        new_dist = (distance_matrix[route[i-1]][other_route[j]] + distance_matrix[other_route[j]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][route[i]] + distance_matrix[route[i]][other_route[j+1]])\n\n                                        if new_dist < old_dist:\n                                            route[i], other_route[j] = other_route[j], route[i]\n                                            new_solution[route_idx] = route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7039234633235187,
            0.1366652548313141
        ],
        "raw_score": [
            58.0593097506559,
            7.644695851627934
        ]
    }
]