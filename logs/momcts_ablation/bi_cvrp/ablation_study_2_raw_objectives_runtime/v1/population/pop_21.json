[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7626046040934145,
            0.21666795015335083
        ],
        "raw_score": [
            57.38218004043512,
            7.516075889345629
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive using crowding-distance-aware selection to prioritize diverse solutions, then applies a hybrid local search that alternates between angle-based route reshuffling (for makespan optimization) and demand-aware swaps (for distance optimization), while ensuring feasibility through capacity checks and spatial constraints, with a fallback mechanism for large-scale route restructuring when standard operations fail. The approach balances both objectives by dynamically switching between spatial and demand-based improvements, with higher priority given to spatial clustering for makespan reduction and proximity-based swaps for distance optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([sol[1] for sol in archive])\n        crowding_dist = np.zeros(len(archive))\n\n        for obj_idx in range(2):\n            sorted_idx = np.argsort(objectives[:, obj_idx])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Spatial-geometric route reshuffling (angle-based clustering for makespan)\n        if random.random() < 0.5:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Calculate angles for angle-based clustering\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n\n                # Sort customers by angle\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n\n                # Check capacity constraint\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n\n        # Demand-aware capacity-constrained swaps (spatial proximity for distance)\n        else:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Find spatially close customers from different routes\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check spatial proximity\n                    dist = np.linalg.norm(coords[route1[i]] - coords[route2[j]])\n                    if dist < np.mean(distance_matrix) * 0.5:  # Only consider close pairs\n                        # Check demand compatibility\n                        if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                            demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                            # Perform swap\n                            route1[i], route2[j] = route2[j], route1[i]\n                            new_solution[route1_idx] = route1\n                            new_solution[route2_idx] = route2\n                            break\n                else:\n                    continue\n                break\n\n        # Fallback mechanism for large-scale restructuring\n        if random.random() < 0.2:\n            # Identify long routes\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 5:\n                # Split into two balanced parts\n                split_pos = len(longest_route) // 2\n                part1 = np.concatenate((longest_route[:split_pos], [0]))\n                part2 = np.concatenate(([0], longest_route[split_pos:-1]))\n\n                if (np.sum(demand[part1[1:-1]]) <= capacity and\n                    np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = part1\n                    new_solution.insert(longest_route_idx + 1, part2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9468684497508806,
            1.1366134881973267
        ],
        "raw_score": [
            36.735819564521165,
            4.314131676940484
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest makespan from the archive, then reconstructs routes by prioritizing high-demand customers (sorted in descending order) and reinserting them into new routes while respecting vehicle capacity constraints. This strategy aims to balance capacity utilization and reduce makespan by focusing on customers with larger demands first. The overall structure involves route fragmentation and a demand-weighted reinsertion heuristic.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    all_customers = []\n\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n\n    # Sort customers by demand in descending order to prioritize high-demand customers\n    all_customers.sort(key=lambda x: -demand[x])\n\n    current_route = [0]\n    current_load = 0\n\n    for customer in all_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.816960311744704,
            0.4819713830947876
        ],
        "raw_score": [
            58.1186865918592,
            7.76925883811885
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive with a weighted preference for lower total distance (50%) over makespan (50%), then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-adaptive swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations when standard improvements fail, always enforcing capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.5, 0.5)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to split the route into two\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 2: If splitting fails, try to relocate a customer to another route\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_pos)\n\n                            new_solution[route_idx] = route\n                            new_solution[other_route_idx] = other_route\n                            break\n                else:\n                    # Step 3: If relocation fails, try a capacity-adaptive swap\n                    for i in range(1, len(route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[route[1:-1]]) + demand[route[i]]):\n                                        old_dist = (distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][other_route[j]] + distance_matrix[other_route[j]][other_route[j+1]])\n                                        new_dist = (distance_matrix[route[i-1]][other_route[j]] + distance_matrix[other_route[j]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][route[i]] + distance_matrix[route[i]][other_route[j+1]])\n\n                                        if new_dist < old_dist:\n                                            route[i], other_route[j] = other_route[j], route[i]\n                                            new_solution[route_idx] = route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7039234633235187,
            0.1366652548313141
        ],
        "raw_score": [
            58.0593097506559,
            7.644695851627934
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and a novel \"route reshuffling\" operator to balance the two objectives while ensuring feasibility. It intelligently selects customers for reinsertion and reshuffles routes to reduce makespan differences, focusing on capacity constraints and objective trade-offs. The process ensures feasibility at each step while targeting both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route merging (if possible) to reduce makespan\n    if len(selected_solution) > 1:\n        merged_routes = []\n        for route in selected_solution:\n            if not merged_routes or np.sum(demand[route[1:-1]]) + np.sum(demand[merged_routes[-1][1:-1]]) <= capacity:\n                if merged_routes:\n                    merged_route = np.concatenate((merged_routes[-1][:-1], route[1:]))\n                    merged_routes[-1] = merged_route\n                else:\n                    merged_routes.append(route)\n            else:\n                merged_routes.append(route)\n        selected_solution = merged_routes\n\n    # Step 2: Customer reinsertion with capacity constraints\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        candidates = route[1:-1]\n        if len(candidates) == 0:\n            new_solution.append(route)\n            continue\n\n        removed_customer = np.random.choice(candidates)\n        remaining_route = route[route != removed_customer]\n\n        # Find best insertion position in existing routes\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, r in enumerate(new_solution):\n            for pos in range(1, len(r)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate((r[1:pos], [removed_customer], r[pos:-1]))]) <= capacity:\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[r[pos-1], removed_customer] +\n                                   distance_matrix[removed_customer, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insertion = (i, pos)\n\n        if best_insertion:\n            i, pos = best_insertion\n            new_route = np.concatenate((new_solution[i][:pos], [removed_customer], new_solution[i][pos:]))\n            new_solution[i] = new_route\n        else:\n            # If no valid insertion found, create new route\n            new_solution.append(np.array([0, removed_customer, 0]))\n\n    # Step 3: Route reshuffling (novel operator) to balance objectives\n    if len(new_solution) > 1:\n        # Select two routes to reshuffle\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Find best split points for both routes\n        best_split = None\n        min_diff = float('inf')\n\n        for split1 in range(1, len(new_solution[idx1])-1):\n            for split2 in range(1, len(new_solution[idx2])-1):\n                # Check capacity constraints for both new routes\n                if (np.sum(demand[new_solution[idx1][1:split1]]) <= capacity and\n                    np.sum(demand[new_solution[idx1][split1:-1]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][1:split2]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][split2:-1]]) <= capacity):\n\n                    # Calculate makespan difference after reshuffling\n                    current_makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n                    new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n                    new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n                    new_makespan1 = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                    new_makespan2 = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n\n                    diff = abs(new_makespan1 - new_makespan2)\n                    if diff < min_diff:\n                        min_diff = diff\n                        best_split = (split1, split2)\n\n        if best_split:\n            split1, split2 = best_split\n            new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n            new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n            new_solution[idx1] = new_route1\n            new_solution[idx2] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8234625192972875,
            2.7163036167621613
        ],
        "raw_score": [
            58.1689844298665,
            7.7370092861205855
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (prioritizing makespan over distance) and applies a hybrid local search combining route splitting (for demand imbalance), customer relocation (to balance makespan), and demand-aware reshuffling (to swap route segments while maintaining capacity constraints). It focuses on reducing makespan by 10% and demand imbalance by 20% of capacity thresholds, ensuring feasibility through rigorous demand checks. The weighted selection (0.4 distance, 0.6 makespan) balances exploration of diverse solutions while the hybrid operators target both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Balance between distance and makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Try to split a route with high demand imbalance\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    second_part_demand = total_demand - first_part_demand\n                    if abs(first_part_demand - second_part_demand) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Relocate customers to balance makespan\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        longest_route = np.argmax(makespans)\n        shortest_route = np.argmin(makespans)\n\n        if makespans[longest_route] - makespans[shortest_route] > 0.1 * np.mean(makespans):\n            for customer_pos in range(1, len(new_solution[longest_route])-1):\n                customer = new_solution[longest_route][customer_pos]\n                if (np.sum(demand[new_solution[shortest_route][1:-1]]) + demand[customer] <= capacity and\n                    len(new_solution[shortest_route]) < len(new_solution[longest_route])):\n                    # Calculate potential makespan improvement\n                    old_dist = (distance_matrix[new_solution[longest_route][customer_pos-1], customer] +\n                               distance_matrix[customer, new_solution[longest_route][customer_pos+1]] -\n                               distance_matrix[new_solution[longest_route][customer_pos-1], new_solution[longest_route][customer_pos+1]])\n                    new_dist = (distance_matrix[new_solution[shortest_route][-2], customer] +\n                               distance_matrix[customer, 0] -\n                               distance_matrix[new_solution[shortest_route][-2], 0])\n                    if old_dist > new_dist:\n                        new_solution[shortest_route] = np.concatenate((new_solution[shortest_route][:-1], [customer], [0]))\n                        new_solution[longest_route] = np.concatenate((new_solution[longest_route][:customer_pos], new_solution[longest_route][customer_pos+1:]))\n                        break\n\n        # Step 3: Demand-aware reshuffling\n        if len(new_solution) > 2:\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n            demand1, demand2 = np.sum(demand[route1[1:-1]]), np.sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > 0.2 * capacity:\n                for split1 in range(1, len(route1)-1):\n                    for split2 in range(1, len(route2)-1):\n                        part1 = route1[1:split1]\n                        part2 = route2[1:split2]\n                        new_demand1 = demand1 - np.sum(demand[part1]) + np.sum(demand[part2])\n                        new_demand2 = demand2 - np.sum(demand[part2]) + np.sum(demand[part1])\n                        if (new_demand1 <= capacity and new_demand2 <= capacity and\n                            abs(new_demand1 - new_demand2) < abs(demand1 - demand2)):\n                            new_route1 = np.concatenate(([0], part1, route2[split2:-1], route1[split1:-1], [0]))\n                            new_route2 = np.concatenate(([0], part2, route1[split1:-1], route2[split2:-1], [0]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                    else:\n                        continue\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7904515528208966,
            0.8658688962459564
        ],
        "raw_score": [
            58.1234035683554,
            7.636296895092969
        ]
    },
    {
        "algorithm": "This algorithm selects a solution from the archive based on a weighted combination of distance and makespan objectives, then applies a hybrid local search combining route reshaping (with demand-aware segment relocation), demand-aware customer reallocation (using spatial clustering), and route merging (for balanced demand pairs) to improve both objectives while maintaining feasibility. The method prioritizes distance reduction (60% weight) over balanced routes (40%) in reshaping and considers spatial proximity (50%) alongside distance in customer insertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])  # More weight on distance\n    selected_idx = min(len(archive) // 3, len(archive) - 1)  # Select a better solution\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route reshaping with demand consideration\n    if len(new_solution) > 1:\n        route_idx = random.choice(range(len(new_solution)))\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Select a segment based on demand density\n            demands = demand[selected_route[1:-1]]\n            segment_length = min(3, len(selected_route) - 2)\n            segment_start = random.randint(1, len(selected_route) - 1 - segment_length)\n            segment_end = segment_start + segment_length\n            removed_segment = selected_route[segment_start:segment_end]\n\n            # Calculate demand of the segment\n            segment_demand = sum(demands[segment_start - 1:segment_end - 1])\n\n            # Find best insertion point considering both distance and demand balance\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(selected_route) - 1):\n                if i not in range(segment_start - 1, segment_end):\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[selected_route[i], removed_segment[0]] +\n                                   distance_matrix[removed_segment[-1], selected_route[i+1]] -\n                                   distance_matrix[selected_route[i], selected_route[i+1]])\n\n                    # Calculate demand balance improvement\n                    current_demand = sum(demand[selected_route[1:-1]])\n                    new_demand = current_demand - segment_demand\n                    balance_score = abs(new_demand - capacity / 2)  # Prefer balanced routes\n\n                    # Combined score\n                    score = 0.6 * dist_increase + 0.4 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(selected_route, best_pos, removed_segment)\n                new_solution[route_idx] = new_route\n\n    # Demand-aware customer reallocation with spatial clustering\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Cluster customers based on spatial proximity and demand\n        clusters = []\n        for customer in unassigned_customers:\n            assigned = False\n            for cluster in clusters:\n                # Check if customer is close to any member of the cluster\n                for member in cluster:\n                    if distance_matrix[customer, member] < 1.5 * np.mean(distance_matrix):\n                        cluster.append(customer)\n                        assigned = True\n                        break\n                if assigned:\n                    break\n            if not assigned:\n                clusters.append([customer])\n\n        for cluster in clusters:\n            # Sort customers in cluster by demand (descending)\n            cluster.sort(key=lambda x: -demand[x])\n\n            for customer in cluster:\n                best_route = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for route_idx in range(len(new_solution)):\n                    route = new_solution[route_idx]\n                    current_demand = sum(demand[route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        for i in range(len(route) - 1):\n                            # Calculate distance increase\n                            dist_increase = (distance_matrix[route[i], customer] +\n                                           distance_matrix[customer, route[i+1]] -\n                                           distance_matrix[route[i], route[i+1]])\n\n                            # Calculate spatial proximity to existing customers\n                            spatial_score = np.mean([distance_matrix[customer, c] for c in route[1:-1]])\n\n                            # Combined score\n                            score = 0.5 * dist_increase + 0.5 * spatial_score\n\n                            if score < best_score:\n                                best_score = score\n                                best_route = route_idx\n                                best_pos = i + 1\n\n                if best_route != -1:\n                    new_route = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[best_route] = new_route\n\n    # Route merging to reduce makespan\n    if len(new_solution) > 2:\n        # Find two routes with similar demands\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        min_diff = float('inf')\n        merge_pair = (-1, -1)\n\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                diff = abs(route_demands[i] - route_demands[j])\n                if diff < min_diff and route_demands[i] + route_demands[j] <= capacity:\n                    min_diff = diff\n                    merge_pair = (i, j)\n\n        if merge_pair != (-1, -1):\n            route1, route2 = new_solution[merge_pair[0]], new_solution[merge_pair[1]]\n\n            # Calculate best merge point\n            best_pos = -1\n            best_increase = float('inf')\n\n            for i in range(len(route1) - 1):\n                for j in range(len(route2) - 1):\n                    # Calculate distance increase for merging at these points\n                    dist_increase = (distance_matrix[route1[i], route2[1]] +\n                                   distance_matrix[route2[-2], route1[i+1]] -\n                                   distance_matrix[route1[i], route1[i+1]] -\n                                   distance_matrix[route2[-2], route2[-1]])\n\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = (i, j)\n\n            if best_pos != -1:\n                # Merge the routes\n                merged_route = np.concatenate([\n                    route1[:best_pos[0] + 1],\n                    route2[1:-1],\n                    route1[best_pos[0] + 1:]\n                ])\n                new_solution = [route for idx, route in enumerate(new_solution)\n                              if idx not in merge_pair] + [merged_route]\n\n    # Ensure the solution remains feasible\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7688276850363361,
            0.5797156393527985
        ],
        "raw_score": [
            57.84734696647112,
            7.624469138800522
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a promising solution from the archive based on trade-off ratios, then applies a two-phase transformation: first partitioning customers into angular sectors to optimize makespan, followed by demand-aware route consolidation to refine distance, while always maintaining feasibility through capacity checks. The method prioritizes spatial clustering in Phase 1 and demand balancing in Phase 2, with iterative merging decisions based on distance improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    trade_off_ratios = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(trade_off_ratios)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Angular sector partitioning for makespan optimization\n    if len(new_solution) > 1:\n        # Calculate angular sectors for all customers\n        depot_coords = coords[0]\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n        angles = np.arctan2(coords[all_customers, 1] - depot_coords[1],\n                          coords[all_customers, 0] - depot_coords[0])\n\n        # Sort customers by angle\n        sorted_indices = np.argsort(angles)\n        sorted_customers = np.array(all_customers)[sorted_indices]\n\n        # Create new routes by splitting into angular sectors\n        num_sectors = min(len(new_solution), len(sorted_customers))\n        sector_size = len(sorted_customers) // num_sectors\n        new_routes = []\n\n        for i in range(num_sectors):\n            start = i * sector_size\n            end = (i + 1) * sector_size if i < num_sectors - 1 else len(sorted_customers)\n            sector_customers = sorted_customers[start:end]\n\n            if len(sector_customers) > 0 and np.sum(demand[sector_customers]) <= capacity:\n                new_route = np.concatenate(([0], sector_customers, [0]))\n                new_routes.append(new_route)\n\n        if len(new_routes) > 1:\n            new_solution = new_routes\n\n    # Phase 2: Demand-aware route consolidation for distance optimization\n    if len(new_solution) > 2:\n        # Calculate route demands and sort by demand\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_routes = sorted(zip(new_solution, route_demands), key=lambda x: x[1])\n        new_solution = [route for route, _ in sorted_routes]\n\n        # Try to merge routes with similar demands\n        merged = True\n        while merged and len(new_solution) > 1:\n            merged = False\n            for i in range(len(new_solution) - 1):\n                if i >= len(new_solution) - 1:\n                    break\n\n                route1, route2 = new_solution[i], new_solution[i+1]\n                demand1, demand2 = sum(demand[route1[1:-1]]), sum(demand[route2[1:-1]])\n\n                if demand1 + demand2 <= capacity:\n                    # Calculate distance improvement\n                    old_dist = (sum(distance_matrix[route1[j], route1[j+1]] for j in range(len(route1)-1)) +\n                               sum(distance_matrix[route2[j], route2[j+1]] for j in range(len(route2)-1)))\n                    new_route = np.concatenate((route1[:-1], route2[1:]))\n                    new_dist = sum(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route)-1))\n\n                    if new_dist < old_dist:\n                        new_solution = new_solution[:i] + [new_route] + new_solution[i+2:]\n                        merged = True\n                        break\n\n    # Ensure all routes are feasible\n    new_solution = [route for route in new_solution if len(route) > 2 and sum(demand[route[1:-1]]) <= capacity]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7595065660994974,
            0.5461699068546295
        ],
        "raw_score": [
            58.245267990149785,
            7.6260714424962135
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding-distance-aware selection, then applies a hybrid local search combining angle-based route reshuffling (prioritizing makespan optimization) and demand-aware swaps (focusing on distance optimization), with dynamic alternation between these operations to balance both objectives while ensuring feasibility through capacity checks and spatial constraints. The method includes a fallback mechanism for large-scale restructuring by splitting long routes when beneficial.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([sol[1] for sol in archive])\n        crowding_dist = np.zeros(len(archive))\n\n        for obj_idx in range(2):\n            sorted_idx = np.argsort(objectives[:, obj_idx])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search\n    if len(new_solution) > 1:\n        # Operator 1: Angle-based reshuffling (makespan optimization)\n        if random.random() < 0.5:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Calculate angles for angle-based clustering\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n\n                # Sort customers by angle\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n\n                # Check capacity constraint\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n\n        # Operator 2: Demand-aware swaps (distance optimization)\n        else:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Find spatially close customers from different routes\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check spatial proximity\n                    dist = np.linalg.norm(coords[route1[i]] - coords[route2[j]])\n                    if dist < np.mean(distance_matrix) * 0.5:  # Only consider close pairs\n                        # Check demand compatibility\n                        if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                            demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                            # Perform swap\n                            route1[i], route2[j] = route2[j], route1[i]\n                            new_solution[route1_idx] = route1\n                            new_solution[route2_idx] = route2\n                            break\n                else:\n                    continue\n                break\n\n        # Fallback mechanism for large-scale restructuring\n        if random.random() < 0.2:\n            # Identify long routes\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 5:\n                # Split into two balanced parts\n                split_pos = len(longest_route) // 2\n                part1 = np.concatenate((longest_route[:split_pos], [0]))\n                part2 = np.concatenate(([0], longest_route[split_pos:-1]))\n\n                if (np.sum(demand[part1[1:-1]]) <= capacity and\n                    np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = part1\n                    new_solution.insert(longest_route_idx + 1, part2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.810596423728601,
            0.908486396074295
        ],
        "raw_score": [
            38.519120943490805,
            4.843382741324403
        ]
    }
]