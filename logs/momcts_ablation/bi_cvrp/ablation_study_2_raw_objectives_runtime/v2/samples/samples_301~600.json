[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive using a weighted Pareto approach (prioritizing total distance over makespan) and applies a hybrid local search combining route splitting, demand-balanced reinsertion, and feasibility checks to improve both objectives while ensuring vehicle capacity constraints are met. The selection prioritizes solutions with better total distance (weight 0.7) and slightly worse makespan (weight 0.3), while the local search intelligently modifies routes by splitting long routes, reinserting customers into shorter routes, and validating capacity constraints at each step. The method avoids standard 2-opt by using demand-aware route adjustments and multi-step validation.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: route splitting with demand-balanced reinsertion\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            segment1, segment2 = route[:split_pos+1], route[split_pos:]\n\n            # Create new routes from segments\n            temp_solution = [seg for seg in new_solution if not np.array_equal(seg, route)]\n            temp_solution.extend([segment1, segment2])\n\n            # Validate and update solution\n            if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n                new_solution = temp_solution\n\n        # Demand-balanced reinsertion step\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                for customer in longest_route[1:-1]:\n                    if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        best_pos = 1\n                        best_improvement = -float('inf')\n                        for i in range(1, len(shortest_route)):\n                            current_cost = distance_matrix[shortest_route[i-1], shortest_route[i]]\n                            new_cost = distance_matrix[shortest_route[i-1], customer] + distance_matrix[customer, shortest_route[i]]\n                            improvement = current_cost - new_cost\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_pos = i\n\n                        if best_improvement > 0:\n                            new_shortest = np.insert(shortest_route, best_pos, customer)\n                            new_longest = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                            new_solution[shortest_route_idx] = new_shortest\n                            new_solution[longest_route_idx] = new_longest\n                            break\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 301,
        "algorithm": "The algorithm prioritizes improving makespan (weight 0.7) over total distance (weight 0.3) by intelligently selecting solutions from the archive, then applying a hybrid local search combining route merging and demand-aware swapping to reduce the longest route while ensuring capacity constraints are met. It balances objectives by favoring solutions with shorter makespan and selectively merging or swapping customers between routes to create feasible, high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        shortest_route_idx = np.argmin(route_lengths)\n\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            # Route merging step\n            if len(shortest_route) + len(longest_route) - 2 <= capacity:\n                merged_route = np.concatenate([shortest_route[:-1], longest_route[1:]])\n                temp_solution = [route for route in new_solution if not np.array_equal(route, shortest_route) and not np.array_equal(route, longest_route)]\n                temp_solution.append(merged_route)\n\n                if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n                    new_solution = temp_solution\n\n        # Demand-aware swapping step\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        customer1 = route1[i]\n                        customer2 = route2[j]\n                        new_route1 = np.delete(route1, i)\n                        new_route1 = np.insert(new_route1, i, customer2)\n                        new_route2 = np.delete(route2, j)\n                        new_route2 = np.insert(new_route2, j, customer1)\n\n                        if (sum(demand[new_route1[1:-1]]) <= capacity and\n                            sum(demand[new_route2[1:-1]]) <= capacity):\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.3678477824571951,
            3.8449882566928864
        ],
        "raw_score": [
            43.0302704418852,
            5.344735527931327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        shortest_route_idx = np.argmin(route_lengths)\n\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            # Route merging step\n            if len(shortest_route) + len(longest_route) - 2 <= capacity:\n                merged_route = np.concatenate([shortest_route[:-1], longest_route[1:]])\n                temp_solution = [route for route in new_solution if not np.array_equal(route, shortest_route) and not np.array_equal(route, longest_route)]\n                temp_solution.append(merged_route)\n\n                if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n                    new_solution = temp_solution\n\n        # Demand-aware swapping step\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        customer1 = route1[i]\n                        customer2 = route2[j]\n                        new_route1 = np.delete(route1, i)\n                        new_route1 = np.insert(new_route1, i, customer2)\n                        new_route2 = np.delete(route2, j)\n                        new_route2 = np.insert(new_route2, j, customer1)\n\n                        if (sum(demand[new_route1[1:-1]]) <= capacity and\n                            sum(demand[new_route2[1:-1]]) <= capacity):\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            break\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 5 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using a weighted Pareto approach (prioritizing total distance over makespan) and applies a hybrid local search combining route splitting, demand-balanced reinsertion, and feasibility checks to improve both objectives while ensuring vehicle capacity constraints are met. The selection prioritizes solutions with better total distance (weight 0.7) and slightly worse makespan (weight 0.3), while the local search intelligently modifies routes by splitting long routes, reinserting customers into shorter routes, and validating capacity constraints at each step. The method avoids standard 2-opt by using demand-aware route adjustments and multi-step validation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: route splitting with demand-balanced reinsertion\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            segment1, segment2 = route[:split_pos+1], route[split_pos:]\n\n            # Create new routes from segments\n            temp_solution = [seg for seg in new_solution if not np.array_equal(seg, route)]\n            temp_solution.extend([segment1, segment2])\n\n            # Validate and update solution\n            if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n                new_solution = temp_solution\n\n        # Demand-balanced reinsertion step\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                for customer in longest_route[1:-1]:\n                    if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        best_pos = 1\n                        best_improvement = -float('inf')\n                        for i in range(1, len(shortest_route)):\n                            current_cost = distance_matrix[shortest_route[i-1], shortest_route[i]]\n                            new_cost = distance_matrix[shortest_route[i-1], customer] + distance_matrix[customer, shortest_route[i]]\n                            improvement = current_cost - new_cost\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_pos = i\n\n                        if best_improvement > 0:\n                            new_shortest = np.insert(shortest_route, best_pos, customer)\n                            new_longest = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                            new_solution[shortest_route_idx] = new_shortest\n                            new_solution[longest_route_idx] = new_longest\n                            break\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThis algorithm selects a solution from the archive using a weighted Pareto-aware approach (prioritizing makespan over distance) and applies a hybrid local search combining segment swaps, demand-aware reallocation, and capacity-constrained route merging to balance both objectives while ensuring feasibility through multi-step validation. The method prioritizes reducing the longest routes by intelligently reallocating customers between routes while maintaining vehicle capacity constraints, and it uses randomized segment swaps to explore the solution space efficiently.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap with demand-aware reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split each route at random positions\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Create segments\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine segments and reinsert customers\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        np.random.shuffle(combined_segments)\n\n        # Rebuild routes with capacity checks\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        # Additional demand-aware reallocation step\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                for customer in longest_route[1:-1]:\n                    if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for i in range(1, len(shortest_route)):\n                            cost = distance_matrix[shortest_route[i-1], customer] + distance_matrix[customer, shortest_route[i]] - distance_matrix[shortest_route[i-1], shortest_route[i]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = i\n\n                        new_shortest = np.insert(shortest_route, best_pos, customer)\n                        new_longest = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                        new_solution[shortest_route_idx] = new_shortest\n                        new_solution[longest_route_idx] = new_longest\n                        break\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    nondominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    weights = [1 / (obj[0] + obj[1]) for _, obj in nondominated]\n    selected_idx = random.choices(range(len(nondominated)), weights=weights, k=1)[0]\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: demand-driven segment swaps and capacity-aware reinsertion\n    if len(new_solution) >= 2:\n        # Identify the longest route (for makespan optimization)\n        makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = makespans.index(max(makespans))\n        longest_route = new_solution[longest_route_idx]\n\n        # Select a segment from the longest route to swap\n        if len(longest_route) > 3:\n            a, b = sorted(random.sample(range(1, len(longest_route)-1), 2))\n            segment = longest_route[a:b+1]\n            segment_demand = np.sum(demand[segment])\n\n            # Find the best route to insert the segment\n            best_route_idx = -1\n            best_improvement = 0\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx or len(route) == 2:\n                    continue\n\n                # Check capacity constraint\n                if np.sum(demand[route]) + segment_demand <= capacity:\n                    # Calculate potential improvement\n                    prev_node = route[-2]\n                    next_node = 0 if len(route) == 1 else route[1]\n                    old_distance = distance_matrix[prev_node][next_node]\n                    new_distance = distance_matrix[prev_node][segment[0]] + distance_matrix[segment[-1]][next_node]\n                    improvement = old_distance - new_distance\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = i\n\n            if best_route_idx != -1:\n                # Insert the segment into the best route\n                best_route = new_solution[best_route_idx]\n                new_route = np.concatenate([best_route[:-1], segment, [0]])\n                new_solution[best_route_idx] = new_route\n\n                # Remove the segment from the longest route\n                new_longest_route = np.concatenate([longest_route[:a], longest_route[b+1:]])\n                new_solution[longest_route_idx] = new_longest_route\n\n                # If the longest route is now empty, remove it\n                if len(new_longest_route) <= 2:\n                    del new_solution[longest_route_idx]\n\n    # Apply a 2-opt-like improvement on the longest route to further optimize makespan\n    if len(new_solution) > 0:\n        makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = makespans.index(max(makespans))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            a, b = sorted(random.sample(range(1, len(longest_route)-1), 2))\n            reversed_segment = longest_route[a:b+1][::-1]\n            new_route = np.concatenate([longest_route[:a], reversed_segment, longest_route[b+1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm combines nondominated solution selection with a hybrid local search that prioritizes demand-based customer reallocation and targeted 2-opt optimization, dynamically balancing distance and makespan improvements while maintaining feasibility through capacity-aware reinsertion. It first identifies nondominated solutions, selects one probabilistically, then reallocates high-demand customers from the longest route to others while ensuring capacity constraints, followed by a 2-opt improvement on the longest route to further refine the makespan. The method intelligently balances exploration and exploitation by leveraging demand-based prioritization and spatial distribution awareness.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    nondominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select a solution from nondominated solutions\n    weights = [1 / (obj[0] + obj[1]) for _, obj in nondominated]\n    selected_idx = random.choices(range(len(nondominated)), weights=weights, k=1)[0]\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: demand-based customer reallocation\n    if len(new_solution) >= 2:\n        # Identify the longest route (for makespan optimization)\n        makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = makespans.index(max(makespans))\n        longest_route = new_solution[longest_route_idx]\n\n        # Select customers to reallocate based on demand and spatial distribution\n        if len(longest_route) > 3:\n            # Sort customers by demand (descending) to prioritize high-demand customers\n            customers = longest_route[1:-1]\n            sorted_customers = sorted(customers, key=lambda x: -demand[x])\n\n            # Try to reallocate each customer to another route\n            for customer in sorted_customers:\n                best_route_idx = -1\n                best_improvement = 0\n\n                for i, route in enumerate(new_solution):\n                    if i == longest_route_idx or len(route) == 2:  # Skip the longest route and empty routes\n                        continue\n\n                    # Calculate the potential new demand for the route\n                    new_demand = np.sum(demand[route]) + demand[customer]\n\n                    if new_demand <= capacity:\n                        # Calculate the potential improvement (distance reduction)\n                        prev_node = route[-2]\n                        next_node = 0 if len(route) == 1 else route[1]\n                        old_distance = distance_matrix[prev_node][next_node]\n                        new_distance = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                        improvement = old_distance - new_distance\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_route_idx = i\n\n                if best_route_idx != -1:\n                    # Reallocate the customer\n                    new_route = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                    new_solution[best_route_idx] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                    new_solution[longest_route_idx] = longest_route\n\n                    # If the longest route is now empty, remove it\n                    if len(longest_route) <= 2:\n                        del new_solution[longest_route_idx]\n                        break\n\n        # Apply 2-opt on the longest route to further optimize makespan\n        if len(new_solution) > 0:\n            makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            longest_route_idx = makespans.index(max(makespans))\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:\n                # Try reversing a random segment\n                a, b = sorted(random.sample(range(1, len(longest_route)-1), 2))\n                reversed_segment = longest_route[a:b+1][::-1]\n                new_route = np.concatenate([longest_route[:a], reversed_segment, longest_route[b+1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route]) <= capacity:\n                    new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower makespan and total distance), then applies a hybrid local search that merges two routes and reinserts their customers into new routes while respecting capacity constraints. The selected routes are removed, their customers are shuffled, and reinserted into new routes with a greedy approach, ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) >= 2:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge the two routes (excluding the depot)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the selected routes from the solution\n        del new_solution[max(route1_idx, route2_idx)]\n        del new_solution[min(route1_idx, route2_idx)]\n\n        # Reinsert customers from the merged route into new routes\n        remaining_customers = merged_route[1:-1]  # Exclude depots\n        np.random.shuffle(remaining_customers)\n\n        # Create new routes while respecting capacity\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in remaining_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Keywords:\n- **Adaptive chained operators**: Combine segment swaps, demand reallocation, and capacity checks.\n- **Dynamic Pareto-biased selection**: Weighted randomness (70% makespan, 30% distance).\n- **Real-time feasibility checks**: Validate capacity and dominance at every step.\n- **Multi-objective chaining**: Link swaps and reallocations for high-impact improvements.\n\n### Advice:\n1. Chain segment swaps with weighted demand reallocation to balance distance and makespan.\n2. Use real-time capacity checks to reject infeasible moves immediately.\n3. Select neighbors based on Pareto-biased objectives (70% makespan, 30% distance).\n4. Design multi-step operators (e.g., swap + reallocate + validate) for efficiency.\n\n### Avoid:\n- Pure 2-opt or random splits (dominated heuristics).\n- Ignoring capacity constraints (infeasible solutions).\n- Static operators (e.g., pure 2-opt); use dynamic, hybrid strategies.\n- Ignoring objective trade-offs (focus on balanced improvements).\n\n### Explanation:\nAdaptive chaining of operators and dynamic Pareto-biased selection ensure balanced improvements. Real-time feasibility checks and multi-step operators avoid dominated heuristics and oversimplified approaches.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 302,
        "algorithm": "The algorithm prioritizes solutions with balanced objectives (30% distance, 70% makespan) to select a base solution, then applies a hybrid local search combining demand-aware reallocation of high-demand customers from the longest route to shorter routes (while respecting capacity) and segment swaps between routes to optimize both objectives. It dynamically validates moves for feasibility and dominance, balancing exploration and exploitation through intelligent operator chaining.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: demand-aware segment swaps and capacity-constrained reallocation\n    if len(new_solution) >= 2:\n        # Identify the longest route (for makespan optimization)\n        makespans = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n        longest_route_idx = np.argmax(makespans)\n        longest_route = new_solution[longest_route_idx]\n\n        # Step 1: Demand-aware reallocation of high-demand customers\n        if len(longest_route) > 3:\n            # Sort customers by demand (descending) to prioritize high-demand customers\n            customers = longest_route[1:-1]\n            sorted_customers = sorted(customers, key=lambda x: -demand[x])\n\n            for customer in sorted_customers:\n                best_route_idx = -1\n                best_improvement = 0\n\n                for i, route in enumerate(new_solution):\n                    if i == longest_route_idx or len(route) == 2:  # Skip the longest route and empty routes\n                        continue\n\n                    # Calculate the potential new demand for the route\n                    new_demand = np.sum(demand[route]) + demand[customer]\n\n                    if new_demand <= capacity:\n                        # Calculate the potential improvement (distance reduction)\n                        prev_node = route[-2]\n                        next_node = 0 if len(route) == 1 else route[1]\n                        old_distance = distance_matrix[prev_node][next_node]\n                        new_distance = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                        improvement = old_distance - new_distance\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_route_idx = i\n\n                if best_route_idx != -1:\n                    # Reallocate the customer\n                    new_route = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                    new_solution[best_route_idx] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                    new_solution[longest_route_idx] = longest_route\n\n                    # If the longest route is now empty, remove it\n                    if len(longest_route) <= 2:\n                        del new_solution[longest_route_idx]\n                        break\n\n        # Step 2: Demand-aware segment swaps between routes\n        if len(new_solution) >= 2:\n            # Select two routes for segment swap\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Split each route at random positions\n            split1 = random.randint(1, len(route1)-2)\n            split2 = random.randint(1, len(route2)-2)\n\n            # Create segments\n            seg1a, seg1b = route1[:split1+1], route1[split1:]\n            seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n            # Combine segments and reinsert customers\n            combined_segments = [seg1a, seg1b, seg2a, seg2b]\n            np.random.shuffle(combined_segments)\n\n            # Rebuild routes with capacity checks\n            temp_solution = []\n            for seg in combined_segments:\n                customers = seg[1:-1]\n                np.random.shuffle(customers)\n                current_route = [0]\n                current_load = 0.0\n\n                for customer in customers:\n                    if current_load + demand[customer] <= capacity:\n                        current_route.append(customer)\n                        current_load += demand[customer]\n                    else:\n                        current_route.append(0)\n                        temp_solution.append(np.array(current_route))\n                        current_route = [0, customer]\n                        current_load = demand[customer]\n\n                if len(current_route) > 1:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n\n            # Validate and update solution\n            if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.815203257172472,
            2.039286732673645
        ],
        "raw_score": [
            58.38806413127491,
            7.824229266577042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: demand-aware segment swaps and capacity-constrained reallocation\n    if len(new_solution) >= 2:\n        # Identify the longest route (for makespan optimization)\n        makespans = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n        longest_route_idx = np.argmax(makespans)\n        longest_route = new_solution[longest_route_idx]\n\n        # Step 1: Demand-aware reallocation of high-demand customers\n        if len(longest_route) > 3:\n            # Sort customers by demand (descending) to prioritize high-demand customers\n            customers = longest_route[1:-1]\n            sorted_customers = sorted(customers, key=lambda x: -demand[x])\n\n            for customer in sorted_customers:\n                best_route_idx = -1\n                best_improvement = 0\n\n                for i, route in enumerate(new_solution):\n                    if i == longest_route_idx or len(route) == 2:  # Skip the longest route and empty routes\n                        continue\n\n                    # Calculate the potential new demand for the route\n                    new_demand = np.sum(demand[route]) + demand[customer]\n\n                    if new_demand <= capacity:\n                        # Calculate the potential improvement (distance reduction)\n                        prev_node = route[-2]\n                        next_node = 0 if len(route) == 1 else route[1]\n                        old_distance = distance_matrix[prev_node][next_node]\n                        new_distance = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                        improvement = old_distance - new_distance\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_route_idx = i\n\n                if best_route_idx != -1:\n                    # Reallocate the customer\n                    new_route = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                    new_solution[best_route_idx] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                    new_solution[longest_route_idx] = longest_route\n\n                    # If the longest route is now empty, remove it\n                    if len(longest_route) <= 2:\n                        del new_solution[longest_route_idx]\n                        break\n\n        # Step 2: Demand-aware segment swaps between routes\n        if len(new_solution) >= 2:\n            # Select two routes for segment swap\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Split each route at random positions\n            split1 = random.randint(1, len(route1)-2)\n            split2 = random.randint(1, len(route2)-2)\n\n            # Create segments\n            seg1a, seg1b = route1[:split1+1], route1[split1:]\n            seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n            # Combine segments and reinsert customers\n            combined_segments = [seg1a, seg1b, seg2a, seg2b]\n            np.random.shuffle(combined_segments)\n\n            # Rebuild routes with capacity checks\n            temp_solution = []\n            for seg in combined_segments:\n                customers = seg[1:-1]\n                np.random.shuffle(customers)\n                current_route = [0]\n                current_load = 0.0\n\n                for customer in customers:\n                    if current_load + demand[customer] <= capacity:\n                        current_route.append(customer)\n                        current_load += demand[customer]\n                    else:\n                        current_route.append(0)\n                        temp_solution.append(np.array(current_route))\n                        current_route = [0, customer]\n                        current_load = demand[customer]\n\n                if len(current_route) > 1:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n\n            # Validate and update solution\n            if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have 8 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm prioritizes solutions with lower total distance, applies a hybrid local search that splits the longest route and rebalances customers between routes to minimize makespan while ensuring capacity constraints are met. It intelligently selects customers to move between routes based on insertion cost, avoiding pure 2-opt and instead combining route splitting and rebalancing for balanced multi-objective improvement.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route (highest makespan)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        route1 = np.concatenate([longest_route[:split_pos], [0]])\n        route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([route1, route2])\n\n        # Step 2: Rebalance customers between routes to minimize makespan\n        for route in new_solution:\n            if len(route) > 2:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != longest_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert the customer into the target route\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[longest_route_idx] = np.delete(route, customer_idx)\n                                break\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using weighted Pareto-aware selection (prioritizing distance over makespan) and applies a hybrid local search that combines segment swaps with dynamic customer reallocation between routes, ensuring capacity feasibility while balancing improvements to both objectives. The selection weights (0.7 for distance, 0.3 for makespan) guide the focus toward distance optimization, while the segment swap and reallocation strategy introduces diversity and potential for multi-objective trade-offs. The solution is validated to ensure vehicle capacity constraints are met before returning the improved neighbor.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap with dynamic reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split each route at a random position\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Create segments\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine segments and reinsert customers\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        np.random.shuffle(combined_segments)\n\n        # Rebuild routes with capacity checks\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using balanced Pareto-aware selection (equal weights for distance and makespan) and applies a novel local search combining route merging, customer reinsertion, and demand-aware splitting to improve both objectives while ensuring feasibility through strict capacity validation. The selected solution undergoes random merging of two routes, followed by shuffling and re-splitting customers to form new feasible routes, prioritizing demand constraints over distance reduction. The neighbor solution is returned if it maintains feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.5, 0.5])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Route merging with demand-aware splitting\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge routes and shuffle customers\n        merged_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        np.random.shuffle(merged_customers)\n\n        # Demand-aware splitting\n        temp_solution = []\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in merged_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted Pareto-aware approach (prioritizing makespan over distance) and applies a hybrid local search combining dynamic segment swaps, demand-aware reallocation, and capacity-preserving route merging to balance objectives while ensuring feasibility. The solution is chosen based on normalized scores (30% distance, 70% makespan), and the local search operator dynamically reshuffles route segments, reallocates customers based on demand, and merges routes when feasible. The method prioritizes reducing the longest route (makespan) while maintaining capacity constraints and improving overall distance.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Dynamic segment swaps\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        # Demand-aware reallocation\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        # Capacity-preserving route merging\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                merged_demand = sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]])\n                if merged_demand <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a combined objective score (sum of distance and makespan) to identify promising candidates, then applies a hybrid local search that splits routes and intelligently reinserts customers based on weighted distance savings and makespan reduction, while ensuring capacity constraints through dynamic validation and a multi-step rebalancing phase that redistributes customers between routes to improve both objectives. The method prioritizes distance savings in reinsertion decisions and focuses on the most significant improvements during the rebalancing phase.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[0] + obj[1]) for obj in [x[1] for x in archive]]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: route splitting with intelligent reinsertion\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Split route at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        seg1, seg2 = route[:split_pos + 1], route[split_pos:]\n\n        # Remove original route\n        del new_solution[route_idx]\n\n        # Reinsert customers from both segments into new routes\n        customers = np.concatenate([seg1[1:-1], seg2[1:-1]])\n        np.random.shuffle(customers)\n\n        # Create new routes with weighted reinsertion (distance + makespan)\n        current_route = [0]\n        current_load = 0.0\n        temp_solution = []\n\n        for customer in customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Multi-step rebalancing phase\n        if len(temp_solution) > 1:\n            # Calculate potential improvements for each customer\n            improvements = []\n            for i, route in enumerate(temp_solution):\n                for j, customer in enumerate(route[1:-1]):\n                    # Calculate distance savings if moved to another route\n                    prev_node = route[j]\n                    next_node = route[j + 2] if j + 2 < len(route) else 0\n                    current_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n                    # Find best alternative route\n                    best_dist = float('inf')\n                    best_route_idx = -1\n                    for k, alt_route in enumerate(temp_solution):\n                        if k == i:\n                            continue\n                        # Check if adding to this route is feasible\n                        if sum(demand[alt_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate insertion cost\n                            for l in range(len(alt_route) - 1):\n                                insert_dist = (distance_matrix[alt_route[l], customer] +\n                                              distance_matrix[customer, alt_route[l + 1]] -\n                                              distance_matrix[alt_route[l], alt_route[l + 1]])\n                                if insert_dist < best_dist:\n                                    best_dist = insert_dist\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        improvements.append((i, j, best_route_idx, current_dist - best_dist))\n\n            # Sort improvements by potential savings (distance + makespan)\n            improvements.sort(key=lambda x: x[3], reverse=True)\n\n            # Apply the best improvements\n            for i, j, best_route_idx, _ in improvements[:min(3, len(improvements))]:\n                route = temp_solution[i]\n                customer = route[j + 1]\n\n                # Remove from current route\n                route = np.concatenate([route[:j + 1], route[j + 2:]])\n                if len(route) == 1:\n                    del temp_solution[i]\n                else:\n                    temp_solution[i] = route\n\n                # Insert into best alternative route\n                alt_route = temp_solution[best_route_idx]\n                best_pos = 0\n                best_insert_cost = float('inf')\n\n                # Find best insertion position\n                for k in range(len(alt_route) - 1):\n                    insert_cost = (distance_matrix[alt_route[k], customer] +\n                                 distance_matrix[customer, alt_route[k + 1]] -\n                                 distance_matrix[alt_route[k], alt_route[k + 1]])\n                    if insert_cost < best_insert_cost:\n                        best_insert_cost = insert_cost\n                        best_pos = k + 1\n\n                # Insert customer\n                alt_route = np.insert(alt_route, best_pos, customer)\n                temp_solution[best_route_idx] = alt_route\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm implements a Pareto-aware hybrid local search that dynamically selects between four novel operators (route expansion, demand-aware segment relocation, adaptive route splitting, and balanced route balancing) based on the current solution's objective trade-off, prioritizing distance reduction when routes are highly imbalanced, improving makespan by relocating incompatible demand segments between routes when distance dominates, splitting routes when beneficial for both objectives, and balancing route lengths to improve both objectives simultaneously. The selection of operators is guided by route length metrics (e.g., makespan vs. average route distance), and all operations ensure feasibility by respecting vehicle capacity constraints.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    makespan = max(route_distances)\n\n    # Operator selection based on current trade-off\n    if len(new_solution) >= 2 and makespan > 1.3 * np.mean(route_distances):  # Route expansion\n        # Add a node from one route to another to balance makespan\n        shortest_idx = np.argmin(route_distances)\n        shortest_route = new_solution[shortest_idx]\n\n        if len(shortest_route) > 3:\n            # Find node to move that maximizes makespan improvement\n            best_improvement = 0\n            best_node = None\n            for node in shortest_route[1:-1]:\n                # Calculate potential makespan improvement if this node is moved\n                temp_route = np.delete(shortest_route, np.where(shortest_route == node)[0][0])\n                temp_distance = sum(distance_matrix[temp_route[i]][temp_route[i+1]] for i in range(len(temp_route)-1))\n                improvement = route_distances[shortest_idx] - temp_distance\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = node\n\n            if best_node is not None:\n                # Find best route to insert the node into\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for i in range(len(new_solution)):\n                    if i != shortest_idx:\n                        route = new_solution[i]\n                        for pos in range(1, len(route)):\n                            cost = (distance_matrix[route[pos-1]][best_node] +\n                                    distance_matrix[best_node][route[pos]] -\n                                    distance_matrix[route[pos-1]][route[pos]])\n                            if cost < best_cost and sum(demand[route[1:-1]]) + demand[best_node] <= capacity:\n                                best_cost = cost\n                                best_route = i\n                                best_pos = pos\n\n                if best_route is not None:\n                    new_route = np.insert(new_solution[best_route], best_pos, best_node)\n                    new_solution[best_route] = new_route\n                    new_solution[shortest_idx] = np.delete(shortest_route, np.where(shortest_route == best_node)[0][0])\n    elif makespan < 0.8 * np.mean(route_distances):  # Demand-aware segment relocation\n        # Move segments between routes to improve both objectives\n        candidate_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(len(new_solution)):\n                if i != j and route_demands[i] + route_demands[j] <= capacity:\n                    candidate_pairs.append((i, j))\n\n        if candidate_pairs:\n            i, j = random.choice(candidate_pairs)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Find compatible segment in route_j to insert into route_i\n            for k in range(1, len(route_j)-1):\n                segment = route_j[k]\n                if sum(demand[route_i[1:-1]]) + demand[segment] <= capacity:\n                    # Find best insertion point in route_i\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route_i)):\n                        cost = (distance_matrix[route_i[pos-1]][segment] +\n                                distance_matrix[segment][route_i[pos]] -\n                                distance_matrix[route_i[pos-1]][route_i[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform insertion\n                    new_route_i = np.insert(route_i, best_pos, segment)\n                    new_route_j = np.delete(route_j, k)\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n    elif len(new_solution) >= 3:  # Adaptive route splitting\n        # Split a long route into two to improve makespan\n        longest_idx = np.argmax(route_distances)\n        longest_route = new_solution[longest_idx]\n\n        if len(longest_route) > 5:\n            # Find best split point that balances the two new routes\n            best_split = None\n            best_balance = float('inf')\n\n            for split in range(2, len(longest_route)-2):\n                first_part = longest_route[:split+1]\n                second_part = np.concatenate([[0], longest_route[split:]])\n\n                first_demand = sum(demand[first_part[1:-1]])\n                second_demand = sum(demand[second_part[1:-1]])\n\n                if first_demand <= capacity and second_demand <= capacity:\n                    first_distance = sum(distance_matrix[first_part[i]][first_part[i+1]] for i in range(len(first_part)-1))\n                    second_distance = sum(distance_matrix[second_part[i]][second_part[i+1]] for i in range(len(second_part)-1))\n                    balance = abs(first_distance - second_distance)\n\n                    if balance < best_balance:\n                        best_balance = balance\n                        best_split = split\n\n            if best_split is not None:\n                first_part = longest_route[:best_split+1]\n                second_part = np.concatenate([[0], longest_route[best_split:]])\n                new_solution[longest_idx] = first_part\n                new_solution.insert(longest_idx+1, second_part)\n    else:  # Balanced route balancing\n        # Adjust routes to balance their lengths\n        avg_distance = np.mean(route_distances)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            current_distance = route_distances[i]\n\n            if current_distance > avg_distance * 1.1:  # Long route\n                # Try to move a node to a shorter route\n                for j in range(len(new_solution)):\n                    if j != i and route_distances[j] < avg_distance * 0.9:\n                        for k in range(1, len(route)-1):\n                            node = route[k]\n                            if sum(demand[new_solution[j][1:-1]]) + demand[node] <= capacity:\n                                # Find best insertion point\n                                best_pos = 1\n                                best_cost = float('inf')\n                                for pos in range(1, len(new_solution[j])):\n                                    cost = (distance_matrix[new_solution[j][pos-1]][node] +\n                                            distance_matrix[node][new_solution[j][pos]] -\n                                            distance_matrix[new_solution[j][pos-1]][new_solution[j][pos]])\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_pos = pos\n\n                                # Perform move\n                                new_solution[j] = np.insert(new_solution[j], best_pos, node)\n                                new_solution[i] = np.delete(route, k)\n                                break\n                        break\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm implements a Pareto-biased selection mechanism (70% makespan, 30% distance) to prioritize solutions, followed by a hybrid local search that performs demand-aware segment swaps between routes while ensuring capacity constraints are respected. It adaptively selects segments based on demand balance and validates feasibility before applying swaps, avoiding pure 2-opt by combining segment swaps with weighted demand reallocation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1]*0.7 + x[1][0]*0.3))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: adaptive demand-aware segment swaps\n    if len(new_solution) >= 2:\n        # Select two routes for segment swap\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find segments to swap based on demand balance\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                segment1 = route1[i:]\n                segment2 = route2[j:]\n\n                # Calculate demand of segments\n                demand1 = sum(demand[segment1])\n                demand2 = sum(demand[segment2])\n\n                # Check capacity constraints after swap\n                new_route1 = np.concatenate([route1[:i], segment2, [0]])\n                new_route2 = np.concatenate([route2[:j], segment1, [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n\n                    # Perform the swap\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    return new_solution\n\n    return new_solution\n\n\nNo. 8 algorithm's description and the corresponding code are:\nThe algorithm combines adaptive segment-based routing with dynamic demand redistribution, prioritizing makespan reduction (70%) over distance optimization (30%) by selecting balanced solutions, then performing multi-phase segment swaps with demand-weighted insertion costs and probabilistic chaining of segment swaps to improve both objectives while maintaining feasibility through capacity validation. It intelligently selects segments based on demand and route structure, ensuring feasible solutions through real-time capacity checks. The hybrid approach balances exploitation of route segments with exploration of demand redistribution to create high-quality neighbors.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Phase 1: Adaptive segment-based routing with demand redistribution\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Split route into segments with demand-weighted selection\n            split_pos = random.randint(1, len(route) - 2)\n            seg1, seg2 = route[:split_pos + 1], route[split_pos:]\n\n            # Calculate demand-weighted insertion costs for segment swaps\n            customers = np.concatenate([seg1[1:-1], seg2[1:-1]])\n            np.random.shuffle(customers)\n\n            # Create new routes with demand-aware insertion\n            temp_solution = []\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n            # Phase 2: Probabilistic chaining of segment swaps and demand rebalancing\n            if len(temp_solution) >= 2 and random.random() < 0.6:\n                # Select two routes for segment swap\n                route1_idx, route2_idx = random.sample(range(len(temp_solution)), 2)\n                route1 = temp_solution[route1_idx]\n                route2 = temp_solution[route2_idx]\n\n                if len(route1) > 3 and len(route2) > 3:\n                    # Select segments with demand-weighted probability\n                    seg1_start = random.randint(1, len(route1) - 2)\n                    seg1_end = random.randint(seg1_start, len(route1) - 2)\n                    seg2_start = random.randint(1, len(route2) - 2)\n                    seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n                    segment1 = route1[seg1_start:seg1_end + 1]\n                    segment2 = route2[seg2_start:seg2_end + 1]\n\n                    # Check feasibility with demand redistribution\n                    if (sum(demand[route1]) - sum(demand[segment1]) + sum(demand[segment2]) <= capacity and\n                        sum(demand[route2]) - sum(demand[segment2]) + sum(demand[segment1]) <= capacity):\n\n                        # Perform segment swap with demand-weighted insertion\n                        new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end + 1:]])\n                        new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end + 1:]])\n\n                        temp_solution[route1_idx] = new_route1\n                        temp_solution[route2_idx] = new_route2\n\n            # Validate and update solution\n            if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n                new_solution = temp_solution\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### Keywords:\n- **Adaptive chained operators**: Segment swaps + demand reallocation + capacity checks.\n- **Dynamic Pareto-biased selection**: Weighted randomness (70% makespan, 30% distance).\n- **Real-time feasibility checks**: Validate capacity and dominance at every step.\n- **Multi-objective chaining**: Link swaps and reallocations for high-impact improvements.\n\n### Advice:\n1. Chain segment swaps with weighted demand reallocation to balance distance and makespan.\n2. Use real-time capacity checks to reject infeasible moves immediately.\n3. Select neighbors based on Pareto-biased objectives (70% makespan, 30% distance).\n4. Design multi-step operators (e.g., swap + reallocate + validate) for efficiency.\n\n### Avoid:\n- Pure 2-opt or random splits (dominated heuristics).\n- Ignoring capacity constraints (infeasible solutions).\n- Static operators (e.g., pure 2-opt); use dynamic, hybrid strategies.\n- Ignoring objective trade-offs (focus on balanced improvements).\n\n### Explanation:\nAdaptive chaining of operators and dynamic Pareto-biased selection ensure balanced improvements. Real-time feasibility checks and multi-step operators avoid dominated heuristics and oversimplified approaches.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 303,
        "algorithm": "The algorithm selects a Pareto-biased solution (prioritizing makespan over distance) and applies a hybrid local search combining adaptive segment swaps and capacity-aware route balancing, ensuring feasibility through real-time demand checks while occasionally splitting long routes for multi-objective improvement. It alternates between inter-route segment exchanges and intra-route splits, with a bias toward reducing the longest route's makespan while maintaining feasible vehicle capacities.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            split1 = random.randint(1, len(route1) - 2)\n            split2 = random.randint(1, len(route2) - 2)\n\n            segment1 = route1[split1:]\n            segment2 = route2[split2:]\n\n            if (sum(demand[route1[1:split1]]) + sum(demand[segment2[1:-1]]) <= capacity and\n                sum(demand[route2[1:split2]]) + sum(demand[segment1[1:-1]]) <= capacity):\n\n                new_route1 = np.concatenate([route1[:split1], segment2, [0]])\n                new_route2 = np.concatenate([route2[:split2], segment1, [0]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n        if random.random() < 0.5:\n            longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 4:\n                split_pos = len(longest_route) // 2\n                route_part1 = np.concatenate([longest_route[:split_pos], [0]])\n                route_part2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n                if (sum(demand[route_part1[1:-1]]) <= capacity and\n                    sum(demand[route_part2[1:-1]]) <= capacity):\n\n                    new_solution[longest_route_idx] = route_part1\n                    new_solution.insert(longest_route_idx + 1, route_part2)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5322127940707755,
            1.0752324163913727
        ],
        "raw_score": [
            54.242674592568775,
            6.92017233711232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            split1 = random.randint(1, len(route1) - 2)\n            split2 = random.randint(1, len(route2) - 2)\n\n            segment1 = route1[split1:]\n            segment2 = route2[split2:]\n\n            if (sum(demand[route1[1:split1]]) + sum(demand[segment2[1:-1]]) <= capacity and\n                sum(demand[route2[1:split2]]) + sum(demand[segment1[1:-1]]) <= capacity):\n\n                new_route1 = np.concatenate([route1[:split1], segment2, [0]])\n                new_route2 = np.concatenate([route2[:split2], segment1, [0]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n        if random.random() < 0.5:\n            longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 4:\n                split_pos = len(longest_route) // 2\n                route_part1 = np.concatenate([longest_route[:split_pos], [0]])\n                route_part2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n                if (sum(demand[route_part1[1:-1]]) <= capacity and\n                    sum(demand[route_part2[1:-1]]) <= capacity):\n\n                    new_solution[longest_route_idx] = route_part1\n                    new_solution.insert(longest_route_idx + 1, route_part2)\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted Pareto-aware approach (prioritizing makespan over distance) and applies a hybrid local search combining dynamic segment swaps, demand-aware reallocation, and capacity-preserving route merging to balance objectives while ensuring feasibility. The solution is chosen based on normalized scores (30% distance, 70% makespan), and the local search operator dynamically reshuffles route segments, reallocates customers based on demand, and merges routes when feasible. The method prioritizes reducing the longest route (makespan) while maintaining capacity constraints and improving overall distance.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Dynamic segment swaps\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        # Demand-aware reallocation\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        # Capacity-preserving route merging\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                merged_demand = sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]])\n                if merged_demand <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm combines a dynamic Pareto-biased selection strategy (prioritizing makespan with 70% weight and distance with 30%) with a hybrid local search operator that adaptively decomposes and reinserts route segments while ensuring capacity constraints, followed by capacity-constrained route fusion to balance improvements in both objectives. It intelligently selects and modifies solutions by decomposing routes into segments, reinserting them optimally, and merging shorter routes into longer ones when feasible. The approach avoids dominated heuristics by focusing on high-makespan solutions while maintaining feasibility through real-time checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Adaptive route decomposition and segment insertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Decompose routes into segments with varying lengths\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n\n        # Insert segment into route2 in demand-aware manner\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert segment and update routes\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end + 1))\n\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Capacity-constrained route fusion\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                if sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Keywords:\n- **Adaptive chained operators**: Segment swaps + demand reallocation + capacity checks.\n- **Dynamic Pareto-biased selection**: Weighted randomness (70% makespan, 30% distance).\n- **Real-time feasibility checks**: Validate capacity and dominance at every step.\n- **Multi-objective chaining**: Link swaps and reallocations for high-impact improvements.\n\n### Advice:\n1. Chain segment swaps with weighted demand reallocation to balance distance and makespan.\n2. Use real-time capacity checks to reject infeasible moves immediately.\n3. Select neighbors based on Pareto-biased objectives (70% makespan, 30% distance).\n4. Design multi-step operators (e.g., swap + reallocate + validate) for efficiency.\n\n### Avoid:\n- Pure 2-opt or random splits (dominated heuristics).\n- Ignoring capacity constraints (infeasible solutions).\n- Static operators (e.g., pure 2-opt); use dynamic, hybrid strategies.\n- Ignoring objective trade-offs (focus on balanced improvements).\n\n### Explanation:\nAdaptive chaining of operators and dynamic Pareto-biased selection ensure balanced improvements. Real-time feasibility checks and multi-step operators avoid dominated heuristics and oversimplified approaches.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 304,
        "algorithm": "The algorithm prioritizes high-makespan solutions (60% weight) and combines a hybrid local search that adaptively extracts high-demand segments from routes, reinserts them into capacity-feasible routes with minimal distance impact, and merges routes to balance objectives. It intelligently selects segments, optimizes insertion points, and merges demand-constrained routes while maintaining feasibility through real-time checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6 * obj[1] + 0.4 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Identify high-demand segments\n        high_demand_segments = []\n        for route in new_solution:\n            customers = route[1:-1]\n            if len(customers) == 0:\n                continue\n            # Find the most demanding segment in the route\n            max_demand = -1\n            best_segment = None\n            for i in range(len(customers)):\n                for j in range(i, len(customers)):\n                    segment_demand = sum(demand[customers[i:j+1]])\n                    if segment_demand > max_demand:\n                        max_demand = segment_demand\n                        best_segment = customers[i:j+1]\n            if best_segment is not None:\n                high_demand_segments.append((route, best_segment))\n\n        if high_demand_segments:\n            # Select a random high-demand segment to move\n            route, segment = random.choice(high_demand_segments)\n            segment_demand = sum(demand[segment])\n\n            # Find the best route to insert the segment into\n            best_route = None\n            best_pos = None\n            best_cost = float('inf')\n\n            for candidate_route in new_solution:\n                if np.array_equal(candidate_route, route):\n                    continue\n                if sum(demand[candidate_route[1:-1]]) + segment_demand > capacity:\n                    continue\n\n                # Find optimal insertion position\n                for pos in range(1, len(candidate_route)):\n                    cost = (distance_matrix[candidate_route[pos-1]][segment[0]] +\n                            distance_matrix[segment[-1]][candidate_route[pos]] -\n                            distance_matrix[candidate_route[pos-1]][candidate_route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = candidate_route\n                        best_pos = pos\n\n            if best_route is not None and best_pos is not None:\n                # Insert the segment\n                new_route = np.concatenate([best_route[:best_pos], segment, best_route[best_pos:]])\n                new_solution.append(new_route)\n\n                # Remove the segment from the original route\n                original_customers = route[1:-1].tolist()\n                for customer in segment:\n                    original_customers.remove(customer)\n                if original_customers:\n                    new_route = [0] + original_customers + [0]\n                    new_solution.append(np.array(new_route))\n\n                # Rebuild the solution with the modified routes\n                temp_solution = []\n                for r in new_solution:\n                    if not np.array_equal(r, route) and not np.array_equal(r, best_route):\n                        temp_solution.append(r)\n                new_solution = temp_solution\n\n        # Demand-aware route merging\n        if len(new_solution) > 1:\n            # Sort routes by demand in descending order\n            route_demands = [(sum(demand[route[1:-1]]), route) for route in new_solution]\n            route_demands.sort(reverse=True, key=lambda x: x[0])\n\n            merged = True\n            while merged and len(new_solution) > 1:\n                merged = False\n                for i in range(len(route_demands)):\n                    for j in range(i+1, len(route_demands)):\n                        d1, r1 = route_demands[i]\n                        d2, r2 = route_demands[j]\n                        if d1 + d2 <= capacity:\n                            merged_route = np.concatenate([r1[:-1], r2[1:]])\n                            new_solution.append(merged_route)\n                            new_solution.remove(r1)\n                            new_solution.remove(r2)\n                            route_demands = [(sum(demand[route[1:-1]]), route) for route in new_solution]\n                            route_demands.sort(reverse=True, key=lambda x: x[0])\n                            merged = True\n                            break\n                    if merged:\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6047632002534374,
            9.981295496225357
        ],
        "raw_score": [
            55.56758580152062,
            7.038048702542487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6 * obj[1] + 0.4 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Identify high-demand segments\n        high_demand_segments = []\n        for route in new_solution:\n            customers = route[1:-1]\n            if len(customers) == 0:\n                continue\n            # Find the most demanding segment in the route\n            max_demand = -1\n            best_segment = None\n            for i in range(len(customers)):\n                for j in range(i, len(customers)):\n                    segment_demand = sum(demand[customers[i:j+1]])\n                    if segment_demand > max_demand:\n                        max_demand = segment_demand\n                        best_segment = customers[i:j+1]\n            if best_segment is not None:\n                high_demand_segments.append((route, best_segment))\n\n        if high_demand_segments:\n            # Select a random high-demand segment to move\n            route, segment = random.choice(high_demand_segments)\n            segment_demand = sum(demand[segment])\n\n            # Find the best route to insert the segment into\n            best_route = None\n            best_pos = None\n            best_cost = float('inf')\n\n            for candidate_route in new_solution:\n                if np.array_equal(candidate_route, route):\n                    continue\n                if sum(demand[candidate_route[1:-1]]) + segment_demand > capacity:\n                    continue\n\n                # Find optimal insertion position\n                for pos in range(1, len(candidate_route)):\n                    cost = (distance_matrix[candidate_route[pos-1]][segment[0]] +\n                            distance_matrix[segment[-1]][candidate_route[pos]] -\n                            distance_matrix[candidate_route[pos-1]][candidate_route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = candidate_route\n                        best_pos = pos\n\n            if best_route is not None and best_pos is not None:\n                # Insert the segment\n                new_route = np.concatenate([best_route[:best_pos], segment, best_route[best_pos:]])\n                new_solution.append(new_route)\n\n                # Remove the segment from the original route\n                original_customers = route[1:-1].tolist()\n                for customer in segment:\n                    original_customers.remove(customer)\n                if original_customers:\n                    new_route = [0] + original_customers + [0]\n                    new_solution.append(np.array(new_route))\n\n                # Rebuild the solution with the modified routes\n                temp_solution = []\n                for r in new_solution:\n                    if not np.array_equal(r, route) and not np.array_equal(r, best_route):\n                        temp_solution.append(r)\n                new_solution = temp_solution\n\n        # Demand-aware route merging\n        if len(new_solution) > 1:\n            # Sort routes by demand in descending order\n            route_demands = [(sum(demand[route[1:-1]]), route) for route in new_solution]\n            route_demands.sort(reverse=True, key=lambda x: x[0])\n\n            merged = True\n            while merged and len(new_solution) > 1:\n                merged = False\n                for i in range(len(route_demands)):\n                    for j in range(i+1, len(route_demands)):\n                        d1, r1 = route_demands[i]\n                        d2, r2 = route_demands[j]\n                        if d1 + d2 <= capacity:\n                            merged_route = np.concatenate([r1[:-1], r2[1:]])\n                            new_solution.append(merged_route)\n                            new_solution.remove(r1)\n                            new_solution.remove(r2)\n                            route_demands = [(sum(demand[route[1:-1]]), route) for route in new_solution]\n                            route_demands.sort(reverse=True, key=lambda x: x[0])\n                            merged = True\n                            break\n                    if merged:\n                        break\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm combines Pareto-aware selection with a multi-step hybrid operator: it first merges underutilized routes to reduce makespan, then performs demand-aware segment relinking between routes by exchanging high-distance segments, and finally applies capacity-preserving segment inversion in the longest route to optimize the distance-makespan tradeoff. The selection prioritizes makespan (60%) over distance (40%) and focuses on routes with low demand and short distances for merging, while ensuring capacity constraints are respected throughout.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    weights = np.array([0.4, 0.6])  # Slightly more emphasis on makespan\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Merge underutilized routes\n    if len(new_solution) >= 2:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find routes with low demand and short distance (potential for merging)\n        candidate_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if (route_demands[i] + route_demands[j] <= capacity * 0.8 and  # Leave some capacity slack\n                    route_distances[i] < np.mean(route_distances) and\n                    route_distances[j] < np.mean(route_distances)):\n                    candidate_pairs.append((i, j))\n\n        if candidate_pairs:\n            # Select the pair with the highest combined distance reduction potential\n            i, j = min(candidate_pairs, key=lambda x: route_distances[x[0]] + route_distances[x[1]])\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 2: Demand-aware segment relinking\n    if len(new_solution) >= 2:\n        # Calculate route characteristics\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find high-distance segments in each route\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            # Identify the longest segment in terms of distance\n            max_segment_distance = -1\n            best_segment = None\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    segment_distance = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                    if segment_distance > max_segment_distance:\n                        max_segment_distance = segment_distance\n                        best_segment = (i, j)\n\n            if best_segment:\n                i, j = best_segment\n                segment = route[i:j+1]\n                segment_demand = sum(demand[segment])\n\n                # Find compatible routes to exchange with\n                compatible_routes = []\n                for k in range(len(new_solution)):\n                    if k == route_idx:\n                        continue\n                    if sum(demand[new_solution[k][1:-1]]) + segment_demand <= capacity:\n                        compatible_routes.append(k)\n\n                if compatible_routes:\n                    # Select the route that would benefit most from the exchange\n                    best_route = min(compatible_routes, key=lambda k: sum(distance_matrix[new_solution[k][l]][new_solution[k][l+1]] for l in range(len(new_solution[k])-1)))\n                    target_route = new_solution[best_route]\n\n                    # Find insertion point in target route\n                    best_insertion = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(target_route)):\n                        insertion_distance = distance_matrix[target_route[pos-1]][segment[0]] + \\\n                                           distance_matrix[segment[-1]][target_route[pos]] - \\\n                                           distance_matrix[target_route[pos-1]][target_route[pos]]\n                        if insertion_distance < min_increase:\n                            min_increase = insertion_distance\n                            best_insertion = pos\n\n                    # Perform the exchange\n                    new_target_route = np.concatenate([target_route[:best_insertion], segment, target_route[best_insertion:]])\n                    new_solution[best_route] = new_target_route\n                    new_solution[route_idx] = np.concatenate([route[:i], route[j+1:]])\n\n    # Step 3: Capacity-preserving segment inversion\n    if len(new_solution) > 0:\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_distances)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:\n            # Find the segment with the most potential for distance reduction\n            max_potential = -1\n            best_segment = None\n            for i in range(1, len(longest_route)-2):\n                for j in range(i+1, len(longest_route)-1):\n                    original_distance = sum(distance_matrix[longest_route[k]][longest_route[k+1]] for k in range(i, j+1))\n                    reversed_distance = sum(distance_matrix[longest_route[k+1]][longest_route[k]] for k in range(i, j))\n                    potential = original_distance - reversed_distance\n                    if potential > max_potential and sum(demand[longest_route[i:j+1]]) <= capacity:\n                        max_potential = potential\n                        best_segment = (i, j)\n\n            if best_segment:\n                i, j = best_segment\n                reversed_segment = longest_route[i:j+1][::-1]\n                new_route = np.concatenate([longest_route[:i], reversed_segment, longest_route[j+1:]])\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm combines a dynamic Pareto-biased selection strategy (prioritizing makespan with 70% weight and distance with 30%) with a hybrid local search operator that adaptively decomposes and reinserts route segments while ensuring capacity constraints, followed by capacity-constrained route fusion to balance improvements in both objectives. It intelligently selects and modifies solutions by decomposing routes into segments, reinserting them optimally, and merging shorter routes into longer ones when feasible. The approach avoids dominated heuristics by focusing on high-makespan solutions while maintaining feasibility through real-time checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Adaptive route decomposition and segment insertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Decompose routes into segments with varying lengths\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n\n        # Insert segment into route2 in demand-aware manner\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert segment and update routes\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end + 1))\n\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Capacity-constrained route fusion\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                if sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Keywords:\n- **Adaptive chained operators**: Segment swaps + demand reallocation + capacity checks.\n- **Dynamic Pareto-biased selection**: Weighted randomness (70% makespan, 30% distance).\n- **Real-time feasibility checks**: Validate capacity and dominance at every step.\n- **Multi-objective chaining**: Link swaps and reallocations for high-impact improvements.\n\n### Advice:\n1. Chain segment swaps with weighted demand reallocation to balance distance and makespan.\n2. Use real-time capacity checks to reject infeasible moves immediately.\n3. Select neighbors based on Pareto-biased objectives (70% makespan, 30% distance).\n4. Design multi-step operators (e.g., swap + reallocate + validate) for efficiency.\n\n### Avoid:\n- Pure 2-opt or random splits (dominated heuristics).\n- Ignoring capacity constraints (infeasible solutions).\n- Static operators (e.g., pure 2-opt); use dynamic, hybrid strategies.\n- Ignoring objective trade-offs (focus on balanced improvements).\n\n### Explanation:\nAdaptive chaining of operators and dynamic Pareto-biased selection ensure balanced improvements. Real-time feasibility checks and multi-step operators avoid dominated heuristics and oversimplified approaches.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 305,
        "algorithm": "The algorithm combines an adaptive Pareto-biased selection (65% makespan, 35% distance) with a hybrid local search that dynamically decomposes routes into demand-balanced segments, reinserts them into compatible routes while preserving capacity constraints, and then applies multi-step segment inversion and reallocation to optimize both objectives. It prioritizes high-makespan solutions for improvement while intelligently balancing demand and avoiding dominated heuristics through real-time feasibility checks. The operator chains segment operations to create high-impact improvements in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.65 * obj[1] + 0.35 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Dynamic segment decomposition and reinsertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find demand-balanced segments in route1\n        total_demand = sum(demand[route1[1:-1]])\n        target_demand = total_demand * 0.4  # Aim for ~40% of route demand in segment\n        current_demand = 0\n        seg1_start = 1\n        seg1_end = 1\n\n        for i in range(1, len(route1)-1):\n            current_demand += demand[route1[i]]\n            if abs(current_demand - target_demand) < abs(sum(demand[route1[seg1_start:seg1_end+1]]) - target_demand):\n                seg1_start = i\n                seg1_end = i\n            if current_demand >= target_demand:\n                seg1_end = i\n                break\n\n        segment1 = route1[seg1_start:seg1_end+1]\n\n        # Check if segment can be inserted into route2\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Perform insertion\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end+1))\n\n            # Update solution\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Multi-step segment inversion and reallocation\n        if len(new_solution) > 1:\n            # Find the longest route\n            route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 4:\n                # Find segment with highest potential for inversion\n                max_potential = -1\n                best_segment = None\n                for i in range(1, len(longest_route)-2):\n                    for j in range(i+1, len(longest_route)-1):\n                        original_distance = sum(distance_matrix[longest_route[k]][longest_route[k+1]] for k in range(i, j+1))\n                        reversed_distance = sum(distance_matrix[longest_route[k+1]][longest_route[k]] for k in range(i, j))\n                        potential = original_distance - reversed_distance\n                        if potential > max_potential and sum(demand[longest_route[i:j+1]]) <= capacity:\n                            max_potential = potential\n                            best_segment = (i, j)\n\n                if best_segment:\n                    i, j = best_segment\n                    reversed_segment = longest_route[i:j+1][::-1]\n                    new_route = np.concatenate([longest_route[:i], reversed_segment, longest_route[j+1:]])\n                    new_solution[longest_route_idx] = new_route\n\n                    # Attempt to reallocate the segment to another route\n                    for route_idx in range(len(new_solution)):\n                        if route_idx == longest_route_idx:\n                            continue\n                        candidate_route = new_solution[route_idx]\n                        if sum(demand[candidate_route[1:-1]]) + sum(demand[reversed_segment]) <= capacity:\n                            # Find best insertion point\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(candidate_route)):\n                                cost = (distance_matrix[candidate_route[pos-1]][reversed_segment[0]] +\n                                        distance_matrix[reversed_segment[-1]][candidate_route[pos]] -\n                                        distance_matrix[candidate_route[pos-1]][candidate_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Perform reallocation\n                            new_candidate_route = np.concatenate([candidate_route[:best_pos], reversed_segment, candidate_route[best_pos:]])\n                            new_solution[route_idx] = new_candidate_route\n                            new_solution[longest_route_idx] = np.concatenate([longest_route[:i], longest_route[j+1:]])\n                            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7413487370980586,
            1.7170321643352509
        ],
        "raw_score": [
            37.70695409141822,
            4.3486922313357805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.65 * obj[1] + 0.35 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Dynamic segment decomposition and reinsertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find demand-balanced segments in route1\n        total_demand = sum(demand[route1[1:-1]])\n        target_demand = total_demand * 0.4  # Aim for ~40% of route demand in segment\n        current_demand = 0\n        seg1_start = 1\n        seg1_end = 1\n\n        for i in range(1, len(route1)-1):\n            current_demand += demand[route1[i]]\n            if abs(current_demand - target_demand) < abs(sum(demand[route1[seg1_start:seg1_end+1]]) - target_demand):\n                seg1_start = i\n                seg1_end = i\n            if current_demand >= target_demand:\n                seg1_end = i\n                break\n\n        segment1 = route1[seg1_start:seg1_end+1]\n\n        # Check if segment can be inserted into route2\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Perform insertion\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end+1))\n\n            # Update solution\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Multi-step segment inversion and reallocation\n        if len(new_solution) > 1:\n            # Find the longest route\n            route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 4:\n                # Find segment with highest potential for inversion\n                max_potential = -1\n                best_segment = None\n                for i in range(1, len(longest_route)-2):\n                    for j in range(i+1, len(longest_route)-1):\n                        original_distance = sum(distance_matrix[longest_route[k]][longest_route[k+1]] for k in range(i, j+1))\n                        reversed_distance = sum(distance_matrix[longest_route[k+1]][longest_route[k]] for k in range(i, j))\n                        potential = original_distance - reversed_distance\n                        if potential > max_potential and sum(demand[longest_route[i:j+1]]) <= capacity:\n                            max_potential = potential\n                            best_segment = (i, j)\n\n                if best_segment:\n                    i, j = best_segment\n                    reversed_segment = longest_route[i:j+1][::-1]\n                    new_route = np.concatenate([longest_route[:i], reversed_segment, longest_route[j+1:]])\n                    new_solution[longest_route_idx] = new_route\n\n                    # Attempt to reallocate the segment to another route\n                    for route_idx in range(len(new_solution)):\n                        if route_idx == longest_route_idx:\n                            continue\n                        candidate_route = new_solution[route_idx]\n                        if sum(demand[candidate_route[1:-1]]) + sum(demand[reversed_segment]) <= capacity:\n                            # Find best insertion point\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(candidate_route)):\n                                cost = (distance_matrix[candidate_route[pos-1]][reversed_segment[0]] +\n                                        distance_matrix[reversed_segment[-1]][candidate_route[pos]] -\n                                        distance_matrix[candidate_route[pos-1]][candidate_route[pos]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Perform reallocation\n                            new_candidate_route = np.concatenate([candidate_route[:best_pos], reversed_segment, candidate_route[best_pos:]])\n                            new_solution[route_idx] = new_candidate_route\n                            new_solution[longest_route_idx] = np.concatenate([longest_route[:i], longest_route[j+1:]])\n                            break\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm combines a dynamic Pareto-biased selection strategy (prioritizing makespan with 70% weight and distance with 30%) with a hybrid local search operator that adaptively decomposes and reinserts route segments while ensuring capacity constraints, followed by capacity-constrained route fusion to balance improvements in both objectives. It intelligently selects and modifies solutions by decomposing routes into segments, reinserting them optimally, and merging shorter routes into longer ones when feasible. The approach avoids dominated heuristics by focusing on high-makespan solutions while maintaining feasibility through real-time checks.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Adaptive route decomposition and segment insertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Decompose routes into segments with varying lengths\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n\n        # Insert segment into route2 in demand-aware manner\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert segment and update routes\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end + 1))\n\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Capacity-constrained route fusion\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                if sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 306,
        "algorithm": "The algorithm implements a hybrid local search combining route segment swapping with adaptive route balancing, prioritizing high-makespan solutions from the archive. It intelligently selects and swaps route segments based on demand similarity (within 30% capacity threshold) while dynamically transferring customers between imbalanced routes to optimize both distance and makespan objectives. The method ensures feasibility through strict capacity checks during segment swaps and customer transfers.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Segment swapping with adaptive demand balancing\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select segments with balanced demand\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n        seg1_demand = sum(demand[segment1])\n\n        # Find compatible segment in route2\n        for seg2_start in range(1, len(route2) - 1):\n            seg2_end = min(seg2_start + (seg1_end - seg1_start), len(route2) - 2)\n            segment2 = route2[seg2_start:seg2_end + 1]\n            seg2_demand = sum(demand[segment2])\n\n            if abs(seg1_demand - seg2_demand) <= capacity * 0.3:  # Demand similarity threshold\n                # Check capacity constraints\n                if (sum(demand[route1[1:-1]]) - seg1_demand + seg2_demand <= capacity and\n                    sum(demand[route2[1:-1]]) - seg2_demand + seg1_demand <= capacity):\n                    # Perform segment swap\n                    new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end+1:]])\n                    new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end+1:]])\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n        # Adaptive route balancing\n        route_lengths = [distance_matrix[route[-2]][route[1]] + np.sum(distance_matrix[route[:-2], route[1:-1]]) +\n                         np.sum(distance_matrix[route[1:-1], route[2:]]) for route in new_solution]\n\n        if len(new_solution) > 1:\n            # Find most imbalanced routes\n            longest_idx = np.argmax(route_lengths)\n            shortest_idx = np.argmin(route_lengths)\n\n            if longest_idx != shortest_idx:\n                longest_route = new_solution[longest_idx]\n                shortest_route = new_solution[shortest_idx]\n\n                # Check if we can transfer a customer from shortest to longest route\n                for i in range(1, len(shortest_route)-1):\n                    customer = shortest_route[i]\n                    if (sum(demand[longest_route[1:-1]]) + demand[customer] <= capacity and\n                        sum(demand[shortest_route[1:-1]]) - demand[customer] <= capacity):\n\n                        # Find optimal insertion position in longest route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(longest_route)):\n                            cost = (distance_matrix[longest_route[pos-1]][customer] +\n                                   distance_matrix[customer][longest_route[pos]] -\n                                   distance_matrix[longest_route[pos-1]][longest_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Perform transfer\n                        new_longest = np.insert(longest_route, best_pos, customer)\n                        new_shortest = np.delete(shortest_route, i)\n\n                        if len(new_shortest) > 2:\n                            new_solution[longest_idx] = new_longest\n                            new_solution[shortest_idx] = new_shortest\n                        else:\n                            new_solution[longest_idx] = new_longest\n                            del new_solution[shortest_idx]\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.49932351970048744,
            0.8904571235179901
        ],
        "raw_score": [
            50.6219278260642,
            6.893116060254317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Segment swapping with adaptive demand balancing\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select segments with balanced demand\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n        seg1_demand = sum(demand[segment1])\n\n        # Find compatible segment in route2\n        for seg2_start in range(1, len(route2) - 1):\n            seg2_end = min(seg2_start + (seg1_end - seg1_start), len(route2) - 2)\n            segment2 = route2[seg2_start:seg2_end + 1]\n            seg2_demand = sum(demand[segment2])\n\n            if abs(seg1_demand - seg2_demand) <= capacity * 0.3:  # Demand similarity threshold\n                # Check capacity constraints\n                if (sum(demand[route1[1:-1]]) - seg1_demand + seg2_demand <= capacity and\n                    sum(demand[route2[1:-1]]) - seg2_demand + seg1_demand <= capacity):\n                    # Perform segment swap\n                    new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end+1:]])\n                    new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end+1:]])\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    break\n\n        # Adaptive route balancing\n        route_lengths = [distance_matrix[route[-2]][route[1]] + np.sum(distance_matrix[route[:-2], route[1:-1]]) +\n                         np.sum(distance_matrix[route[1:-1], route[2:]]) for route in new_solution]\n\n        if len(new_solution) > 1:\n            # Find most imbalanced routes\n            longest_idx = np.argmax(route_lengths)\n            shortest_idx = np.argmin(route_lengths)\n\n            if longest_idx != shortest_idx:\n                longest_route = new_solution[longest_idx]\n                shortest_route = new_solution[shortest_idx]\n\n                # Check if we can transfer a customer from shortest to longest route\n                for i in range(1, len(shortest_route)-1):\n                    customer = shortest_route[i]\n                    if (sum(demand[longest_route[1:-1]]) + demand[customer] <= capacity and\n                        sum(demand[shortest_route[1:-1]]) - demand[customer] <= capacity):\n\n                        # Find optimal insertion position in longest route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(longest_route)):\n                            cost = (distance_matrix[longest_route[pos-1]][customer] +\n                                   distance_matrix[customer][longest_route[pos]] -\n                                   distance_matrix[longest_route[pos-1]][longest_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n\n                        # Perform transfer\n                        new_longest = np.insert(longest_route, best_pos, customer)\n                        new_shortest = np.delete(shortest_route, i)\n\n                        if len(new_shortest) > 2:\n                            new_solution[longest_idx] = new_longest\n                            new_solution[shortest_idx] = new_shortest\n                        else:\n                            new_solution[longest_idx] = new_longest\n                            del new_solution[shortest_idx]\n                        break\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm combines a dynamic Pareto-biased selection strategy (prioritizing makespan with 70% weight and distance with 30%) with a hybrid local search operator that adaptively decomposes and reinserts route segments while ensuring capacity constraints, followed by capacity-constrained route fusion to balance improvements in both objectives. It intelligently selects and modifies solutions by decomposing routes into segments, reinserting them optimally, and merging shorter routes into longer ones when feasible. The approach avoids dominated heuristics by focusing on high-makespan solutions while maintaining feasibility through real-time checks.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Adaptive route decomposition and segment insertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Decompose routes into segments with varying lengths\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n\n        # Insert segment into route2 in demand-aware manner\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert segment and update routes\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end + 1))\n\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Capacity-constrained route fusion\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                if sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 307,
        "algorithm": "The algorithm implements a Pareto-biased selection strategy (prioritizing distance with 60% weight and makespan with 40%) combined with a hybrid local search that adaptively decomposes and reinserts route segments while ensuring capacity constraints, followed by capacity-constrained route splitting to balance improvements in both objectives. It intelligently selects and modifies solutions by decomposing routes into segments, reinserting them optimally, and splitting longer routes into shorter ones when feasible. The method avoids pure 2-opt by incorporating demand-aware segment insertion and adaptive route decomposition.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Adaptive route decomposition and segment insertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Decompose routes into segments with varying lengths\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n\n        # Insert segment into route2 in demand-aware manner\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert segment and update routes\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end + 1))\n\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Capacity-constrained route splitting\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:\n                split_pos = random.randint(2, len(longest_route) - 2)\n                if sum(demand[longest_route[1:split_pos]]) <= capacity and sum(demand[longest_route[split_pos:-1]]) <= capacity:\n                    new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n                    new_route2 = np.concatenate([[0], longest_route[split_pos:-1], [0]])\n                    new_solution[longest_route_idx] = new_route1\n                    new_solution.insert(longest_route_idx + 1, new_route2)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5227068123820812,
            1.529973953962326
        ],
        "raw_score": [
            42.98462063808989,
            2.778594677031146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Adaptive route decomposition and segment insertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Decompose routes into segments with varying lengths\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n\n        # Insert segment into route2 in demand-aware manner\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert segment and update routes\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end + 1))\n\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Capacity-constrained route splitting\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:\n                split_pos = random.randint(2, len(longest_route) - 2)\n                if sum(demand[longest_route[1:split_pos]]) <= capacity and sum(demand[longest_route[split_pos:-1]]) <= capacity:\n                    new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n                    new_route2 = np.concatenate([[0], longest_route[split_pos:-1], [0]])\n                    new_solution[longest_route_idx] = new_route1\n                    new_solution.insert(longest_route_idx + 1, new_route2)\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 6 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm combines a dynamic Pareto-biased selection strategy (prioritizing makespan with 70% weight and distance with 30%) with a hybrid local search operator that adaptively decomposes and reinserts route segments while ensuring capacity constraints, followed by capacity-constrained route fusion to balance improvements in both objectives. It intelligently selects and modifies solutions by decomposing routes into segments, reinserting them optimally, and merging shorter routes into longer ones when feasible. The approach avoids dominated heuristics by focusing on high-makespan solutions while maintaining feasibility through real-time checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Adaptive route decomposition and segment insertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Decompose routes into segments with varying lengths\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        segment1 = route1[seg1_start:seg1_end + 1]\n\n        # Insert segment into route2 in demand-aware manner\n        if sum(demand[route2[1:-1]]) + sum(demand[segment1]) <= capacity:\n            # Find optimal insertion position in route2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route2)):\n                cost = (distance_matrix[route2[pos-1]][segment1[0]] +\n                        distance_matrix[segment1[-1]][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            # Insert segment and update routes\n            new_route2 = np.concatenate([route2[:best_pos], segment1, route2[best_pos:]])\n            new_route1 = np.delete(route1, slice(seg1_start, seg1_end + 1))\n\n            if len(new_route1) > 2:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                new_solution[route2_idx] = new_route2\n                del new_solution[route1_idx]\n\n        # Capacity-constrained route fusion\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                if sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a Pareto-biased solution (70% makespan, 30% distance) and applies a hybrid local search combining segment swaps between routes and dynamic demand reallocation, ensuring feasibility by real-time capacity validation and balancing objectives through multi-step improvements. It prioritizes makespan reduction by favoring solutions with longer routes and performs segment swaps while optionally reallocating customers to better balance demand across routes. The selection is biased toward solutions with higher makespan to focus improvement efforts on the more critical objective.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n            segment1 = route1[seg1_start:seg1_end + 1]\n            segment2 = route2[seg2_start:seg2_end + 1]\n\n            if (sum(demand[route1]) - sum(demand[segment1]) + sum(demand[segment2]) <= capacity and\n                sum(demand[route2]) - sum(demand[segment2]) + sum(demand[segment1]) <= capacity):\n\n                new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end + 1:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                if random.random() < 0.5:\n                    for route in new_solution:\n                        if len(route) > 3:\n                            customer = random.choice(route[1:-1])\n                            for target_route in new_solution:\n                                if target_route is not route and sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                    best_pos = 1\n                                    best_cost = float('inf')\n                                    for pos in range(1, len(target_route)):\n                                        cost = (distance_matrix[target_route[pos-1]][customer] +\n                                                distance_matrix[customer][target_route[pos]] -\n                                                distance_matrix[target_route[pos-1]][target_route[pos]])\n                                        if cost < best_cost:\n                                            best_cost = cost\n                                            best_pos = pos\n                                    target_route = np.insert(target_route, best_pos, customer)\n                                    route = np.delete(route, np.where(route == customer)[0][0])\n                                    break\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThis algorithm selects a solution from the archive using a weighted Pareto-aware approach (prioritizing makespan over distance) and applies a hybrid local search combining segment swaps, demand-aware reallocation, and capacity-constrained route merging to balance both objectives while ensuring feasibility through multi-step validation. The method prioritizes reducing the longest routes by intelligently reallocating customers between routes while maintaining vehicle capacity constraints, and it uses randomized segment swaps to explore the solution space efficiently.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap with demand-aware reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split each route at random positions\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Create segments\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine segments and reinsert customers\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        np.random.shuffle(combined_segments)\n\n        # Rebuild routes with capacity checks\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        # Additional demand-aware reallocation step\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                for customer in longest_route[1:-1]:\n                    if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for i in range(1, len(shortest_route)):\n                            cost = distance_matrix[shortest_route[i-1], customer] + distance_matrix[customer, shortest_route[i]] - distance_matrix[shortest_route[i-1], shortest_route[i]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = i\n\n                        new_shortest = np.insert(shortest_route, best_pos, customer)\n                        new_longest = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                        new_solution[shortest_route_idx] = new_shortest\n                        new_solution[longest_route_idx] = new_longest\n                        break\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    nondominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    weights = [1 / (obj[0] + obj[1]) for _, obj in nondominated]\n    selected_idx = random.choices(range(len(nondominated)), weights=weights, k=1)[0]\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: demand-driven segment swaps and capacity-aware reinsertion\n    if len(new_solution) >= 2:\n        # Identify the longest route (for makespan optimization)\n        makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = makespans.index(max(makespans))\n        longest_route = new_solution[longest_route_idx]\n\n        # Select a segment from the longest route to swap\n        if len(longest_route) > 3:\n            a, b = sorted(random.sample(range(1, len(longest_route)-1), 2))\n            segment = longest_route[a:b+1]\n            segment_demand = np.sum(demand[segment])\n\n            # Find the best route to insert the segment\n            best_route_idx = -1\n            best_improvement = 0\n\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx or len(route) == 2:\n                    continue\n\n                # Check capacity constraint\n                if np.sum(demand[route]) + segment_demand <= capacity:\n                    # Calculate potential improvement\n                    prev_node = route[-2]\n                    next_node = 0 if len(route) == 1 else route[1]\n                    old_distance = distance_matrix[prev_node][next_node]\n                    new_distance = distance_matrix[prev_node][segment[0]] + distance_matrix[segment[-1]][next_node]\n                    improvement = old_distance - new_distance\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = i\n\n            if best_route_idx != -1:\n                # Insert the segment into the best route\n                best_route = new_solution[best_route_idx]\n                new_route = np.concatenate([best_route[:-1], segment, [0]])\n                new_solution[best_route_idx] = new_route\n\n                # Remove the segment from the longest route\n                new_longest_route = np.concatenate([longest_route[:a], longest_route[b+1:]])\n                new_solution[longest_route_idx] = new_longest_route\n\n                # If the longest route is now empty, remove it\n                if len(new_longest_route) <= 2:\n                    del new_solution[longest_route_idx]\n\n    # Apply a 2-opt-like improvement on the longest route to further optimize makespan\n    if len(new_solution) > 0:\n        makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = makespans.index(max(makespans))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            a, b = sorted(random.sample(range(1, len(longest_route)-1), 2))\n            reversed_segment = longest_route[a:b+1][::-1]\n            new_route = np.concatenate([longest_route[:a], reversed_segment, longest_route[b+1:]])\n\n            # Check capacity constraint\n            if np.sum(demand[new_route]) <= capacity:\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm combines nondominated solution selection with a hybrid local search that prioritizes demand-based customer reallocation and targeted 2-opt optimization, dynamically balancing distance and makespan improvements while maintaining feasibility through capacity-aware reinsertion. It first identifies nondominated solutions, selects one probabilistically, then reallocates high-demand customers from the longest route to others while ensuring capacity constraints, followed by a 2-opt improvement on the longest route to further refine the makespan. The method intelligently balances exploration and exploitation by leveraging demand-based prioritization and spatial distribution awareness.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    nondominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select a solution from nondominated solutions\n    weights = [1 / (obj[0] + obj[1]) for _, obj in nondominated]\n    selected_idx = random.choices(range(len(nondominated)), weights=weights, k=1)[0]\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: demand-based customer reallocation\n    if len(new_solution) >= 2:\n        # Identify the longest route (for makespan optimization)\n        makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = makespans.index(max(makespans))\n        longest_route = new_solution[longest_route_idx]\n\n        # Select customers to reallocate based on demand and spatial distribution\n        if len(longest_route) > 3:\n            # Sort customers by demand (descending) to prioritize high-demand customers\n            customers = longest_route[1:-1]\n            sorted_customers = sorted(customers, key=lambda x: -demand[x])\n\n            # Try to reallocate each customer to another route\n            for customer in sorted_customers:\n                best_route_idx = -1\n                best_improvement = 0\n\n                for i, route in enumerate(new_solution):\n                    if i == longest_route_idx or len(route) == 2:  # Skip the longest route and empty routes\n                        continue\n\n                    # Calculate the potential new demand for the route\n                    new_demand = np.sum(demand[route]) + demand[customer]\n\n                    if new_demand <= capacity:\n                        # Calculate the potential improvement (distance reduction)\n                        prev_node = route[-2]\n                        next_node = 0 if len(route) == 1 else route[1]\n                        old_distance = distance_matrix[prev_node][next_node]\n                        new_distance = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                        improvement = old_distance - new_distance\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_route_idx = i\n\n                if best_route_idx != -1:\n                    # Reallocate the customer\n                    new_route = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                    new_solution[best_route_idx] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                    new_solution[longest_route_idx] = longest_route\n\n                    # If the longest route is now empty, remove it\n                    if len(longest_route) <= 2:\n                        del new_solution[longest_route_idx]\n                        break\n\n        # Apply 2-opt on the longest route to further optimize makespan\n        if len(new_solution) > 0:\n            makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            longest_route_idx = makespans.index(max(makespans))\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:\n                # Try reversing a random segment\n                a, b = sorted(random.sample(range(1, len(longest_route)-1), 2))\n                reversed_segment = longest_route[a:b+1][::-1]\n                new_route = np.concatenate([longest_route[:a], reversed_segment, longest_route[b+1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route]) <= capacity:\n                    new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower makespan and total distance), then applies a hybrid local search that merges two routes and reinserts their customers into new routes while respecting capacity constraints. The selected routes are removed, their customers are shuffled, and reinserted into new routes with a greedy approach, ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) >= 2:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge the two routes (excluding the depot)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the selected routes from the solution\n        del new_solution[max(route1_idx, route2_idx)]\n        del new_solution[min(route1_idx, route2_idx)]\n\n        # Reinsert customers from the merged route into new routes\n        remaining_customers = merged_route[1:-1]  # Exclude depots\n        np.random.shuffle(remaining_customers)\n\n        # Create new routes while respecting capacity\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in remaining_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Keywords:\n- **Adaptive chained operators**: Segment swaps + demand reallocation + capacity checks.\n- **Dynamic Pareto-biased selection**: Weighted randomness (70% makespan, 30% distance).\n- **Real-time feasibility checks**: Validate capacity and dominance at every step.\n- **Multi-objective chaining**: Link swaps and reallocations for high-impact improvements.\n\n### Advice:\n1. Chain segment swaps with weighted demand reallocation to balance distance and makespan.\n2. Use real-time capacity checks to reject infeasible moves immediately.\n3. Select neighbors based on Pareto-biased objectives (70% makespan, 30% distance).\n4. Design multi-step operators (e.g., swap + reallocate + validate) for efficiency.\n\n### Avoid:\n- Pure 2-opt or random splits (dominated heuristics).\n- Ignoring capacity constraints (infeasible solutions).\n- Static operators (e.g., pure 2-opt); use dynamic, hybrid strategies.\n- Ignoring objective trade-offs (focus on balanced improvements).\n\n### Explanation:\nAdaptive chaining of operators and dynamic Pareto-biased selection ensure balanced improvements. Real-time feasibility checks and multi-step operators avoid dominated heuristics and oversimplified approaches.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 308,
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of makespan (70%) and distance (30%), then applies a hybrid local search combining segment swaps between routes, demand-aware customer reallocation from the longest route, and capacity-constrained route merging to improve both objectives while maintaining feasibility. It prioritizes high-demand customers for reallocation and dynamically adjusts the focus between objectives based on the current solution's characteristics.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap + demand reallocation + route merging\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Segment swap between two routes\n        if len(route1) > 3 and len(route2) > 3:\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n            segment1 = route1[seg1_start:seg1_end + 1]\n            segment2 = route2[seg2_start:seg2_end + 1]\n\n            if (sum(demand[route1]) - sum(demand[segment1]) + sum(demand[segment2]) <= capacity and\n                sum(demand[route2]) - sum(demand[segment2]) + sum(demand[segment1]) <= capacity):\n\n                new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end + 1:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n        # Demand-aware reallocation from longest route\n        makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(makespans)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            customers = sorted(longest_route[1:-1], key=lambda x: -demand[x])\n            for customer in customers:\n                best_route_idx = -1\n                best_improvement = 0\n\n                for i, route in enumerate(new_solution):\n                    if i == longest_route_idx or len(route) == 2:\n                        continue\n\n                    if sum(demand[route]) + demand[customer] <= capacity:\n                        prev_node = route[-2]\n                        next_node = route[1] if len(route) > 2 else 0\n                        old_distance = distance_matrix[prev_node][next_node]\n                        new_distance = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                        improvement = old_distance - new_distance\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_route_idx = i\n\n                if best_route_idx != -1:\n                    new_route = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                    new_solution[best_route_idx] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                    new_solution[longest_route_idx] = longest_route\n\n                    if len(longest_route) <= 2:\n                        del new_solution[longest_route_idx]\n                        break\n\n        # Capacity-constrained route merging\n        if len(new_solution) > 1:\n            makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            longest_route_idx = np.argmax(makespans)\n            shortest_route_idx = np.argmin(makespans)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                if sum(demand[longest_route]) + sum(demand[shortest_route]) <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6116543748772024,
            1.8304382264614105
        ],
        "raw_score": [
            34.43273607850615,
            3.9667235121753377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap + demand reallocation + route merging\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Segment swap between two routes\n        if len(route1) > 3 and len(route2) > 3:\n            seg1_start = random.randint(1, len(route1) - 2)\n            seg1_end = random.randint(seg1_start, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 2)\n            seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n            segment1 = route1[seg1_start:seg1_end + 1]\n            segment2 = route2[seg2_start:seg2_end + 1]\n\n            if (sum(demand[route1]) - sum(demand[segment1]) + sum(demand[segment2]) <= capacity and\n                sum(demand[route2]) - sum(demand[segment2]) + sum(demand[segment1]) <= capacity):\n\n                new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end + 1:]])\n                new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end + 1:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n        # Demand-aware reallocation from longest route\n        makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(makespans)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:\n            customers = sorted(longest_route[1:-1], key=lambda x: -demand[x])\n            for customer in customers:\n                best_route_idx = -1\n                best_improvement = 0\n\n                for i, route in enumerate(new_solution):\n                    if i == longest_route_idx or len(route) == 2:\n                        continue\n\n                    if sum(demand[route]) + demand[customer] <= capacity:\n                        prev_node = route[-2]\n                        next_node = route[1] if len(route) > 2 else 0\n                        old_distance = distance_matrix[prev_node][next_node]\n                        new_distance = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n                        improvement = old_distance - new_distance\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_route_idx = i\n\n                if best_route_idx != -1:\n                    new_route = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                    new_solution[best_route_idx] = new_route\n                    longest_route = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                    new_solution[longest_route_idx] = longest_route\n\n                    if len(longest_route) <= 2:\n                        del new_solution[longest_route_idx]\n                        break\n\n        # Capacity-constrained route merging\n        if len(new_solution) > 1:\n            makespans = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            longest_route_idx = np.argmax(makespans)\n            shortest_route_idx = np.argmin(makespans)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                if sum(demand[longest_route]) + sum(demand[shortest_route]) <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have 8 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm prioritizes solutions with lower total distance, applies a hybrid local search that splits the longest route and rebalances customers between routes to minimize makespan while ensuring capacity constraints are met. It intelligently selects customers to move between routes based on insertion cost, avoiding pure 2-opt and instead combining route splitting and rebalancing for balanced multi-objective improvement.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route (highest makespan)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        route1 = np.concatenate([longest_route[:split_pos], [0]])\n        route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([route1, route2])\n\n        # Step 2: Rebalance customers between routes to minimize makespan\n        for route in new_solution:\n            if len(route) > 2:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != longest_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert the customer into the target route\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[longest_route_idx] = np.delete(route, customer_idx)\n                                break\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using weighted Pareto-aware selection (prioritizing distance over makespan) and applies a hybrid local search that combines segment swaps with dynamic customer reallocation between routes, ensuring capacity feasibility while balancing improvements to both objectives. The selection weights (0.7 for distance, 0.3 for makespan) guide the focus toward distance optimization, while the segment swap and reallocation strategy introduces diversity and potential for multi-objective trade-offs. The solution is validated to ensure vehicle capacity constraints are met before returning the improved neighbor.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap with dynamic reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split each route at a random position\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Create segments\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine segments and reinsert customers\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        np.random.shuffle(combined_segments)\n\n        # Rebuild routes with capacity checks\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using balanced Pareto-aware selection (equal weights for distance and makespan) and applies a novel local search combining route merging, customer reinsertion, and demand-aware splitting to improve both objectives while ensuring feasibility through strict capacity validation. The selected solution undergoes random merging of two routes, followed by shuffling and re-splitting customers to form new feasible routes, prioritizing demand constraints over distance reduction. The neighbor solution is returned if it maintains feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.5, 0.5])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Route merging with demand-aware splitting\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge routes and shuffle customers\n        merged_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        np.random.shuffle(merged_customers)\n\n        # Demand-aware splitting\n        temp_solution = []\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in merged_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted Pareto-aware approach (prioritizing makespan over distance) and applies a hybrid local search combining dynamic segment swaps, demand-aware reallocation, and capacity-preserving route merging to balance objectives while ensuring feasibility. The solution is chosen based on normalized scores (30% distance, 70% makespan), and the local search operator dynamically reshuffles route segments, reallocates customers based on demand, and merges routes when feasible. The method prioritizes reducing the longest route (makespan) while maintaining capacity constraints and improving overall distance.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Dynamic segment swaps\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        # Demand-aware reallocation\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        # Capacity-preserving route merging\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                merged_demand = sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]])\n                if merged_demand <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a combined objective score (sum of distance and makespan) to identify promising candidates, then applies a hybrid local search that splits routes and intelligently reinserts customers based on weighted distance savings and makespan reduction, while ensuring capacity constraints through dynamic validation and a multi-step rebalancing phase that redistributes customers between routes to improve both objectives. The method prioritizes distance savings in reinsertion decisions and focuses on the most significant improvements during the rebalancing phase.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[0] + obj[1]) for obj in [x[1] for x in archive]]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: route splitting with intelligent reinsertion\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Split route at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        seg1, seg2 = route[:split_pos + 1], route[split_pos:]\n\n        # Remove original route\n        del new_solution[route_idx]\n\n        # Reinsert customers from both segments into new routes\n        customers = np.concatenate([seg1[1:-1], seg2[1:-1]])\n        np.random.shuffle(customers)\n\n        # Create new routes with weighted reinsertion (distance + makespan)\n        current_route = [0]\n        current_load = 0.0\n        temp_solution = []\n\n        for customer in customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Multi-step rebalancing phase\n        if len(temp_solution) > 1:\n            # Calculate potential improvements for each customer\n            improvements = []\n            for i, route in enumerate(temp_solution):\n                for j, customer in enumerate(route[1:-1]):\n                    # Calculate distance savings if moved to another route\n                    prev_node = route[j]\n                    next_node = route[j + 2] if j + 2 < len(route) else 0\n                    current_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n                    # Find best alternative route\n                    best_dist = float('inf')\n                    best_route_idx = -1\n                    for k, alt_route in enumerate(temp_solution):\n                        if k == i:\n                            continue\n                        # Check if adding to this route is feasible\n                        if sum(demand[alt_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate insertion cost\n                            for l in range(len(alt_route) - 1):\n                                insert_dist = (distance_matrix[alt_route[l], customer] +\n                                              distance_matrix[customer, alt_route[l + 1]] -\n                                              distance_matrix[alt_route[l], alt_route[l + 1]])\n                                if insert_dist < best_dist:\n                                    best_dist = insert_dist\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        improvements.append((i, j, best_route_idx, current_dist - best_dist))\n\n            # Sort improvements by potential savings (distance + makespan)\n            improvements.sort(key=lambda x: x[3], reverse=True)\n\n            # Apply the best improvements\n            for i, j, best_route_idx, _ in improvements[:min(3, len(improvements))]:\n                route = temp_solution[i]\n                customer = route[j + 1]\n\n                # Remove from current route\n                route = np.concatenate([route[:j + 1], route[j + 2:]])\n                if len(route) == 1:\n                    del temp_solution[i]\n                else:\n                    temp_solution[i] = route\n\n                # Insert into best alternative route\n                alt_route = temp_solution[best_route_idx]\n                best_pos = 0\n                best_insert_cost = float('inf')\n\n                # Find best insertion position\n                for k in range(len(alt_route) - 1):\n                    insert_cost = (distance_matrix[alt_route[k], customer] +\n                                 distance_matrix[customer, alt_route[k + 1]] -\n                                 distance_matrix[alt_route[k], alt_route[k + 1]])\n                    if insert_cost < best_insert_cost:\n                        best_insert_cost = insert_cost\n                        best_pos = k + 1\n\n                # Insert customer\n                alt_route = np.insert(alt_route, best_pos, customer)\n                temp_solution[best_route_idx] = alt_route\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm implements a Pareto-aware hybrid local search that dynamically selects between four novel operators (route expansion, demand-aware segment relocation, adaptive route splitting, and balanced route balancing) based on the current solution's objective trade-off, prioritizing distance reduction when routes are highly imbalanced, improving makespan by relocating incompatible demand segments between routes when distance dominates, splitting routes when beneficial for both objectives, and balancing route lengths to improve both objectives simultaneously. The selection of operators is guided by route length metrics (e.g., makespan vs. average route distance), and all operations ensure feasibility by respecting vehicle capacity constraints.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    makespan = max(route_distances)\n\n    # Operator selection based on current trade-off\n    if len(new_solution) >= 2 and makespan > 1.3 * np.mean(route_distances):  # Route expansion\n        # Add a node from one route to another to balance makespan\n        shortest_idx = np.argmin(route_distances)\n        shortest_route = new_solution[shortest_idx]\n\n        if len(shortest_route) > 3:\n            # Find node to move that maximizes makespan improvement\n            best_improvement = 0\n            best_node = None\n            for node in shortest_route[1:-1]:\n                # Calculate potential makespan improvement if this node is moved\n                temp_route = np.delete(shortest_route, np.where(shortest_route == node)[0][0])\n                temp_distance = sum(distance_matrix[temp_route[i]][temp_route[i+1]] for i in range(len(temp_route)-1))\n                improvement = route_distances[shortest_idx] - temp_distance\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = node\n\n            if best_node is not None:\n                # Find best route to insert the node into\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for i in range(len(new_solution)):\n                    if i != shortest_idx:\n                        route = new_solution[i]\n                        for pos in range(1, len(route)):\n                            cost = (distance_matrix[route[pos-1]][best_node] +\n                                    distance_matrix[best_node][route[pos]] -\n                                    distance_matrix[route[pos-1]][route[pos]])\n                            if cost < best_cost and sum(demand[route[1:-1]]) + demand[best_node] <= capacity:\n                                best_cost = cost\n                                best_route = i\n                                best_pos = pos\n\n                if best_route is not None:\n                    new_route = np.insert(new_solution[best_route], best_pos, best_node)\n                    new_solution[best_route] = new_route\n                    new_solution[shortest_idx] = np.delete(shortest_route, np.where(shortest_route == best_node)[0][0])\n    elif makespan < 0.8 * np.mean(route_distances):  # Demand-aware segment relocation\n        # Move segments between routes to improve both objectives\n        candidate_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(len(new_solution)):\n                if i != j and route_demands[i] + route_demands[j] <= capacity:\n                    candidate_pairs.append((i, j))\n\n        if candidate_pairs:\n            i, j = random.choice(candidate_pairs)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Find compatible segment in route_j to insert into route_i\n            for k in range(1, len(route_j)-1):\n                segment = route_j[k]\n                if sum(demand[route_i[1:-1]]) + demand[segment] <= capacity:\n                    # Find best insertion point in route_i\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route_i)):\n                        cost = (distance_matrix[route_i[pos-1]][segment] +\n                                distance_matrix[segment][route_i[pos]] -\n                                distance_matrix[route_i[pos-1]][route_i[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform insertion\n                    new_route_i = np.insert(route_i, best_pos, segment)\n                    new_route_j = np.delete(route_j, k)\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n    elif len(new_solution) >= 3:  # Adaptive route splitting\n        # Split a long route into two to improve makespan\n        longest_idx = np.argmax(route_distances)\n        longest_route = new_solution[longest_idx]\n\n        if len(longest_route) > 5:\n            # Find best split point that balances the two new routes\n            best_split = None\n            best_balance = float('inf')\n\n            for split in range(2, len(longest_route)-2):\n                first_part = longest_route[:split+1]\n                second_part = np.concatenate([[0], longest_route[split:]])\n\n                first_demand = sum(demand[first_part[1:-1]])\n                second_demand = sum(demand[second_part[1:-1]])\n\n                if first_demand <= capacity and second_demand <= capacity:\n                    first_distance = sum(distance_matrix[first_part[i]][first_part[i+1]] for i in range(len(first_part)-1))\n                    second_distance = sum(distance_matrix[second_part[i]][second_part[i+1]] for i in range(len(second_part)-1))\n                    balance = abs(first_distance - second_distance)\n\n                    if balance < best_balance:\n                        best_balance = balance\n                        best_split = split\n\n            if best_split is not None:\n                first_part = longest_route[:best_split+1]\n                second_part = np.concatenate([[0], longest_route[best_split:]])\n                new_solution[longest_idx] = first_part\n                new_solution.insert(longest_idx+1, second_part)\n    else:  # Balanced route balancing\n        # Adjust routes to balance their lengths\n        avg_distance = np.mean(route_distances)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            current_distance = route_distances[i]\n\n            if current_distance > avg_distance * 1.1:  # Long route\n                # Try to move a node to a shorter route\n                for j in range(len(new_solution)):\n                    if j != i and route_distances[j] < avg_distance * 0.9:\n                        for k in range(1, len(route)-1):\n                            node = route[k]\n                            if sum(demand[new_solution[j][1:-1]]) + demand[node] <= capacity:\n                                # Find best insertion point\n                                best_pos = 1\n                                best_cost = float('inf')\n                                for pos in range(1, len(new_solution[j])):\n                                    cost = (distance_matrix[new_solution[j][pos-1]][node] +\n                                            distance_matrix[node][new_solution[j][pos]] -\n                                            distance_matrix[new_solution[j][pos-1]][new_solution[j][pos]])\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_pos = pos\n\n                                # Perform move\n                                new_solution[j] = np.insert(new_solution[j], best_pos, node)\n                                new_solution[i] = np.delete(route, k)\n                                break\n                        break\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm implements a Pareto-biased selection mechanism (70% makespan, 30% distance) to prioritize solutions, followed by a hybrid local search that performs demand-aware segment swaps between routes while ensuring capacity constraints are respected. It adaptively selects segments based on demand balance and validates feasibility before applying swaps, avoiding pure 2-opt by combining segment swaps with weighted demand reallocation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1]*0.7 + x[1][0]*0.3))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: adaptive demand-aware segment swaps\n    if len(new_solution) >= 2:\n        # Select two routes for segment swap\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find segments to swap based on demand balance\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                segment1 = route1[i:]\n                segment2 = route2[j:]\n\n                # Calculate demand of segments\n                demand1 = sum(demand[segment1])\n                demand2 = sum(demand[segment2])\n\n                # Check capacity constraints after swap\n                new_route1 = np.concatenate([route1[:i], segment2, [0]])\n                new_route2 = np.concatenate([route2[:j], segment1, [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n\n                    # Perform the swap\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n                    return new_solution\n\n    return new_solution\n\n\nNo. 8 algorithm's description and the corresponding code are:\nThe algorithm combines adaptive segment-based routing with dynamic demand redistribution, prioritizing makespan reduction (70%) over distance optimization (30%) by selecting balanced solutions, then performing multi-phase segment swaps with demand-weighted insertion costs and probabilistic chaining of segment swaps to improve both objectives while maintaining feasibility through capacity validation. It intelligently selects segments based on demand and route structure, ensuring feasible solutions through real-time capacity checks. The hybrid approach balances exploitation of route segments with exploration of demand redistribution to create high-quality neighbors.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Phase 1: Adaptive segment-based routing with demand redistribution\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Split route into segments with demand-weighted selection\n            split_pos = random.randint(1, len(route) - 2)\n            seg1, seg2 = route[:split_pos + 1], route[split_pos:]\n\n            # Calculate demand-weighted insertion costs for segment swaps\n            customers = np.concatenate([seg1[1:-1], seg2[1:-1]])\n            np.random.shuffle(customers)\n\n            # Create new routes with demand-aware insertion\n            temp_solution = []\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n            # Phase 2: Probabilistic chaining of segment swaps and demand rebalancing\n            if len(temp_solution) >= 2 and random.random() < 0.6:\n                # Select two routes for segment swap\n                route1_idx, route2_idx = random.sample(range(len(temp_solution)), 2)\n                route1 = temp_solution[route1_idx]\n                route2 = temp_solution[route2_idx]\n\n                if len(route1) > 3 and len(route2) > 3:\n                    # Select segments with demand-weighted probability\n                    seg1_start = random.randint(1, len(route1) - 2)\n                    seg1_end = random.randint(seg1_start, len(route1) - 2)\n                    seg2_start = random.randint(1, len(route2) - 2)\n                    seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n                    segment1 = route1[seg1_start:seg1_end + 1]\n                    segment2 = route2[seg2_start:seg2_end + 1]\n\n                    # Check feasibility with demand redistribution\n                    if (sum(demand[route1]) - sum(demand[segment1]) + sum(demand[segment2]) <= capacity and\n                        sum(demand[route2]) - sum(demand[segment2]) + sum(demand[segment1]) <= capacity):\n\n                        # Perform segment swap with demand-weighted insertion\n                        new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end + 1:]])\n                        new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end + 1:]])\n\n                        temp_solution[route1_idx] = new_route1\n                        temp_solution[route2_idx] = new_route2\n\n            # Validate and update solution\n            if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n                new_solution = temp_solution\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### Keywords:\n- **Adaptive chained operators**: Segment swaps + demand reallocation + capacity checks.\n- **Dynamic Pareto-biased selection**: Weighted randomness (70% makespan, 30% distance).\n- **Real-time feasibility checks**: Validate capacity and dominance at every step.\n- **Multi-objective chaining**: Link swaps and reallocations for high-impact improvements.\n\n### Advice:\n1. Chain segment swaps with weighted demand reallocation to balance distance and makespan.\n2. Use real-time capacity checks to reject infeasible moves immediately.\n3. Select neighbors based on Pareto-biased objectives (70% makespan, 30% distance).\n4. Design multi-step operators (e.g., swap + reallocate + validate) for efficiency.\n\n### Avoid:\n- Pure 2-opt or random splits (dominated heuristics).\n- Ignoring capacity constraints (infeasible solutions).\n- Static operators (e.g., pure 2-opt); use dynamic, hybrid strategies.\n- Ignoring objective trade-offs (focus on balanced improvements).\n\n### Explanation:\nAdaptive chaining of operators and dynamic Pareto-biased selection ensure balanced improvements. Real-time feasibility checks and multi-step operators avoid dominated heuristics and oversimplified approaches.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 309,
        "algorithm": "The algorithm selects a Pareto-biased solution (prioritizing makespan over distance) and applies a hybrid local search combining adaptive segment swaps and demand-weighted reallocation, ensuring capacity feasibility through real-time validation. It first performs a segment swap between two randomly selected routes, then conditionally applies a multi-phase improvement chaining step to further optimize the solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Phase 1: Adaptive segment swap with demand-weighted selection\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select segments with demand-weighted probability\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        seg2_start = random.randint(1, len(route2) - 2)\n        seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n        segment1 = route1[seg1_start:seg1_end + 1]\n        segment2 = route2[seg2_start:seg2_end + 1]\n\n        # Check feasibility with demand redistribution\n        if (sum(demand[route1]) - sum(demand[segment1]) + sum(demand[segment2]) <= capacity and\n            sum(demand[route2]) - sum(demand[segment2]) + sum(demand[segment1]) <= capacity):\n\n            # Perform segment swap with demand-weighted insertion\n            new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end + 1:]])\n            new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end + 1:]])\n\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n        # Phase 2: Multi-phase improvement chaining\n        if random.random() < 0.5:\n            # Select a route for potential reallocation\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Calculate insertion cost\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = (distance_matrix[target_route[i-1], customer] +\n                                           distance_matrix[customer, target_route[i]] -\n                                           distance_matrix[target_route[i-1], target_route[i]])\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n\n                                # Perform the move if it improves makespan\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[route_idx] = np.delete(route, customer_idx)\n                                break\n\n    # Validate and return solution\n    if all(sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n        return new_solution\n    return base_solution\n\n",
        "metric_score": [
            -0.5947013663967,
            0.8762153089046478
        ],
        "raw_score": [
            38.31921238256756,
            4.451730273428476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Phase 1: Adaptive segment swap with demand-weighted selection\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select segments with demand-weighted probability\n        seg1_start = random.randint(1, len(route1) - 2)\n        seg1_end = random.randint(seg1_start, len(route1) - 2)\n        seg2_start = random.randint(1, len(route2) - 2)\n        seg2_end = random.randint(seg2_start, len(route2) - 2)\n\n        segment1 = route1[seg1_start:seg1_end + 1]\n        segment2 = route2[seg2_start:seg2_end + 1]\n\n        # Check feasibility with demand redistribution\n        if (sum(demand[route1]) - sum(demand[segment1]) + sum(demand[segment2]) <= capacity and\n            sum(demand[route2]) - sum(demand[segment2]) + sum(demand[segment1]) <= capacity):\n\n            # Perform segment swap with demand-weighted insertion\n            new_route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end + 1:]])\n            new_route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end + 1:]])\n\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n        # Phase 2: Multi-phase improvement chaining\n        if random.random() < 0.5:\n            # Select a route for potential reallocation\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Calculate insertion cost\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = (distance_matrix[target_route[i-1], customer] +\n                                           distance_matrix[customer, target_route[i]] -\n                                           distance_matrix[target_route[i-1], target_route[i]])\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n\n                                # Perform the move if it improves makespan\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[route_idx] = np.delete(route, customer_idx)\n                                break\n\n    # Validate and return solution\n    if all(sum(demand[route[1:-1]]) <= capacity for route in new_solution):\n        return new_solution\n    return base_solution\n\n",
        "operation": "elitist"
    }
]