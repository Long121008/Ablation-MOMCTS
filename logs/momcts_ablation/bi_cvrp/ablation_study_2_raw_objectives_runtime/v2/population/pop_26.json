[
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search that splits the longest route and rebalances customers between routes to minimize makespan while ensuring capacity constraints are met. It intelligently selects customers to move between routes based on insertion cost, avoiding pure 2-opt and instead combining route splitting and rebalancing for balanced multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route (highest makespan)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        route1 = np.concatenate([longest_route[:split_pos], [0]])\n        route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([route1, route2])\n\n        # Step 2: Rebalance customers between routes to minimize makespan\n        for route in new_solution:\n            if len(route) > 2:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != longest_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert the customer into the target route\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[longest_route_idx] = np.delete(route, customer_idx)\n                                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8872942947388127,
            10.71958303451538
        ],
        "raw_score": [
            58.54333419585228,
            7.716499608727731
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted Pareto-aware selection (prioritizing distance over makespan) and applies a hybrid local search that combines segment swaps with dynamic customer reallocation between routes, ensuring capacity feasibility while balancing improvements to both objectives. The selection weights (0.7 for distance, 0.3 for makespan) guide the focus toward distance optimization, while the segment swap and reallocation strategy introduces diversity and potential for multi-objective trade-offs. The solution is validated to ensure vehicle capacity constraints are met before returning the improved neighbor.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap with dynamic reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split each route at a random position\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Create segments\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine segments and reinsert customers\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        np.random.shuffle(combined_segments)\n\n        # Rebuild routes with capacity checks\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8333614876440076,
            0.3195435106754303
        ],
        "raw_score": [
            57.89115394559542,
            7.602944309570047
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using balanced Pareto-aware selection (equal weights for distance and makespan) and applies a novel local search combining route merging, customer reinsertion, and demand-aware splitting to improve both objectives while ensuring feasibility through strict capacity validation. The selected solution undergoes random merging of two routes, followed by shuffling and re-splitting customers to form new feasible routes, prioritizing demand constraints over distance reduction. The neighbor solution is returned if it maintains feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.5, 0.5])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Route merging with demand-aware splitting\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge routes and shuffle customers\n        merged_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        np.random.shuffle(merged_customers)\n\n        # Demand-aware splitting\n        temp_solution = []\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in merged_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8261492845593692,
            0.24679729342460632
        ],
        "raw_score": [
            58.198058125964096,
            7.815595584099687
        ]
    },
    {
        "algorithm": "The algorithm combines weighted Pareto-aware selection with dynamic segment swapping, demand-aware reallocation, and capacity-constrained route merging to balance distance and makespan improvements while ensuring feasibility. It prioritizes makespan reduction (weight=0.7) over distance (weight=0.3) when selecting solutions, and uses randomized segment swaps and demand-based reallocation to generate neighbors, followed by optional route merging to improve efficiency.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Dynamic segment swapping\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine and shuffle segments\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        # Demand-aware reallocation\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Capacity validation\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        # Route merging if beneficial\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                merged_demand = np.sum(demand[longest_route[1:-1]]) + np.sum(demand[shortest_route[1:-1]])\n                if merged_demand <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8587400056773007,
            0.4929153025150299
        ],
        "raw_score": [
            58.36680385170219,
            7.873125418411563
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-aware selection with a multi-step hybrid operator: it first merges underutilized routes to reduce makespan, then performs demand-aware segment relinking between routes by exchanging high-distance segments, and finally applies capacity-preserving segment inversion in the longest route to optimize the distance-makespan tradeoff. The selection prioritizes makespan (60%) over distance (40%) and focuses on routes with low demand and short distances for merging, while ensuring capacity constraints are respected throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    weights = np.array([0.4, 0.6])  # Slightly more emphasis on makespan\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Merge underutilized routes\n    if len(new_solution) >= 2:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find routes with low demand and short distance (potential for merging)\n        candidate_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if (route_demands[i] + route_demands[j] <= capacity * 0.8 and  # Leave some capacity slack\n                    route_distances[i] < np.mean(route_distances) and\n                    route_distances[j] < np.mean(route_distances)):\n                    candidate_pairs.append((i, j))\n\n        if candidate_pairs:\n            # Select the pair with the highest combined distance reduction potential\n            i, j = min(candidate_pairs, key=lambda x: route_distances[x[0]] + route_distances[x[1]])\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 2: Demand-aware segment relinking\n    if len(new_solution) >= 2:\n        # Calculate route characteristics\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find high-distance segments in each route\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            # Identify the longest segment in terms of distance\n            max_segment_distance = -1\n            best_segment = None\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    segment_distance = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                    if segment_distance > max_segment_distance:\n                        max_segment_distance = segment_distance\n                        best_segment = (i, j)\n\n            if best_segment:\n                i, j = best_segment\n                segment = route[i:j+1]\n                segment_demand = sum(demand[segment])\n\n                # Find compatible routes to exchange with\n                compatible_routes = []\n                for k in range(len(new_solution)):\n                    if k == route_idx:\n                        continue\n                    if sum(demand[new_solution[k][1:-1]]) + segment_demand <= capacity:\n                        compatible_routes.append(k)\n\n                if compatible_routes:\n                    # Select the route that would benefit most from the exchange\n                    best_route = min(compatible_routes, key=lambda k: sum(distance_matrix[new_solution[k][l]][new_solution[k][l+1]] for l in range(len(new_solution[k])-1)))\n                    target_route = new_solution[best_route]\n\n                    # Find insertion point in target route\n                    best_insertion = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(target_route)):\n                        insertion_distance = distance_matrix[target_route[pos-1]][segment[0]] + \\\n                                           distance_matrix[segment[-1]][target_route[pos]] - \\\n                                           distance_matrix[target_route[pos-1]][target_route[pos]]\n                        if insertion_distance < min_increase:\n                            min_increase = insertion_distance\n                            best_insertion = pos\n\n                    # Perform the exchange\n                    new_target_route = np.concatenate([target_route[:best_insertion], segment, target_route[best_insertion:]])\n                    new_solution[best_route] = new_target_route\n                    new_solution[route_idx] = np.concatenate([route[:i], route[j+1:]])\n\n    # Step 3: Capacity-preserving segment inversion\n    if len(new_solution) > 0:\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_distances)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:\n            # Find the segment with the most potential for distance reduction\n            max_potential = -1\n            best_segment = None\n            for i in range(1, len(longest_route)-2):\n                for j in range(i+1, len(longest_route)-1):\n                    original_distance = sum(distance_matrix[longest_route[k]][longest_route[k+1]] for k in range(i, j+1))\n                    reversed_distance = sum(distance_matrix[longest_route[k+1]][longest_route[k]] for k in range(i, j))\n                    potential = original_distance - reversed_distance\n                    if potential > max_potential and sum(demand[longest_route[i:j+1]]) <= capacity:\n                        max_potential = potential\n                        best_segment = (i, j)\n\n            if best_segment:\n                i, j = best_segment\n                reversed_segment = longest_route[i:j+1][::-1]\n                new_route = np.concatenate([longest_route[:i], reversed_segment, longest_route[j+1:]])\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8699461803648509,
            5.810759276151657
        ],
        "raw_score": [
            54.938909175611954,
            6.801893023072205
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a probability inversely proportional to its makespan, then applies a route-splitting local search by splitting the longest route into smaller segments, reinserting customers into new routes while ensuring capacity feasibility, and prioritizing routes with higher makespan for improvement. The method avoids standard 2-opt by focusing on strategic route decomposition and reinsertion, balancing both total distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = [sol[1][1] for sol in archive]\n    total_makespan = sum(makespans)\n    probs = [total_makespan / (m + 1e-6) for m in makespans]\n    probs = [p / sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Route-splitting local search\n    if len(new_solution) >= 1:\n        # Select the longest route\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the route at a random position\n        split_pos = random.randint(1, len(longest_route)-2)\n        first_part = longest_route[:split_pos+1]\n        second_part = longest_route[split_pos:]\n\n        # Remove the original long route\n        del new_solution[longest_route_idx]\n\n        # Reinsert customers from both parts into new routes\n        for part in [first_part, second_part]:\n            customers = part[1:-1]  # Exclude depots\n            np.random.shuffle(customers)\n\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8322810265757914,
            0.4726947844028473
        ],
        "raw_score": [
            58.50130341793871,
            7.765728630611369
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted scoring (70% makespan, 30% distance) and applies a hybrid local search that randomly splits two routes, shuffles segments, reallocates customers with demand checks, and reconstructs feasible routes while prioritizing capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7927952972949865,
            0.3386287987232208
        ],
        "raw_score": [
            58.26743417235241,
            7.749824575626347
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using inverse Pareto dominance weights, then applies a hybrid local search combining route merging (when feasible), demand-aware customer reallocation (balancing route lengths), and route splitting (to improve load balance) while ensuring capacity constraints. It prioritizes reducing the longest routes and merging shorter routes, with randomness in selection and splitting to explore diverse neighbors. The method balances distance and makespan objectives through targeted route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Route merging with demand check\n        if len(route1) > 2 and len(route2) > 2:\n            merged_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if merged_demand <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n        # Demand-aware customer reallocation\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                for customer in longest_route[1:-1]:\n                    if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for i in range(1, len(shortest_route)):\n                            cost = distance_matrix[shortest_route[i-1], customer] + distance_matrix[customer, shortest_route[i]] - distance_matrix[shortest_route[i-1], shortest_route[i]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = i\n\n                        new_shortest = np.insert(shortest_route, best_pos, customer)\n                        new_longest = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                        new_solution[shortest_route_idx] = new_shortest\n                        new_solution[longest_route_idx] = new_longest\n                        break\n\n        # Route splitting for better load balancing\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:\n                split_pos = random.randint(1, len(route) - 2)\n                first_part = route[:split_pos + 1]\n                second_part = np.concatenate([[0], route[split_pos + 1:]])\n\n                if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                    new_solution[i] = first_part\n                    new_solution.insert(i + 1, second_part)\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8548515546317587,
            0.559120774269104
        ],
        "raw_score": [
            57.95839860572578,
            7.571481775525301
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted Pareto-aware selection (30% distance, 70% makespan) and applies a hybrid local search combining segment swaps, random reallocation, and capacity-aware route merging to improve both objectives while ensuring feasibility. It prioritizes reducing the longest route (makespan) by strategically shuffling and merging segments while maintaining vehicle capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        if len(new_solution) > 2:\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                        temp_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n                        temp_solution.append(merged_route)\n                        if all(sum(demand[r[1:-1]]) <= capacity for r in temp_solution):\n                            new_solution = temp_solution\n                            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7591679682145136,
            0.37524330615997314
        ],
        "raw_score": [
            57.79661661624829,
            7.724984232083177
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid score that combines normalized distance and makespan objectives with route imbalance metrics, then applies a demand-aware route merging and splitting operator that prioritizes balancing route demands and lengths while maintaining capacity constraints. The selection favors solutions with better objective values and more balanced routes, while the operator intelligently redistributes customers between routes to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def hybrid_score(obj):\n        # Normalize objectives\n        total_dist = obj[0]\n        makespan = obj[1]\n        max_dist = max(o[0] for _, o in archive)\n        max_makespan = max(o[1] for _, o in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n\n        # Calculate route imbalance metric\n        imbalance = 0\n        for route in archive[0][0]:\n            route_demand = np.sum(demand[route[1:-1]])\n            imbalance += abs(route_demand - capacity/2) / (capacity/2)\n\n        # Combined score: prioritize solutions with better balance and non-dominated objectives\n        return 0.4 * (1 - norm_dist) + 0.4 * (1 - norm_makespan) + 0.2 * (1 - imbalance/len(archive[0][0]))\n\n    # Select solution with highest hybrid score\n    scores = [hybrid_score(obj) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Demand-aware route merging and splitting operator\n    if len(new_solution) >= 2:\n        # Calculate route metrics\n        route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n\n        # Find most imbalanced routes\n        max_demand_idx = np.argmax(route_demands)\n        min_length_idx = np.argmin(route_lengths)\n\n        if max_demand_idx != min_length_idx:\n            # Try to merge customers from overloaded route to underutilized route\n            overloaded_route = new_solution[max_demand_idx]\n            underutilized_route = new_solution[min_length_idx]\n\n            # Sort customers by demand in descending order\n            customers = sorted(overloaded_route[1:-1], key=lambda x: -demand[x])\n\n            for customer in customers:\n                new_demand = np.sum(demand[underutilized_route[1:-1]]) + demand[customer]\n                if new_demand <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for i in range(1, len(underutilized_route)):\n                        cost = (distance_matrix[underutilized_route[i-1], customer] +\n                                distance_matrix[customer, underutilized_route[i]] -\n                                distance_matrix[underutilized_route[i-1], underutilized_route[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                    # Insert customer and remove from overloaded route\n                    new_underutilized = np.insert(underutilized_route, best_pos, customer)\n                    new_overloaded = np.delete(overloaded_route, np.where(overloaded_route == customer)[0][0])\n\n                    # Update solution\n                    new_solution[min_length_idx] = new_underutilized\n                    new_solution[max_demand_idx] = new_overloaded\n\n                    # Check if overloaded route is now empty (can be removed)\n                    if len(new_overloaded) == 2:  # Only depot nodes left\n                        new_solution.pop(max_demand_idx)\n                    break\n\n    # Additional local improvement: try to split long routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # More than just depot nodes\n            route_demand = np.sum(demand[route[1:-1]])\n            # Calculate demand ratio and length ratio\n            demand_ratio = route_demand / capacity\n            length_ratio = np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) / np.sum(distance_matrix)\n\n            # Split condition: route is too long or too overloaded\n            if length_ratio > 0.3 or demand_ratio > 0.7:\n                # Find best split point\n                best_split = None\n                best_split_score = float('inf')\n                for j in range(1, len(route)-1):\n                    first_part = route[:j+1]\n                    second_part = np.insert(route[j:], 0, 0)\n\n                    first_demand = np.sum(demand[first_part[1:-1]])\n                    second_demand = np.sum(demand[second_part[1:-1]])\n\n                    if first_demand <= capacity and second_demand <= capacity:\n                        # Calculate split score (combination of demand balance and distance)\n                        split_score = (abs(first_demand - second_demand) / capacity +\n                                     abs(len(first_part) - len(second_part)) / len(route))\n                        if split_score < best_split_score:\n                            best_split_score = split_score\n                            best_split = j\n\n                if best_split is not None:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = np.insert(route[best_split:], 0, 0)\n\n                    # Update solution\n                    new_solution[i] = first_part\n                    new_solution.insert(i+1, second_part)\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8257206747401613,
            3.0014378428459167
        ],
        "raw_score": [
            58.010134556706525,
            7.636752842114738
        ]
    }
]