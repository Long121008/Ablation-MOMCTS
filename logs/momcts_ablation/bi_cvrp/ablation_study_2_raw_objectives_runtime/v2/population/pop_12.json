[
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with high makespan for improvement) and applies a hybrid local search strategy: first attempting route merging if feasible, then splitting oversized routes to balance demand, and finally reallocating customers between routes to reduce the longest route (makespan) while ensuring capacity constraints are met. The method intelligently combines these operations to balance both total distance and makespan objectives.\n\n*(Key design points: prioritizes makespan reduction, merges routes when possible, splits routes to balance demand, and reallocates customers to minimize the longest route, all while maintaining feasibility.)*",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[-1][0].copy()  # Select the worst in makespan (potential for improvement)\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route merging (if two routes have low total demand, merge them)\n    if len(new_solution) > 1:\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    merged = True\n                    break\n            if merged:\n                break\n\n    # Step 2: Route splitting (if a route has high demand, split it into two)\n    if not merged and len(new_solution) < len(coords) - 1:  # Avoid too many routes\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            customers = route[1:-1]\n            if len(customers) > 1:\n                # Find a split point that balances the route\n                total_demand = np.sum(demand[customers])\n                if total_demand > capacity:\n                    # Find the split point that minimizes the sum of demands on both sides\n                    best_split = 1\n                    min_diff = float('inf')\n                    for k in range(1, len(customers)):\n                        left_demand = np.sum(demand[customers[:k]])\n                        right_demand = total_demand - left_demand\n                        diff = abs(left_demand - right_demand)\n                        if diff < min_diff:\n                            min_diff = diff\n                            best_split = k\n                    # Split the route\n                    route1 = np.concatenate([[0], customers[:best_split], [0]])\n                    route2 = np.concatenate([[0], customers[best_split:], [0]])\n                    new_solution[i] = route1\n                    new_solution.insert(i + 1, route2)\n                    break\n\n    # Step 3: Customer reallocation (move customers between routes to balance makespan)\n    if len(new_solution) > 1:\n        # Find the route with the highest makespan\n        max_makespan_route_idx = np.argmax([np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution])\n        max_route = new_solution[max_makespan_route_idx]\n        max_customers = max_route[1:-1]\n\n        # Try to move a customer from this route to another\n        for customer in max_customers:\n            for i in range(len(new_solution)):\n                if i != max_makespan_route_idx:\n                    candidate_route = new_solution[i]\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[customer] <= capacity:\n                        # Remove customer from max_route\n                        max_route = np.delete(max_route, np.where(max_route == customer)[0][0])\n                        # Insert customer into candidate_route (at best position)\n                        candidate_customers = candidate_route[1:-1]\n                        best_pos = 0\n                        min_added_distance = float('inf')\n                        for pos in range(len(candidate_customers) + 1):\n                            # Calculate the added distance\n                            if pos == 0:\n                                added_distance = distance_matrix[0, customer] + distance_matrix[customer, candidate_customers[0]] - distance_matrix[0, candidate_customers[0]]\n                            elif pos == len(candidate_customers):\n                                added_distance = distance_matrix[candidate_customers[-1], customer] + distance_matrix[customer, 0] - distance_matrix[candidate_customers[-1], 0]\n                            else:\n                                added_distance = distance_matrix[candidate_customers[pos-1], customer] + distance_matrix[customer, candidate_customers[pos]] - distance_matrix[candidate_customers[pos-1], candidate_customers[pos]]\n                            if added_distance < min_added_distance:\n                                min_added_distance = added_distance\n                                best_pos = pos\n                        # Insert customer at best position\n                        new_candidate_route = np.insert(candidate_route, best_pos + 1, customer)\n                        new_solution[i] = new_candidate_route\n                        new_solution[max_makespan_route_idx] = max_route\n                        break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7183271987983886,
            1.8778762817382812
        ],
        "raw_score": [
            57.11386094756787,
            7.615842585356178
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with low makespan and total distance from the archive, then applies a hybrid local search that splits routes at random positions and reinserts customers into existing routes or creates new ones, ensuring feasibility by checking vehicle capacity constraints. It handles missing customers by creating new routes, balancing both objectives while maintaining solution feasibility. The key innovation is the combination of route-splitting with demand-aware reinsertion, avoiding standard methods like pure 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Hybrid local search: route-splitting with demand-aware reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Reinsert customers from the second part back into the solution\n        customers_to_reinsert = part2[1:-1]  # Exclude depots\n        new_solution.append(part1.copy())\n\n        # Try to insert customers into existing routes or create new ones\n        for customer in customers_to_reinsert:\n            inserted = False\n            for i in range(len(new_solution)):\n                temp_route = np.insert(new_solution[i], -1, customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_solution[i] = temp_route\n                    inserted = True\n                    break\n\n            if not inserted:\n                new_solution.append(np.array([0, customer, 0]))\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = set(range(1, len(demand))) - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        for customer in missing_customers:\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7816711410201282,
            7.224736332893372
        ],
        "raw_score": [
            57.95259418000826,
            7.6711049661801844
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower makespan and total distance), then applies a hybrid local search that merges two routes and reinserts their customers into new routes while respecting capacity constraints. The selected routes are removed, their customers are shuffled, and reinserted into new routes with a greedy approach, ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) >= 2:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge the two routes (excluding the depot)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the selected routes from the solution\n        del new_solution[max(route1_idx, route2_idx)]\n        del new_solution[min(route1_idx, route2_idx)]\n\n        # Reinsert customers from the merged route into new routes\n        remaining_customers = merged_route[1:-1]  # Exclude depots\n        np.random.shuffle(remaining_customers)\n\n        # Create new routes while respecting capacity\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in remaining_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.3859883488764832,
            0.4115249514579773
        ],
        "raw_score": [
            41.152501233435785,
            4.500788477866207
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging and customer reallocation. It first attempts to merge two feasible routes, then reallocates a customer from one route to another using greedy insertion to minimize additional travel distance. The method balances objectives while ensuring feasibility by checking capacity constraints at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge (if possible)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by concatenating them (excluding the depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Remove the two routes and add the merged route\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Step 2: Randomly reallocate a customer from a route to another route (if possible)\n    if len(new_solution) > 1:\n        # Select a random route to remove a customer from\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 2:  # Ensure the route has customers to remove\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(source_route) - 2)\n            customer = source_route[customer_idx]\n\n            # Try to insert the customer into another route\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx != source_route_idx:\n                    target_route = new_solution[target_route_idx]\n                    # Check if adding the customer exceeds capacity\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert the customer into the target route (greedy insertion)\n                        best_position = 1  # Default to insert after depot\n                        best_cost = float('inf')\n                        for i in range(1, len(target_route)):\n                            # Cost of inserting customer between i-1 and i\n                            cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_position = i\n                        # Insert the customer\n                        new_route = np.insert(target_route, best_position, customer)\n                        new_solution[target_route_idx] = new_route\n                        # Remove the customer from the source route\n                        new_solution[source_route_idx] = np.delete(source_route, customer_idx)\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5551090437252774,
            0.6128853261470795
        ],
        "raw_score": [
            27.170352502309257,
            2.9091272372427848
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining route segment swapping and reinsertion while ensuring vehicle capacity constraints are maintained. It prioritizes solutions with better combined objective performance and focuses on modifying two randomly selected routes by exchanging customer segments, with optional 2-opt improvements for further optimization. The capacity constraints are strictly enforced at each modification step to maintain feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: segment swap with reinsertion\n    if len(new_solution) >= 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Segment from route1\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n            segment_demand1 = np.sum(demand[segment1])\n\n            # Segment from route2\n            start2 = random.randint(1, len(route2) - 2)\n            end2 = random.randint(start2, len(route2) - 2)\n            segment2 = route2[start2:end2 + 1]\n            segment_demand2 = np.sum(demand[segment2])\n\n            # Check capacity constraints\n            new_route1_demand = np.sum(demand[route1]) - segment_demand1 + segment_demand2\n            new_route2_demand = np.sum(demand[route2]) - segment_demand2 + segment_demand1\n\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Optional: Apply a simple 2-opt improvement on the modified routes\n                for i in [route1_idx, route2_idx]:\n                    route = new_solution[i]\n                    if len(route) > 3:\n                        # Try reversing a random segment\n                        a, b = sorted(random.sample(range(1, len(route)-1), 2))\n                        reversed_segment = route[a:b+1][::-1]\n                        new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n\n                        # Check capacity constraint\n                        if np.sum(demand[new_route]) <= capacity:\n                            new_solution[i] = new_route\n\n    # Handle cases where only one route exists (unlikely in practice)\n    elif len(new_solution) == 1 and len(new_solution[0]) > 3:\n        route = new_solution[0]\n        # Try reversing a random segment\n        a, b = sorted(random.sample(range(1, len(route)-1), 2))\n        reversed_segment = route[a:b+1][::-1]\n        new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route]) <= capacity:\n            new_solution[0] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.47906748423652423,
            0.5748716592788696
        ],
        "raw_score": [
            38.696631252475,
            4.405245693062968
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search that splits the longest route and rebalances customers between routes to minimize makespan while ensuring capacity constraints are met. It intelligently selects customers to move between routes based on insertion cost, avoiding pure 2-opt and instead combining route splitting and rebalancing for balanced multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route (highest makespan)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        route1 = np.concatenate([longest_route[:split_pos], [0]])\n        route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([route1, route2])\n\n        # Step 2: Rebalance customers between routes to minimize makespan\n        for route in new_solution:\n            if len(route) > 2:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != longest_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert the customer into the target route\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[longest_route_idx] = np.delete(route, customer_idx)\n                                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8872942947388127,
            10.71958303451538
        ],
        "raw_score": [
            58.54333419585228,
            7.716499608727731
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the best makespan from the archive, then applies a hybrid local search that first splits the least efficient route (based on demand-to-distance ratio) into two balanced routes, followed by adaptively reallocating the most promising customer from the least efficient route to the most compatible route, prioritizing capacity feasibility and insertion cost reduction. The method balances objectives by focusing on route efficiency and dynamic customer insertion points.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route efficiency scores (higher is better)\n    route_scores = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_scores.append(0)\n            continue\n        total_demand = sum(demand[customers])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        efficiency = total_demand / route_distance if route_distance > 0 else 0\n        route_scores.append(efficiency)\n\n    # Hybrid local search: route splitting and adaptive customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Split the least efficient route (if it exists)\n        min_score_idx = np.argmin(route_scores)\n        if route_scores[min_score_idx] > 0:  # Only split if route has customers\n            split_route = new_solution[min_score_idx]\n            customers = split_route[1:-1]\n\n            # Find split point that balances demand and distance\n            best_split = 1\n            best_balance = float('inf')\n            for i in range(1, len(customers)):\n                part1 = customers[:i]\n                part2 = customers[i:]\n                demand1 = sum(demand[part1])\n                demand2 = sum(demand[part2])\n                balance = abs(demand1 - demand2)\n                if balance < best_balance:\n                    best_balance = balance\n                    best_split = i\n\n            # Create two new routes\n            route1 = np.concatenate([[0], customers[:best_split], [0]])\n            route2 = np.concatenate([[0], customers[best_split:], [0]])\n\n            # Replace the original route with the two new ones\n            new_solution.pop(min_score_idx)\n            new_solution.append(route1)\n            new_solution.append(route2)\n\n            # Update route scores\n            route_scores.pop(min_score_idx)\n            route_scores.append(sum(demand[route1[1:-1]]) / sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)))\n            route_scores.append(sum(demand[route2[1:-1]]) / sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n\n    # Step 2: Adaptive customer reallocation\n    if len(new_solution) > 1:\n        # Select the most inefficient route to improve\n        min_score_idx = np.argmin(route_scores)\n        source_route = new_solution[min_score_idx]\n\n        if len(source_route) > 2:  # Ensure the route has customers to remove\n            # Calculate insertion potential for each customer\n            customer_scores = []\n            for i in range(1, len(source_route)-1):\n                customer = source_route[i]\n                # Score based on demand and distance trade-off\n                score = demand[customer] / (distance_matrix[source_route[i-1], source_route[i+1]] -\n                                          distance_matrix[source_route[i-1], source_route[i]] -\n                                          distance_matrix[source_route[i], source_route[i+1]])\n                customer_scores.append(score)\n\n            # Select customer with highest score (most promising to relocate)\n            if customer_scores:\n                best_customer_idx = np.argmax(customer_scores)\n                customer = source_route[best_customer_idx + 1]  # +1 because we skipped depot\n\n                # Try to insert into the most compatible route\n                best_route_idx = -1\n                best_insertion_cost = float('inf')\n                for target_idx in range(len(new_solution)):\n                    if target_idx != min_score_idx:\n                        target_route = new_solution[target_idx]\n                        current_demand = sum(demand[target_route[1:-1]])\n                        if current_demand + demand[customer] <= capacity:\n                            # Find best insertion position\n                            best_position = 1\n                            best_cost = float('inf')\n                            for i in range(1, len(target_route)):\n                                cost = (distance_matrix[target_route[i-1], customer] +\n                                       distance_matrix[customer, target_route[i]] -\n                                       distance_matrix[target_route[i-1], target_route[i]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_position = i\n                            if best_cost < best_insertion_cost:\n                                best_insertion_cost = best_cost\n                                best_route_idx = target_idx\n\n                if best_route_idx != -1:\n                    # Perform the insertion\n                    target_route = new_solution[best_route_idx]\n                    best_position = 1\n                    best_cost = float('inf')\n                    for i in range(1, len(target_route)):\n                        cost = (distance_matrix[target_route[i-1], customer] +\n                               distance_matrix[customer, target_route[i]] -\n                               distance_matrix[target_route[i-1], target_route[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_position = i\n\n                    new_route = np.insert(target_route, best_position, customer)\n                    new_solution[best_route_idx] = new_route\n                    # Remove from source route\n                    new_solution[min_score_idx] = np.delete(source_route, best_customer_idx + 1)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5485249304189359,
            7.265410870313644
        ],
        "raw_score": [
            55.51369556289667,
            6.765714112227632
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive based on makespan and total distance, then applies a hybrid local search combining route segment exchange and demand-aware reinsertion to balance both objectives while ensuring capacity constraints. It prioritizes solutions with shorter makespan first, then total distance, and intelligently exchanges segments between routes while reinserting customers to improve efficiency. The method ensures feasibility by checking capacity constraints before each operation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) > 1:\n        # Hybrid local search: segment exchange with demand-aware reinsertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select segments from both routes\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n            segment_demand1 = np.sum(demand[segment1])\n\n            start2 = random.randint(1, len(route2) - 2)\n            end2 = random.randint(start2, len(route2) - 2)\n            segment2 = route2[start2:end2 + 1]\n            segment_demand2 = np.sum(demand[segment2])\n\n            # Check capacity constraints\n            new_route1_demand = np.sum(demand[route1]) - segment_demand1 + segment_demand2\n            new_route2_demand = np.sum(demand[route2]) - segment_demand2 + segment_demand1\n\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform the exchange\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Demand-aware reinsertion for further improvement\n                for route_idx in [route1_idx, route2_idx]:\n                    route = new_solution[route_idx]\n                    customers = route[1:-1]\n                    for i in range(len(customers)):\n                        customer = customers[i]\n                        # Try to reinsert customer into another route\n                        for target_idx in range(len(new_solution)):\n                            if target_idx != route_idx:\n                                target_route = new_solution[target_idx]\n                                if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                    # Find best insertion position\n                                    best_pos = 1\n                                    best_cost = float('inf')\n                                    for pos in range(1, len(target_route)):\n                                        cost = distance_matrix[target_route[pos-1], customer] + distance_matrix[customer, target_route[pos]] - distance_matrix[target_route[pos-1], target_route[pos]]\n                                        if cost < best_cost:\n                                            best_cost = cost\n                                            best_pos = pos\n                                    # Perform insertion\n                                    new_route = np.insert(target_route, best_pos, customer)\n                                    new_solution[target_idx] = new_route\n                                    # Remove from original route\n                                    new_solution[route_idx] = np.delete(route, i + 1)\n                                    break\n                        else:\n                            continue\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4632079984267319,
            0.6977574229240417
        ],
        "raw_score": [
            30.98157695498189,
            3.4502149940461893
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan (shortest longest route) from the archive and splits its longest route into two, then dynamically reallocates customers between routes using a greedy insertion heuristic while ensuring capacity constraints are met. The approach prioritizes balancing route lengths (makespan) by splitting the longest route and redistributing customers to potentially reduce the total distance, leveraging a probabilistic and cost-based insertion strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route to split\n        longest_route_idx = np.argmax([len(route) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_point = len(longest_route) // 2\n        part1 = longest_route[:split_point + 1]\n        part2 = np.concatenate([[0], longest_route[split_point:]])\n\n        # Replace the original route with the two split parts\n        new_solution[longest_route_idx] = part1\n        new_solution.append(part2)\n\n        # Step 2: Dynamically reallocate customers between routes\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 2:  # Ensure the route has customers to remove\n                for customer_idx in range(1, len(route) - 1):\n                    customer = route[customer_idx]\n                    current_load = sum(demand[route[1:-1]])\n                    # Find a target route to reallocate the customer\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != route_idx:\n                            target_route = new_solution[target_route_idx]\n                            target_load = sum(demand[target_route[1:-1]])\n                            if target_load + demand[customer] <= capacity:\n                                # Calculate insertion cost\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = (distance_matrix[target_route[i-1], customer] +\n                                            distance_matrix[customer, target_route[i]] -\n                                            distance_matrix[target_route[i-1], target_route[i]])\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                # Insert the customer\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                # Remove the customer from the source route\n                                new_solution[route_idx] = np.delete(route, customer_idx)\n                                break\n    return new_solution\n\n",
        "metric_score": [
            -0.6839986383122407,
            10.763436764478683
        ],
        "raw_score": [
            58.123658013113086,
            7.6325750520192965
        ]
    },
    {
        "algorithm": "The algorithm combines route merging with dynamic splitting and probabilistic customer reallocation, prioritizing distance reduction (70%) while balancing makespan (30%) through a hybrid objective function. It intelligently selects routes for merging based on capacity feasibility and reallocates customers to minimize both objectives, with a focus on improving the longest routes. The method ensures feasibility through iterative demand checks and local repairs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: dynamic route splitting and probabilistic customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Merge two routes with high potential for improvement\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Calculate potential improvement score (normalized distance + route length)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n            # Step 2: Dynamically split the merged route based on demand patterns\n            if len(merged_route) > 2:\n                customers = merged_route[1:-1]\n                np.random.shuffle(customers)\n                current_route = [0]\n                current_load = 0.0\n                split_routes = []\n\n                for customer in customers:\n                    if current_load + demand[customer] <= capacity:\n                        current_route.append(customer)\n                        current_load += demand[customer]\n                    else:\n                        current_route.append(0)\n                        split_routes.append(np.array(current_route))\n                        current_route = [0, customer]\n                        current_load = demand[customer]\n\n                if len(current_route) > 1:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n\n                # Replace the merged route with split routes\n                new_solution.pop()\n                new_solution.extend(split_routes)\n\n        # Step 3: Probabilistic customer reallocation to balance objectives\n        if len(new_solution) > 1:\n            for _ in range(min(3, len(new_solution))):  # Limit the number of reallocations\n                source_route_idx = random.randint(0, len(new_solution) - 1)\n                source_route = new_solution[source_route_idx]\n                if len(source_route) > 2:  # Ensure the route has customers to remove\n                    customer_idx = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_idx]\n\n                    # Evaluate target routes based on a hybrid objective (distance + makespan)\n                    best_target_idx = -1\n                    best_score = float('inf')\n\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != source_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Calculate insertion cost and potential makespan impact\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n\n                                # Hybrid score: weighted sum of distance cost and makespan impact\n                                current_makespan = max(len(route) - 1 for route in new_solution)\n                                new_route_length = len(target_route) + 1\n                                score = 0.7 * best_cost + 0.3 * (new_route_length - current_makespan)\n\n                                if score < best_score:\n                                    best_score = score\n                                    best_target_idx = target_route_idx\n\n                    if best_target_idx != -1:\n                        # Perform the reallocation\n                        target_route = new_solution[best_target_idx]\n                        best_position = 1\n                        best_cost = float('inf')\n                        for i in range(1, len(target_route)):\n                            cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_position = i\n\n                        new_route = np.insert(target_route, best_position, customer)\n                        new_solution[best_target_idx] = new_route\n                        new_solution[source_route_idx] = np.delete(source_route, customer_idx)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.32854147766445263,
            1.2493100464344025
        ],
        "raw_score": [
            22.437602046531843,
            2.310517738166981
        ]
    }
]