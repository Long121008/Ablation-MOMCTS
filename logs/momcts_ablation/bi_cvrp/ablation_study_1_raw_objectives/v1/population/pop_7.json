[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging to improve the solution while ensuring feasibility. It randomly selects two routes, relocates a segment between them if capacity allows, or merges them if possible, and checks feasibility before returning the new solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Relocate a segment between routes or merge two routes\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:  # Need at least one customer to relocate\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5333262969216688,
            0.22810059785842896
        ],
        "raw_score": [
            37.52143125387771,
            4.577189938048067
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with balanced makespan and distance, then applies a hybrid local search combining spatial-aware route merging and demand-aware customer redistribution. It first clusters routes by spatial proximity, merging feasible routes or redistributing customers between nearby clusters, followed by balancing demand imbalances by transferring customers between routes while maintaining capacity constraints. The approach prioritizes spatial proximity for merging and demand balance for redistribution, ensuring feasible solutions while targeting simultaneous improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial-aware route clustering\n    if len(new_solution) > 1:\n        # Calculate centroids for each route\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n\n        # Pair routes with closest centroids\n        route_pairs = []\n        used = set()\n        for i in range(len(centroids)):\n            if i in used:\n                continue\n            min_dist = float('inf')\n            best_j = -1\n            for j in range(i+1, len(centroids)):\n                if j not in used:\n                    dist = np.linalg.norm(centroids[i] - centroids[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_j = j\n            if best_j != -1:\n                route_pairs.append((i, best_j))\n                used.add(i)\n                used.add(best_j)\n\n        # For each pair, try merging if capacity allows\n        for i, j in route_pairs:\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution[j] = np.array([0])  # Mark for removal\n            else:\n                # Redistribute customers based on spatial proximity\n                customers = list(route1[1:-1]) + list(route2[1:-1])\n                centroid1 = centroids[i]\n                centroid2 = centroids[j]\n\n                # Split customers between routes\n                route1_customers = []\n                route2_customers = []\n                for customer in customers:\n                    dist1 = np.linalg.norm(coords[customer] - centroid1)\n                    dist2 = np.linalg.norm(coords[customer] - centroid2)\n                    if dist1 < dist2:\n                        route1_customers.append(customer)\n                    else:\n                        route2_customers.append(customer)\n\n                # Rebuild routes with new customers\n                if sum(demand[node] for node in route1_customers) <= capacity:\n                    new_solution[i] = np.concatenate([[0], route1_customers, [0]])\n                if sum(demand[node] for node in route2_customers) <= capacity:\n                    new_solution[j] = np.concatenate([[0], route2_customers, [0]])\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 2: Demand-aware customer redistribution\n    if len(new_solution) > 1:\n        # Find the most imbalanced route (highest demand deviation from average)\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n        imbalances = [abs(d - avg_demand) for d in route_demands]\n        source_idx = imbalances.index(max(imbalances))\n\n        # Find the most compatible route to receive customers\n        target_idx = min(range(len(new_solution)), key=lambda i: abs(sum(demand[node] for node in new_solution[i][1:-1]) - avg_demand) if i != source_idx else float('inf'))\n\n        source_route = new_solution[source_idx]\n        target_route = new_solution[target_idx]\n\n        # Try to transfer customers from source to target\n        source_customers = list(source_route[1:-1])\n        target_customers = list(target_route[1:-1])\n        transferred = False\n\n        for customer in source_customers:\n            if sum(demand[node] for node in target_customers) + demand[customer] <= capacity:\n                target_customers.append(customer)\n                source_customers.remove(customer)\n                transferred = True\n\n        if transferred:\n            # Rebuild routes\n            new_solution[source_idx] = np.concatenate([[0], source_customers, [0]])\n            new_solution[target_idx] = np.concatenate([[0], target_customers, [0]])\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8311703624804405,
            1.0237776935100555
        ],
        "raw_score": [
            58.3023752816847,
            7.88680034130579
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging, while also incorporating a novel \"route splitting\" mechanism (with a 30% chance) to improve solutions while ensuring feasibility. It intelligently selects routes, segments, and insertion points, checks capacity constraints, and reverts to the original solution if feasibility is violated. The algorithm balances exploration (random selection) and exploitation (prioritization) of high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n        # Novel route splitting mechanism\n        if len(new_solution) < len(base_solution) and random.random() < 0.3:  # 30% chance to split a route\n            long_route = max(new_solution, key=lambda r: len(r))\n            if len(long_route) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(long_route) - 3)\n                first_part = np.concatenate([long_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check capacity constraints for both parts\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution.remove(long_route)\n                    new_solution.append(first_part)\n                    new_solution.append(second_part)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7624629018001627,
            0.2549241781234741
        ],
        "raw_score": [
            36.91533735728953,
            4.559352320583427
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing lower makespan (with total distance as a tiebreaker), then applies a hybrid local search that randomly inverts a route segment (if feasible) and may split the route into two (if both resulting routes are capacity-feasible). The method ensures feasibility by reverting changes if capacity constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize solutions with lower makespan, then total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Invert a segment within a route or split a route into two\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Need at least one customer to invert or split\n            # Invert a segment within the route\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            inverted_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Check if the inverted route is feasible\n            if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                new_solution[route_idx] = route  # Revert if infeasible\n            else:\n                # Try splitting the route if inversion is successful\n                split_pos = random.randint(1, len(new_route) - 2)\n                first_part = np.concatenate([[0], new_route[1:split_pos + 1], [0]])\n                second_part = np.concatenate([[0], new_route[split_pos + 1:-1], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9001978421599203,
            1.1289136409759521
        ],
        "raw_score": [
            68.28775165670466,
            2.6695998127591607
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest makespan (prioritized over total distance) from the archive and applies a hybrid local search combining inter-route customer transfers, capacity-aware 2-opt within routes, and route splitting to handle capacity violations, ensuring feasibility and potential multi-objective improvements. The method favors routes with lower makespan and total distance, while the local search intelligently explores inter-route and intra-route moves to balance both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting, inter-route insertion, and capacity-aware 2-opt\n    if len(new_solution) > 1:\n        # Randomly select two routes for inter-route operations\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Inter-route insertion: try to move a customer from route1 to route2\n        if len(route1) > 2:\n            # Select a random customer from route1 (excluding depots)\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Check if moving this customer to route2 is feasible\n            current_load = sum(demand[node] for node in route2)\n            if current_load + demand[customer] <= capacity:\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Insert customer into route2 (try different positions)\n                best_position = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate insertion cost\n                    cost = distance_matrix[route2[pos-1]][customer] + distance_matrix[customer][route2[pos]] - distance_matrix[route2[pos-1]][route2[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_position = pos\n\n                # Insert the customer\n                new_route2 = np.concatenate([route2[:best_position], [customer], route2[best_position:]])\n                new_solution[route2_idx] = new_route2\n\n        # Capacity-aware 2-opt within a route\n        for route in new_solution:\n            if len(route) > 4:  # Need at least 4 nodes to perform 2-opt\n                # Select two edges to reverse\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n\n                # Check capacity constraint for the new segment\n                segment_demand = sum(demand[node] for node in route[i:j+1])\n                if segment_demand <= capacity:\n                    # Reverse the segment\n                    route[i:j+1] = route[i:j+1][::-1]\n\n    # Route splitting if a route is too long\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # If route has more than just depots\n            # Calculate cumulative demand\n            cumulative_demand = np.cumsum([demand[node] for node in route[1:-1]])\n            split_pos = np.where(cumulative_demand > capacity)[0]\n\n            if len(split_pos) > 0:\n                # Split at the first position where capacity is exceeded\n                split_point = split_pos[0] + 1  # +1 because we want to split after this customer\n\n                # Create new route from the split point\n                new_route = np.concatenate([[0], route[split_point:-1], [0]])\n                new_solution[i] = np.concatenate([[0], route[1:split_point+1], [0]])\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5896292014551943,
            0.2732754051685333
        ],
        "raw_score": [
            45.66104831782705,
            4.913209142017411
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan from the archive, applies a hybrid local search that splits overloaded routes to balance demand, and reallocates customers between routes to reduce total distance while maintaining feasibility. It prioritizes makespan reduction through route splitting and distance optimization through customer reallocation, ensuring vehicle capacity constraints are always satisfied.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Check if splitting the route can improve makespan\n        total_demand = sum(demand[customer] for customer in route[1:-1])\n        if total_demand <= capacity:\n            continue  # Route is already feasible\n\n        # Find the best split point to balance demand\n        best_split = -1\n        min_max_load = float('inf')\n        current_load = 0\n\n        for j in range(1, len(route)-1):\n            current_load += demand[route[j]]\n            remaining_load = total_demand - current_load\n            max_load = max(current_load, remaining_load)\n\n            if max_load < min_max_load:\n                min_max_load = max_load\n                best_split = j\n\n        if best_split != -1:\n            # Split the route at best_split\n            new_route1 = np.concatenate([route[:best_split+1], [0]])\n            new_route2 = np.concatenate([[0], route[best_split+1:]])\n\n            # Replace the original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Reallocate customers to improve distance while maintaining feasibility\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to move customers to other routes if it reduces total distance\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            current_route_index = i\n\n            # Find the best route to move the customer to\n            best_route_index = -1\n            best_distance_reduction = 0\n\n            for k in range(len(new_solution)):\n                if k == current_route_index:\n                    continue\n\n                other_route = new_solution[k]\n                if sum(demand[customer] for customer in other_route[1:-1]) + demand[customer] > capacity:\n                    continue  # Skip if adding customer exceeds capacity\n\n                # Calculate distance reduction if moved\n                # Distance before: distance from predecessor to customer and customer to successor in current route\n                pred = route[j-1]\n                succ = route[j+1]\n                original_distance = distance_matrix[pred, customer] + distance_matrix[customer, succ]\n\n                # Distance after: distance from last node in other route to customer and customer to depot\n                last_node = other_route[-2]\n                new_distance = distance_matrix[last_node, customer] + distance_matrix[customer, 0]\n\n                distance_reduction = original_distance - new_distance\n\n                if distance_reduction > best_distance_reduction:\n                    best_distance_reduction = distance_reduction\n                    best_route_index = k\n\n            if best_route_index != -1:\n                # Move the customer to the best route\n                customer = route[j]\n                new_solution[best_route_index] = np.concatenate([new_solution[best_route_index][:-1], [customer], [0]])\n\n                # Remove the customer from the original route\n                new_solution[current_route_index] = np.concatenate([route[:j], route[j+1:]])\n\n                # If the original route is now empty, remove it\n                if len(new_solution[current_route_index]) == 2:\n                    del new_solution[current_route_index]\n                    break  # Restart the loop since the list has changed\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8197619970622914,
            4.295692175626755
        ],
        "raw_score": [
            58.032952507921905,
            7.675296988668824
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the lowest makespan and highest total distance, indicating potential for multi-objective improvement, then applies a hybrid local search combining route splitting, optimal customer reinsertion, and route merging to generate a feasible neighbor solution while prioritizing capacity constraints and minimizing distance increases. The process balances exploration (random selection) with exploitation (optimal insertions/merges) to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1], -archive[i][1][0]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reinsertion, and route merging\n    if len(new_solution) > 1:\n        # Step 1: Route splitting - split the longest route into two\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n        split_pos = len(longest_route) // 2\n        new_route1 = longest_route[:split_pos + 1]\n        new_route2 = longest_route[split_pos:]\n\n        # Ensure depot is at the start and end of each new route\n        if new_route1[-1] != 0:\n            new_route1 = np.append(new_route1, 0)\n        if new_route2[0] != 0:\n            new_route2 = np.insert(new_route2, 0, 0)\n\n        # Check capacity constraints\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[longest_route_idx] = new_route1\n            new_solution.insert(longest_route_idx + 1, new_route2)\n\n    # Step 2: Customer reinsertion - remove a random customer and reinsert it optimally\n    if len(new_solution) > 1:\n        # Select a route with more than 2 customers (excluding depot)\n        candidate_routes = [i for i in range(len(new_solution)) if len(new_solution[i]) > 3]\n        if candidate_routes:\n            route_idx = random.choice(candidate_routes)\n            route = new_solution[route_idx]\n            # Remove a random customer (not depot)\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n            # Remove the customer\n            new_route = np.delete(route, customer_pos)\n            new_solution[route_idx] = new_route\n\n            # Find the best position to reinsert the customer\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)):\n                current_route = new_solution[i]\n                # Try inserting after each node in the route (except last depot)\n                for pos in range(1, len(current_route)):\n                    # Construct new route\n                    temp_route = np.insert(current_route, pos, customer)\n                    # Check capacity constraint\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Calculate insertion cost (distance increase)\n                        prev_node = temp_route[pos-1]\n                        next_node = temp_route[pos+1]\n                        cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route_idx = i\n                            best_pos = pos\n\n            # Perform the best insertion\n            if best_route_idx != -1:\n                best_route = new_solution[best_route_idx]\n                new_route = np.insert(best_route, best_pos, customer)\n                new_solution[best_route_idx] = new_route\n\n    # Step 3: Route merging - merge two routes if possible\n    if len(new_solution) > 1:\n        # Find the two routes with the smallest total distance increase when merged\n        best_pair = None\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Try merging route1 into route2 (connecting last of route1 to first of route2)\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    # Calculate merging cost\n                    cost = (distance_matrix[route1[-2]][route2[1]] -\n                           distance_matrix[route1[-2]][0] -\n                           distance_matrix[0][route2[1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pair = (i, j)\n\n        # Perform the best merge\n        if best_pair is not None:\n            i, j = best_pair\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6840469735992674,
            1.7850463688373566
        ],
        "raw_score": [
            58.461134754796745,
            7.725335228089083
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive (prioritizing those with shorter makespan) and applies a hybrid local search combining route fragmentation (splitting long routes) with a demand-aware 2-opt operator (reversing segments to reduce distance while respecting capacity constraints). It ensures feasibility by checking capacity constraints at each step and splitting routes if violated. The focus is on balancing distance and makespan minimization while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance and crowding distance\n    selected_idx = 0\n    min_makespan = float('inf')\n    for i, (sol, (dist, ms)) in enumerate(archive):\n        if ms < min_makespan:\n            min_makespan = ms\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + demand-aware 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Can be split\n            split_pos = len(longest_route) // 2\n            route1 = longest_route[:split_pos + 1]\n            route2 = longest_route[split_pos:]\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.pop(longest_route_idx)\n                new_solution.append(route1)\n                new_solution.append(route2)\n\n    # Step 2: Demand-aware 2-opt - improve routes by considering demand patterns\n    for route in new_solution:\n        if len(route) > 3:\n            improved = True\n            while improved:\n                improved = False\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        # Calculate current and new distances\n                        current_dist = (distance_matrix[route[i-1]][route[i]] +\n                                       distance_matrix[route[j]][route[j+1]])\n                        new_dist = (distance_matrix[route[i-1]][route[j]] +\n                                   distance_matrix[route[i]][route[j+1]])\n\n                        # Calculate current and new demands\n                        segment = route[i:j+1]\n                        current_demand = sum(demand[segment])\n                        reversed_demand = sum(demand[segment[::-1]])\n\n                        if new_dist < current_dist and reversed_demand <= capacity:\n                            # Reverse the segment to improve distance\n                            route[i:j+1] = route[j:i-1:-1]\n                            improved = True\n                            break\n                    if improved:\n                        break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, split the route\n            split_pos = 1\n            current_load = 0\n            for i in range(1, len(route)-1):\n                if current_load + demand[route[i]] > capacity:\n                    # Split before this node\n                    new_route = route[:i] + [0]\n                    remaining_route = [0] + route[i:]\n                    new_solution.remove(route)\n                    new_solution.append(new_route)\n                    new_solution.append(remaining_route)\n                    break\n                current_load += demand[route[i]]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7590913293379504,
            11.036344200372696
        ],
        "raw_score": [
            58.470635245599155,
            7.780710701920874
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest makespan (prioritizing route length reduction) and performs a systematic segment relocation from the longest route to other routes, evaluating all possible segments to minimize makespan while considering capacity constraints and insertion costs. It balances makespan reduction with total distance optimization by strategically placing relocated segments to minimize additional travel distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1], archive[i][1][0]))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Find the longest route (target for reduction)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Try to relocate segments from longest route to other routes\n        best_relocation = None\n        best_improvement = 0\n\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == longest_route_idx:\n                continue\n\n            other_route = new_solution[other_route_idx]\n\n            # Evaluate all possible segments from longest route\n            for start in range(1, len(longest_route) - 1):\n                for end in range(start, len(longest_route) - 1):\n                    segment = longest_route[start:end+1]\n                    segment_demand = np.sum(demand[segment])\n\n                    if np.sum(demand[other_route[1:-1]]) + segment_demand <= capacity:\n                        # Calculate potential improvement\n                        original_longest = len(longest_route)\n                        new_longest = len(longest_route) - (end - start + 1)\n                        other_route_length = len(other_route) + (end - start + 1)\n\n                        # Improvement is reduction in makespan (positive value)\n                        improvement = original_longest - max(new_longest, other_route_length)\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_relocation = (other_route_idx, start, end, segment)\n\n        # Perform the best relocation if found\n        if best_relocation is not None:\n            other_route_idx, start, end, segment = best_relocation\n            other_route = new_solution[other_route_idx]\n\n            # Remove segment from longest route\n            longest_route = np.concatenate([longest_route[:start], longest_route[end+1:]])\n            new_solution[longest_route_idx] = longest_route\n\n            # Add segment to other route (try to minimize distance increase)\n            best_insert_pos = 1\n            best_insert_cost = float('inf')\n\n            for pos in range(1, len(other_route)):\n                # Calculate insertion cost\n                prev_node = other_route[pos-1]\n                next_node = other_route[pos]\n                cost = (distance_matrix[prev_node][segment[0]] +\n                        distance_matrix[segment[-1]][next_node] -\n                        distance_matrix[prev_node][next_node])\n\n                if cost < best_insert_cost:\n                    best_insert_cost = cost\n                    best_insert_pos = pos\n\n            # Insert segment at best position\n            new_other_route = np.concatenate([other_route[:best_insert_pos], segment, other_route[best_insert_pos:]])\n            new_solution[other_route_idx] = new_other_route\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.730628041318885,
            5.071630924940109
        ],
        "raw_score": [
            53.66299569398137,
            6.403905508683793
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of total distance and makespan) and applies a hybrid local search combining demand-aware route splitting, inter-route customer reallocation, and optimal route merging, prioritizing distance reduction (70%) over makespan improvement (30%) to balance both objectives while ensuring feasibility. The method intelligently splits overloaded routes, reallocates customers to reduce distance and makespan, and merges feasible routes to improve efficiency.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: demand-aware route splitting, customer reallocation, and route merging\n    if len(new_solution) > 1:\n        # Step 1: Demand-aware route splitting\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) <= 3:\n                continue\n\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand <= capacity:\n                continue\n\n            # Find the best split point to balance demand\n            best_split = -1\n            min_imbalance = float('inf')\n            current_load = 0\n\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                remaining_load = total_demand - current_load\n                imbalance = abs(current_load - remaining_load)\n\n                if imbalance < min_imbalance:\n                    min_imbalance = imbalance\n                    best_split = j\n\n            if best_split != -1:\n                new_route1 = np.concatenate([route[:best_split+1], [0]])\n                new_route2 = np.concatenate([[0], route[best_split+1:]])\n                new_solution[i] = new_route1\n                new_solution.insert(i+1, new_route2)\n\n        # Step 2: Inter-route customer reallocation\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) <= 3:\n                continue\n\n            for j in range(1, len(route)-1):\n                customer = route[j]\n                current_route_index = i\n\n                best_route_index = -1\n                best_improvement = 0\n\n                for k in range(len(new_solution)):\n                    if k == current_route_index:\n                        continue\n\n                    other_route = new_solution[k]\n                    if sum(demand[node] for node in other_route[1:-1]) + demand[customer] > capacity:\n                        continue\n\n                    # Calculate multi-objective improvement\n                    pred = route[j-1]\n                    succ = route[j+1]\n                    original_distance = distance_matrix[pred, customer] + distance_matrix[customer, succ]\n\n                    last_node = other_route[-2]\n                    new_distance = distance_matrix[last_node, customer] + distance_matrix[customer, 0]\n\n                    distance_reduction = original_distance - new_distance\n                    makespan_improvement = max(\n                        sum(distance_matrix[route_idx, route_idx+1] for route_idx in range(len(route)-1)),\n                        sum(distance_matrix[other_route_idx, other_route_idx+1] for other_route_idx in range(len(other_route)-1)) + new_distance\n                    ) - max(\n                        sum(distance_matrix[route_idx, route_idx+1] for route_idx in range(len(route)-1)),\n                        sum(distance_matrix[other_route_idx, other_route_idx+1] for other_route_idx in range(len(other_route)-1))\n                    )\n\n                    total_improvement = 0.7 * distance_reduction + 0.3 * makespan_improvement\n\n                    if total_improvement > best_improvement:\n                        best_improvement = total_improvement\n                        best_route_index = k\n\n                if best_route_index != -1:\n                    new_solution[best_route_index] = np.concatenate([new_solution[best_route_index][:-1], [customer], [0]])\n                    new_solution[current_route_index] = np.concatenate([route[:j], route[j+1:]])\n\n                    if len(new_solution[current_route_index]) == 2:\n                        del new_solution[current_route_index]\n                        break\n\n        # Step 3: Optimal route merging\n        best_pair = None\n        best_improvement = 0\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) > capacity:\n                    continue\n\n                # Calculate multi-objective improvement\n                original_distance = sum(distance_matrix[route1_idx, route1_idx+1] for route1_idx in range(len(route1)-1)) + \\\n                                   sum(distance_matrix[route2_idx, route2_idx+1] for route2_idx in range(len(route2)-1))\n                merged_distance = sum(distance_matrix[merged_idx, merged_idx+1] for merged_idx in range(len(np.concatenate([route1[:-1], route2[1:]]))-1))\n\n                distance_improvement = original_distance - merged_distance\n                makespan_improvement = max(\n                    sum(distance_matrix[route1_idx, route1_idx+1] for route1_idx in range(len(route1)-1)),\n                    sum(distance_matrix[route2_idx, route2_idx+1] for route2_idx in range(len(route2)-1))\n                ) - merged_distance\n\n                total_improvement = 0.7 * distance_improvement + 0.3 * makespan_improvement\n\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pair = (i, j)\n\n        if best_pair is not None:\n            i, j = best_pair\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6796069861252629,
            5.80739551782608
        ],
        "raw_score": [
            58.26780801467536,
            7.851560018798306
        ]
    }
]