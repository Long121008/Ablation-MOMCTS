[
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with balanced makespan and distance, then applies a hybrid local search combining spatial-aware route merging and demand-aware customer redistribution. It first clusters routes by spatial proximity, merging feasible routes or redistributing customers between nearby clusters, followed by balancing demand imbalances by transferring customers between routes while maintaining capacity constraints. The approach prioritizes spatial proximity for merging and demand balance for redistribution, ensuring feasible solutions while targeting simultaneous improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial-aware route clustering\n    if len(new_solution) > 1:\n        # Calculate centroids for each route\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n\n        # Pair routes with closest centroids\n        route_pairs = []\n        used = set()\n        for i in range(len(centroids)):\n            if i in used:\n                continue\n            min_dist = float('inf')\n            best_j = -1\n            for j in range(i+1, len(centroids)):\n                if j not in used:\n                    dist = np.linalg.norm(centroids[i] - centroids[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_j = j\n            if best_j != -1:\n                route_pairs.append((i, best_j))\n                used.add(i)\n                used.add(best_j)\n\n        # For each pair, try merging if capacity allows\n        for i, j in route_pairs:\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution[j] = np.array([0])  # Mark for removal\n            else:\n                # Redistribute customers based on spatial proximity\n                customers = list(route1[1:-1]) + list(route2[1:-1])\n                centroid1 = centroids[i]\n                centroid2 = centroids[j]\n\n                # Split customers between routes\n                route1_customers = []\n                route2_customers = []\n                for customer in customers:\n                    dist1 = np.linalg.norm(coords[customer] - centroid1)\n                    dist2 = np.linalg.norm(coords[customer] - centroid2)\n                    if dist1 < dist2:\n                        route1_customers.append(customer)\n                    else:\n                        route2_customers.append(customer)\n\n                # Rebuild routes with new customers\n                if sum(demand[node] for node in route1_customers) <= capacity:\n                    new_solution[i] = np.concatenate([[0], route1_customers, [0]])\n                if sum(demand[node] for node in route2_customers) <= capacity:\n                    new_solution[j] = np.concatenate([[0], route2_customers, [0]])\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 2: Demand-aware customer redistribution\n    if len(new_solution) > 1:\n        # Find the most imbalanced route (highest demand deviation from average)\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n        imbalances = [abs(d - avg_demand) for d in route_demands]\n        source_idx = imbalances.index(max(imbalances))\n\n        # Find the most compatible route to receive customers\n        target_idx = min(range(len(new_solution)), key=lambda i: abs(sum(demand[node] for node in new_solution[i][1:-1]) - avg_demand) if i != source_idx else float('inf'))\n\n        source_route = new_solution[source_idx]\n        target_route = new_solution[target_idx]\n\n        # Try to transfer customers from source to target\n        source_customers = list(source_route[1:-1])\n        target_customers = list(target_route[1:-1])\n        transferred = False\n\n        for customer in source_customers:\n            if sum(demand[node] for node in target_customers) + demand[customer] <= capacity:\n                target_customers.append(customer)\n                source_customers.remove(customer)\n                transferred = True\n\n        if transferred:\n            # Rebuild routes\n            new_solution[source_idx] = np.concatenate([[0], source_customers, [0]])\n            new_solution[target_idx] = np.concatenate([[0], target_customers, [0]])\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8311703624804405,
            1.0237776935100555
        ],
        "raw_score": [
            58.3023752816847,
            7.88680034130579
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing lower makespan (with total distance as a tiebreaker), then applies a hybrid local search that randomly inverts a route segment (if feasible) and may split the route into two (if both resulting routes are capacity-feasible). The method ensures feasibility by reverting changes if capacity constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize solutions with lower makespan, then total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Invert a segment within a route or split a route into two\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Need at least one customer to invert or split\n            # Invert a segment within the route\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            inverted_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Check if the inverted route is feasible\n            if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                new_solution[route_idx] = route  # Revert if infeasible\n            else:\n                # Try splitting the route if inversion is successful\n                split_pos = random.randint(1, len(new_route) - 2)\n                first_part = np.concatenate([[0], new_route[1:split_pos + 1], [0]])\n                second_part = np.concatenate([[0], new_route[split_pos + 1:-1], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9001978421599203,
            1.1289136409759521
        ],
        "raw_score": [
            68.28775165670466,
            2.6695998127591607
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted trade-off between distance (60%) and makespan (40%), then applies a hybrid local search that first clusters customers by demand imbalance to create new routes, followed by spatial-aware segment inversion to optimize route distances, while ensuring all operations maintain vehicle capacity constraints. The method prioritizes routes with high demand variability and long segments for improvement, with feasibility checks that revert to the original solution if constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Identify route with highest demand imbalance\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            # Demand-aware route clustering\n            if len(route) > 4:\n                # Group customers by demand similarity\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                # Split into high and low demand groups\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    # Create new routes for each group\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]  # Focus on the new route\n\n            # Spatial-aware segment inversion\n            if len(route) > 3:\n                # Find the most distant segment\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                # Invert the most distant segment\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8070185825262003,
            0.1717846393585205
        ],
        "raw_score": [
            58.04923532146222,
            7.751749039460872
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search combining route segment reversal and demand-aware insertion, and includes a 70% chance to split large routes while ensuring capacity constraints are met. It intelligently selects promising solutions from the archive, modifies them through creative local search operators, and reverts to the original if feasibility is violated. The method balances exploration and exploitation by combining segment reversal, inter-route customer transfers, and conditional route splitting.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: x[1][0])  # Prioritize solutions with lower total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose one route at random\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx]\n\n        # Reverse a segment in the route\n        if len(route) > 3:\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            reversed_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], reversed_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Insert a customer from another route if demands allow\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 2:\n                insert_pos = random.randint(1, len(other_route) - 1)\n                insert_node = other_route[insert_pos]\n                if sum(demand[node] for node in new_route[1:-1]) + demand[insert_node] <= capacity:\n                    new_route = np.concatenate([new_route, [insert_node]])\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = np.concatenate([other_route[:insert_pos], other_route[insert_pos + 1:]])\n\n        # Novel route splitting mechanism\n        if len(new_solution) < 3 and random.random() < 0.7:  # 70% chance to split\n            # Find a route with high demand that can be split\n            for route in new_solution:\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand > capacity * 0.7:  # Split routes with demand > 70% of capacity\n                    split_pos = random.randint(1, len(route) - 2)\n                    new_route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos + 1:-1], [0]])\n                    if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                        sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                        new_solution.remove(route)\n                        new_solution.extend([new_route1, new_route2])\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4472340025984207,
            0.13136020302772522
        ],
        "raw_score": [
            34.81157256184183,
            4.406394682854535
        ]
    },
    {
        "algorithm": "The algorithm selects a solution with the lowest combined total distance and makespan from the archive, then applies a hybrid local search combining demand-clustered route splitting (randomly dividing high-demand routes) and spatial-aware customer reallocation (moving depot-proximal customers between routes while respecting capacity constraints). It prioritizes solutions with balanced objectives and uses randomized operations to explore the solution space while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-clustered splitting\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            customers = route[1:-1]\n            if len(customers) > 1:\n                split_pos = random.randint(1, len(customers) - 1)\n                first_part = np.concatenate([[0], customers[:split_pos], [0]])\n                second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    route = new_solution[-1]\n\n        # Spatial-aware reallocation\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            depot_coords = coords[0]\n            closest_customer = min(route[1:-1], key=lambda x: np.linalg.norm(coords[x] - depot_coords))\n\n            if sum(demand[node] for node in other_route[1:-1]) + demand[closest_customer] <= capacity:\n                insert_pos = random.randint(1, len(other_route) - 1)\n                new_other_route = np.concatenate([other_route[:insert_pos], [closest_customer], other_route[insert_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                new_route = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                           route[np.where(route == closest_customer)[0][0] + 1:]])\n                new_solution[route_idx] = new_route\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.6393687239905992,
            0.18348291516304016
        ],
        "raw_score": [
            55.530776053518665,
            5.9390028569596165
        ]
    },
    {
        "algorithm": "The algorithm combines demand-aware clustering with spatial-aware redistribution, prioritizing routes with high demand imbalance to balance distance and makespan objectives while ensuring feasibility through dynamic capacity checks. It first redistributes customers from overloaded routes to underutilized routes based on spatial proximity and demand feasibility, then applies an adaptive segment inversion mechanism to reverse long route segments for makespan optimization, reverting to the original solution if capacity constraints are violated. The algorithm emphasizes demand balance and spatial efficiency while maintaining feasibility through iterative checks and selective segment operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: max([sum(demand[route[1:-1]]) for route in x[0]]) - min([sum(demand[route[1:-1]]) for route in x[0]]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-aware clustering and redistribution\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        max_demand_route = np.argmax(route_demands)\n        min_demand_route = np.argmin(route_demands)\n\n        # Find customers in max demand route that can be moved to min demand route\n        max_route = new_solution[max_demand_route]\n        min_route = new_solution[min_demand_route]\n        current_min_demand = route_demands[min_demand_route]\n\n        for customer in max_route[1:-1]:\n            if current_min_demand + demand[customer] <= capacity:\n                # Find best insertion point in min demand route (spatial-aware)\n                best_pos = 1\n                min_distance_increase = float('inf')\n\n                for i in range(1, len(min_route)):\n                    # Calculate distance increase if inserted at position i\n                    prev_node = min_route[i-1]\n                    next_node = min_route[i]\n                    current_dist = distance_matrix[prev_node][next_node]\n                    new_dist = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node]\n\n                    if new_dist - current_dist < min_distance_increase:\n                        min_distance_increase = new_dist - current_dist\n                        best_pos = i\n\n                # Perform the move\n                new_min_route = np.concatenate([min_route[:best_pos], [customer], min_route[best_pos:]])\n                new_max_route = np.delete(max_route, np.where(max_route == customer)[0][0])\n\n                if len(new_max_route) > 2:\n                    new_solution[max_demand_route] = new_max_route\n                    new_solution[min_demand_route] = new_min_route\n                    break\n\n        # Adaptive segment inversion for makespan optimization\n        if len(new_solution) > 0:\n            # Select route with longest segment (potential for improvement)\n            longest_route_idx = np.argmax([len(route) for route in new_solution])\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 3:\n                # Find segment with maximum distance\n                max_segment_dist = -1\n                best_segment = (1, 1)  # default to first segment\n\n                for i in range(1, len(longest_route)-1):\n                    for j in range(i+1, len(longest_route)-1):\n                        segment_dist = sum(distance_matrix[longest_route[k]][longest_route[k+1]] for k in range(i, j))\n                        if segment_dist > max_segment_dist:\n                            max_segment_dist = segment_dist\n                            best_segment = (i, j)\n\n                i, j = best_segment\n                inverted_segment = longest_route[i:j+1][::-1]\n                new_route = np.concatenate([longest_route[:i], inverted_segment, longest_route[j+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[longest_route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8428050631403599,
            6.670592367649078
        ],
        "raw_score": [
            57.28428965898158,
            7.613909309310344
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan from the archive, applies a hybrid local search that splits overloaded routes to balance demand, and reallocates customers between routes to reduce total distance while maintaining feasibility. It prioritizes makespan reduction through route splitting and distance optimization through customer reallocation, ensuring vehicle capacity constraints are always satisfied.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Check if splitting the route can improve makespan\n        total_demand = sum(demand[customer] for customer in route[1:-1])\n        if total_demand <= capacity:\n            continue  # Route is already feasible\n\n        # Find the best split point to balance demand\n        best_split = -1\n        min_max_load = float('inf')\n        current_load = 0\n\n        for j in range(1, len(route)-1):\n            current_load += demand[route[j]]\n            remaining_load = total_demand - current_load\n            max_load = max(current_load, remaining_load)\n\n            if max_load < min_max_load:\n                min_max_load = max_load\n                best_split = j\n\n        if best_split != -1:\n            # Split the route at best_split\n            new_route1 = np.concatenate([route[:best_split+1], [0]])\n            new_route2 = np.concatenate([[0], route[best_split+1:]])\n\n            # Replace the original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Reallocate customers to improve distance while maintaining feasibility\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to move customers to other routes if it reduces total distance\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            current_route_index = i\n\n            # Find the best route to move the customer to\n            best_route_index = -1\n            best_distance_reduction = 0\n\n            for k in range(len(new_solution)):\n                if k == current_route_index:\n                    continue\n\n                other_route = new_solution[k]\n                if sum(demand[customer] for customer in other_route[1:-1]) + demand[customer] > capacity:\n                    continue  # Skip if adding customer exceeds capacity\n\n                # Calculate distance reduction if moved\n                # Distance before: distance from predecessor to customer and customer to successor in current route\n                pred = route[j-1]\n                succ = route[j+1]\n                original_distance = distance_matrix[pred, customer] + distance_matrix[customer, succ]\n\n                # Distance after: distance from last node in other route to customer and customer to depot\n                last_node = other_route[-2]\n                new_distance = distance_matrix[last_node, customer] + distance_matrix[customer, 0]\n\n                distance_reduction = original_distance - new_distance\n\n                if distance_reduction > best_distance_reduction:\n                    best_distance_reduction = distance_reduction\n                    best_route_index = k\n\n            if best_route_index != -1:\n                # Move the customer to the best route\n                customer = route[j]\n                new_solution[best_route_index] = np.concatenate([new_solution[best_route_index][:-1], [customer], [0]])\n\n                # Remove the customer from the original route\n                new_solution[current_route_index] = np.concatenate([route[:j], route[j+1:]])\n\n                # If the original route is now empty, remove it\n                if len(new_solution[current_route_index]) == 2:\n                    del new_solution[current_route_index]\n                    break  # Restart the loop since the list has changed\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8197619970622914,
            4.295692175626755
        ],
        "raw_score": [
            58.032952507921905,
            7.675296988668824
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging, while also incorporating a novel \"route splitting\" mechanism (with a 30% chance) to improve solutions while ensuring feasibility. It intelligently selects routes, segments, and insertion points, checks capacity constraints, and reverts to the original solution if feasibility is violated. The algorithm balances exploration (random selection) and exploitation (prioritization) of high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n        # Novel route splitting mechanism\n        if len(new_solution) < len(base_solution) and random.random() < 0.3:  # 30% chance to split a route\n            long_route = max(new_solution, key=lambda r: len(r))\n            if len(long_route) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(long_route) - 3)\n                first_part = np.concatenate([long_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check capacity constraints for both parts\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution.remove(long_route)\n                    new_solution.append(first_part)\n                    new_solution.append(second_part)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7624629018001627,
            0.2549241781234741
        ],
        "raw_score": [
            36.91533735728953,
            4.559352320583427
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive (prioritizing shorter makespan and then distance), applies hierarchical clustering to group customers based on demand and spatial proximity, and then constructs new routes through demand-aware merging and splitting while maintaining capacity constraints. It uses distance-based heuristics to identify and split routes with excessive detours, ensuring feasible and potentially improved solutions. The key design idea is to balance spatial connectivity and demand efficiency while intelligently redistributing customers between routes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    all_customers = []\n    for route in new_solution:\n        all_customers.extend(route[1:-1])\n\n    if not all_customers:\n        return new_solution\n\n    from scipy.cluster.hierarchy import fcluster, linkage\n    features = np.column_stack([demand[all_customers], coords[all_customers].mean(axis=1)])\n    Z = linkage(features, method='ward')\n    clusters = fcluster(Z, t=len(new_solution), criterion='maxclust')\n\n    clustered_routes = []\n    for cluster_id in np.unique(clusters):\n        cluster_customers = [all_customers[i] for i, cid in enumerate(clusters) if cid == cluster_id]\n        if not cluster_customers:\n            continue\n\n        depot_distances = distance_matrix[0, cluster_customers]\n        sorted_customers = [x for _, x in sorted(zip(depot_distances, cluster_customers))]\n\n        current_route = [0]\n        current_load = 0\n        for customer in sorted_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                clustered_routes.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n        current_route.append(0)\n        clustered_routes.append(np.array(current_route))\n\n    merged_routes = []\n    for route in clustered_routes:\n        merged = False\n        for i, existing_route in enumerate(merged_routes):\n            if sum(demand[node] for node in existing_route[1:-1]) + sum(demand[node] for node in route[1:-1]) <= capacity:\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_routes[i] = merged_route\n                merged = True\n                break\n        if not merged:\n            merged_routes.append(route.copy())\n\n    for route in merged_routes:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    for i in range(len(merged_routes)):\n        route = merged_routes[i]\n        customers = route[1:-1]\n        if len(customers) > 1:\n            total_dist = sum(distance_matrix[customers[j-1]][customers[j]] for j in range(1, len(customers)))\n            total_dist += distance_matrix[0][customers[0]] + distance_matrix[customers[-1]][0]\n            avg_dist = total_dist / len(customers)\n\n            for j in range(1, len(customers)-1):\n                if distance_matrix[customers[j-1]][customers[j]] > 1.5 * avg_dist:\n                    new_route1 = np.array([0] + customers[:j] + [0])\n                    new_route2 = np.array([0] + customers[j:] + [0])\n                    if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                        sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                        merged_routes[i] = new_route1\n                        merged_routes.append(new_route2)\n                        break\n\n    return merged_routes\n\n",
        "metric_score": [
            -0.8143697787866883,
            1.347191721200943
        ],
        "raw_score": [
            58.8163143790444,
            7.755327176783741
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (prioritizing those with makespan/distance ratios close to 1) and applies a hybrid local search combining demand-based hierarchical route splitting and spatial-aware customer reallocation, ensuring feasibility through capacity checks while intelligently balancing the bi-objective trade-offs. The selection criterion emphasizes solutions where makespan and distance are relatively balanced, while the search operator prioritizes demand clustering and spatial proximity to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-clustered hierarchical splitting\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            customers = route[1:-1]\n            if len(customers) > 1:\n                # Hierarchical clustering based on demand\n                demand_values = demand[customers]\n                sorted_indices = np.argsort(demand_values)\n                split_pos = len(customers) // 2\n\n                first_part = np.concatenate([[0], customers[sorted_indices[:split_pos]], [0]])\n                second_part = np.concatenate([[0], customers[sorted_indices[split_pos:]], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    route = new_solution[-1]\n\n        # Spatial-aware reallocation\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Find customer in current route closest to other route's centroid\n            other_route_coords = coords[other_route[1:-1]]\n            other_centroid = np.mean(other_route_coords, axis=0)\n            closest_customer = min(route[1:-1], key=lambda x: np.linalg.norm(coords[x] - other_centroid))\n\n            if sum(demand[node] for node in other_route[1:-1]) + demand[closest_customer] <= capacity:\n                # Insert closest customer into other route at position closest to its coordinates\n                other_route_coords = coords[other_route[1:-1]]\n                distances = [np.linalg.norm(coords[closest_customer] - coord) for coord in other_route_coords]\n                insert_pos = np.argmin(distances) + 1\n\n                new_other_route = np.concatenate([other_route[:insert_pos], [closest_customer], other_route[insert_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                new_route = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                           route[np.where(route == closest_customer)[0][0] + 1:]])\n                new_solution[route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.6645379240643329,
            0.1927325427532196
        ],
        "raw_score": [
            58.79058686924157,
            5.575881036470572
        ]
    }
]