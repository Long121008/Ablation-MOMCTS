[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging to improve the solution while ensuring feasibility. It randomly selects two routes, relocates a segment between them if capacity allows, or merges them if possible, and checks feasibility before returning the new solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Relocate a segment between routes or merge two routes\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:  # Need at least one customer to relocate\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5333262969216688,
            0.22810059785842896
        ],
        "raw_score": [
            37.52143125387771,
            4.577189938048067
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with balanced makespan and distance, then applies a hybrid local search combining spatial-aware route merging and demand-aware customer redistribution. It first clusters routes by spatial proximity, merging feasible routes or redistributing customers between nearby clusters, followed by balancing demand imbalances by transferring customers between routes while maintaining capacity constraints. The approach prioritizes spatial proximity for merging and demand balance for redistribution, ensuring feasible solutions while targeting simultaneous improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial-aware route clustering\n    if len(new_solution) > 1:\n        # Calculate centroids for each route\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n\n        # Pair routes with closest centroids\n        route_pairs = []\n        used = set()\n        for i in range(len(centroids)):\n            if i in used:\n                continue\n            min_dist = float('inf')\n            best_j = -1\n            for j in range(i+1, len(centroids)):\n                if j not in used:\n                    dist = np.linalg.norm(centroids[i] - centroids[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_j = j\n            if best_j != -1:\n                route_pairs.append((i, best_j))\n                used.add(i)\n                used.add(best_j)\n\n        # For each pair, try merging if capacity allows\n        for i, j in route_pairs:\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution[j] = np.array([0])  # Mark for removal\n            else:\n                # Redistribute customers based on spatial proximity\n                customers = list(route1[1:-1]) + list(route2[1:-1])\n                centroid1 = centroids[i]\n                centroid2 = centroids[j]\n\n                # Split customers between routes\n                route1_customers = []\n                route2_customers = []\n                for customer in customers:\n                    dist1 = np.linalg.norm(coords[customer] - centroid1)\n                    dist2 = np.linalg.norm(coords[customer] - centroid2)\n                    if dist1 < dist2:\n                        route1_customers.append(customer)\n                    else:\n                        route2_customers.append(customer)\n\n                # Rebuild routes with new customers\n                if sum(demand[node] for node in route1_customers) <= capacity:\n                    new_solution[i] = np.concatenate([[0], route1_customers, [0]])\n                if sum(demand[node] for node in route2_customers) <= capacity:\n                    new_solution[j] = np.concatenate([[0], route2_customers, [0]])\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 2: Demand-aware customer redistribution\n    if len(new_solution) > 1:\n        # Find the most imbalanced route (highest demand deviation from average)\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n        imbalances = [abs(d - avg_demand) for d in route_demands]\n        source_idx = imbalances.index(max(imbalances))\n\n        # Find the most compatible route to receive customers\n        target_idx = min(range(len(new_solution)), key=lambda i: abs(sum(demand[node] for node in new_solution[i][1:-1]) - avg_demand) if i != source_idx else float('inf'))\n\n        source_route = new_solution[source_idx]\n        target_route = new_solution[target_idx]\n\n        # Try to transfer customers from source to target\n        source_customers = list(source_route[1:-1])\n        target_customers = list(target_route[1:-1])\n        transferred = False\n\n        for customer in source_customers:\n            if sum(demand[node] for node in target_customers) + demand[customer] <= capacity:\n                target_customers.append(customer)\n                source_customers.remove(customer)\n                transferred = True\n\n        if transferred:\n            # Rebuild routes\n            new_solution[source_idx] = np.concatenate([[0], source_customers, [0]])\n            new_solution[target_idx] = np.concatenate([[0], target_customers, [0]])\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8311703624804405,
            1.0237776935100555
        ],
        "raw_score": [
            58.3023752816847,
            7.88680034130579
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging, while also incorporating a novel \"route splitting\" mechanism (with a 30% chance) to improve solutions while ensuring feasibility. It intelligently selects routes, segments, and insertion points, checks capacity constraints, and reverts to the original solution if feasibility is violated. The algorithm balances exploration (random selection) and exploitation (prioritization) of high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n        # Novel route splitting mechanism\n        if len(new_solution) < len(base_solution) and random.random() < 0.3:  # 30% chance to split a route\n            long_route = max(new_solution, key=lambda r: len(r))\n            if len(long_route) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(long_route) - 3)\n                first_part = np.concatenate([long_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check capacity constraints for both parts\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution.remove(long_route)\n                    new_solution.append(first_part)\n                    new_solution.append(second_part)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7624629018001627,
            0.2549241781234741
        ],
        "raw_score": [
            36.91533735728953,
            4.559352320583427
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing lower makespan (with total distance as a tiebreaker), then applies a hybrid local search that randomly inverts a route segment (if feasible) and may split the route into two (if both resulting routes are capacity-feasible). The method ensures feasibility by reverting changes if capacity constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize solutions with lower makespan, then total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Invert a segment within a route or split a route into two\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Need at least one customer to invert or split\n            # Invert a segment within the route\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            inverted_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Check if the inverted route is feasible\n            if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                new_solution[route_idx] = route  # Revert if infeasible\n            else:\n                # Try splitting the route if inversion is successful\n                split_pos = random.randint(1, len(new_route) - 2)\n                first_part = np.concatenate([[0], new_route[1:split_pos + 1], [0]])\n                second_part = np.concatenate([[0], new_route[split_pos + 1:-1], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9001978421599203,
            1.1289136409759521
        ],
        "raw_score": [
            68.28775165670466,
            2.6695998127591607
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance (with makespan as a tiebreaker) from the archive, then applies a hybrid local search combining route inversion, segment relocation, and merging to generate feasible neighbors while balancing both objectives. It probabilistically selects one of three operations to modify routes, ensuring capacity constraints are met, and falls back to the original solution if feasibility is violated. The approach intelligently explores the solution space by combining novel route transformations while maintaining solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0], x[1][1]))  # Prioritize solutions with lower total distance, then makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Randomly choose one of three operations: invert, relocate, or merge\n        operation = random.choice(['invert', 'relocate', 'merge'])\n\n        if operation == 'invert' and len(new_solution) > 0:\n            # Select a random route and invert a segment\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                segment_start = random.randint(1, len(route) - 2)\n                segment_end = random.randint(segment_start, len(route) - 2)\n                inverted_segment = route[segment_start:segment_end + 1][::-1]\n                new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        elif operation == 'relocate' and len(new_solution) > 1:\n            # Relocate a segment between two different routes\n            src_route_idx = random.randint(0, len(new_solution) - 1)\n            dst_route_idx = random.randint(0, len(new_solution) - 1)\n            if src_route_idx != dst_route_idx:\n                src_route = new_solution[src_route_idx]\n                dst_route = new_solution[dst_route_idx]\n                if len(src_route) > 3 and len(dst_route) > 2:\n                    segment_start = random.randint(1, len(src_route) - 2)\n                    segment_end = random.randint(segment_start, len(src_route) - 2)\n                    relocated_segment = src_route[segment_start:segment_end + 1]\n                    new_src_route = np.concatenate([src_route[:segment_start], src_route[segment_end + 1:]])\n                    new_dst_route = np.concatenate([dst_route[:1], relocated_segment, dst_route[1:]])\n\n                    if (sum(demand[node] for node in new_src_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in new_dst_route[1:-1]) <= capacity):\n                        new_solution[src_route_idx] = new_src_route\n                        new_solution[dst_route_idx] = new_dst_route\n\n        elif operation == 'merge' and len(new_solution) > 1:\n            # Merge two routes if their combined demand is feasible\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 2 and len(route2) > 2:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                if sum(demand[node] for node in merged_route[1:-1]) <= capacity:\n                    new_solution.pop(max(route1_idx, route2_idx))\n                    new_solution.pop(min(route1_idx, route2_idx))\n                    new_solution.append(merged_route)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5183306671620231,
            0.2092544138431549
        ],
        "raw_score": [
            35.40889539301948,
            4.49321926746614
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest total distance (prioritizing makespan as a tiebreaker) from the archive, then applies a hybrid local search that randomly swaps segments between two routes while ensuring feasibility by reverting infeasible changes and conditionally merging routes if needed. It prioritizes load-balanced routes by checking capacity constraints and reverts to the original solution if any route exceeds capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0], x[1][1]))  # Prioritize solutions with lower total distance, then makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Swap segments between two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments from both routes\n            seg1_start, seg1_end = sorted(random.sample(range(1, len(route1) - 1), 2))\n            seg2_start, seg2_end = sorted(random.sample(range(1, len(route2) - 1), 2))\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end + 1], route1[seg1_end + 1:]])\n            new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end + 1], route2[seg2_end + 1:]])\n\n            # Check feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                # Conditional merging if swapping fails\n                merged_route = np.concatenate([route1, route2[1:-1], [0]])\n                if sum(demand[node] for node in merged_route[1:-1]) <= capacity:\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6393399640001438,
            0.24897456169128418
        ],
        "raw_score": [
            34.66491860488229,
            4.428994547812563
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower makespan, then applies a hybrid local search combining demand-clustered route splitting, spatial-aware customer reallocation, and segment inversion, while ensuring feasibility through capacity checks. It dynamically selects routes and customers for modification, balancing distance and makespan objectives through strategic segment operations and spatial proximity considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize lower makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Demand-clustered splitting\n            customers = route[1:-1]\n            if len(customers) > 1:\n                split_pos = random.randint(1, len(customers) - 1)\n                first_part = np.concatenate([[0], customers[:split_pos], [0]])\n                second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    route = new_solution[-1]  # Focus on the new route\n\n            # Spatial-aware reallocation\n            if len(new_solution) > 1 and len(route) > 3:\n                other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx]\n\n                # Find closest customer in the current route to the other route's depot\n                depot_coords = coords[0]\n                closest_customer = min(route[1:-1], key=lambda x: np.linalg.norm(coords[x] - depot_coords))\n\n                if sum(demand[node] for node in other_route[1:-1]) + demand[closest_customer] <= capacity:\n                    # Insert closest customer into other route\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.concatenate([other_route[:insert_pos], [closest_customer], other_route[insert_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove from current route\n                    new_route = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                               route[np.where(route == closest_customer)[0][0] + 1:]])\n                    new_solution[route_idx] = new_route\n\n            # Segment inversion\n            if len(route) > 3:\n                segment_start = random.randint(1, len(route) - 2)\n                segment_end = random.randint(segment_start, len(route) - 2)\n                inverted_segment = route[segment_start:segment_end + 1][::-1]\n                new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7958546958714325,
            0.5512029230594635
        ],
        "raw_score": [
            62.771142253628895,
            5.684504530286869
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan from the archive, applies a hybrid local search that splits overloaded routes to balance demand, and reallocates customers between routes to reduce total distance while maintaining feasibility. It prioritizes makespan reduction through route splitting and distance optimization through customer reallocation, ensuring vehicle capacity constraints are always satisfied.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Check if splitting the route can improve makespan\n        total_demand = sum(demand[customer] for customer in route[1:-1])\n        if total_demand <= capacity:\n            continue  # Route is already feasible\n\n        # Find the best split point to balance demand\n        best_split = -1\n        min_max_load = float('inf')\n        current_load = 0\n\n        for j in range(1, len(route)-1):\n            current_load += demand[route[j]]\n            remaining_load = total_demand - current_load\n            max_load = max(current_load, remaining_load)\n\n            if max_load < min_max_load:\n                min_max_load = max_load\n                best_split = j\n\n        if best_split != -1:\n            # Split the route at best_split\n            new_route1 = np.concatenate([route[:best_split+1], [0]])\n            new_route2 = np.concatenate([[0], route[best_split+1:]])\n\n            # Replace the original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Reallocate customers to improve distance while maintaining feasibility\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to move customers to other routes if it reduces total distance\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            current_route_index = i\n\n            # Find the best route to move the customer to\n            best_route_index = -1\n            best_distance_reduction = 0\n\n            for k in range(len(new_solution)):\n                if k == current_route_index:\n                    continue\n\n                other_route = new_solution[k]\n                if sum(demand[customer] for customer in other_route[1:-1]) + demand[customer] > capacity:\n                    continue  # Skip if adding customer exceeds capacity\n\n                # Calculate distance reduction if moved\n                # Distance before: distance from predecessor to customer and customer to successor in current route\n                pred = route[j-1]\n                succ = route[j+1]\n                original_distance = distance_matrix[pred, customer] + distance_matrix[customer, succ]\n\n                # Distance after: distance from last node in other route to customer and customer to depot\n                last_node = other_route[-2]\n                new_distance = distance_matrix[last_node, customer] + distance_matrix[customer, 0]\n\n                distance_reduction = original_distance - new_distance\n\n                if distance_reduction > best_distance_reduction:\n                    best_distance_reduction = distance_reduction\n                    best_route_index = k\n\n            if best_route_index != -1:\n                # Move the customer to the best route\n                customer = route[j]\n                new_solution[best_route_index] = np.concatenate([new_solution[best_route_index][:-1], [customer], [0]])\n\n                # Remove the customer from the original route\n                new_solution[current_route_index] = np.concatenate([route[:j], route[j+1:]])\n\n                # If the original route is now empty, remove it\n                if len(new_solution[current_route_index]) == 2:\n                    del new_solution[current_route_index]\n                    break  # Restart the loop since the list has changed\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8197619970622914,
            4.295692175626755
        ],
        "raw_score": [
            58.032952507921905,
            7.675296988668824
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of makespan (70%) and total distance (30%), then applies a hybrid local search that combines route merging (when feasible), demand-balanced route splitting (to balance capacity), and adaptive 3-opt (on the longest route) to improve both objectives while maintaining feasibility. It prioritizes reducing makespan early by favoring solutions with shorter longest routes, while also optimizing total distance through intelligent route restructuring.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (0.7 * x[1][1] + 0.3 * x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging, demand-balanced splitting, and adaptive 3-opt\n    if len(new_solution) > 1:\n        # Route merging: try to merge two routes if their combined demand is within capacity\n        for _ in range(min(3, len(new_solution) - 1)):\n            route1_idx, route2_idx = sorted(random.sample(range(len(new_solution)), 2))\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if sum(demand[node] for node in route1) + sum(demand[node] for node in route2) <= capacity:\n                # Merge routes by connecting them at the closest pair of nodes\n                min_dist = float('inf')\n                best_pair = (None, None)\n\n                for i in range(1, len(route1) - 1):\n                    for j in range(1, len(route2) - 1):\n                        dist = distance_matrix[route1[i]][route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (i, j)\n\n                if best_pair[0] is not None:\n                    # Create merged route\n                    merged_route = np.concatenate([\n                        route1[:best_pair[0] + 1],\n                        route2[best_pair[1]:],\n                        route1[best_pair[0] + 1:]\n                    ])\n                    new_solution[route1_idx] = merged_route\n                    new_solution.pop(route2_idx)\n                    break\n\n        # Demand-balanced route splitting: split routes that are too long\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:\n                total_demand = sum(demand[node] for node in route[1:-1])\n                if total_demand > capacity:\n                    # Find optimal split point to balance demand\n                    cumulative_demand = np.cumsum([demand[node] for node in route[1:-1]])\n                    target_demand = total_demand / 2\n                    split_point = np.argmin(np.abs(cumulative_demand - target_demand)) + 1\n\n                    # Create new route from split point\n                    new_route = np.concatenate([[0], route[split_point:-1], [0]])\n                    new_solution[i] = np.concatenate([[0], route[1:split_point+1], [0]])\n                    new_solution.append(new_route)\n\n        # Adaptive 3-opt: perform 3-opt on the longest route\n        if len(new_solution) > 0:\n            longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            route = new_solution[longest_route_idx]\n\n            if len(route) > 5:  # Need at least 6 nodes for 3-opt\n                # Select three edges to reconnect\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n\n                # Generate all possible 3-opt configurations\n                configs = [\n                    (route[:i+1], route[i+1:j+1][::-1], route[j+1:k+1][::-1], route[k+1:]),\n                    (route[:i+1], route[j+1:k+1], route[i+1:j+1][::-1], route[k+1:]),\n                    (route[:j+1], route[i+1:k+1][::-1], route[j+1:i+1][::-1], route[k+1:])\n                ]\n\n                # Find the best configuration that maintains capacity constraints\n                best_config = None\n                min_cost = float('inf')\n\n                for config in configs:\n                    # Check capacity for each segment\n                    valid = True\n                    for segment in config[1:-1]:\n                        if sum(demand[node] for node in segment) > capacity:\n                            valid = False\n                            break\n\n                    if valid:\n                        # Calculate total cost of the configuration\n                        total_cost = 0\n                        prev_node = 0\n                        for segment in config:\n                            for node in segment:\n                                total_cost += distance_matrix[prev_node][node]\n                                prev_node = node\n\n                        if total_cost < min_cost:\n                            min_cost = total_cost\n                            best_config = config\n\n                if best_config is not None:\n                    # Apply the best configuration\n                    new_route = np.concatenate(best_config)\n                    new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4455812537469833,
            0.23222047090530396
        ],
        "raw_score": [
            51.52299102153323,
            6.576942519958482
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest makespan (prioritized over total distance) from the archive and applies a hybrid local search combining inter-route customer transfers, capacity-aware 2-opt within routes, and route splitting to handle capacity violations, ensuring feasibility and potential multi-objective improvements. The method favors routes with lower makespan and total distance, while the local search intelligently explores inter-route and intra-route moves to balance both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting, inter-route insertion, and capacity-aware 2-opt\n    if len(new_solution) > 1:\n        # Randomly select two routes for inter-route operations\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Inter-route insertion: try to move a customer from route1 to route2\n        if len(route1) > 2:\n            # Select a random customer from route1 (excluding depots)\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Check if moving this customer to route2 is feasible\n            current_load = sum(demand[node] for node in route2)\n            if current_load + demand[customer] <= capacity:\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Insert customer into route2 (try different positions)\n                best_position = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate insertion cost\n                    cost = distance_matrix[route2[pos-1]][customer] + distance_matrix[customer][route2[pos]] - distance_matrix[route2[pos-1]][route2[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_position = pos\n\n                # Insert the customer\n                new_route2 = np.concatenate([route2[:best_position], [customer], route2[best_position:]])\n                new_solution[route2_idx] = new_route2\n\n        # Capacity-aware 2-opt within a route\n        for route in new_solution:\n            if len(route) > 4:  # Need at least 4 nodes to perform 2-opt\n                # Select two edges to reverse\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n\n                # Check capacity constraint for the new segment\n                segment_demand = sum(demand[node] for node in route[i:j+1])\n                if segment_demand <= capacity:\n                    # Reverse the segment\n                    route[i:j+1] = route[i:j+1][::-1]\n\n    # Route splitting if a route is too long\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # If route has more than just depots\n            # Calculate cumulative demand\n            cumulative_demand = np.cumsum([demand[node] for node in route[1:-1]])\n            split_pos = np.where(cumulative_demand > capacity)[0]\n\n            if len(split_pos) > 0:\n                # Split at the first position where capacity is exceeded\n                split_point = split_pos[0] + 1  # +1 because we want to split after this customer\n\n                # Create new route from the split point\n                new_route = np.concatenate([[0], route[split_point:-1], [0]])\n                new_solution[i] = np.concatenate([[0], route[1:split_point+1], [0]])\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5896292014551943,
            0.2732754051685333
        ],
        "raw_score": [
            45.66104831782705,
            4.913209142017411
        ]
    }
]