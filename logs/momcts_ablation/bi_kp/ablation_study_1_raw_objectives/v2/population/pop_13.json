[
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (prioritizing those with high combined objective product) and applies a hybrid local search combining weighted item addition, adaptive swapping, and probabilistic flipping, while dynamically adjusting weights based on solution quality and ensuring feasibility through capacity checks. It emphasizes objective-aware selection (using weighted value metrics) and diversity maintenance (through probabilistic flips), creating a balance between exploration and exploitation. The key design focuses on adaptive weights, combined value metrics, and solution quality-aware operations to improve multi-objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives\n    archive.sort(key=lambda x: -(x[1][0] * x[1][1]))  # Sort by product of objectives\n    selected_idx = min(len(archive) // 3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate dynamic weights based on current solution quality\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = (current_value1 / total_value1) if total_value1 > 0 else 0.5\n    weight2 = (current_value2 / total_value2) if total_value2 > 0 else 0.5\n\n    # Hybrid local search: weighted item addition\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate combined value metric with adaptive weights\n        combined_values = (weight1 * value1_lst[potential_items] + weight2 * value2_lst[potential_items]) / weight_lst[potential_items]\n        top_items = potential_items[np.argsort(combined_values)[-2:]]  # Select top 2 items\n\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive swapping based on objective contributions\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Calculate relative importance of items\n        importance = (weight1 * value1_lst[in_solution] + weight2 * value2_lst[in_solution]) / weight_lst[in_solution]\n        sorted_items = in_solution[np.argsort(importance)]\n\n        # Swap least important with most promising excluded items\n        if len(sorted_items) >= 2:\n            least_important = sorted_items[0]\n            most_promising = np.argmax(combined_values) if len(potential_items) > 0 else -1\n\n            if most_promising != -1 and most_promising in potential_items:\n                temp_weight = current_weight - weight_lst[least_important] + weight_lst[most_promising]\n                if temp_weight <= capacity:\n                    new_solution[least_important] = 0\n                    new_solution[most_promising] = 1\n\n    # Probabilistic flip based on solution quality and diversity\n    flip_prob = 0.4 if (current_value1 + current_value2) / (total_value1 + total_value2) > 0.6 else 0.8\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        flip_idx = np.random.choice(len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8522696808180721,
            0.22630241513252258
        ],
        "raw_score": [
            27.121475374476667,
            27.863057367568054
        ]
    },
    {
        "algorithm": "The algorithm selects a promising non-dominated solution from the archive by prioritizing those with high potential for improvement in either objective, then applies a hybrid local search combining biased item removal/addition, balanced swaps, and probabilistic flips to generate high-quality neighbors while ensuring feasibility. The selection is guided by objective-biased probabilities, favoring either value1 or value2 improvement based on the current solution's potential, and the local search dynamically adjusts operations to explore diverse, high-potential regions of the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective improvement potential and select solution\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n    potential_scores = []\n\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue\n\n        # Calculate normalized potential for each objective\n        potential1 = (max_value1 - obj[0]) / (max_value1 + 1e-8)\n        potential2 = (max_value2 - obj[1]) / (max_value2 + 1e-8)\n\n        # Combine with objective weights based on relative potential\n        combined_potential = (potential1 + potential2) * (1 + abs(potential1 - potential2))\n        potential_scores.append((sol, combined_potential))\n\n    if not potential_scores:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Select solution with highest potential\n    potential_scores.sort(key=lambda x: -x[1])\n    base_solution = potential_scores[0][0].copy()\n\n    # Generate neighbor with novel hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Objective-biased item selection\n    objective_bias = random.random()\n    if objective_bias < 0.5:\n        # Focus on value1 improvement\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            # Remove item with lowest value1/weight ratio\n            ratios = value1_lst[candidates] / (weight_lst[candidates] + 1e-8)\n            idx = candidates[np.argmin(ratios)]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n    else:\n        # Focus on value2 improvement\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            # Remove item with lowest value2/weight ratio\n            ratios = value2_lst[candidates] / (weight_lst[candidates] + 1e-8)\n            idx = candidates[np.argmin(ratios)]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n\n    # Phase 2: Random addition with objective bias\n    if random.random() < 0.4:\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            if objective_bias < 0.5:\n                # Add item with highest value1/weight ratio\n                ratios = value1_lst[candidates] / (weight_lst[candidates] + 1e-8)\n            else:\n                # Add item with highest value2/weight ratio\n                ratios = value2_lst[candidates] / (weight_lst[candidates] + 1e-8)\n            idx = candidates[np.argmax(ratios)]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Phase 3: Balanced swaps with diversity\n    if np.sum(new_solution) > 1 and random.random() < 0.5:\n        items = np.where(new_solution == 1)[0]\n        i, j = random.sample(list(items), 2)\n        # Check if swap maintains feasibility\n        if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 4: Probabilistic flip with objective bias\n    if random.random() < 0.3:\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1 and total_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n        elif new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9296926897978155,
            0.3622717261314392
        ],
        "raw_score": [
            27.831550612136972,
            28.052400795200953
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate adaptive weights for objectives\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = current_value1 / total_value1 if total_value1 > 0 else 0.5\n    weight2 = current_value2 / total_value2 if total_value2 > 0 else 0.5\n\n    # Identify promising items to consider\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate weighted values for potential items\n        weighted_values = weight1 * value1_lst[potential_items] + weight2 * value2_lst[potential_items]\n        # Select top 3 items with highest weighted value\n        top_items = potential_items[np.argsort(weighted_values)[-3:]]\n\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Perform targeted swapping with items in solution\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Select two items to swap based on their contribution to both objectives\n        swap_candidates = sorted(in_solution, key=lambda x: -(weight1 * value1_lst[x] + weight2 * value2_lst[x]))[:2]\n        if len(swap_candidates) == 2:\n            idx1, idx2 = swap_candidates\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Perform random flip with probability based on current solution quality\n    flip_prob = 0.3 if (current_value1 + current_value2) / (total_value1 + total_value2) > 0.7 else 0.7\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        flip_idx = np.random.choice(len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8179565713407433,
            0.27593129873275757
        ],
        "raw_score": [
            27.604553890686965,
            28.184297658157398
        ]
    },
    {
        "algorithm": "The heuristic selects a balanced solution from the archive, then applies a hybrid local search combining targeted swaps (prioritizing high-value items), probabilistic flips, feasibility checks, and greedy additions of valuable items. It dynamically adjusts weights based on current solution quality and ensures feasibility through intelligent item removals and additions. The approach balances exploration and exploitation while maintaining Pareto optimality potential.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate adaptive weights for objectives\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = current_value1 / total_value1 if total_value1 > 0 else 0.5\n    weight2 = current_value2 / total_value2 if total_value2 > 0 else 0.5\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Targeted swapping based on adaptive weights\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        swap_candidates = sorted(in_solution, key=lambda x: -(weight1 * value1_lst[x] + weight2 * value2_lst[x]))[:2]\n        if len(swap_candidates) == 2:\n            idx1, idx2 = swap_candidates\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight = temp_weight\n\n    # Step 2: Random flip with probability based on solution quality\n    flip_prob = 0.3 if (current_value1 + current_value2) / (total_value1 + total_value2) > 0.7 else 0.7\n    if np.random.random() < flip_prob and n_items > 0:\n        flip_idx = np.random.choice(n_items)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    # Step 3: Ensure feasibility by removing the least valuable items if needed\n    while current_weight > capacity and len(in_solution) > 0:\n        remove_idx = in_solution[np.argmin(weight1 * value1_lst[in_solution] + weight2 * value2_lst[in_solution])]\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n        in_solution = np.where(new_solution == 1)[0]\n\n    # Step 4: Add the most valuable available items if there's remaining capacity\n    available_items = np.where(new_solution == 0)[0]\n    while len(available_items) > 0 and current_weight < capacity:\n        add_idx = available_items[np.argmax(weight1 * value1_lst[available_items] + weight2 * value2_lst[available_items])]\n        if current_weight + weight_lst[add_idx] <= capacity:\n            new_solution[add_idx] = 1\n            current_weight += weight_lst[add_idx]\n            available_items = np.where(new_solution == 0)[0]\n        else:\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8073380266351767,
            0.2613680064678192
        ],
        "raw_score": [
            27.274817832427832,
            28.08075458475086
        ]
    },
    {
        "algorithm": "The heuristic selects a near-capacity solution from the archive, then applies a hybrid local search combining item swapping and random flipping, with targeted replacement for feasibility, prioritizing solutions with high potential for multi-objective improvement while ensuring all generated neighbors remain feasible. It intelligently handles infeasibility by undoing operations and adding/removing the most valuable items, with a focus on balancing both objectives through weighted value considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback to first solution if no candidates\n\n    # Select a solution with high potential (e.g., near-capacity but not fully packed)\n    selected_sol = max(candidates, key=lambda x: np.sum(weight_lst * x))\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Randomly swap two items\n    idx1, idx2 = np.random.choice(n_items, size=2, replace=False)\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility after swap\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If swap violates capacity, undo it and try another approach\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Step 2: Randomly flip one item\n        flip_idx = np.random.choice(n_items)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility after flip\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If flip violates capacity, remove the most expensive item\n            if new_solution[flip_idx] == 1:\n                new_solution[flip_idx] = 0\n            else:\n                # Find the most expensive item to add\n                available_items = np.where(new_solution == 0)[0]\n                if len(available_items) > 0:\n                    expensive_item = available_items[np.argmax(value1_lst[available_items] + value2_lst[available_items])]\n                    if np.sum(weight_lst * new_solution) + weight_lst[expensive_item] <= capacity:\n                        new_solution[expensive_item] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9035397066548494,
            0.47091394662857056
        ],
        "raw_score": [
            27.34055461589349,
            28.03176024888062
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives using a novelty-aware selection\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Adaptive objective weighting with novelty factor\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = (current_value1 / total_value1) * (1 - (current_value1 / total_value1)) if total_value1 > 0 else 0.5\n    weight2 = (current_value2 / total_value2) * (1 - (current_value2 / total_value2)) if total_value2 > 0 else 0.5\n\n    # Novelty-driven item selection: prioritize items that create \"novel\" value combinations\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate novelty scores based on value ratios and current solution's coverage\n        novelty_scores = []\n        for item in potential_items:\n            ratio1 = value1_lst[item] / (current_value1 + 1e-6)\n            ratio2 = value2_lst[item] / (current_value2 + 1e-6)\n            novelty = abs(ratio1 - ratio2) * (1 - min(ratio1, ratio2))\n            novelty_scores.append(novelty)\n\n        # Select top items with highest novelty and feasible addition\n        novelty_scores = np.array(novelty_scores)\n        top_items = potential_items[np.argsort(novelty_scores)[-3:]]\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Context-aware swapping: swap items that create better value trade-offs\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Calculate trade-off scores for each item\n        tradeoff_scores = []\n        for i in in_solution:\n            tradeoff = abs((value1_lst[i] - current_value1) / (value2_lst[i] - current_value2 + 1e-6))\n            tradeoff_scores.append(tradeoff)\n\n        # Select items with worst trade-offs for potential removal\n        worst_items = in_solution[np.argsort(tradeoff_scores)[:2]]\n        if len(worst_items) == 2:\n            idx1, idx2 = worst_items\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Dynamic exploration: probabilistic flip with novelty-based probability\n    flip_prob = 0.2 + 0.6 * (1 - (current_value1 + current_value2) / (total_value1 + total_value2))\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        # Select items with high novelty for flipping\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            novelty_scores = []\n            for i in flip_candidates:\n                ratio1 = value1_lst[i] / (current_value1 + 1e-6)\n                ratio2 = value2_lst[i] / (current_value2 + 1e-6)\n                novelty_scores.append(abs(ratio1 - ratio2))\n\n            flip_idx = flip_candidates[np.argmax(novelty_scores)]\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9117416583656477,
            0.6331888437271118
        ],
        "raw_score": [
            27.47455128805673,
            28.37877368886923
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using dynamic objective weighting based on diversity, then applies a hybrid local search combining value-density improvements, strategic item swaps, capacity balancing, and occasional random perturbations to generate feasible neighbor solutions. It prioritizes items with higher combined value density while ensuring feasibility through a capacity-balancing step, and occasionally perturbs the solution to escape local optima. The weighted value metric guides the selection of promising solutions for further improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic objective weights based on archive diversity\n    obj1_values = np.array([obj[0] for _, obj in archive])\n    obj2_values = np.array([obj[1] for _, obj in archive])\n    obj1_range = np.max(obj1_values) - np.min(obj1_values)\n    obj2_range = np.max(obj2_values) - np.min(obj2_values)\n\n    # Dynamic weighting based on archive diversity\n    if obj1_range > 0 and obj2_range > 0:\n        weight1 = obj2_range / (obj1_range + obj2_range)\n        weight2 = 1 - weight1\n    else:\n        weight1, weight2 = 0.5, 0.5\n\n    # Calculate weighted value metric\n    def weighted_value(sol):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            return -np.inf\n        value1 = np.sum(value1_lst * sol)\n        value2 = np.sum(value2_lst * sol)\n        return (weight1 * value1 + weight2 * value2) * (1 - (total_weight / capacity))\n\n    # Select solution with highest weighted value\n    selected_sol, _ = max(archive, key=lambda x: weighted_value(x[0]))\n    new_solution = selected_sol.copy()\n\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Hybrid local search operator\n    total_weight = np.sum(weight_lst * new_solution)\n    available_weight = capacity - total_weight\n\n    # Calculate combined value density\n    combined_value = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-combined_value)\n\n    # Step 1: Add high-value items that fit\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= available_weight:\n            new_solution[idx] = 1\n            available_weight -= weight_lst[idx]\n\n    # Step 2: Strategic item swaps\n    if np.random.rand() < 0.4:\n        in_solution = np.where(new_solution == 1)[0]\n        out_solution = np.where(new_solution == 0)[0]\n\n        if len(in_solution) > 0 and len(out_solution) > 0:\n            # Find best item to remove (lowest value density)\n            remove_idx = in_solution[np.argmin(combined_value[in_solution])]\n            # Find best item to add (highest value density among available)\n            add_idx = out_solution[np.argmax(combined_value[out_solution])]\n\n            # Check if swap is feasible\n            if weight_lst[add_idx] - weight_lst[remove_idx] <= available_weight:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Step 3: Capacity balancing\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        in_solution = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(in_solution) > 0:\n            remove_idx = in_solution[np.argmin(combined_value[in_solution])]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            in_solution = np.where(new_solution == 1)[0]\n\n    # Step 4: Random perturbation\n    if np.random.rand() < 0.2:\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 1:\n            # Randomly select 1-2 items to flip\n            flip_count = min(2, len(in_solution))\n            flip_indices = np.random.choice(in_solution, flip_count, replace=False)\n            for idx in flip_indices:\n                new_solution[idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9205943145787344,
            4.148276001214981
        ],
        "raw_score": [
            31.081209053454582,
            31.173129640220836
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized potential\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n    potential_scores = []\n\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue\n\n        # Calculate normalized potential for each objective\n        potential1 = (max_value1 - obj[0]) / (max_value1 + 1e-8)\n        potential2 = (max_value2 - obj[1]) / (max_value2 + 1e-8)\n\n        # Combine with adaptive weights based on relative potential\n        combined_potential = (potential1 + potential2) * (1 + abs(potential1 - potential2))\n        potential_scores.append((sol, combined_potential))\n\n    if not potential_scores:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    potential_scores.sort(key=lambda x: -x[1])\n    base_solution = potential_scores[0][0].copy()\n\n    # Generate neighbor with adaptive local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Marginal item replacement\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate marginal contributions\n        in_marginals = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        out_marginals = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n        # Replace worst in-item with best out-item if feasible\n        worst_in = in_items[np.argmin(in_marginals)]\n        best_out = out_items[np.argmax(out_marginals)]\n\n        if total_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n            new_solution[worst_in] = 0\n            new_solution[best_out] = 1\n            total_weight = total_weight - weight_lst[worst_in] + weight_lst[best_out]\n\n    # Phase 2: Objective-biased swaps\n    if len(in_items) >= 2 and random.random() < 0.6:\n        # Calculate objective-specific marginals\n        value1_marginals = value1_lst[in_items] / weight_lst[in_items]\n        value2_marginals = value2_lst[in_items] / weight_lst[in_items]\n\n        # Select items with low marginals in one objective\n        if random.random() < 0.5:\n            # Focus on value1 improvement\n            low_value1 = in_items[np.argsort(value1_marginals)[:2]]\n        else:\n            # Focus on value2 improvement\n            low_value1 = in_items[np.argsort(value2_marginals)[:2]]\n\n        # Find best out-item for swap\n        if len(out_items) > 0:\n            out_marginals = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n            best_out = out_items[np.argmax(out_marginals)]\n\n            # Perform swap if feasible\n            if total_weight - weight_lst[low_value1[0]] + weight_lst[best_out] <= capacity:\n                new_solution[low_value1[0]] = 0\n                new_solution[best_out] = 1\n                total_weight = total_weight - weight_lst[low_value1[0]] + weight_lst[best_out]\n\n    # Phase 3: Probabilistic flips with objective bias\n    flip_prob = 0.3 if (np.sum(value1_lst * new_solution) + np.sum(value2_lst * new_solution)) / (max_value1 + max_value2) > 0.7 else 0.5\n    if random.random() < flip_prob:\n        if random.random() < 0.5 and len(in_items) > 0:\n            # Remove low-marginal item\n            marginals = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            idx = in_items[np.argmin(marginals)]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        elif len(out_items) > 0:\n            # Add high-marginal item\n            marginals = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n            idx = out_items[np.argmax(marginals)]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9019376134198027,
            0.39216312766075134
        ],
        "raw_score": [
            27.423485354036217,
            27.702511738711678
        ]
    },
    {
        "algorithm": "The algorithm employs a hybrid selection strategy that prioritizes solutions with high value diversity, combining dynamic objective weighting with a multi-stage local search that includes value-driven item insertion, adaptive swapping, and probabilistic flipping to balance exploration and exploitation while ensuring feasibility. It dynamically adjusts flip probabilities based on the solution's Pareto dominance and focuses on improving value trade-offs through weighted value ratios and complementary item selections.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize solutions with high value diversity and potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 4, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Dynamic objective weighting based on current solution's position\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = (current_value1 / (total_value1 + 1e-6)) * (1 - (current_value1 / (total_value1 + 1e-6)))\n    weight2 = (current_value2 / (total_value2 + 1e-6)) * (1 - (current_value2 / (total_value2 + 1e-6)))\n\n    # Value-driven item selection: prioritize items that create balanced value improvements\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate value improvement scores\n        value_scores = []\n        for item in potential_items:\n            if current_weight + weight_lst[item] > capacity:\n                value_scores.append(0)\n                continue\n            ratio1 = value1_lst[item] / (current_value1 + 1e-6)\n            ratio2 = value2_lst[item] / (current_value2 + 1e-6)\n            value_scores.append(weight1 * ratio1 + weight2 * ratio2)\n\n        # Select top items with highest value scores\n        top_items = potential_items[np.argsort(value_scores)[-2:]]\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive swapping: swap items that create better value trade-offs\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Calculate trade-off scores for each item\n        tradeoff_scores = []\n        for i in in_solution:\n            tradeoff = abs((value1_lst[i] - current_value1) / (value2_lst[i] - current_value2 + 1e-6))\n            tradeoff_scores.append(tradeoff)\n\n        # Select items with worst trade-offs for potential removal\n        worst_items = in_solution[np.argsort(tradeoff_scores)[:1]]\n        if len(worst_items) > 0:\n            idx = worst_items[0]\n            # Find best item to swap with\n            best_swap = None\n            best_score = -1\n            for item in potential_items:\n                if current_weight - weight_lst[idx] + weight_lst[item] <= capacity:\n                    ratio1 = value1_lst[item] / (current_value1 + 1e-6)\n                    ratio2 = value2_lst[item] / (current_value2 + 1e-6)\n                    score = weight1 * ratio1 + weight2 * ratio2\n                    if score > best_score:\n                        best_score = score\n                        best_swap = item\n\n            if best_swap is not None:\n                new_solution[idx] = 0\n                new_solution[best_swap] = 1\n\n    # Dynamic exploration: probabilistic flip with value-aware probability\n    flip_prob = 0.1 + 0.4 * (1 - (current_value1 + current_value2) / (total_value1 + total_value2))\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        # Select items with high value potential for flipping\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            value_scores = []\n            for i in flip_candidates:\n                ratio1 = value1_lst[i] / (current_value1 + 1e-6)\n                ratio2 = value2_lst[i] / (current_value2 + 1e-6)\n                value_scores.append(weight1 * ratio1 + weight2 * ratio2)\n\n            flip_idx = flip_candidates[np.argmin(value_scores)]\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8988171251681039,
            0.5861128270626068
        ],
        "raw_score": [
            27.56373170955588,
            27.846930117034944
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using dynamic objective weighting, then applies a hybrid local search that removes the least novel item (based on value ratio balance) and adds the most valuable item (weighted by current objective priorities) while ensuring feasibility. It also includes probabilistic flipping of items with high potential improvement, prioritizing objectives that are currently underrepresented.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using dynamic objective weighting to prioritize underrepresented objectives\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    archive.sort(key=lambda x: -(x[1][0] / total_value1 + x[1][1] / total_value2))\n    selected_idx = min(len(archive) // 3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Dynamic objective weights based on current solution's underrepresentation\n    weight1 = 1 - (current_value1 / total_value1) if total_value1 > 0 else 0.5\n    weight2 = 1 - (current_value2 / total_value2) if total_value2 > 0 else 0.5\n\n    # Hybrid local search: novelty-driven swap\n    in_solution = np.where(new_solution == 1)[0]\n    potential_items = np.where(new_solution == 0)[0]\n\n    if len(in_solution) > 0 and len(potential_items) > 0:\n        # Calculate novelty scores for items in solution\n        novelty_scores = []\n        for i in in_solution:\n            ratio1 = value1_lst[i] / (current_value1 + 1e-6)\n            ratio2 = value2_lst[i] / (current_value2 + 1e-6)\n            novelty_scores.append(abs(ratio1 - ratio2))\n\n        # Select least novel item for potential removal\n        least_novel_idx = in_solution[np.argmin(novelty_scores)]\n\n        # Calculate potential additions with weighted value metric\n        combined_values = (weight1 * value1_lst[potential_items] + weight2 * value2_lst[potential_items]) / weight_lst[potential_items]\n        best_add_idx = potential_items[np.argmax(combined_values)]\n\n        # Perform swap if feasible\n        temp_weight = current_weight - weight_lst[least_novel_idx] + weight_lst[best_add_idx]\n        if temp_weight <= capacity:\n            new_solution[least_novel_idx] = 0\n            new_solution[best_add_idx] = 1\n            current_weight = temp_weight\n\n    # Probabilistic flip with objective-aware probability\n    flip_prob = 0.3 + 0.5 * (1 - (current_value1 / total_value1 + current_value2 / total_value2) / 2)\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        # Select items with highest potential improvement\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            # Calculate potential improvement for each candidate\n            improvement_scores = []\n            for i in flip_candidates:\n                ratio1 = value1_lst[i] / (current_value1 + 1e-6)\n                ratio2 = value2_lst[i] / (current_value2 + 1e-6)\n                improvement_scores.append(weight1 * ratio1 + weight2 * ratio2)\n\n            flip_idx = flip_candidates[np.argmax(improvement_scores)]\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7727567325316299,
            0.3280051350593567
        ],
        "raw_score": [
            27.405380829461773,
            28.118865103772286
        ]
    }
]