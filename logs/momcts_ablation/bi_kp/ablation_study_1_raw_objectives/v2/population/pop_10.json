[
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (prioritizing those with high combined objective product) and applies a hybrid local search combining weighted item addition, adaptive swapping, and probabilistic flipping, while dynamically adjusting weights based on solution quality and ensuring feasibility through capacity checks. It emphasizes objective-aware selection (using weighted value metrics) and diversity maintenance (through probabilistic flips), creating a balance between exploration and exploitation. The key design focuses on adaptive weights, combined value metrics, and solution quality-aware operations to improve multi-objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives\n    archive.sort(key=lambda x: -(x[1][0] * x[1][1]))  # Sort by product of objectives\n    selected_idx = min(len(archive) // 3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate dynamic weights based on current solution quality\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = (current_value1 / total_value1) if total_value1 > 0 else 0.5\n    weight2 = (current_value2 / total_value2) if total_value2 > 0 else 0.5\n\n    # Hybrid local search: weighted item addition\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate combined value metric with adaptive weights\n        combined_values = (weight1 * value1_lst[potential_items] + weight2 * value2_lst[potential_items]) / weight_lst[potential_items]\n        top_items = potential_items[np.argsort(combined_values)[-2:]]  # Select top 2 items\n\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive swapping based on objective contributions\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Calculate relative importance of items\n        importance = (weight1 * value1_lst[in_solution] + weight2 * value2_lst[in_solution]) / weight_lst[in_solution]\n        sorted_items = in_solution[np.argsort(importance)]\n\n        # Swap least important with most promising excluded items\n        if len(sorted_items) >= 2:\n            least_important = sorted_items[0]\n            most_promising = np.argmax(combined_values) if len(potential_items) > 0 else -1\n\n            if most_promising != -1 and most_promising in potential_items:\n                temp_weight = current_weight - weight_lst[least_important] + weight_lst[most_promising]\n                if temp_weight <= capacity:\n                    new_solution[least_important] = 0\n                    new_solution[most_promising] = 1\n\n    # Probabilistic flip based on solution quality and diversity\n    flip_prob = 0.4 if (current_value1 + current_value2) / (total_value1 + total_value2) > 0.6 else 0.8\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        flip_idx = np.random.choice(len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8522696808180721,
            0.22630241513252258
        ],
        "raw_score": [
            27.121475374476667,
            27.863057367568054
        ]
    },
    {
        "algorithm": "The algorithm selects a promising non-dominated solution from the archive by prioritizing those with high potential for improvement in either objective, then applies a hybrid local search combining biased item removal/addition, balanced swaps, and probabilistic flips to generate high-quality neighbors while ensuring feasibility. The selection is guided by objective-biased probabilities, favoring either value1 or value2 improvement based on the current solution's potential, and the local search dynamically adjusts operations to explore diverse, high-potential regions of the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective improvement potential and select solution\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n    potential_scores = []\n\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue\n\n        # Calculate normalized potential for each objective\n        potential1 = (max_value1 - obj[0]) / (max_value1 + 1e-8)\n        potential2 = (max_value2 - obj[1]) / (max_value2 + 1e-8)\n\n        # Combine with objective weights based on relative potential\n        combined_potential = (potential1 + potential2) * (1 + abs(potential1 - potential2))\n        potential_scores.append((sol, combined_potential))\n\n    if not potential_scores:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Select solution with highest potential\n    potential_scores.sort(key=lambda x: -x[1])\n    base_solution = potential_scores[0][0].copy()\n\n    # Generate neighbor with novel hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Objective-biased item selection\n    objective_bias = random.random()\n    if objective_bias < 0.5:\n        # Focus on value1 improvement\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            # Remove item with lowest value1/weight ratio\n            ratios = value1_lst[candidates] / (weight_lst[candidates] + 1e-8)\n            idx = candidates[np.argmin(ratios)]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n    else:\n        # Focus on value2 improvement\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            # Remove item with lowest value2/weight ratio\n            ratios = value2_lst[candidates] / (weight_lst[candidates] + 1e-8)\n            idx = candidates[np.argmin(ratios)]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n\n    # Phase 2: Random addition with objective bias\n    if random.random() < 0.4:\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            if objective_bias < 0.5:\n                # Add item with highest value1/weight ratio\n                ratios = value1_lst[candidates] / (weight_lst[candidates] + 1e-8)\n            else:\n                # Add item with highest value2/weight ratio\n                ratios = value2_lst[candidates] / (weight_lst[candidates] + 1e-8)\n            idx = candidates[np.argmax(ratios)]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Phase 3: Balanced swaps with diversity\n    if np.sum(new_solution) > 1 and random.random() < 0.5:\n        items = np.where(new_solution == 1)[0]\n        i, j = random.sample(list(items), 2)\n        # Check if swap maintains feasibility\n        if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 4: Probabilistic flip with objective bias\n    if random.random() < 0.3:\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1 and total_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n        elif new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9296926897978155,
            0.3622717261314392
        ],
        "raw_score": [
            27.831550612136972,
            28.052400795200953
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate adaptive weights for objectives\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = current_value1 / total_value1 if total_value1 > 0 else 0.5\n    weight2 = current_value2 / total_value2 if total_value2 > 0 else 0.5\n\n    # Identify promising items to consider\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate weighted values for potential items\n        weighted_values = weight1 * value1_lst[potential_items] + weight2 * value2_lst[potential_items]\n        # Select top 3 items with highest weighted value\n        top_items = potential_items[np.argsort(weighted_values)[-3:]]\n\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Perform targeted swapping with items in solution\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Select two items to swap based on their contribution to both objectives\n        swap_candidates = sorted(in_solution, key=lambda x: -(weight1 * value1_lst[x] + weight2 * value2_lst[x]))[:2]\n        if len(swap_candidates) == 2:\n            idx1, idx2 = swap_candidates\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Perform random flip with probability based on current solution quality\n    flip_prob = 0.3 if (current_value1 + current_value2) / (total_value1 + total_value2) > 0.7 else 0.7\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        flip_idx = np.random.choice(len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8179565713407433,
            0.27593129873275757
        ],
        "raw_score": [
            27.604553890686965,
            28.184297658157398
        ]
    },
    {
        "algorithm": "The heuristic selects a balanced solution from the archive, then applies a hybrid local search combining targeted swaps (prioritizing high-value items), probabilistic flips, feasibility checks, and greedy additions of valuable items. It dynamically adjusts weights based on current solution quality and ensures feasibility through intelligent item removals and additions. The approach balances exploration and exploitation while maintaining Pareto optimality potential.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate adaptive weights for objectives\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = current_value1 / total_value1 if total_value1 > 0 else 0.5\n    weight2 = current_value2 / total_value2 if total_value2 > 0 else 0.5\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Targeted swapping based on adaptive weights\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        swap_candidates = sorted(in_solution, key=lambda x: -(weight1 * value1_lst[x] + weight2 * value2_lst[x]))[:2]\n        if len(swap_candidates) == 2:\n            idx1, idx2 = swap_candidates\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight = temp_weight\n\n    # Step 2: Random flip with probability based on solution quality\n    flip_prob = 0.3 if (current_value1 + current_value2) / (total_value1 + total_value2) > 0.7 else 0.7\n    if np.random.random() < flip_prob and n_items > 0:\n        flip_idx = np.random.choice(n_items)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    # Step 3: Ensure feasibility by removing the least valuable items if needed\n    while current_weight > capacity and len(in_solution) > 0:\n        remove_idx = in_solution[np.argmin(weight1 * value1_lst[in_solution] + weight2 * value2_lst[in_solution])]\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n        in_solution = np.where(new_solution == 1)[0]\n\n    # Step 4: Add the most valuable available items if there's remaining capacity\n    available_items = np.where(new_solution == 0)[0]\n    while len(available_items) > 0 and current_weight < capacity:\n        add_idx = available_items[np.argmax(weight1 * value1_lst[available_items] + weight2 * value2_lst[available_items])]\n        if current_weight + weight_lst[add_idx] <= capacity:\n            new_solution[add_idx] = 1\n            current_weight += weight_lst[add_idx]\n            available_items = np.where(new_solution == 0)[0]\n        else:\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8073380266351767,
            0.2613680064678192
        ],
        "raw_score": [
            27.274817832427832,
            28.08075458475086
        ]
    },
    {
        "algorithm": "The heuristic selects a near-capacity solution from the archive, then applies a hybrid local search combining item swapping and random flipping, with targeted replacement for feasibility, prioritizing solutions with high potential for multi-objective improvement while ensuring all generated neighbors remain feasible. It intelligently handles infeasibility by undoing operations and adding/removing the most valuable items, with a focus on balancing both objectives through weighted value considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback to first solution if no candidates\n\n    # Select a solution with high potential (e.g., near-capacity but not fully packed)\n    selected_sol = max(candidates, key=lambda x: np.sum(weight_lst * x))\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Randomly swap two items\n    idx1, idx2 = np.random.choice(n_items, size=2, replace=False)\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility after swap\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If swap violates capacity, undo it and try another approach\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Step 2: Randomly flip one item\n        flip_idx = np.random.choice(n_items)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility after flip\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If flip violates capacity, remove the most expensive item\n            if new_solution[flip_idx] == 1:\n                new_solution[flip_idx] = 0\n            else:\n                # Find the most expensive item to add\n                available_items = np.where(new_solution == 0)[0]\n                if len(available_items) > 0:\n                    expensive_item = available_items[np.argmax(value1_lst[available_items] + value2_lst[available_items])]\n                    if np.sum(weight_lst * new_solution) + weight_lst[expensive_item] <= capacity:\n                        new_solution[expensive_item] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9035397066548494,
            0.47091394662857056
        ],
        "raw_score": [
            27.34055461589349,
            28.03176024888062
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives using a novelty-aware selection\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Adaptive objective weighting with novelty factor\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = (current_value1 / total_value1) * (1 - (current_value1 / total_value1)) if total_value1 > 0 else 0.5\n    weight2 = (current_value2 / total_value2) * (1 - (current_value2 / total_value2)) if total_value2 > 0 else 0.5\n\n    # Novelty-driven item selection: prioritize items that create \"novel\" value combinations\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate novelty scores based on value ratios and current solution's coverage\n        novelty_scores = []\n        for item in potential_items:\n            ratio1 = value1_lst[item] / (current_value1 + 1e-6)\n            ratio2 = value2_lst[item] / (current_value2 + 1e-6)\n            novelty = abs(ratio1 - ratio2) * (1 - min(ratio1, ratio2))\n            novelty_scores.append(novelty)\n\n        # Select top items with highest novelty and feasible addition\n        novelty_scores = np.array(novelty_scores)\n        top_items = potential_items[np.argsort(novelty_scores)[-3:]]\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Context-aware swapping: swap items that create better value trade-offs\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Calculate trade-off scores for each item\n        tradeoff_scores = []\n        for i in in_solution:\n            tradeoff = abs((value1_lst[i] - current_value1) / (value2_lst[i] - current_value2 + 1e-6))\n            tradeoff_scores.append(tradeoff)\n\n        # Select items with worst trade-offs for potential removal\n        worst_items = in_solution[np.argsort(tradeoff_scores)[:2]]\n        if len(worst_items) == 2:\n            idx1, idx2 = worst_items\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Dynamic exploration: probabilistic flip with novelty-based probability\n    flip_prob = 0.2 + 0.6 * (1 - (current_value1 + current_value2) / (total_value1 + total_value2))\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        # Select items with high novelty for flipping\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            novelty_scores = []\n            for i in flip_candidates:\n                ratio1 = value1_lst[i] / (current_value1 + 1e-6)\n                ratio2 = value2_lst[i] / (current_value2 + 1e-6)\n                novelty_scores.append(abs(ratio1 - ratio2))\n\n            flip_idx = flip_candidates[np.argmax(novelty_scores)]\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9117416583656477,
            0.6331888437271118
        ],
        "raw_score": [
            27.47455128805673,
            28.37877368886923
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using dynamic objective weighting, then applies a hybrid local search that removes the least novel item (based on value ratio balance) and adds the most valuable item (weighted by current objective priorities) while ensuring feasibility. It also includes probabilistic flipping of items with high potential improvement, prioritizing objectives that are currently underrepresented.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using dynamic objective weighting to prioritize underrepresented objectives\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    archive.sort(key=lambda x: -(x[1][0] / total_value1 + x[1][1] / total_value2))\n    selected_idx = min(len(archive) // 3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Dynamic objective weights based on current solution's underrepresentation\n    weight1 = 1 - (current_value1 / total_value1) if total_value1 > 0 else 0.5\n    weight2 = 1 - (current_value2 / total_value2) if total_value2 > 0 else 0.5\n\n    # Hybrid local search: novelty-driven swap\n    in_solution = np.where(new_solution == 1)[0]\n    potential_items = np.where(new_solution == 0)[0]\n\n    if len(in_solution) > 0 and len(potential_items) > 0:\n        # Calculate novelty scores for items in solution\n        novelty_scores = []\n        for i in in_solution:\n            ratio1 = value1_lst[i] / (current_value1 + 1e-6)\n            ratio2 = value2_lst[i] / (current_value2 + 1e-6)\n            novelty_scores.append(abs(ratio1 - ratio2))\n\n        # Select least novel item for potential removal\n        least_novel_idx = in_solution[np.argmin(novelty_scores)]\n\n        # Calculate potential additions with weighted value metric\n        combined_values = (weight1 * value1_lst[potential_items] + weight2 * value2_lst[potential_items]) / weight_lst[potential_items]\n        best_add_idx = potential_items[np.argmax(combined_values)]\n\n        # Perform swap if feasible\n        temp_weight = current_weight - weight_lst[least_novel_idx] + weight_lst[best_add_idx]\n        if temp_weight <= capacity:\n            new_solution[least_novel_idx] = 0\n            new_solution[best_add_idx] = 1\n            current_weight = temp_weight\n\n    # Probabilistic flip with objective-aware probability\n    flip_prob = 0.3 + 0.5 * (1 - (current_value1 / total_value1 + current_value2 / total_value2) / 2)\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        # Select items with highest potential improvement\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            # Calculate potential improvement for each candidate\n            improvement_scores = []\n            for i in flip_candidates:\n                ratio1 = value1_lst[i] / (current_value1 + 1e-6)\n                ratio2 = value2_lst[i] / (current_value2 + 1e-6)\n                improvement_scores.append(weight1 * ratio1 + weight2 * ratio2)\n\n            flip_idx = flip_candidates[np.argmax(improvement_scores)]\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7727567325316299,
            0.3280051350593567
        ],
        "raw_score": [
            27.405380829461773,
            28.118865103772286
        ]
    },
    {
        "algorithm": "The algorithm employs a hybrid selection strategy that prioritizes solutions with high value diversity, combining dynamic objective weighting with a multi-stage local search that includes value-driven item insertion, adaptive swapping, and probabilistic flipping to balance exploration and exploitation while ensuring feasibility. It dynamically adjusts flip probabilities based on the solution's Pareto dominance and focuses on improving value trade-offs through weighted value ratios and complementary item selections.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize solutions with high value diversity and potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 4, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Dynamic objective weighting based on current solution's position\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = (current_value1 / (total_value1 + 1e-6)) * (1 - (current_value1 / (total_value1 + 1e-6)))\n    weight2 = (current_value2 / (total_value2 + 1e-6)) * (1 - (current_value2 / (total_value2 + 1e-6)))\n\n    # Value-driven item selection: prioritize items that create balanced value improvements\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate value improvement scores\n        value_scores = []\n        for item in potential_items:\n            if current_weight + weight_lst[item] > capacity:\n                value_scores.append(0)\n                continue\n            ratio1 = value1_lst[item] / (current_value1 + 1e-6)\n            ratio2 = value2_lst[item] / (current_value2 + 1e-6)\n            value_scores.append(weight1 * ratio1 + weight2 * ratio2)\n\n        # Select top items with highest value scores\n        top_items = potential_items[np.argsort(value_scores)[-2:]]\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive swapping: swap items that create better value trade-offs\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Calculate trade-off scores for each item\n        tradeoff_scores = []\n        for i in in_solution:\n            tradeoff = abs((value1_lst[i] - current_value1) / (value2_lst[i] - current_value2 + 1e-6))\n            tradeoff_scores.append(tradeoff)\n\n        # Select items with worst trade-offs for potential removal\n        worst_items = in_solution[np.argsort(tradeoff_scores)[:1]]\n        if len(worst_items) > 0:\n            idx = worst_items[0]\n            # Find best item to swap with\n            best_swap = None\n            best_score = -1\n            for item in potential_items:\n                if current_weight - weight_lst[idx] + weight_lst[item] <= capacity:\n                    ratio1 = value1_lst[item] / (current_value1 + 1e-6)\n                    ratio2 = value2_lst[item] / (current_value2 + 1e-6)\n                    score = weight1 * ratio1 + weight2 * ratio2\n                    if score > best_score:\n                        best_score = score\n                        best_swap = item\n\n            if best_swap is not None:\n                new_solution[idx] = 0\n                new_solution[best_swap] = 1\n\n    # Dynamic exploration: probabilistic flip with value-aware probability\n    flip_prob = 0.1 + 0.4 * (1 - (current_value1 + current_value2) / (total_value1 + total_value2))\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        # Select items with high value potential for flipping\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            value_scores = []\n            for i in flip_candidates:\n                ratio1 = value1_lst[i] / (current_value1 + 1e-6)\n                ratio2 = value2_lst[i] / (current_value2 + 1e-6)\n                value_scores.append(weight1 * ratio1 + weight2 * ratio2)\n\n            flip_idx = flip_candidates[np.argmin(value_scores)]\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8988171251681039,
            0.5861128270626068
        ],
        "raw_score": [
            27.56373170955588,
            27.846930117034944
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid of dominance ranking and crowding distance, then applies a novel local search operator that combines adaptive item selection with probabilistic swaps and dynamic mutation to generate neighbors while ensuring feasibility. It prioritizes items with high combined efficiency scores (normalized by both objective values and weight) and uses probabilistic selection based on relative utility for swaps and mutations. The mutation rate adapts dynamically based on the solution's overall quality, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine dominance ranking with crowding distance\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], -np.linalg.norm(np.array(x[1]) - np.array([np.mean([v[0] for v in archive]), np.mean([v[1] for v in archive])]))))\n    selected_idx = min(len(archive) // 3, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current metrics\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate normalized objective weights\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    norm_value1 = current_value1 / total_value1 if total_value1 > 0 else 0.5\n    norm_value2 = current_value2 / total_value2 if total_value2 > 0 else 0.5\n\n    # Adaptive item selection: consider both value and weight efficiency\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate combined efficiency score\n        efficiency_scores = (norm_value1 * value1_lst[potential_items] + norm_value2 * value2_lst[potential_items]) / (weight_lst[potential_items] + 1e-6)\n        top_items = potential_items[np.argsort(efficiency_scores)[-2:]]\n\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Probabilistic swap with adaptive temperature\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Calculate swap probabilities based on relative utility\n        swap_utils = norm_value1 * value1_lst[in_solution] + norm_value2 * value2_lst[in_solution]\n        swap_probs = np.exp(swap_utils / (np.sum(swap_utils) + 1e-6))\n        swap_probs = swap_probs / np.sum(swap_probs)\n\n        # Select two items to swap\n        idx1, idx2 = np.random.choice(in_solution, size=2, p=swap_probs, replace=False)\n        temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n        if temp_weight <= capacity:\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Dynamic mutation rate based on solution quality\n    mutation_rate = 0.4 if (current_value1 + current_value2) / (total_value1 + total_value2) > 0.6 else 0.8\n    if np.random.random() < mutation_rate and len(new_solution) > 0:\n        # Select mutation candidates based on both value and weight\n        mutation_scores = (norm_value1 * value1_lst + norm_value2 * value2_lst) / (weight_lst + 1e-6)\n        mutation_probs = np.exp(mutation_scores / (np.sum(mutation_scores) + 1e-6))\n        mutation_probs = mutation_probs / np.sum(mutation_probs)\n\n        mutation_idx = np.random.choice(len(new_solution), p=mutation_probs)\n        if new_solution[mutation_idx] == 1:\n            if current_weight - weight_lst[mutation_idx] <= capacity:\n                new_solution[mutation_idx] = 0\n        else:\n            if current_weight + weight_lst[mutation_idx] <= capacity:\n                new_solution[mutation_idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8533480310861542,
            1.2029791176319122
        ],
        "raw_score": [
            27.01697369534874,
            27.770754145074644
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on normalized objective values, then applies a hybrid local search combining probabilistic item removal (for low-value items), strategic addition of high-value-density items, random swaps between items, and occasional random flips to explore the solution space while ensuring feasibility. The selection prioritizes solutions with higher combined normalized objectives, and the local search balances exploitation (high-value additions) with exploration (random operations) to generate diverse high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    # Here, we select the solution with the highest sum of normalized objectives\n    normalized_objectives = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        normalized_obj = (obj[0] / (np.sum(value1_lst) + 1e-8), obj[1] / (np.sum(value2_lst) + 1e-8))\n        normalized_objectives.append((sol, normalized_obj))\n\n    if not normalized_objectives:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Sort by sum of normalized objectives (prioritize solutions with higher potential)\n    normalized_objectives.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = normalized_objectives[0][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic removal of low-value items\n    candidates = np.where(new_solution == 1)[0]\n    if len(candidates) > 0:\n        for idx in candidates:\n            if random.random() < 0.5 and total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Strategic addition of high-value items\n    candidates = np.where(new_solution == 0)[0]\n    if len(candidates) > 0:\n        # Sort by value density (value1 + value2) / weight\n        value_density = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_density)[::-1]\n        for idx in sorted_indices:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Apply a random swap between two items (exploration)\n    if np.sum(new_solution) > 1:\n        items = np.where(new_solution == 1)[0]\n        i, j = random.sample(list(items), 2)\n        # Check if swap is feasible\n        if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply a random flip with probability 0.3 (diversification)\n    if random.random() < 0.3:\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1 and total_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n        elif new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.2566695503967128,
            0.40656906366348267
        ],
        "raw_score": [
            48.990416380591356,
            48.38358173879731
        ]
    }
]