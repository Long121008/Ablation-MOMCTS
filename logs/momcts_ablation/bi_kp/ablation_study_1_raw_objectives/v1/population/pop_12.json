[
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest objective diversity (difference between value1 and value2), then performs a hybrid local search by flipping items based on their normalized marginal contributions to both objectives, prioritizing those with the highest combined marginal value while ensuring feasibility. It sorts items by their normalized marginal value and iteratively flips items to maximize combined objective gains without exceeding capacity. The key design ideas are prioritizing objective diversity for selection and using normalized marginal contributions for intelligent flipping.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest objective diversity (difference between value1 and value2)\n    best_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate normalized marginal contributions for each item\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Normalize marginal contributions\n    max_marginal = np.max(marginal_combined)\n    if max_marginal > 0:\n        normalized_marginal = marginal_combined / max_marginal\n    else:\n        normalized_marginal = marginal_combined\n\n    # Sort items by normalized marginal contribution (descending)\n    sorted_indices = np.argsort(-normalized_marginal)\n\n    # Try to flip items with high normalized marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9101876645710116,
            0.3497251272201538
        ],
        "raw_score": [
            27.004661735141276,
            27.688360888346264
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest normalized objective product (balancing both objectives)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        best_idx = 0\n    else:\n        best_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0] * archive[i][1][1]) / (max_obj1 * max_obj2))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate normalized marginal gains for both objectives\n    marginal_gain1 = value1_lst / (weight_lst + 1e-10)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-10)\n    marginal_norm1 = marginal_gain1 / (np.max(marginal_gain1) + 1e-10)\n    marginal_norm2 = marginal_gain2 / (np.max(marginal_gain2) + 1e-10)\n\n    # Combine marginal gains with adaptive weights based on solution's current performance\n    weight_obj1 = 1.0 if np.sum(value1_lst[base_solution == 1]) < 0.7 * max_obj1 else 0.5\n    weight_obj2 = 1.0 if np.sum(value2_lst[base_solution == 1]) < 0.7 * max_obj2 else 0.5\n    combined_marginal = weight_obj1 * marginal_norm1 + weight_obj2 * marginal_norm2\n\n    # Sort items by combined marginal gain and attempt to flip top candidates\n    sorted_indices = np.argsort(-combined_marginal)\n    for idx in sorted_indices[:max(1, len(weight_lst)//10)]:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no improvement, perform a targeted swap between high-marginal and low-marginal items\n    if np.array_equal(new_solution, base_solution):\n        high_marginal = np.argsort(-combined_marginal)[:len(weight_lst)//2]\n        low_marginal = np.argsort(combined_marginal)[:len(weight_lst)//2]\n\n        for h in high_marginal:\n            for l in low_marginal:\n                if new_solution[h] == 1 and new_solution[l] == 0:\n                    new_weight = current_weight - weight_lst[h] + weight_lst[l]\n                    if new_weight <= capacity:\n                        new_solution[h], new_solution[l] = 0, 1\n                        current_weight = new_weight\n                        break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8522335976313615,
            0.24278834462165833
        ],
        "raw_score": [
            27.69394350063845,
            28.12451233846662
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that probabilistically adds, removes, or swaps items based on their marginal contributions, ensuring feasibility through adaptive weight checks. It balances exploration/exploitation by favoring diverse marginal gains and intelligently navigating the Pareto front through probabilistic operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal gains in both objectives\n    selected_idx = 0\n    max_marginal_product = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        if len(excluded_items) == 0 or len(included_items) == 0:\n            continue\n\n        # Calculate marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_gains2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_product = np.mean(marginal_gains1) * np.mean(marginal_gains2)\n\n        if marginal_product > max_marginal_product:\n            max_marginal_product = marginal_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for all items\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Hybrid local search: probabilistic decision between add, remove, or swap\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        decision = random.choices(['add', 'remove', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n        if decision == 'add':\n            # Add the best excluded item based on combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: marginal_combined[x], reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n        elif decision == 'remove':\n            # Remove the least marginal item in either objective\n            included_sorted = sorted(included_items, key=lambda x: min(marginal_value1[x], marginal_value2[x]))\n            for item in included_sorted:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    break\n\n        elif decision == 'swap':\n            # Swap one excluded with one included item\n            swap_excluded = random.choice(excluded_items)\n            swap_included = random.choice(included_items)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n            if new_weight <= capacity:\n                new_solution[swap_included] = 0\n                new_solution[swap_excluded] = 1\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            excluded_sorted = sorted(excluded_items, key=lambda x: marginal_combined[x], reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -1.002058205017338,
            1.9492744207382202
        ],
        "raw_score": [
            27.19939705469744,
            27.641547598415023
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of normalized objectives, then performs a hybrid local search by iteratively flipping items with the highest marginal contribution to both objectives, while dynamically adjusting weights to prioritize underperforming objectives and ensuring feasibility. It also includes a diversification step to escape local optima by randomly flipping an item if no improvement is found. The key design ideas are adaptive objective weighting, marginal contribution-based flipping, and a diversification mechanism to enhance solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted sum of objectives (adaptive weights)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        best_idx = 0\n    else:\n        best_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0]/max_obj1 + archive[i][1][1]/max_obj2))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Calculate normalized marginal contributions\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_norm1 = marginal_value1 / (np.max(marginal_value1) + 1e-10)\n    marginal_norm2 = marginal_value2 / (np.max(marginal_value2) + 1e-10)\n\n    # Adaptive weight based on current solution's performance\n    weight_obj1 = 1.0 if current_value1 < 0.5 * max_obj1 else 0.7\n    weight_obj2 = 1.0 if current_value2 < 0.5 * max_obj2 else 0.7\n    marginal_combined = weight_obj1 * marginal_norm1 + weight_obj2 * marginal_norm2\n\n    # Sort items by combined marginal contribution\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Try to flip items with high marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try to remove item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional diversification: flip one random item if no improvement\n    if np.array_equal(new_solution, base_solution):\n        candidates = [i for i in range(len(weight_lst)) if (base_solution[i] == 1 and current_weight - weight_lst[i] >= 0) or\n                     (base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n        if candidates:\n            idx = np.random.choice(candidates)\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9034034519201828,
            0.4050176739692688
        ],
        "raw_score": [
            27.177010817087208,
            27.878927497500193
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on normalized objective values) and performs a hybrid local search by flipping items with the highest weighted marginal contributions to both objectives, prioritizing those that balance the current solution's trade-off between the two objectives while ensuring feasibility. It uses a weight balance factor derived from the current solution's objective values to guide the search and normalizes marginal contributions to ensure fair evaluation. The algorithm iteratively tries to add or remove items in descending order of their normalized marginal value, always checking feasibility constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of normalized objective values\n    def normalize_objective(obj):\n        max_val = max(obj[0], obj[1]) if max(obj[0], obj[1]) > 0 else 1\n        return (obj[0]/max_val + obj[1]/max_val)\n\n    best_idx = max(range(len(archive)), key=lambda i: normalize_objective(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and objective values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = archive[best_idx][1][0]\n    current_value2 = archive[best_idx][1][1]\n\n    # Calculate marginal contributions with weight balancing\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    weight_balance = (current_value1 / (current_value1 + current_value2 + 1e-6)) if (current_value1 + current_value2) > 0 else 0.5\n    marginal_combined = (weight_balance * marginal_value1) + ((1 - weight_balance) * marginal_value2)\n\n    # Normalize marginal contributions\n    max_marginal = np.max(marginal_combined)\n    if max_marginal > 0:\n        normalized_marginal = marginal_combined / max_marginal\n    else:\n        normalized_marginal = marginal_combined\n\n    # Sort items by normalized marginal contribution (descending)\n    sorted_indices = np.argsort(-normalized_marginal)\n\n    # Try to flip items with high normalized marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8837917919702295,
            0.35130399465560913
        ],
        "raw_score": [
            27.334740622964368,
            28.139057699098053
        ]
    },
    {
        "algorithm": "This heuristic selects the solution with the highest combined value (sum of both objectives) from the archive, then performs a hybrid local search by flipping items based on their marginal contributions to both objectives, prioritizing those with higher combined marginal value, while ensuring feasibility by checking the weight constraint after each flip. The algorithm sorts items by their marginal value contributions and iteratively tries to add or remove items, favoring those with the greatest potential improvement to both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined value (sum of both objectives)\n    best_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Try to flip items with high marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8416615865743579,
            0.3444518744945526
        ],
        "raw_score": [
            27.292796936643587,
            28.053736520041188
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that probabilistically adds, removes, or swaps items based on their marginal contributions to either objective, ensuring feasibility by checking weight constraints. It balances exploration and exploitation by favoring solutions with diverse marginal gains and intelligently navigates the Pareto front by leveraging both objectives' trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal gains in both objectives\n    selected_idx = 0\n    max_marginal_product = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        if len(excluded_items) == 0 or len(included_items) == 0:\n            continue\n\n        # Calculate marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_gains2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_product = np.mean(marginal_gains1) * np.mean(marginal_gains2)\n\n        if marginal_product > max_marginal_product:\n            max_marginal_product = marginal_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic decision between add, remove, or swap\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Probabilistic decision: 0.4 for add, 0.3 for remove, 0.3 for swap\n        decision = random.choices(['add', 'remove', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n        if decision == 'add':\n            # Add the best excluded item based on combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n        elif decision == 'remove':\n            # Remove the least marginal item in either objective\n            included_sorted = sorted(included_items, key=lambda x: min(value1_lst[x] / (weight_lst[x] + 1e-6), value2_lst[x] / (weight_lst[x] + 1e-6)))\n            for item in included_sorted:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    break\n\n        elif decision == 'swap':\n            # Swap one excluded with one included item\n            swap_excluded = random.choice(excluded_items)\n            swap_included = random.choice(included_items)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n            if new_weight <= capacity:\n                new_solution[swap_included] = 0\n                new_solution[swap_excluded] = 1\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9510446561453485,
            1.9513874053955078
        ],
        "raw_score": [
            27.300142368173844,
            27.834733828952686
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive based on dominance counts, then performs a value-driven reallocation by adaptively prioritizing items with high marginal gains for both objectives, balancing their importance through dynamic weights and ensuring feasibility by strictly enforcing capacity constraints. The solution iteratively removes or adds items in order of combined gain, with weights adjusted based on the current solution's objective values.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is non-dominated in both objectives\n    selected_idx = 0\n    max_dominance = -1\n\n    for i, (solution, (v1, v2)) in enumerate(archive):\n        dominance = 0\n        for j, (other_solution, (ov1, ov2)) in enumerate(archive):\n            if i != j:\n                if (v1 >= ov1 and v2 > ov2) or (v1 > ov1 and v2 >= ov2):\n                    dominance += 1\n        if dominance > max_dominance:\n            max_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Calculate marginal gains for both objectives\n    marginal_value1 = value1_lst - (new_solution * value1_lst)\n    marginal_value2 = value2_lst - (new_solution * value2_lst)\n\n    # Calculate adaptive weights based on current solution's objective values\n    if current_value1 + current_value2 == 0:\n        weight_obj1 = 0.5\n        weight_obj2 = 0.5\n    else:\n        weight_obj1 = current_value1 / (current_value1 + current_value2)\n        weight_obj2 = current_value2 / (current_value1 + current_value2)\n\n    # Calculate combined gain with adaptive weights\n    combined_gain = weight_obj1 * marginal_value1 + weight_obj2 * marginal_value2\n\n    # Sort items by combined gain (descending)\n    sorted_indices = np.argsort(-combined_gain)\n\n    # Perform value-driven reallocation\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9009213125392311,
            0.4814946949481964
        ],
        "raw_score": [
            27.052198797808302,
            27.480380197435533
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the highest sum of normalized objective values) and performs a hybrid local search by flipping items with the highest weighted marginal contributions to both objectives, dynamically adjusting the weights based on the current dominance of each objective in the archive while ensuring feasibility. The key design ideas are prioritizing solutions with high combined normalized objective values and using a dynamic weighting scheme to guide the local search toward improving both objectives proportionally.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate objective sums for normalization\n    total_value1 = sum(obj[0] for _, obj in archive)\n    total_value2 = sum(obj[1] for _, obj in archive)\n\n    # Select solution with highest sum of normalized objectives\n    if total_value1 + total_value2 > 0:\n        best_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0] / total_value1 + archive[i][1][1] / total_value2))\n    else:\n        best_idx = np.random.randint(len(archive))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate dynamic weights for objectives\n    obj1_weight = np.mean([obj[0] for _, obj in archive]) / (total_value1 + 1e-8)\n    obj2_weight = np.mean([obj[1] for _, obj in archive]) / (total_value2 + 1e-8)\n\n    # Calculate weighted marginal contributions\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    weighted_marginal = obj1_weight * marginal_value1 + obj2_weight * marginal_value2\n\n    # Sort items by weighted marginal contribution (descending)\n    sorted_indices = np.argsort(-weighted_marginal)\n\n    # Try to flip items with high weighted marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7935652586132858,
            0.3648923337459564
        ],
        "raw_score": [
            27.333744650936556,
            27.80072540145981
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive by prioritizing those with the most differing item selections, then performs a value-driven reallocation by dynamically reassigning items based on their normalized contributions to both objectives (weighted equally) while ensuring feasibility through a capacity-aware greedy process. The method balances both objectives by considering their normalized marginal gains when deciding which items to add or remove from the solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity relative to the archive\n    selected_idx = 0\n    max_diversity = -1\n\n    for i, (solution, _) in enumerate(archive):\n        diversity = 0\n        for j, (other_solution, _) in enumerate(archive):\n            if i != j:\n                diversity += np.sum(solution != other_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Normalize marginal contributions for both objectives\n    marginal_value1 = value1_lst - (new_solution * value1_lst)\n    marginal_value2 = value2_lst - (new_solution * value2_lst)\n\n    # Calculate normalized marginal gains\n    norm_value1 = marginal_value1 / (np.max(marginal_value1) + 1e-10)\n    norm_value2 = marginal_value2 / (np.max(marginal_value2) + 1e-10)\n    combined_gain = 0.5 * norm_value1 + 0.5 * norm_value2\n\n    # Sort items by combined normalized gain (descending)\n    sorted_indices = np.argsort(-combined_gain)\n\n    # Perform value-driven reallocation\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9406314534704926,
            3.105784237384796
        ],
        "raw_score": [
            27.42755884149911,
            27.854506065197445
        ]
    }
]