[
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest objective diversity (difference between value1 and value2), then performs a hybrid local search by flipping items based on their normalized marginal contributions to both objectives, prioritizing those with the highest combined marginal value while ensuring feasibility. It sorts items by their normalized marginal value and iteratively flips items to maximize combined objective gains without exceeding capacity. The key design ideas are prioritizing objective diversity for selection and using normalized marginal contributions for intelligent flipping.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest objective diversity (difference between value1 and value2)\n    best_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate normalized marginal contributions for each item\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Normalize marginal contributions\n    max_marginal = np.max(marginal_combined)\n    if max_marginal > 0:\n        normalized_marginal = marginal_combined / max_marginal\n    else:\n        normalized_marginal = marginal_combined\n\n    # Sort items by normalized marginal contribution (descending)\n    sorted_indices = np.argsort(-normalized_marginal)\n\n    # Try to flip items with high normalized marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9101876645710116,
            0.3497251272201538
        ],
        "raw_score": [
            27.004661735141276,
            27.688360888346264
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest normalized objective product (balancing both objectives)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        best_idx = 0\n    else:\n        best_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0] * archive[i][1][1]) / (max_obj1 * max_obj2))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate normalized marginal gains for both objectives\n    marginal_gain1 = value1_lst / (weight_lst + 1e-10)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-10)\n    marginal_norm1 = marginal_gain1 / (np.max(marginal_gain1) + 1e-10)\n    marginal_norm2 = marginal_gain2 / (np.max(marginal_gain2) + 1e-10)\n\n    # Combine marginal gains with adaptive weights based on solution's current performance\n    weight_obj1 = 1.0 if np.sum(value1_lst[base_solution == 1]) < 0.7 * max_obj1 else 0.5\n    weight_obj2 = 1.0 if np.sum(value2_lst[base_solution == 1]) < 0.7 * max_obj2 else 0.5\n    combined_marginal = weight_obj1 * marginal_norm1 + weight_obj2 * marginal_norm2\n\n    # Sort items by combined marginal gain and attempt to flip top candidates\n    sorted_indices = np.argsort(-combined_marginal)\n    for idx in sorted_indices[:max(1, len(weight_lst)//10)]:\n        if base_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no improvement, perform a targeted swap between high-marginal and low-marginal items\n    if np.array_equal(new_solution, base_solution):\n        high_marginal = np.argsort(-combined_marginal)[:len(weight_lst)//2]\n        low_marginal = np.argsort(combined_marginal)[:len(weight_lst)//2]\n\n        for h in high_marginal:\n            for l in low_marginal:\n                if new_solution[h] == 1 and new_solution[l] == 0:\n                    new_weight = current_weight - weight_lst[h] + weight_lst[l]\n                    if new_weight <= capacity:\n                        new_solution[h], new_solution[l] = 0, 1\n                        current_weight = new_weight\n                        break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8522335976313615,
            0.24278834462165833
        ],
        "raw_score": [
            27.69394350063845,
            28.12451233846662
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that probabilistically adds, removes, or swaps items based on their marginal contributions, ensuring feasibility through adaptive weight checks. It balances exploration/exploitation by favoring diverse marginal gains and intelligently navigating the Pareto front through probabilistic operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal gains in both objectives\n    selected_idx = 0\n    max_marginal_product = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        if len(excluded_items) == 0 or len(included_items) == 0:\n            continue\n\n        # Calculate marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_gains2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_product = np.mean(marginal_gains1) * np.mean(marginal_gains2)\n\n        if marginal_product > max_marginal_product:\n            max_marginal_product = marginal_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for all items\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Hybrid local search: probabilistic decision between add, remove, or swap\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        decision = random.choices(['add', 'remove', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n        if decision == 'add':\n            # Add the best excluded item based on combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: marginal_combined[x], reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n        elif decision == 'remove':\n            # Remove the least marginal item in either objective\n            included_sorted = sorted(included_items, key=lambda x: min(marginal_value1[x], marginal_value2[x]))\n            for item in included_sorted:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    break\n\n        elif decision == 'swap':\n            # Swap one excluded with one included item\n            swap_excluded = random.choice(excluded_items)\n            swap_included = random.choice(included_items)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n            if new_weight <= capacity:\n                new_solution[swap_included] = 0\n                new_solution[swap_excluded] = 1\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            excluded_sorted = sorted(excluded_items, key=lambda x: marginal_combined[x], reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -1.002058205017338,
            1.9492744207382202
        ],
        "raw_score": [
            27.19939705469744,
            27.641547598415023
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest combined marginal gain in both objectives, then performs a hybrid local search combining 80% flips and 20% swaps, prioritizing items with high marginal contributions while maintaining feasibility through dynamic weight checks and greedy removal of least marginal items. It prioritizes items with high combined marginal values (value1 + value2) for flips, and swaps high-marginal with low-marginal items, with a fallback to removing least marginal items if no improvement is found.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined marginal gain in both objectives\n    max_marginal_product = -1\n    best_idx = 0\n    for i, (solution, _) in enumerate(archive):\n        marginal_gain1 = value1_lst - (solution * value1_lst)\n        marginal_gain2 = value2_lst - (solution * value2_lst)\n        marginal_product = np.sum(marginal_gain1) * np.sum(marginal_gain2)\n        if marginal_product > max_marginal_product:\n            max_marginal_product = marginal_product\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Hybrid local search with probabilistic operations\n    decision = random.choices(['flip', 'swap'], weights=[0.8, 0.2])[0]\n\n    if decision == 'flip':\n        # Flip items with highest marginal gain while maintaining feasibility\n        sorted_indices = np.argsort(-marginal_combined)\n        for idx in sorted_indices:\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    else:  # swap\n        # Swap items with high and low marginal gains\n        high_marginal = np.argsort(-marginal_combined)[:len(weight_lst)//2]\n        low_marginal = np.argsort(marginal_combined)[:len(weight_lst)//2]\n\n        for h in high_marginal:\n            for l in low_marginal:\n                if new_solution[h] == 1 and new_solution[l] == 0:\n                    new_weight = current_weight - weight_lst[h] + weight_lst[l]\n                    if new_weight <= capacity:\n                        new_solution[h], new_solution[l] = 0, 1\n                        current_weight = new_weight\n                        break\n            else:\n                continue\n            break\n\n    # If no improvement, remove least marginal items to ensure feasibility\n    if np.array_equal(new_solution, base_solution):\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            sorted_items = sorted(included_items, key=lambda x: min(marginal_value1[x], marginal_value2[x]))\n            for item in sorted_items:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9244802393279061,
            1.3732020854949951
        ],
        "raw_score": [
            27.014648589544763,
            27.806012759233937
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high combined objective potential and weight efficiency, then applies a two-phase local search: first removing items with extreme objective imbalances, followed by balanced swaps that prioritize objective alignment while maintaining feasibility. The method emphasizes dynamic weight adjustment and objective-balanced item selection to improve solution quality across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective potential and weight efficiency\n    selected_idx = 0\n    max_score = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        remaining_capacity = capacity - current_weight\n\n        # Calculate potential improvements with weight constraints\n        excluded_items = np.where(solution == 0)[0]\n        if len(excluded_items) > 0:\n            potential_v1 = np.sum(value1_lst[excluded_items][weight_lst[excluded_items] <= remaining_capacity])\n            potential_v2 = np.sum(value2_lst[excluded_items][weight_lst[excluded_items] <= remaining_capacity])\n            potential_score = (potential_v1 + potential_v2) * (1 - current_weight/capacity)\n        else:\n            potential_score = 0\n\n        # Calculate current solution's diversity score\n        diversity_score = np.sum(solution) / len(solution)\n\n        # Combine scores with diversity factor\n        combined_score = potential_score * (1 + 0.5 * diversity_score)\n\n        if combined_score > max_score:\n            max_score = combined_score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: Dynamic item removal based on objective balance\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(included_items) > 0:\n        # Calculate objective balance scores\n        v1_scores = value1_lst[included_items] / (value1_lst[included_items] + value2_lst[included_items] + 1e-6)\n        v2_scores = value2_lst[included_items] / (value1_lst[included_items] + value2_lst[included_items] + 1e-6)\n        balance_scores = np.abs(v1_scores - v2_scores)\n\n        # Remove items with most extreme objective imbalance\n        remove_candidates = np.argsort(balance_scores)[-max(1, len(balance_scores)//4):]\n\n        for idx in remove_candidates[::-1]:\n            new_solution[included_items[idx]] = 0\n            current_weight -= weight_lst[included_items[idx]]\n\n    # Phase 2: Objective-balanced swaps with dynamic weight adjustment\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Calculate objective balance factors\n        total_v1 = np.sum(value1_lst[included_items])\n        total_v2 = np.sum(value2_lst[included_items])\n        balance_factor = total_v1 / (total_v1 + total_v2 + 1e-6)\n\n        # Prioritize adding items that balance objectives\n        excluded_v1 = value1_lst[excluded_items]\n        excluded_v2 = value2_lst[excluded_items]\n        excluded_weights = weight_lst[excluded_items]\n\n        # Calculate balance potential for each excluded item\n        balance_potentials = np.abs(excluded_v1 / (excluded_v1 + excluded_v2 + 1e-6) - balance_factor)\n\n        # Sort by most balanced potential and weight efficiency\n        candidate_order = np.lexsort((excluded_weights, balance_potentials))\n\n        for candidate in candidate_order:\n            item = excluded_items[candidate]\n            if current_weight + weight_lst[item] <= capacity:\n                # Find worst included item to swap out\n                included_v1 = value1_lst[included_items]\n                included_v2 = value2_lst[included_items]\n\n                # Calculate dominance scores considering balance\n                dominance_scores = (included_v1 + included_v2) * (1 - np.abs(included_v1/(included_v1 + included_v2 + 1e-6) - balance_factor))\n\n                worst_included = np.argmin(dominance_scores)\n\n                if dominance_scores[worst_included] < (value1_lst[item] + value2_lst[item]) * (1 - np.abs(excluded_v1[candidate]/(excluded_v1[candidate] + excluded_v2[candidate] + 1e-6) - balance_factor)):\n                    new_solution[included_items[worst_included]] = 0\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item] - weight_lst[included_items[worst_included]]\n                    break\n\n    # Final feasibility check\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n\n        # Remove items with lowest combined value-to-weight ratio\n        v1_ratio = value1_lst[included_items] / weight_lst[included_items]\n        v2_ratio = value2_lst[included_items] / weight_lst[included_items]\n        combined_ratio = v1_ratio + v2_ratio\n\n        remove_idx = included_items[np.argmin(combined_ratio)]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9213858102526389,
            1.1756430864334106
        ],
        "raw_score": [
            27.263109409781297,
            27.91676298032771
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects a solution from the archive by combining Pareto dominance and marginal gain scores, then applies a hybrid local search that probabilistically flips low-marginal items or swaps high-marginal items, dynamically adjusting the search focus based on the current solution's objective trade-off while ensuring feasibility through greedy weight checks. It prioritizes value1 over value2 when the trade-off ratio favors it, using marginal gains to guide item selection and removal.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined Pareto dominance and marginal gain\n    selected_idx = 0\n    max_score = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        # Calculate Pareto dominance score\n        dominance = 0\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] > objective[0] and other_obj[1] > objective[1]):\n                dominance += 1\n\n        # Calculate marginal gains\n        marginal_gain1 = np.sum(value1_lst[excluded_items]) / np.sum(weight_lst[excluded_items]) if len(excluded_items) > 0 else 0\n        marginal_gain2 = np.sum(value2_lst[excluded_items]) / np.sum(weight_lst[excluded_items]) if len(excluded_items) > 0 else 0\n        score = dominance + marginal_gain1 + marginal_gain2\n\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search with adaptive focus\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Determine search focus based on current trade-off\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        value_ratio = archive[selected_idx][1][0] / (archive[selected_idx][1][1] + 1e-6)\n\n        if random.random() < 0.7:  # 70% chance for flip operation\n            # Remove low-marginal items\n            if value_ratio > 1.0:  # More focus on value1\n                flip_items = sorted(included_items, key=lambda x: value1_lst[x]/weight_lst[x])\n            else:  # More focus on value2\n                flip_items = sorted(included_items, key=lambda x: value2_lst[x]/weight_lst[x])\n\n            for item in flip_items:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    break\n\n            # Add high-marginal items\n            if value_ratio > 1.0:  # More focus on value1\n                add_items = sorted(excluded_items, key=lambda x: value1_lst[x]/weight_lst[x], reverse=True)\n            else:  # More focus on value2\n                add_items = sorted(excluded_items, key=lambda x: value2_lst[x]/weight_lst[x], reverse=True)\n\n            for item in add_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n        else:  # 30% chance for swap operation\n            # Select low-marginal included item\n            if value_ratio > 1.0:\n                swap_in = sorted(included_items, key=lambda x: value1_lst[x]/weight_lst[x])[0]\n            else:\n                swap_in = sorted(included_items, key=lambda x: value2_lst[x]/weight_lst[x])[0]\n\n            # Select high-marginal excluded item\n            if value_ratio > 1.0:\n                swap_out = sorted(excluded_items, key=lambda x: value1_lst[x]/weight_lst[x], reverse=True)[0]\n            else:\n                swap_out = sorted(excluded_items, key=lambda x: value2_lst[x]/weight_lst[x], reverse=True)[0]\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.934074515389139,
            1.4034859538078308
        ],
        "raw_score": [
            27.613624391883015,
            28.037701054057656
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of normalized objectives, then performs a hybrid local search by iteratively flipping items with the highest marginal contribution to both objectives, while dynamically adjusting weights to prioritize underperforming objectives and ensuring feasibility. It also includes a diversification step to escape local optima by randomly flipping an item if no improvement is found. The key design ideas are adaptive objective weighting, marginal contribution-based flipping, and a diversification mechanism to enhance solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted sum of objectives (adaptive weights)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        best_idx = 0\n    else:\n        best_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0]/max_obj1 + archive[i][1][1]/max_obj2))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Calculate normalized marginal contributions\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_norm1 = marginal_value1 / (np.max(marginal_value1) + 1e-10)\n    marginal_norm2 = marginal_value2 / (np.max(marginal_value2) + 1e-10)\n\n    # Adaptive weight based on current solution's performance\n    weight_obj1 = 1.0 if current_value1 < 0.5 * max_obj1 else 0.7\n    weight_obj2 = 1.0 if current_value2 < 0.5 * max_obj2 else 0.7\n    marginal_combined = weight_obj1 * marginal_norm1 + weight_obj2 * marginal_norm2\n\n    # Sort items by combined marginal contribution\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Try to flip items with high marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try to remove item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional diversification: flip one random item if no improvement\n    if np.array_equal(new_solution, base_solution):\n        candidates = [i for i in range(len(weight_lst)) if (base_solution[i] == 1 and current_weight - weight_lst[i] >= 0) or\n                     (base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n        if candidates:\n            idx = np.random.choice(candidates)\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9034034519201828,
            0.4050176739692688
        ],
        "raw_score": [
            27.177010817087208,
            27.878927497500193
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on normalized objective values) and performs a hybrid local search by flipping items with the highest weighted marginal contributions to both objectives, prioritizing those that balance the current solution's trade-off between the two objectives while ensuring feasibility. It uses a weight balance factor derived from the current solution's objective values to guide the search and normalizes marginal contributions to ensure fair evaluation. The algorithm iteratively tries to add or remove items in descending order of their normalized marginal value, always checking feasibility constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of normalized objective values\n    def normalize_objective(obj):\n        max_val = max(obj[0], obj[1]) if max(obj[0], obj[1]) > 0 else 1\n        return (obj[0]/max_val + obj[1]/max_val)\n\n    best_idx = max(range(len(archive)), key=lambda i: normalize_objective(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and objective values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = archive[best_idx][1][0]\n    current_value2 = archive[best_idx][1][1]\n\n    # Calculate marginal contributions with weight balancing\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    weight_balance = (current_value1 / (current_value1 + current_value2 + 1e-6)) if (current_value1 + current_value2) > 0 else 0.5\n    marginal_combined = (weight_balance * marginal_value1) + ((1 - weight_balance) * marginal_value2)\n\n    # Normalize marginal contributions\n    max_marginal = np.max(marginal_combined)\n    if max_marginal > 0:\n        normalized_marginal = marginal_combined / max_marginal\n    else:\n        normalized_marginal = marginal_combined\n\n    # Sort items by normalized marginal contribution (descending)\n    sorted_indices = np.argsort(-normalized_marginal)\n\n    # Try to flip items with high normalized marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8837917919702295,
            0.35130399465560913
        ],
        "raw_score": [
            27.334740622964368,
            28.139057699098053
        ]
    },
    {
        "algorithm": "This heuristic selects the solution with the highest combined value (sum of both objectives) from the archive, then performs a hybrid local search by flipping items based on their marginal contributions to both objectives, prioritizing those with higher combined marginal value, while ensuring feasibility by checking the weight constraint after each flip. The algorithm sorts items by their marginal value contributions and iteratively tries to add or remove items, favoring those with the greatest potential improvement to both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined value (sum of both objectives)\n    best_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Try to flip items with high marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8416615865743579,
            0.3444518744945526
        ],
        "raw_score": [
            27.292796936643587,
            28.053736520041188
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that probabilistically adds, removes, or swaps items based on their marginal contributions to either objective, ensuring feasibility by checking weight constraints. It balances exploration and exploitation by favoring solutions with diverse marginal gains and intelligently navigates the Pareto front by leveraging both objectives' trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal gains in both objectives\n    selected_idx = 0\n    max_marginal_product = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        if len(excluded_items) == 0 or len(included_items) == 0:\n            continue\n\n        # Calculate marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_gains2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_product = np.mean(marginal_gains1) * np.mean(marginal_gains2)\n\n        if marginal_product > max_marginal_product:\n            max_marginal_product = marginal_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic decision between add, remove, or swap\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Probabilistic decision: 0.4 for add, 0.3 for remove, 0.3 for swap\n        decision = random.choices(['add', 'remove', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n        if decision == 'add':\n            # Add the best excluded item based on combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n        elif decision == 'remove':\n            # Remove the least marginal item in either objective\n            included_sorted = sorted(included_items, key=lambda x: min(value1_lst[x] / (weight_lst[x] + 1e-6), value2_lst[x] / (weight_lst[x] + 1e-6)))\n            for item in included_sorted:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    break\n\n        elif decision == 'swap':\n            # Swap one excluded with one included item\n            swap_excluded = random.choice(excluded_items)\n            swap_included = random.choice(included_items)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n            if new_weight <= capacity:\n                new_solution[swap_included] = 0\n                new_solution[swap_excluded] = 1\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9510446561453485,
            1.9513874053955078
        ],
        "raw_score": [
            27.300142368173844,
            27.834733828952686
        ]
    }
]