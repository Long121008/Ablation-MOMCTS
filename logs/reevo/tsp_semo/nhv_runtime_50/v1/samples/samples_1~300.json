[
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between objectives (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a custom 3-opt move (reverse a segment and reinsert)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, 1)  # Rotate segment by 1\n\n    # Step 3: Apply a custom move to improve both objectives\n    # Check if swapping nodes at i and k improves both distances\n    if (distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[i+1]]) < \\\n       (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8786119824514542,
            0.46553748846054077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between objectives (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a custom 3-opt move (reverse a segment and reinsert)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, 1)  # Rotate segment by 1\n\n    # Step 3: Apply a custom move to improve both objectives\n    # Check if swapping nodes at i and k improves both distances\n    if (distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[i+1]]) < \\\n       (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between objectives (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a custom 3-opt move (reverse a segment and reinsert)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, 1)  # Rotate segment by 1\n\n    # Step 3: Apply a custom move to improve both objectives\n    # Check if swapping nodes at i and k improves both distances\n    if (distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[i+1]]) < \\\n       (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8786119824514542,
            0.46553748846054077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between objectives (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a custom 3-opt move (reverse a segment and reinsert)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, 1)  # Rotate segment by 1\n\n    # Step 3: Apply a custom move to improve both objectives\n    # Check if swapping nodes at i and k improves both distances\n    if (distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[i+1]]) < \\\n       (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between objectives (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a custom 3-opt move (reverse a segment and reinsert)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, 1)  # Rotate segment by 1\n\n    # Step 3: Apply a custom move to improve both objectives\n    # Check if swapping nodes at i and k improves both distances\n    if (distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[i+1]]) < \\\n       (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8786119824514542,
            0.46553748846054077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between objectives (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a custom 3-opt move (reverse a segment and reinsert)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, 1)  # Rotate segment by 1\n\n    # Step 3: Apply a custom move to improve both objectives\n    # Check if swapping nodes at i and k improves both distances\n    if (distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[i+1]]) < \\\n       (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not in the Pareto front)\n    # Here, we select a solution that is not the best in either objective\n    objectives = [obj for _, obj in archive]\n    if len(objectives) < 2:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Find solutions that are not Pareto optimal\n        non_pareto_indices = []\n        for i in range(len(objectives)):\n            is_pareto = True\n            for j in range(len(objectives)):\n                if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    is_pareto = False\n                    break\n            if not is_pareto:\n                non_pareto_indices.append(i)\n\n        if non_pareto_indices:\n            selected_idx = random.choice(non_pareto_indices)\n            selected_solution = archive[selected_idx][0].copy()\n        else:\n            selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to perform 2-opt\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 2, n - 1) if i + 2 < n else (i + 1) % n\n\n    # Reverse the segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply novel edge insertion: randomly select a node and insert it in a new position\n    if n > 3:\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7842736776429937,
            0.5100080370903015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not in the Pareto front)\n    # Here, we select a solution that is not the best in either objective\n    objectives = [obj for _, obj in archive]\n    if len(objectives) < 2:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Find solutions that are not Pareto optimal\n        non_pareto_indices = []\n        for i in range(len(objectives)):\n            is_pareto = True\n            for j in range(len(objectives)):\n                if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    is_pareto = False\n                    break\n            if not is_pareto:\n                non_pareto_indices.append(i)\n\n        if non_pareto_indices:\n            selected_idx = random.choice(non_pareto_indices)\n            selected_solution = archive[selected_idx][0].copy()\n        else:\n            selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to perform 2-opt\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 2, n - 1) if i + 2 < n else (i + 1) % n\n\n    # Reverse the segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply novel edge insertion: randomly select a node and insert it in a new position\n    if n > 3:\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    new_solution = base_solution.copy()\n\n    # Perform edge exchange (similar to 2-opt but with a twist)\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b = min(a, b), max(a, b)\n    c, d = min(c, d), max(c, d)\n\n    # Check if the exchange improves both objectives\n    def cost_change(sol, a, b, c, d):\n        # Original cost\n        orig_cost1 = (distance_matrix_1[sol[a-1], sol[a]] + distance_matrix_1[sol[b], sol[(b+1)%n]] +\n                      distance_matrix_1[sol[c-1], sol[c]] + distance_matrix_1[sol[d], sol[(d+1)%n]])\n        orig_cost2 = (distance_matrix_2[sol[a-1], sol[a]] + distance_matrix_2[sol[b], sol[(b+1)%n]] +\n                      distance_matrix_2[sol[c-1], sol[c]] + distance_matrix_2[sol[d], sol[(d+1)%n]])\n\n        # New cost after exchange\n        new_cost1 = (distance_matrix_1[sol[a-1], sol[c]] + distance_matrix_1[sol[b], sol[d]] +\n                     distance_matrix_1[sol[c], sol[(b+1)%n]] + distance_matrix_1[sol[d], sol[(d+1)%n]])\n        new_cost2 = (distance_matrix_2[sol[a-1], sol[c]] + distance_matrix_2[sol[b], sol[d]] +\n                     distance_matrix_2[sol[c], sol[(b+1)%n]] + distance_matrix_2[sol[d], sol[(d+1)%n]])\n\n        return (orig_cost1 - new_cost1, orig_cost2 - new_cost2)\n\n    delta1, delta2 = cost_change(new_solution, a, b, c, d)\n    if delta1 > 0 and delta2 > 0:\n        # Perform the exchange if it improves both objectives\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n        new_solution[c:d+1] = np.flip(new_solution[c:d+1])\n    else:\n        # Fallback to segment relocation if edge exchange doesn't help\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j = min(i, j), max(i, j)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.82693977840252,
            0.2533620595932007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    new_solution = base_solution.copy()\n\n    # Perform edge exchange (similar to 2-opt but with a twist)\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b = min(a, b), max(a, b)\n    c, d = min(c, d), max(c, d)\n\n    # Check if the exchange improves both objectives\n    def cost_change(sol, a, b, c, d):\n        # Original cost\n        orig_cost1 = (distance_matrix_1[sol[a-1], sol[a]] + distance_matrix_1[sol[b], sol[(b+1)%n]] +\n                      distance_matrix_1[sol[c-1], sol[c]] + distance_matrix_1[sol[d], sol[(d+1)%n]])\n        orig_cost2 = (distance_matrix_2[sol[a-1], sol[a]] + distance_matrix_2[sol[b], sol[(b+1)%n]] +\n                      distance_matrix_2[sol[c-1], sol[c]] + distance_matrix_2[sol[d], sol[(d+1)%n]])\n\n        # New cost after exchange\n        new_cost1 = (distance_matrix_1[sol[a-1], sol[c]] + distance_matrix_1[sol[b], sol[d]] +\n                     distance_matrix_1[sol[c], sol[(b+1)%n]] + distance_matrix_1[sol[d], sol[(d+1)%n]])\n        new_cost2 = (distance_matrix_2[sol[a-1], sol[c]] + distance_matrix_2[sol[b], sol[d]] +\n                     distance_matrix_2[sol[c], sol[(b+1)%n]] + distance_matrix_2[sol[d], sol[(d+1)%n]])\n\n        return (orig_cost1 - new_cost1, orig_cost2 - new_cost2)\n\n    delta1, delta2 = cost_change(new_solution, a, b, c, d)\n    if delta1 > 0 and delta2 > 0:\n        # Perform the exchange if it improves both objectives\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n        new_solution[c:d+1] = np.flip(new_solution[c:d+1])\n    else:\n        # Fallback to segment relocation if edge exchange doesn't help\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j = min(i, j), max(i, j)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    new_solution = base_solution.copy()\n\n    # Perform edge exchange (similar to 2-opt but with a twist)\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b = min(a, b), max(a, b)\n    c, d = min(c, d), max(c, d)\n\n    # Check if the exchange improves both objectives\n    def cost_change(sol, a, b, c, d):\n        # Original cost\n        orig_cost1 = (distance_matrix_1[sol[a-1], sol[a]] + distance_matrix_1[sol[b], sol[(b+1)%n]] +\n                      distance_matrix_1[sol[c-1], sol[c]] + distance_matrix_1[sol[d], sol[(d+1)%n]])\n        orig_cost2 = (distance_matrix_2[sol[a-1], sol[a]] + distance_matrix_2[sol[b], sol[(b+1)%n]] +\n                      distance_matrix_2[sol[c-1], sol[c]] + distance_matrix_2[sol[d], sol[(d+1)%n]])\n\n        # New cost after exchange\n        new_cost1 = (distance_matrix_1[sol[a-1], sol[c]] + distance_matrix_1[sol[b], sol[d]] +\n                     distance_matrix_1[sol[c], sol[(b+1)%n]] + distance_matrix_1[sol[d], sol[(d+1)%n]])\n        new_cost2 = (distance_matrix_2[sol[a-1], sol[c]] + distance_matrix_2[sol[b], sol[d]] +\n                     distance_matrix_2[sol[c], sol[(b+1)%n]] + distance_matrix_2[sol[d], sol[(d+1)%n]])\n\n        return (orig_cost1 - new_cost1, orig_cost2 - new_cost2)\n\n    delta1, delta2 = cost_change(new_solution, a, b, c, d)\n    if delta1 > 0 and delta2 > 0:\n        # Perform the exchange if it improves both objectives\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n        new_solution[c:d+1] = np.flip(new_solution[c:d+1])\n    else:\n        # Fallback to segment relocation if edge exchange doesn't help\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j = min(i, j), max(i, j)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.82693977840252,
            0.2533620595932007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    new_solution = base_solution.copy()\n\n    # Perform edge exchange (similar to 2-opt but with a twist)\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b = min(a, b), max(a, b)\n    c, d = min(c, d), max(c, d)\n\n    # Check if the exchange improves both objectives\n    def cost_change(sol, a, b, c, d):\n        # Original cost\n        orig_cost1 = (distance_matrix_1[sol[a-1], sol[a]] + distance_matrix_1[sol[b], sol[(b+1)%n]] +\n                      distance_matrix_1[sol[c-1], sol[c]] + distance_matrix_1[sol[d], sol[(d+1)%n]])\n        orig_cost2 = (distance_matrix_2[sol[a-1], sol[a]] + distance_matrix_2[sol[b], sol[(b+1)%n]] +\n                      distance_matrix_2[sol[c-1], sol[c]] + distance_matrix_2[sol[d], sol[(d+1)%n]])\n\n        # New cost after exchange\n        new_cost1 = (distance_matrix_1[sol[a-1], sol[c]] + distance_matrix_1[sol[b], sol[d]] +\n                     distance_matrix_1[sol[c], sol[(b+1)%n]] + distance_matrix_1[sol[d], sol[(d+1)%n]])\n        new_cost2 = (distance_matrix_2[sol[a-1], sol[c]] + distance_matrix_2[sol[b], sol[d]] +\n                     distance_matrix_2[sol[c], sol[(b+1)%n]] + distance_matrix_2[sol[d], sol[(d+1)%n]])\n\n        return (orig_cost1 - new_cost1, orig_cost2 - new_cost2)\n\n    delta1, delta2 = cost_change(new_solution, a, b, c, d)\n    if delta1 > 0 and delta2 > 0:\n        # Perform the exchange if it improves both objectives\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n        new_solution[c:d+1] = np.flip(new_solution[c:d+1])\n    else:\n        # Fallback to segment relocation if edge exchange doesn't help\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j = min(i, j), max(i, j)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (higher dominance = worse solutions)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select a solution from the top 50% with higher potential\n        candidate_solutions = archive_sorted[:max(1, len(archive) // 2)]\n        selected_solution = random.choice(candidate_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    n = len(new_solution)\n    if n >= 4:\n        # Perform a randomized 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n        # Custom edge-swap: swap edges between two randomly selected nodes\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Invalid neighbor solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6461853097575456,
            0.47443974018096924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (higher dominance = worse solutions)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select a solution from the top 50% with higher potential\n        candidate_solutions = archive_sorted[:max(1, len(archive) // 2)]\n        selected_solution = random.choice(candidate_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    n = len(new_solution)\n    if n >= 4:\n        # Perform a randomized 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n        # Custom edge-swap: swap edges between two randomly selected nodes\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Invalid neighbor solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform edge exchange (swap two edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion (relocate a node to a better position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n - 1):\n        # Insert node at position 'pos' and calculate the cost\n        candidate = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7368778694426565,
            3.168906092643738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform edge exchange (swap two edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion (relocate a node to a better position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(n - 1):\n        # Insert node at position 'pos' and calculate the cost\n        candidate = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Apply 3-opt: reverse the segment between i and j, then swap k with i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility\n    assert len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.8784430172312803,
            0.4574790596961975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Apply 3-opt: reverse the segment between i and j, then swap k with i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility\n    assert len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.std(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i, j, k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            idx = np.where(new_solution == dup)[0][1]  # Second occurrence\n            new_solution[idx] = missing[0]\n\n    return new_solution\n\n",
        "score": [
            -0.39552258356850867,
            0.7677712440490723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.std(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i, j, k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            idx = np.where(new_solution == dup)[0][1]  # Second occurrence\n            new_solution[idx] = missing[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    if len(new_solution) > 3:\n        # Choose between segment reversal or node swap\n        if random.random() < 0.7:  # 70% chance for segment reversal\n            # Multi-objective segment reversal\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            segment = new_solution[i:j+1]\n\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            seg_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n            # Reverse segment if it improves both objectives\n            if (seg_cost1 > sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment))) and\n                seg_cost2 > sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))):\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Node swap operator\n            i, j = random.sample(range(len(new_solution)), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate cost change for both objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%len(new_solution)]] +\n                     distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%len(new_solution)]] -\n                     (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%len(new_solution)]] +\n                      distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%len(new_solution)]]))\n\n            delta2 = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%len(new_solution)]] +\n                     distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%len(new_solution)]] -\n                     (distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%len(new_solution)]] +\n                      distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%len(new_solution)]]))\n\n            # Accept swap if it improves both objectives\n            if delta1 < 0 and delta2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.39726855476224576,
            0.7846338748931885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        base_solution, _ = random.choice(top_candidates)\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    if len(new_solution) > 3:\n        # Choose between segment reversal or node swap\n        if random.random() < 0.7:  # 70% chance for segment reversal\n            # Multi-objective segment reversal\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            segment = new_solution[i:j+1]\n\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            seg_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n            # Reverse segment if it improves both objectives\n            if (seg_cost1 > sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment))) and\n                seg_cost2 > sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))):\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Node swap operator\n            i, j = random.sample(range(len(new_solution)), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate cost change for both objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%len(new_solution)]] +\n                     distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%len(new_solution)]] -\n                     (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%len(new_solution)]] +\n                      distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%len(new_solution)]]))\n\n            delta2 = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%len(new_solution)]] +\n                     distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%len(new_solution)]] -\n                     (distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%len(new_solution)]] +\n                      distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%len(new_solution)]]))\n\n            # Accept swap if it improves both objectives\n            if delta1 < 0 and delta2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct positions to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware swap: improve the solution based on both objectives\n    for _ in range(2):  # Perform a few swaps to improve both objectives\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept if both objectives improve or one improves significantly with minimal loss in the other\n        if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2) or \\\n           (potential_cost1 < current_cost1 * 0.95 and potential_cost2 < current_cost2 * 1.1) or \\\n           (potential_cost1 < current_cost1 * 1.1 and potential_cost2 < current_cost2 * 0.95):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8352702243156795,
            0.47619980573654175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct positions to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware swap: improve the solution based on both objectives\n    for _ in range(2):  # Perform a few swaps to improve both objectives\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept if both objectives improve or one improves significantly with minimal loss in the other\n        if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2) or \\\n           (potential_cost1 < current_cost1 * 0.95 and potential_cost2 < current_cost2 * 1.1) or \\\n           (potential_cost1 < current_cost1 * 1.1 and potential_cost2 < current_cost2 * 0.95):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with high diversity (randomly from non-dominated)\n    selected_sol, _ = random.choice(non_dominated)\n    new_solution = selected_sol.copy()\n\n    # Step 3: Apply hybrid local search (combination of edge reassignment and segment inversion)\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Edge reassignment (swap two non-adjacent edges)\n    i, j = random.sample(range(1, n-1), 2)\n    if abs(i - j) > 1:  # Ensure edges are not adjacent\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion (reverse a random segment)\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8265291483767451,
            0.4885081648826599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with high diversity (randomly from non-dominated)\n    selected_sol, _ = random.choice(non_dominated)\n    new_solution = selected_sol.copy()\n\n    # Step 3: Apply hybrid local search (combination of edge reassignment and segment inversion)\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Edge reassignment (swap two non-adjacent edges)\n    i, j = random.sample(range(1, n-1), 2)\n    if abs(i - j) > 1:  # Ensure edges are not adjacent\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion (reverse a random segment)\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., dominated or non-dominated but not optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with edge exchange\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt for the first objective\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8131654031796507,
            0.4561538100242615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., dominated or non-dominated but not optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with edge exchange\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt for the first objective\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge exchange: swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge-swap based on both objectives\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Evaluate the segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n    segment_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n    # Step 3: Find the best edge to swap within the segment based on both objectives\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(len(segment)):\n        for j in range(i+1, len(segment)):\n            # Calculate the change in both objectives if we swap edges i and j\n            old_edges_cost1 = (distance_matrix_1[segment[i-1], segment[i]] +\n                              distance_matrix_1[segment[j], segment[(j+1)%len(segment)]])\n            old_edges_cost2 = (distance_matrix_2[segment[i-1], segment[i]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]])\n\n            new_edges_cost1 = (distance_matrix_1[segment[i-1], segment[j]] +\n                              distance_matrix_1[segment[i], segment[(j+1)%len(segment)]])\n            new_edges_cost2 = (distance_matrix_2[segment[i-1], segment[j]] +\n                              distance_matrix_2[segment[i], segment[(j+1)%len(segment)]])\n\n            # Calculate improvement (weighted sum of both objectives)\n            improvement = (old_edges_cost1 - new_edges_cost1) + (old_edges_cost2 - new_edges_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    # Apply the best swap if it improves the solution\n    if best_improvement > 0:\n        segment[best_i], segment[best_j] = segment[best_j], segment[best_i]\n\n    # Update the solution with the modified segment\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # If invalid (due to possible errors in edge swaps), revert to base solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7676433812256599,
            1.244426190853119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge-swap based on both objectives\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Evaluate the segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n    segment_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n    # Step 3: Find the best edge to swap within the segment based on both objectives\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(len(segment)):\n        for j in range(i+1, len(segment)):\n            # Calculate the change in both objectives if we swap edges i and j\n            old_edges_cost1 = (distance_matrix_1[segment[i-1], segment[i]] +\n                              distance_matrix_1[segment[j], segment[(j+1)%len(segment)]])\n            old_edges_cost2 = (distance_matrix_2[segment[i-1], segment[i]] +\n                              distance_matrix_2[segment[j], segment[(j+1)%len(segment)]])\n\n            new_edges_cost1 = (distance_matrix_1[segment[i-1], segment[j]] +\n                              distance_matrix_1[segment[i], segment[(j+1)%len(segment)]])\n            new_edges_cost2 = (distance_matrix_2[segment[i-1], segment[j]] +\n                              distance_matrix_2[segment[i], segment[(j+1)%len(segment)]])\n\n            # Calculate improvement (weighted sum of both objectives)\n            improvement = (old_edges_cost1 - new_edges_cost1) + (old_edges_cost2 - new_edges_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    # Apply the best swap if it improves the solution\n    if best_improvement > 0:\n        segment[best_i], segment[best_j] = segment[best_j], segment[best_i]\n\n    # Update the solution with the modified segment\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # If invalid (due to possible errors in edge swaps), revert to base solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position (like node insertion)\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    possible_positions = [i for i in range(n) if i != current_pos]\n    new_pos = random.choice(possible_positions)\n\n    # Perform insertion\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9052136008423072,
            0.4375982880592346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position (like node insertion)\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    possible_positions = [i for i in range(n) if i != current_pos]\n    new_pos = random.choice(possible_positions)\n\n    # Perform insertion\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position (like node insertion)\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    possible_positions = [i for i in range(n) if i != current_pos]\n    new_pos = random.choice(possible_positions)\n\n    # Perform insertion\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9052136008423072,
            0.4375982880592346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position (like node insertion)\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    possible_positions = [i for i in range(n) if i != current_pos]\n    new_pos = random.choice(possible_positions)\n\n    # Perform insertion\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position (like node insertion)\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    possible_positions = [i for i in range(n) if i != current_pos]\n    new_pos = random.choice(possible_positions)\n\n    # Perform insertion\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9052136008423072,
            0.4375982880592346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position (like node insertion)\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    possible_positions = [i for i in range(n) if i != current_pos]\n    new_pos = random.choice(possible_positions)\n\n    # Perform insertion\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined cost (sum of both objectives)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Apply hybrid local search: 3-opt with segment inversion and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reversing segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Apply segment inversion between a and c\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Apply a swap between two random positions to further perturb\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8551309031108895,
            0.5013735294342041
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined cost (sum of both objectives)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Apply hybrid local search: 3-opt with segment inversion and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reversing segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Apply segment inversion between a and c\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Apply a swap between two random positions to further perturb\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.2))  # Select from top 20%\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:  # 50% chance for edge exchange\n        # Select two non-adjacent edges to exchange\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n\n        # Perform edge exchange\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n    else:  # 50% chance for segment relocation\n        # Select a segment to relocate\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n\n        # Select a new position for the segment\n        pos = random.randint(0, n-1)\n        while pos >= seg_start and pos <= seg_end:\n            pos = random.randint(0, n-1)\n\n        # Extract the segment\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8007683650144601,
            0.5115212798118591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.2))  # Select from top 20%\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:  # 50% chance for edge exchange\n        # Select two non-adjacent edges to exchange\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n\n        # Perform edge exchange\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n    else:  # 50% chance for segment relocation\n        # Select a segment to relocate\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n\n        # Select a new position for the segment\n        pos = random.randint(0, n-1)\n        while pos >= seg_start and pos <= seg_end:\n            pos = random.randint(0, n-1)\n\n        # Extract the segment\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its total cost\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    if total_cost == 0:\n        probabilities = [1.0 / len(archive) for _ in archive]\n    else:\n        probabilities = [1.0 - (cost / total_cost) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion + path relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge insertion (insert a random edge from another part of the tour)\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) <= 1:\n        i, j = random.sample(range(n), 2)  # Ensure sufficient distance\n\n    # Insert edge (i, j) at a random position\n    k = random.randint(0, n - 1)\n    if k == i or k == j:\n        k = (k + 1) % n\n\n    # Create a new tour by inserting edge (i, j) at position k\n    new_tour = []\n    for idx in range(n):\n        if idx == k:\n            new_tour.append(base_solution[i])\n            new_tour.append(base_solution[j])\n        else:\n            new_tour.append(base_solution[idx])\n\n    # Ensure no duplicates and all nodes are included\n    if len(set(new_tour)) != n:\n        # Fallback to simple swap if insertion fails\n        a, b = random.sample(range(n), 2)\n        new_tour = new_solution.copy()\n        new_tour[a], new_tour[b] = new_tour[b], new_tour[a]\n\n    new_solution = np.array(new_tour)\n\n    # Step 2: Path relocation (move a random segment to another position)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Extract segment [a, b] and insert it after position c\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.concatenate([remaining[:c+1], segment, remaining[c+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8101579103143558,
            0.5578086376190186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its total cost\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    if total_cost == 0:\n        probabilities = [1.0 / len(archive) for _ in archive]\n    else:\n        probabilities = [1.0 - (cost / total_cost) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion + path relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge insertion (insert a random edge from another part of the tour)\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) <= 1:\n        i, j = random.sample(range(n), 2)  # Ensure sufficient distance\n\n    # Insert edge (i, j) at a random position\n    k = random.randint(0, n - 1)\n    if k == i or k == j:\n        k = (k + 1) % n\n\n    # Create a new tour by inserting edge (i, j) at position k\n    new_tour = []\n    for idx in range(n):\n        if idx == k:\n            new_tour.append(base_solution[i])\n            new_tour.append(base_solution[j])\n        else:\n            new_tour.append(base_solution[idx])\n\n    # Ensure no duplicates and all nodes are included\n    if len(set(new_tour)) != n:\n        # Fallback to simple swap if insertion fails\n        a, b = random.sample(range(n), 2)\n        new_tour = new_solution.copy()\n        new_tour[a], new_tour[b] = new_tour[b], new_tour[a]\n\n    new_solution = np.array(new_tour)\n\n    # Step 2: Path relocation (move a random segment to another position)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Extract segment [a, b] and insert it after position c\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.concatenate([remaining[:c+1], segment, remaining[c+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge exchange strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Step 1: Randomly select 4 distinct indices to perform a 3-opt-like move\n    indices = random.sample(range(n), 4)\n    i, j, k, l = sorted(indices)\n\n    # Step 2: Apply a novel edge exchange strategy\n    # Reverse segments between i-j and k-l, then reconnect with a cross-exchange\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[k:l+1]\n\n    # Create the new segments by reversing and exchanging\n    new_segment1 = segment1[::-1]\n    new_segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_segment1,\n        new_solution[j+1:k],\n        new_segment2,\n        new_solution[l+1:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes covered)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the novel move fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7617952887909221,
            0.45712703466415405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge exchange strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Step 1: Randomly select 4 distinct indices to perform a 3-opt-like move\n    indices = random.sample(range(n), 4)\n    i, j, k, l = sorted(indices)\n\n    # Step 2: Apply a novel edge exchange strategy\n    # Reverse segments between i-j and k-l, then reconnect with a cross-exchange\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[k:l+1]\n\n    # Create the new segments by reversing and exchanging\n    new_segment1 = segment1[::-1]\n    new_segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_segment1,\n        new_solution[j+1:k],\n        new_segment2,\n        new_solution[l+1:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes covered)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the novel move fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected = None\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for _, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 < cost2) or (other_cost1 < cost1 and other_cost2 <= cost2):\n                dominated = True\n                break\n        if not dominated:\n            selected = sol.copy()\n            break\n\n    if selected is None:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments to modify\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform segment reversal and exchange\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Ensure segments are of same length for exchange\n    if len(segment1) == len(segment2):\n        new_solution[a:b] = segment2\n        new_solution[c:d] = segment1\n    else:\n        # If lengths differ, perform reversal instead\n        new_solution[a:b] = segment1[::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8057172825673609,
            0.4675135612487793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected = None\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for _, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 < cost2) or (other_cost1 < cost1 and other_cost2 <= cost2):\n                dominated = True\n                break\n        if not dominated:\n            selected = sol.copy()\n            break\n\n    if selected is None:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments to modify\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform segment reversal and exchange\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Ensure segments are of same length for exchange\n    if len(segment1) == len(segment2):\n        new_solution[a:b] = segment2\n        new_solution[c:d] = segment1\n    else:\n        # If lengths differ, perform reversal instead\n        new_solution[a:b] = segment1[::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Random edge swap (basic 2-opt variation)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment relocation (novel operator)\n    if n > 4:\n        segment_length = random.randint(2, min(4, n // 3))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert segment at random position\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If duplicate nodes exist, repair by restoring missing nodes\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7225897470286273,
            0.47390615940093994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Random edge swap (basic 2-opt variation)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment relocation (novel operator)\n    if n > 4:\n        segment_length = random.randint(2, min(4, n // 3))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert segment at random position\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If duplicate nodes exist, repair by restoring missing nodes\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    non_dominated = [sol for sol, obj in archive if obj[0] < np.percentile([o[0] for _, o in archive], 75) or obj[1] < np.percentile([o[1] for _, o in archive], 75)]\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (swap two edges)\n    if j - i > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If i and j are adjacent, perform a 2-opt move instead\n        if i == 0 and j == n - 1:\n            new_solution = np.flip(new_solution)\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random insertion to diversify\n    if random.random() < 0.3:\n        k, l = sorted(random.sample(range(n), 2))\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l+1], [node], new_solution[l+1:]])\n\n    # Ensure feasibility (no duplicates and complete tour)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8415336141408114,
            1.9621522426605225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    non_dominated = [sol for sol, obj in archive if obj[0] < np.percentile([o[0] for _, o in archive], 75) or obj[1] < np.percentile([o[1] for _, o in archive], 75)]\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (swap two edges)\n    if j - i > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If i and j are adjacent, perform a 2-opt move instead\n        if i == 0 and j == n - 1:\n            new_solution = np.flip(new_solution)\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random insertion to diversify\n    if random.random() < 0.3:\n        k, l = sorted(random.sample(range(n), 2))\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l+1], [node], new_solution[l+1:]])\n\n    # Ensure feasibility (no duplicates and complete tour)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a balance between high diversity and low cost\n    def diversity_score(sol):\n        # Measure diversity by comparing with other solutions in the archive\n        diversity = 0.0\n        for other_sol, _ in archive:\n            diversity += np.sum(sol != other_sol)\n        return diversity / len(archive)\n\n    def cost_score(sol):\n        # Prefer solutions with lower total cost in both objectives\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1 + cost2\n\n    # Calculate scores for all solutions\n    scored_solutions = []\n    for sol, _ in archive:\n        diversity = diversity_score(sol)\n        cost = cost_score(sol)\n        # Combine scores (normalize diversity and cost)\n        total_score = diversity / (cost + 1e-6)  # Avoid division by zero\n        scored_solutions.append((sol, total_score))\n\n    # Select the solution with the highest combined score\n    scored_solutions.sort(key=lambda x: -x[1])\n    base_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: 3-opt with edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse the segment between b and c\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n        # Edge insertion: try inserting a random node elsewhere\n        if n > 4:\n            node_to_move = random.choice(new_solution)\n            # Remove and reinsert the node at a random position\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8664177183292482,
            1.7610017657279968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a balance between high diversity and low cost\n    def diversity_score(sol):\n        # Measure diversity by comparing with other solutions in the archive\n        diversity = 0.0\n        for other_sol, _ in archive:\n            diversity += np.sum(sol != other_sol)\n        return diversity / len(archive)\n\n    def cost_score(sol):\n        # Prefer solutions with lower total cost in both objectives\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1 + cost2\n\n    # Calculate scores for all solutions\n    scored_solutions = []\n    for sol, _ in archive:\n        diversity = diversity_score(sol)\n        cost = cost_score(sol)\n        # Combine scores (normalize diversity and cost)\n        total_score = diversity / (cost + 1e-6)  # Avoid division by zero\n        scored_solutions.append((sol, total_score))\n\n    # Select the solution with the highest combined score\n    scored_solutions.sort(key=lambda x: -x[1])\n    base_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: 3-opt with edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse the segment between b and c\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n        # Edge insertion: try inserting a random node elsewhere\n        if n > 4:\n            node_to_move = random.choice(new_solution)\n            # Remove and reinsert the node at a random position\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt: randomly select three edges and reconnect them\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reconnect the edges in a new order\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel edge insertion: insert a randomly selected node in a new position\n    if n >= 2:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.43194827039734207,
            0.4542425274848938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt: randomly select three edges and reconnect them\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reconnect the edges in a new order\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel edge insertion: insert a randomly selected node in a new position\n    if n >= 2:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not too close to the Pareto front)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt-like move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour in a new order\n    new_order = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    # Apply a custom edge swap based on distance matrices\n    if random.random() < 0.5:  # 50% chance to apply edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        cost2 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        if cost2 < cost1:  # Only swap if it improves the first objective\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5057724834954767,
            0.4567277431488037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not too close to the Pareto front)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt-like move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour in a new order\n    new_order = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    # Apply a custom edge swap based on distance matrices\n    if random.random() < 0.5:  # 50% chance to apply edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        cost2 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        if cost2 < cost1:  # Only swap if it improves the first objective\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    potential_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = [sol for sol, _ in archive]\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Try all possible combinations of segments\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    # Evaluate candidates based on both objectives\n    best_candidate = new_solution\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    # Apply custom edge insertion if 3-opt didn't improve\n    if best_candidate is new_solution:\n        # Select a random edge to remove and reinsert\n        remove_idx = random.randint(0, n-1)\n        removed_node = best_candidate[remove_idx]\n        new_candidate = np.delete(best_candidate, remove_idx)\n\n        # Find best insertion point\n        best_insert_pos = 0\n        best_insert_cost = float('inf')\n\n        for i in range(len(new_candidate)):\n            candidate_sol = np.insert(new_candidate, i, removed_node)\n            cost1 = sum(distance_matrix_1[candidate_sol[i-1], candidate_sol[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate_sol[i-1], candidate_sol[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_insert_cost:\n                best_insert_cost = total_cost\n                best_insert_pos = i\n\n        best_candidate = np.insert(new_candidate, best_insert_pos, removed_node)\n\n    return best_candidate\n\n",
        "score": [
            -0.8979584415431323,
            1.61721271276474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    potential_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        potential_solutions = [sol for sol, _ in archive]\n\n    base_solution = random.choice(potential_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Try all possible combinations of segments\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    # Evaluate candidates based on both objectives\n    best_candidate = new_solution\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    # Apply custom edge insertion if 3-opt didn't improve\n    if best_candidate is new_solution:\n        # Select a random edge to remove and reinsert\n        remove_idx = random.randint(0, n-1)\n        removed_node = best_candidate[remove_idx]\n        new_candidate = np.delete(best_candidate, remove_idx)\n\n        # Find best insertion point\n        best_insert_pos = 0\n        best_insert_cost = float('inf')\n\n        for i in range(len(new_candidate)):\n            candidate_sol = np.insert(new_candidate, i, removed_node)\n            cost1 = sum(distance_matrix_1[candidate_sol[i-1], candidate_sol[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate_sol[i-1], candidate_sol[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_insert_cost:\n                best_insert_cost = total_cost\n                best_insert_pos = i\n\n        best_candidate = np.insert(new_candidate, best_insert_pos, removed_node)\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combination of edge exchange and insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge exchange: swap edges between i and j\n    new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Insertion: move a random segment to a new position\n    k, l = np.random.choice(n, size=2, replace=False)\n    if k > l:\n        k, l = l, k\n\n    segment = new_solution[k:l]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = selected_solution.copy()\n        swap_pos = np.random.choice(n, size=2, replace=False)\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.421992108850686,
            0.46287107467651367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combination of edge exchange and insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge exchange: swap edges between i and j\n    new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Insertion: move a random segment to a new position\n    k, l = np.random.choice(n, size=2, replace=False)\n    if k > l:\n        k, l = l, k\n\n    segment = new_solution[k:l]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = selected_solution.copy()\n        swap_pos = np.random.choice(n, size=2, replace=False)\n        new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance count\n    # (simplified approach - in practice, you'd track dominance counts)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly choose between edge exchange and segment relocation\n        if random.random() < 0.5:\n            # Edge exchange (similar to 2-opt but with more flexibility)\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                # Reverse the segment between i and j\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment relocation (move a segment to a different position)\n            i, j, k = sorted(random.sample(range(n), 3))\n            if i != j and j != k:\n                segment = new_solution[i:j+1]\n                # Remove the segment and insert it after position k\n                remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n                new_solution = np.concatenate([\n                    remaining[:k+1],\n                    segment,\n                    remaining[k+1:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.7519533394206646,
            0.4905359148979187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance count\n    # (simplified approach - in practice, you'd track dominance counts)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly choose between edge exchange and segment relocation\n        if random.random() < 0.5:\n            # Edge exchange (similar to 2-opt but with more flexibility)\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                # Reverse the segment between i and j\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment relocation (move a segment to a different position)\n            i, j, k = sorted(random.sample(range(n), 3))\n            if i != j and j != k:\n                segment = new_solution[i:j+1]\n                # Remove the segment and insert it after position k\n                remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n                new_solution = np.concatenate([\n                    remaining[:k+1],\n                    segment,\n                    remaining[k+1:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = [i for i in range(len(archive_sorted)) if i not in {0, len(archive_sorted)-1}]\n    if not candidate_indices:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Generate all possible 3-opt moves and select the best one\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2)\n\n    current_cost = calculate_cost(new_solution)\n    best_cost = current_cost\n    best_solution = new_solution.copy()\n\n    # Try all possible 3-opt moves\n    for i in range(a, b):\n        for j in range(b, c):\n            # Try reversing segment between i and j\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            new_cost = calculate_cost(temp_solution)\n            if sum(new_cost) < sum(best_cost):\n                best_cost = new_cost\n                best_solution = temp_solution.copy()\n\n    # If no improvement, try a custom edge swap based on distance matrices\n    if best_cost == current_cost:\n        # Find the pair of edges with the highest combined distance in both objectives\n        max_diff = -1\n        swap_i, swap_j = -1, -1\n        for i in range(n):\n            j = (i + 1) % n\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            diff = dist1 + dist2\n            if diff > max_diff:\n                max_diff = diff\n                swap_i, swap_j = i, j\n\n        if swap_i != -1 and swap_j != -1:\n            # Swap the nodes to potentially reduce the total distance\n            temp_solution = new_solution.copy()\n            temp_solution[swap_i], temp_solution[swap_j] = temp_solution[swap_j], temp_solution[swap_i]\n            new_cost = calculate_cost(temp_solution)\n            if sum(new_cost) < sum(current_cost):\n                best_solution = temp_solution.copy()\n\n    return best_solution\n\n",
        "score": [
            -0.6981525376933838,
            8.093173801898956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = [i for i in range(len(archive_sorted)) if i not in {0, len(archive_sorted)-1}]\n    if not candidate_indices:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Generate all possible 3-opt moves and select the best one\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2)\n\n    current_cost = calculate_cost(new_solution)\n    best_cost = current_cost\n    best_solution = new_solution.copy()\n\n    # Try all possible 3-opt moves\n    for i in range(a, b):\n        for j in range(b, c):\n            # Try reversing segment between i and j\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            new_cost = calculate_cost(temp_solution)\n            if sum(new_cost) < sum(best_cost):\n                best_cost = new_cost\n                best_solution = temp_solution.copy()\n\n    # If no improvement, try a custom edge swap based on distance matrices\n    if best_cost == current_cost:\n        # Find the pair of edges with the highest combined distance in both objectives\n        max_diff = -1\n        swap_i, swap_j = -1, -1\n        for i in range(n):\n            j = (i + 1) % n\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            diff = dist1 + dist2\n            if diff > max_diff:\n                max_diff = diff\n                swap_i, swap_j = i, j\n\n        if swap_i != -1 and swap_j != -1:\n            # Swap the nodes to potentially reduce the total distance\n            temp_solution = new_solution.copy()\n            temp_solution[swap_i], temp_solution[swap_j] = temp_solution[swap_j], temp_solution[swap_i]\n            new_cost = calculate_cost(temp_solution)\n            if sum(new_cost) < sum(current_cost):\n                best_solution = temp_solution.copy()\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of current cost)\n    potentials = [1.0 / (obj[0] + obj[1]) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to exchange\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a generalized edge exchange (similar to Or-opt)\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Reconstruct the solution with exchanged segments\n    new_solution = np.concatenate([\n        new_solution[:i],\n        segment2,\n        new_solution[j:k],\n        segment1,\n        new_solution[l:]\n    ])\n\n    # Ensure the solution is a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, fall back to a simpler edge exchange\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7730981225651472,
            0.13101649284362793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of current cost)\n    potentials = [1.0 / (obj[0] + obj[1]) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to exchange\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a generalized edge exchange (similar to Or-opt)\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Reconstruct the solution with exchanged segments\n    new_solution = np.concatenate([\n        new_solution[:i],\n        segment2,\n        new_solution[j:k],\n        segment1,\n        new_solution[l:]\n    ])\n\n    # Ensure the solution is a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, fall back to a simpler edge exchange\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of current cost)\n    potentials = [1.0 / (obj[0] + obj[1]) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to exchange\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a generalized edge exchange (similar to Or-opt)\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Reconstruct the solution with exchanged segments\n    new_solution = np.concatenate([\n        new_solution[:i],\n        segment2,\n        new_solution[j:k],\n        segment1,\n        new_solution[l:]\n    ])\n\n    # Ensure the solution is a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, fall back to a simpler edge exchange\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7730981225651472,
            0.13101649284362793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of current cost)\n    potentials = [1.0 / (obj[0] + obj[1]) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to exchange\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a generalized edge exchange (similar to Or-opt)\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Reconstruct the solution with exchanged segments\n    new_solution = np.concatenate([\n        new_solution[:i],\n        segment2,\n        new_solution[j:k],\n        segment1,\n        new_solution[l:]\n    ])\n\n    # Ensure the solution is a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, fall back to a simpler edge exchange\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge insertion: move a segment to a new position\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore new structures\n    k, l = np.random.choice(n, 2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Swap-based improvement: swap two nodes if it improves both objectives\n    a, b = np.random.choice(n, 2, replace=False)\n    original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    # Revert if not improving both objectives\n    if (new_cost1 > original_cost1) or (new_cost2 > original_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8459679900300974,
            0.5388160347938538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge insertion: move a segment to a new position\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore new structures\n    k, l = np.random.choice(n, 2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Swap-based improvement: swap two nodes if it improves both objectives\n    a, b = np.random.choice(n, 2, replace=False)\n    original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    # Revert if not improving both objectives\n    if (new_cost1 > original_cost1) or (new_cost2 > original_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30%)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))\n\n    # Step 2: Reverse the selected segment (like 2-opt but with variable length)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 3: Randomly insert a node elsewhere in the tour\n    if n > 2:\n        node_to_move = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-2)\n        if insert_pos >= node_to_move:\n            insert_pos += 1\n        new_solution = np.insert(new_solution, insert_pos, new_solution[node_to_move])\n        if node_to_move < insert_pos:\n            new_solution = np.delete(new_solution, node_to_move)\n        else:\n            new_solution = np.delete(new_solution, node_to_move + 1)\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8553042761150708,
            0.49755585193634033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30%)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))\n\n    # Step 2: Reverse the selected segment (like 2-opt but with variable length)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 3: Randomly insert a node elsewhere in the tour\n    if n > 2:\n        node_to_move = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-2)\n        if insert_pos >= node_to_move:\n            insert_pos += 1\n        new_solution = np.insert(new_solution, insert_pos, new_solution[node_to_move])\n        if node_to_move < insert_pos:\n            new_solution = np.delete(new_solution, node_to_move)\n        else:\n            new_solution = np.delete(new_solution, node_to_move + 1)\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and relocate\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between 2-opt and relocate\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Relocate operator\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7998442652550849,
            0.4390241503715515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and relocate\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between 2-opt and relocate\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Relocate operator\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n_nodes = len(new_solution)\n    if n_nodes < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine the segment length for relocation (adaptive based on instance size)\n        segment_length = max(2, min(5, n_nodes // 4))\n\n        # With 50% probability, perform edge exchange (2-opt variant)\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Perform segment relocation (novel operator)\n            # Select two non-overlapping segments\n            seg1_start = random.randint(0, n_nodes - segment_length)\n            seg1_end = seg1_start + segment_length - 1\n            seg2_start = random.randint(0, n_nodes - segment_length)\n            seg2_end = seg2_start + segment_length - 1\n\n            # Ensure segments don't overlap\n            if seg1_end < seg2_start or seg2_end < seg1_start:\n                # Extract segments\n                seg1 = new_solution[seg1_start:seg1_end+1]\n                seg2 = new_solution[seg2_start:seg2_end+1]\n\n                # Remove segments\n                new_solution = np.delete(new_solution, np.concatenate([\n                    np.arange(seg1_start, seg1_end+1),\n                    np.arange(seg2_start, seg2_end+1)\n                ]))\n\n                # Insert segments in reverse order\n                insert_pos1 = random.randint(0, len(new_solution))\n                insert_pos2 = random.randint(0, len(new_solution) - len(seg1))\n\n                new_solution = np.insert(new_solution, insert_pos1, seg2)\n                new_solution = np.insert(new_solution, insert_pos2, seg1)\n\n    return new_solution\n\n",
        "score": [
            -0.7986229619533789,
            0.44276630878448486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n_nodes = len(new_solution)\n    if n_nodes < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine the segment length for relocation (adaptive based on instance size)\n        segment_length = max(2, min(5, n_nodes // 4))\n\n        # With 50% probability, perform edge exchange (2-opt variant)\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Perform segment relocation (novel operator)\n            # Select two non-overlapping segments\n            seg1_start = random.randint(0, n_nodes - segment_length)\n            seg1_end = seg1_start + segment_length - 1\n            seg2_start = random.randint(0, n_nodes - segment_length)\n            seg2_end = seg2_start + segment_length - 1\n\n            # Ensure segments don't overlap\n            if seg1_end < seg2_start or seg2_end < seg1_start:\n                # Extract segments\n                seg1 = new_solution[seg1_start:seg1_end+1]\n                seg2 = new_solution[seg2_start:seg2_end+1]\n\n                # Remove segments\n                new_solution = np.delete(new_solution, np.concatenate([\n                    np.arange(seg1_start, seg1_end+1),\n                    np.arange(seg2_start, seg2_end+1)\n                ]))\n\n                # Insert segments in reverse order\n                insert_pos1 = random.randint(0, len(new_solution))\n                insert_pos2 = random.randint(0, len(new_solution) - len(seg1))\n\n                new_solution = np.insert(new_solution, insert_pos1, seg2)\n                new_solution = np.insert(new_solution, insert_pos2, seg1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weight for both objectives\n    archive_sorted = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combination of 3-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion: move a random node to a new position\n    node_to_move = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.86137097394294,
            0.43989330530166626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weight for both objectives\n    archive_sorted = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combination of 3-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion: move a random node to a new position\n    node_to_move = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest hypervolume contribution (or random if all have similar objectives)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Simple heuristic: select a solution that is not dominated by others\n        non_dominated = []\n        for i, (obj_i) in enumerate(objectives):\n            dominated = False\n            for j, (obj_j) in enumerate(objectives):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append(i)\n        if non_dominated:\n            selected_idx = np.random.choice(non_dominated)\n        else:\n            selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with adaptive segment selection\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: select three random segments and attempt to reconnect them\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Create all possible 3-opt neighbors and select the best one\n        candidates = [\n            new_solution.copy(),  # original\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),  # 2-opt on first segment\n            np.concatenate([new_solution[:j], new_solution[j:k][::-1], new_solution[k:]]),  # 2-opt on middle segment\n            np.concatenate([new_solution[:k], new_solution[k:][::-1]]),  # 2-opt on last segment\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),  # shift middle to front\n            np.concatenate([new_solution[:i], new_solution[k:], new_solution[i:k]]),  # shift last to front\n            np.concatenate([new_solution[:j], new_solution[i:j], new_solution[j:k], new_solution[k:]]),  # shift first to middle\n        ]\n\n        # Evaluate all candidates using a weighted sum of objectives\n        best_candidate = new_solution.copy()\n        best_cost = float('inf')\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2  # Simple weighted sum (could be adaptive)\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate.copy()\n\n        new_solution = best_candidate.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7347589187308908,
            2.350598990917206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest hypervolume contribution (or random if all have similar objectives)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Simple heuristic: select a solution that is not dominated by others\n        non_dominated = []\n        for i, (obj_i) in enumerate(objectives):\n            dominated = False\n            for j, (obj_j) in enumerate(objectives):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append(i)\n        if non_dominated:\n            selected_idx = np.random.choice(non_dominated)\n        else:\n            selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with adaptive segment selection\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: select three random segments and attempt to reconnect them\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Create all possible 3-opt neighbors and select the best one\n        candidates = [\n            new_solution.copy(),  # original\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),  # 2-opt on first segment\n            np.concatenate([new_solution[:j], new_solution[j:k][::-1], new_solution[k:]]),  # 2-opt on middle segment\n            np.concatenate([new_solution[:k], new_solution[k:][::-1]]),  # 2-opt on last segment\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),  # shift middle to front\n            np.concatenate([new_solution[:i], new_solution[k:], new_solution[i:k]]),  # shift last to front\n            np.concatenate([new_solution[:j], new_solution[i:j], new_solution[j:k], new_solution[k:]]),  # shift first to middle\n        ]\n\n        # Evaluate all candidates using a weighted sum of objectives\n        best_candidate = new_solution.copy()\n        best_cost = float('inf')\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2  # Simple weighted sum (could be adaptive)\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate.copy()\n\n        new_solution = best_candidate.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment swapping\n    if n > 4:\n        # Edge insertion: remove a random edge and reinsert it in a better position\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n        # Find the best insertion position based on both objectives\n        best_pos = 1\n        best_cost = float('inf')\n\n        for pos in range(1, n-1):\n            temp_sol = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Segment swapping: swap two random segments of the tour\n        a, b = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n        c, d = sorted(np.random.choice(range(a+1, n-1), 2, replace=False))\n\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7795866977117105,
            2.790067195892334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment swapping\n    if n > 4:\n        # Edge insertion: remove a random edge and reinsert it in a better position\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n        # Find the best insertion position based on both objectives\n        best_pos = 1\n        best_cost = float('inf')\n\n        for pos in range(1, n-1):\n            temp_sol = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Segment swapping: swap two random segments of the tour\n        a, b = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n        c, d = sorted(np.random.choice(range(a+1, n-1), 2, replace=False))\n\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        selected = random.choice(sorted_archive[:max(1, len(archive) // 3)])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    if n > 3:\n        # Randomly choose between two operators\n        if random.random() < 0.5:\n            # Edge exchange: swap two non-consecutive edges\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Segment reversal with distance-based selection\n            # Find the longest edge in the first objective space\n            max_dist = -1\n            split_point = 1\n            for i in range(n-1):\n                dist = distance_matrix_1[new_solution[i], new_solution[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_point = i + 1\n\n            # Reverse the segment around the longest edge\n            segment_length = min(3, n // 4)\n            start = max(1, split_point - segment_length // 2)\n            end = min(n-1, split_point + segment_length // 2)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7500422054859295,
            0.44948267936706543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        selected = random.choice(sorted_archive[:max(1, len(archive) // 3)])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    if n > 3:\n        # Randomly choose between two operators\n        if random.random() < 0.5:\n            # Edge exchange: swap two non-consecutive edges\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Segment reversal with distance-based selection\n            # Find the longest edge in the first objective space\n            max_dist = -1\n            split_point = 1\n            for i in range(n-1):\n                dist = distance_matrix_1[new_solution[i], new_solution[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_point = i + 1\n\n            # Reverse the segment around the longest edge\n            segment_length = min(3, n // 4)\n            start = max(1, split_point - segment_length // 2)\n            end = min(n-1, split_point + segment_length // 2)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (higher is better)\n    dominance_scores = []\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]:\n                dominated += 1\n        dominance_scores.append(1 / (1 + dominated))\n\n    # Normalize scores to get probabilities\n    total = sum(dominance_scores)\n    probabilities = [score / total for score in dominance_scores]\n\n    # Select a solution based on dominance\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to exchange or reverse\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply edge exchange if segments are of similar size\n    if abs(b - a) == abs(d - c):\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution[a:b+1] = segment2\n        new_solution[c:d+1] = segment1\n    else:\n        # Apply segment reversal if sizes differ\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    if len(duplicates) > 0:\n        # Fix duplicates by swapping with missing nodes\n        all_nodes = set(range(n))\n        missing = list(all_nodes - set(new_solution))\n        for dup in duplicates:\n            if missing:\n                idx = np.where(new_solution == dup)[0][1]  # second occurrence\n                new_solution[idx] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8255311716378324,
            0.5297167897224426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (higher is better)\n    dominance_scores = []\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]:\n                dominated += 1\n        dominance_scores.append(1 / (1 + dominated))\n\n    # Normalize scores to get probabilities\n    total = sum(dominance_scores)\n    probabilities = [score / total for score in dominance_scores]\n\n    # Select a solution based on dominance\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to exchange or reverse\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply edge exchange if segments are of similar size\n    if abs(b - a) == abs(d - c):\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution[a:b+1] = segment2\n        new_solution[c:d+1] = segment1\n    else:\n        # Apply segment reversal if sizes differ\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    if len(duplicates) > 0:\n        # Fix duplicates by swapping with missing nodes\n        all_nodes = set(range(n))\n        missing = list(all_nodes - set(new_solution))\n        for dup in duplicates:\n            if missing:\n                idx = np.where(new_solution == dup)[0][1]  # second occurrence\n                new_solution[idx] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    def selection_score(solution_obj):\n        # Prioritize solutions with lower total cost and higher diversity\n        total_cost = sum(solution_obj)\n        return total_cost  # Can be enhanced with other metrics\n\n    # Sort solutions by their selection score\n    archive_sorted = sorted(archive, key=lambda x: selection_score(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 3-opt local search\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(random.sample(range(N), 3))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n        candidate[j:k+1] = candidate[j:k+1][::-1]   # Reverse segment\n        candidate[i:k+1] = candidate[i:k+1][::-1] # Reverse entire segment\n\n        # Check if the new solution is better in at least one objective\n        old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n        new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution = candidate\n\n    # Apply a custom edge-swap strategy to further improve the solution\n    for _ in range(5):\n        i, j = sorted(random.sample(range(N), 2))\n        if j - i > 1:  # Ensure we have at least one node in between\n            candidate = new_solution.copy()\n            candidate[i+1:j] = candidate[i+1:j][::-1]  # Reverse segment between i and j\n\n            # Check feasibility and improvement\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n            new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8995540577382134,
            2.0102171897888184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    def selection_score(solution_obj):\n        # Prioritize solutions with lower total cost and higher diversity\n        total_cost = sum(solution_obj)\n        return total_cost  # Can be enhanced with other metrics\n\n    # Sort solutions by their selection score\n    archive_sorted = sorted(archive, key=lambda x: selection_score(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 3-opt local search\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(random.sample(range(N), 3))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n        candidate[j:k+1] = candidate[j:k+1][::-1]   # Reverse segment\n        candidate[i:k+1] = candidate[i:k+1][::-1] # Reverse entire segment\n\n        # Check if the new solution is better in at least one objective\n        old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n        new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution = candidate\n\n    # Apply a custom edge-swap strategy to further improve the solution\n    for _ in range(5):\n        i, j = sorted(random.sample(range(N), 2))\n        if j - i > 1:  # Ensure we have at least one node in between\n            candidate = new_solution.copy()\n            candidate[i+1:j] = candidate[i+1:j][::-1]  # Reverse segment between i and j\n\n            # Check feasibility and improvement\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n            new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (lowest sum of objectives) for local improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + Path relinking\n    n = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two edges to modify\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n\n        # Edge insertion: Remove two edges and reconnect\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n        # Path relinking: Swap segments to explore better paths\n        if np.random.random() < 0.5:\n            k, l = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n        # Ensure feasibility (no duplicates and all nodes visited)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final check to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: Randomly shuffle if feasibility is violated\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.803346541388396,
            0.4989050626754761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (lowest sum of objectives) for local improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + Path relinking\n    n = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two edges to modify\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n\n        # Edge insertion: Remove two edges and reconnect\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n        # Path relinking: Swap segments to explore better paths\n        if np.random.random() < 0.5:\n            k, l = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n        # Ensure feasibility (no duplicates and all nodes visited)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final check to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: Randomly shuffle if feasibility is violated\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: a combination of edge insertion and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (3-opt style)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[i:j+1]\n    np.random.shuffle(segment)\n    new_solution[i:j+1] = segment\n\n    # Randomly insert a node elsewhere (edge insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility by checking for duplicates (should not happen due to operations)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.5494447590943352,
            0.49412864446640015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: a combination of edge insertion and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (3-opt style)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[i:j+1]\n    np.random.shuffle(segment)\n    new_solution[i:j+1] = segment\n\n    # Randomly insert a node elsewhere (edge insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility by checking for duplicates (should not happen due to operations)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified: lower cost in both objectives = better)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0))\n    total_rank = np.sum(ranks, axis=1)\n    probs = (1.0 / (1.0 + total_rank)) / np.sum(1.0 / (1.0 + total_rank))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt + novel edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions (for 3-opt)\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel edge-swap: swap edges between two random non-adjacent segments\n    if n >= 6:\n        a, b = sorted(random.sample(range(n-1), 2))\n        if b - a >= 2:\n            # Swap the edges between segments a-a+1 and b-b+1\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and apply simple 2-opt\n        new_solution = base_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8833520403923252,
            0.5192825198173523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified: lower cost in both objectives = better)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0))\n    total_rank = np.sum(ranks, axis=1)\n    probs = (1.0 / (1.0 + total_rank)) / np.sum(1.0 / (1.0 + total_rank))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt + novel edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions (for 3-opt)\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel edge-swap: swap edges between two random non-adjacent segments\n    if n >= 6:\n        a, b = sorted(random.sample(range(n-1), 2))\n        if b - a >= 2:\n            # Swap the edges between segments a-a+1 and b-b+1\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and apply simple 2-opt\n        new_solution = base_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but not already optimal)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, 3)  # Select from top 3 or last if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    if n > 3:\n        # Select two random non-adjacent edges to exchange\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        while (i + 1) % n == j or (j + 1) % n == i:\n            i, j = np.random.choice(range(n), size=2, replace=False)\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # With 50% probability, also perform segment reversal between two random positions\n        if np.random.rand() < 0.5:\n            a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible by checking for duplicates and fixing if needed\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Find a position where inserting the node doesn't create duplicates\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7873171214008907,
            0.46034693717956543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but not already optimal)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, 3)  # Select from top 3 or last if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    if n > 3:\n        # Select two random non-adjacent edges to exchange\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        while (i + 1) % n == j or (j + 1) % n == i:\n            i, j = np.random.choice(range(n), size=2, replace=False)\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # With 50% probability, also perform segment reversal between two random positions\n        if np.random.rand() < 0.5:\n            a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible by checking for duplicates and fixing if needed\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Find a position where inserting the node doesn't create duplicates\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    n = len(new_solution)\n\n    # Edge insertion: randomly select two edges and reconnect them\n    i, j = sorted(random.sample(range(n), 2))\n    if i + 1 != j:\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Segment relocation: move a segment to a different position considering both objectives\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Find the best insertion point considering both objectives\n    best_pos = None\n    best_cost = (float('inf'), float('inf'))\n\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue\n\n        # Temporarily insert the segment\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:start], new_solution[end:]])\n\n        # Calculate the cost of the new solution\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (cost1 < best_cost[0] or cost2 < best_cost[1]) and (cost1 <= best_cost[0] or cost2 <= best_cost[1]):\n            best_cost = (cost1, cost2)\n            best_pos = pos\n\n    if best_pos is not None:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:start], new_solution[end:]])\n\n    return new_solution\n\n",
        "score": [
            -0.560195447599594,
            2.440004825592041
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    n = len(new_solution)\n\n    # Edge insertion: randomly select two edges and reconnect them\n    i, j = sorted(random.sample(range(n), 2))\n    if i + 1 != j:\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Segment relocation: move a segment to a different position considering both objectives\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Find the best insertion point considering both objectives\n    best_pos = None\n    best_cost = (float('inf'), float('inf'))\n\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue\n\n        # Temporarily insert the segment\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:start], new_solution[end:]])\n\n        # Calculate the cost of the new solution\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (cost1 < best_cost[0] or cost2 < best_cost[1]) and (cost1 <= best_cost[0] or cost2 <= best_cost[1]):\n            best_cost = (cost1, cost2)\n            best_pos = pos\n\n    if best_pos is not None:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:start], new_solution[end:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with lower costs\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (1 / (costs + 1e-10)) / np.sum(1 / (costs + 1e-10))\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment reversal: reverse a random segment of the solution\n    seg_start = np.random.randint(0, n)\n    seg_end = np.random.randint(seg_start + 1, n + 1)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9561141983955359,
            0.4914708137512207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with lower costs\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (1 / (costs + 1e-10)) / np.sum(1 / (costs + 1e-10))\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment reversal: reverse a random segment of the solution\n    seg_start = np.random.randint(0, n)\n    seg_end = np.random.randint(seg_start + 1, n + 1)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with lower costs\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (1 / (costs + 1e-10)) / np.sum(1 / (costs + 1e-10))\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment reversal: reverse a random segment of the solution\n    seg_start = np.random.randint(0, n)\n    seg_end = np.random.randint(seg_start + 1, n + 1)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9561141983955359,
            0.4914708137512207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with lower costs\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (1 / (costs + 1e-10)) / np.sum(1 / (costs + 1e-10))\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment reversal: reverse a random segment of the solution\n    seg_start = np.random.randint(0, n)\n    seg_end = np.random.randint(seg_start + 1, n + 1)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    N = len(base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a segment of the tour (3-5 nodes)\n    segment_length = random.randint(3, min(5, N // 2))\n    start_idx = random.randint(0, N - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Step 2: Remove the segment and insert it in a new position\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply a novel segment reversal with probability 0.5\n    if random.random() < 0.5:\n        rev_start = random.randint(0, len(new_solution) - 2)\n        rev_end = random.randint(rev_start + 1, len(new_solution) - 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Step 4: Apply edge insertion based on both distance matrices\n    for _ in range(3):  # Perform 3 edge insertions\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i == j:\n            continue\n\n        # Calculate potential improvement in both objectives\n        a, b, c = new_solution[i], new_solution[j], new_solution[(j + 1) % len(new_solution)]\n        delta1 = distance_matrix_1[a, c] - distance_matrix_1[a, b] - distance_matrix_1[b, c]\n        delta2 = distance_matrix_2[a, c] - distance_matrix_2[a, b] - distance_matrix_2[b, c]\n\n        # Accept if either objective improves\n        if delta1 < 0 or delta2 < 0:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6671978219355881,
            0.0992882251739502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    N = len(base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a segment of the tour (3-5 nodes)\n    segment_length = random.randint(3, min(5, N // 2))\n    start_idx = random.randint(0, N - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Step 2: Remove the segment and insert it in a new position\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply a novel segment reversal with probability 0.5\n    if random.random() < 0.5:\n        rev_start = random.randint(0, len(new_solution) - 2)\n        rev_end = random.randint(rev_start + 1, len(new_solution) - 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Step 4: Apply edge insertion based on both distance matrices\n    for _ in range(3):  # Perform 3 edge insertions\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i == j:\n            continue\n\n        # Calculate potential improvement in both objectives\n        a, b, c = new_solution[i], new_solution[j], new_solution[(j + 1) % len(new_solution)]\n        delta1 = distance_matrix_1[a, c] - distance_matrix_1[a, b] - distance_matrix_1[b, c]\n        delta2 = distance_matrix_2[a, c] - distance_matrix_2[a, b] - distance_matrix_2[b, c]\n\n        # Accept if either objective improves\n        if delta1 < 0 or delta2 < 0:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    N = len(base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a segment of the tour (3-5 nodes)\n    segment_length = random.randint(3, min(5, N // 2))\n    start_idx = random.randint(0, N - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Step 2: Remove the segment and insert it in a new position\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply a novel segment reversal with probability 0.5\n    if random.random() < 0.5:\n        rev_start = random.randint(0, len(new_solution) - 2)\n        rev_end = random.randint(rev_start + 1, len(new_solution) - 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Step 4: Apply edge insertion based on both distance matrices\n    for _ in range(3):  # Perform 3 edge insertions\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i == j:\n            continue\n\n        # Calculate potential improvement in both objectives\n        a, b, c = new_solution[i], new_solution[j], new_solution[(j + 1) % len(new_solution)]\n        delta1 = distance_matrix_1[a, c] - distance_matrix_1[a, b] - distance_matrix_1[b, c]\n        delta2 = distance_matrix_2[a, c] - distance_matrix_2[a, b] - distance_matrix_2[b, c]\n\n        # Accept if either objective improves\n        if delta1 < 0 or delta2 < 0:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6671978219355881,
            0.0992882251739502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    N = len(base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a segment of the tour (3-5 nodes)\n    segment_length = random.randint(3, min(5, N // 2))\n    start_idx = random.randint(0, N - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Step 2: Remove the segment and insert it in a new position\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply a novel segment reversal with probability 0.5\n    if random.random() < 0.5:\n        rev_start = random.randint(0, len(new_solution) - 2)\n        rev_end = random.randint(rev_start + 1, len(new_solution) - 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Step 4: Apply edge insertion based on both distance matrices\n    for _ in range(3):  # Perform 3 edge insertions\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i == j:\n            continue\n\n        # Calculate potential improvement in both objectives\n        a, b, c = new_solution[i], new_solution[j], new_solution[(j + 1) % len(new_solution)]\n        delta1 = distance_matrix_1[a, c] - distance_matrix_1[a, b] - distance_matrix_1[b, c]\n        delta2 = distance_matrix_2[a, c] - distance_matrix_2[a, b] - distance_matrix_2[b, c]\n\n        # Accept if either objective improves\n        if delta1 < 0 or delta2 < 0:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high cost)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    if n > 3:\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion: remove segment and reinsert it in reverse order\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment[::-1]])\n\n        # Ensure the tour remains valid (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if insertion causes duplicates\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Additional local improvement: reverse a random segment if it improves both objectives\n    if n > 3:\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost before and after reversal\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Create temporary solution with reversed segment\n        temp_solution = new_solution.copy()\n        temp_solution[k:l+1] = reversed_segment\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Accept if both objectives improve or at least one improves\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.837574860636142,
            0.5753759741783142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high cost)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    if n > 3:\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion: remove segment and reinsert it in reverse order\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment[::-1]])\n\n        # Ensure the tour remains valid (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if insertion causes duplicates\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Additional local improvement: reverse a random segment if it improves both objectives\n    if n > 3:\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost before and after reversal\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Create temporary solution with reversed segment\n        temp_solution = new_solution.copy()\n        temp_solution[k:l+1] = reversed_segment\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Accept if both objectives improve or at least one improves\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (e.g., Pareto front candidates)\n    # Here, we select the solution with the best trade-off between the two objectives\n    def pareto_dominance(obj1, obj2):\n        return (obj1[0] <= obj2[0] and obj1[1] < obj2[1]) or (obj1[0] < obj2[0] and obj1[1] <= obj2[1])\n\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Find non-dominated solutions (Pareto front)\n    pareto_front = []\n    for i, obj in enumerate(archive_objectives):\n        dominated = False\n        for j, other_obj in enumerate(archive_objectives):\n            if i != j and pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Select a random solution from the Pareto front\n        selected_idx = np.random.choice(pareto_front)\n        base_solution = archive_solutions[selected_idx].copy()\n    else:\n        # If no Pareto front, select a random solution\n        selected_idx = np.random.randint(0, len(archive))\n        base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments for reversal\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Ensure segments are of reasonable size and non-overlapping\n    if abs(j - i) < 2 or abs(l - k) < 2 or (i <= k <= j and k <= l <= j):\n        # Fallback to standard 2-opt if segments are invalid\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Reverse the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7713332150117507,
            0.5878238677978516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (e.g., Pareto front candidates)\n    # Here, we select the solution with the best trade-off between the two objectives\n    def pareto_dominance(obj1, obj2):\n        return (obj1[0] <= obj2[0] and obj1[1] < obj2[1]) or (obj1[0] < obj2[0] and obj1[1] <= obj2[1])\n\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Find non-dominated solutions (Pareto front)\n    pareto_front = []\n    for i, obj in enumerate(archive_objectives):\n        dominated = False\n        for j, other_obj in enumerate(archive_objectives):\n            if i != j and pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Select a random solution from the Pareto front\n        selected_idx = np.random.choice(pareto_front)\n        base_solution = archive_solutions[selected_idx].copy()\n    else:\n        # If no Pareto front, select a random solution\n        selected_idx = np.random.randint(0, len(archive))\n        base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments for reversal\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Ensure segments are of reasonable size and non-overlapping\n    if abs(j - i) < 2 or abs(l - k) < 2 or (i <= k <= j and k <= l <= j):\n        # Fallback to standard 2-opt if segments are invalid\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Reverse the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.argmax([np.var(obj) for _, obj in archive])][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange (2-opt-like but with a twist)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment relocation (novel operator)\n    if np.random.rand() < 0.5:  # 50% chance to apply\n        seg_start, seg_end = np.sort(np.random.choice(n, 2, replace=False))\n        insert_pos = np.random.randint(0, n)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler edge exchange\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.29120176960082217,
            1.0482322573661804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.argmax([np.var(obj) for _, obj in archive])][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange (2-opt-like but with a twist)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment relocation (novel operator)\n    if np.random.rand() < 0.5:  # 50% chance to apply\n        seg_start, seg_end = np.sort(np.random.choice(n, 2, replace=False))\n        insert_pos = np.random.randint(0, n)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler edge exchange\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom swap\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then reverse between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom swap: swap nodes at positions i and k if it improves both objectives\n    if i != k:\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n\n        # Check if the swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n        new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[k-1], temp_solution[k]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n        new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[k-1], temp_solution[k]]\n\n        if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9529834676077196,
            0.4833429455757141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom swap\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then reverse between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom swap: swap nodes at positions i and k if it improves both objectives\n    if i != k:\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n\n        # Check if the swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n        new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[k-1], temp_solution[k]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n        new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[k-1], temp_solution[k]]\n\n        if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with higher costs)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by total cost descending\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Edge insertion: randomly select two edges and insert one into the other\n    i, j = sorted(random.sample(range(1, n - 1), 2))\n    if i + 1 == j:\n        i, j = j, i  # Ensure i and j are not adjacent\n\n    # Insert node j between i and i+1\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        [new_solution[j]],\n        new_solution[i+1:j],\n        new_solution[j+1:]\n    ])\n\n    # Segment reversal: reverse a random segment to improve both objectives\n    k, l = sorted(random.sample(range(1, n - 1), 2))\n    if k + 1 == l:\n        k, l = l, k  # Ensure k and l are not adjacent\n\n    # Reverse the segment between k and l\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8554668139077224,
            0.4677366018295288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with higher costs)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by total cost descending\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Edge insertion: randomly select two edges and insert one into the other\n    i, j = sorted(random.sample(range(1, n - 1), 2))\n    if i + 1 == j:\n        i, j = j, i  # Ensure i and j are not adjacent\n\n    # Insert node j between i and i+1\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        [new_solution[j]],\n        new_solution[i+1:j],\n        new_solution[j+1:]\n    ])\n\n    # Segment reversal: reverse a random segment to improve both objectives\n    k, l = sorted(random.sample(range(1, n - 1), 2))\n    if k + 1 == l:\n        k, l = l, k  # Ensure k and l are not adjacent\n\n    # Reverse the segment between k and l\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (swap two edges)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Novel segment inversion: reverse a segment between two random nodes\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7414279401236613,
            0.4466462731361389
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (swap two edges)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Novel segment inversion: reverse a segment between two random nodes\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized costs)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_objectives = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge exchange and segment reversal\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to exchange\n        i, j = np.random.choice(n, 2, replace=False)\n        k, l = np.random.choice(n, 2, replace=False)\n\n        # Ensure we're not creating cycles or invalid tours\n        if i == j or k == l or i == k or i == l or j == k or j == l:\n            continue\n\n        # Perform edge exchange\n        new_solution[[i, j, k, l]] = new_solution[[k, l, i, j]]\n\n        # Randomly decide to perform segment reversal between two points\n        if np.random.rand() < 0.5:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap as fallback\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7743309404268122,
            0.5618778467178345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized costs)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_objectives = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge exchange and segment reversal\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to exchange\n        i, j = np.random.choice(n, 2, replace=False)\n        k, l = np.random.choice(n, 2, replace=False)\n\n        # Ensure we're not creating cycles or invalid tours\n        if i == j or k == l or i == k or i == l or j == k or j == l:\n            continue\n\n        # Perform edge exchange\n        new_solution[[i, j, k, l]] = new_solution[[k, l, i, j]]\n\n        # Randomly decide to perform segment reversal between two points\n        if np.random.rand() < 0.5:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap as fallback\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Random edge swap (similar to 2-opt but more flexible)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation (novel mechanism)\n    if n > 4:\n        seg_len = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - seg_len)\n        segment = new_solution[start:start+seg_len]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_len:], segment])\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid.\"\n\n    return new_solution\n\n",
        "score": [
            -0.7747751051450835,
            0.5308151245117188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Random edge swap (similar to 2-opt but more flexible)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation (novel mechanism)\n    if n > 4:\n        seg_len = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - seg_len)\n        segment = new_solution[start:start+seg_len]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_len:], segment])\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between the two objectives (Pareto front approximation)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to avoid bias towards one objective\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    normalized_objectives = [\n        ((o[0] - min_obj1) / (max_obj1 - min_obj1), (o[1] - min_obj2) / (max_obj2 - min_obj2))\n        for o in objectives\n    ]\n\n    # Select a solution with the best normalized trade-off (closest to the Pareto front)\n    selected_idx = np.argmin([o1 + o2 for o1, o2 in normalized_objectives])\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments to perform 3-opt\n    segment_indices = sorted(np.random.choice(range(1, n), size=3, replace=False))\n    i, j, k = segment_indices\n\n    # Perform 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Apply a novel edge-swap strategy to further improve the solution\n    for _ in range(2):  # Perform a limited number of swaps\n        a, b = np.random.choice(range(1, n), size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Check if swapping edges (a, a+1) and (b, b+1) improves at least one objective\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform the swap\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.718844891517287,
            0.5328307747840881
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between the two objectives (Pareto front approximation)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to avoid bias towards one objective\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    normalized_objectives = [\n        ((o[0] - min_obj1) / (max_obj1 - min_obj1), (o[1] - min_obj2) / (max_obj2 - min_obj2))\n        for o in objectives\n    ]\n\n    # Select a solution with the best normalized trade-off (closest to the Pareto front)\n    selected_idx = np.argmin([o1 + o2 for o1, o2 in normalized_objectives])\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments to perform 3-opt\n    segment_indices = sorted(np.random.choice(range(1, n), size=3, replace=False))\n    i, j, k = segment_indices\n\n    # Perform 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Apply a novel edge-swap strategy to further improve the solution\n    for _ in range(2):  # Perform a limited number of swaps\n        a, b = np.random.choice(range(1, n), size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Check if swapping edges (a, a+1) and (b, b+1) improves at least one objective\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform the swap\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high variance in objectives or high costs)\n    def selection_criteria(sol_obj: Tuple[np.ndarray, Tuple[float, float]]) -> float:\n        sol, (cost1, cost2) = sol_obj\n        # Prefer solutions with high costs or high variance in objectives\n        return (cost1 + cost2) * (abs(cost1 - cost2) + 1)\n\n    selected = max(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt + edge-swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select 4 distinct indices to perform 3-opt\n    indices = random.sample(range(n), 4)\n    i, j, k, l = sorted(indices)\n\n    # Apply 3-opt (reversing segments)\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Apply edge-swap to further improve both objectives\n    def edge_swap(sol: np.ndarray, d1: np.ndarray, d2: np.ndarray) -> np.ndarray:\n        n = len(sol)\n        for _ in range(10):  # Limit iterations to avoid excessive computation\n            a, b, c, d = random.sample(range(n), 4)\n            # Ensure indices are in order\n            a, b, c, d = sorted([a, b, c, d])\n            # Calculate current and new edge costs\n            current_cost = (d1[sol[a], sol[b]] + d1[sol[c], sol[d]] +\n                            d2[sol[a], sol[b]] + d2[sol[c], sol[d]])\n            new_cost = (d1[sol[a], sol[c]] + d1[sol[b], sol[d]] +\n                        d2[sol[a], sol[c]] + d2[sol[b], sol[d]])\n            if new_cost < current_cost:\n                # Perform the swap\n                sol[b], sol[c] = sol[c], sol[b]\n        return sol\n\n    new_solution = edge_swap(new_solution, distance_matrix_1, distance_matrix_2)\n\n    # Ensure validity (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.5142327521533567,
            0.5520027875900269
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high variance in objectives or high costs)\n    def selection_criteria(sol_obj: Tuple[np.ndarray, Tuple[float, float]]) -> float:\n        sol, (cost1, cost2) = sol_obj\n        # Prefer solutions with high costs or high variance in objectives\n        return (cost1 + cost2) * (abs(cost1 - cost2) + 1)\n\n    selected = max(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt + edge-swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select 4 distinct indices to perform 3-opt\n    indices = random.sample(range(n), 4)\n    i, j, k, l = sorted(indices)\n\n    # Apply 3-opt (reversing segments)\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Apply edge-swap to further improve both objectives\n    def edge_swap(sol: np.ndarray, d1: np.ndarray, d2: np.ndarray) -> np.ndarray:\n        n = len(sol)\n        for _ in range(10):  # Limit iterations to avoid excessive computation\n            a, b, c, d = random.sample(range(n), 4)\n            # Ensure indices are in order\n            a, b, c, d = sorted([a, b, c, d])\n            # Calculate current and new edge costs\n            current_cost = (d1[sol[a], sol[b]] + d1[sol[c], sol[d]] +\n                            d2[sol[a], sol[b]] + d2[sol[c], sol[d]])\n            new_cost = (d1[sol[a], sol[c]] + d1[sol[b], sol[d]] +\n                        d2[sol[a], sol[c]] + d2[sol[b], sol[d]])\n            if new_cost < current_cost:\n                # Perform the swap\n                sol[b], sol[c] = sol[c], sol[b]\n        return sol\n\n    new_solution = edge_swap(new_solution, distance_matrix_1, distance_matrix_2)\n\n    # Ensure validity (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high cost)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combination of node insertion and edge reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Node insertion (move a node to a different position)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Edge reversal (reverse a segment of the tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0006931495941616,
            0.5660408139228821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high cost)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combination of node insertion and edge reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Node insertion (move a node to a different position)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Edge reversal (reverse a segment of the tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high cost)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combination of node insertion and edge reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Node insertion (move a node to a different position)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Edge reversal (reverse a segment of the tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0006931495941616,
            0.5660408139228821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high cost)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combination of node insertion and edge reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Node insertion (move a node to a different position)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Edge reversal (reverse a segment of the tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a full random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a combination of edge and node operations\n        operation = random.choice(['swap', 'insert', 'reverse', 'edge_swap'])\n\n        if operation == 'swap':\n            # Random swap of two nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'insert':\n            # Randomly insert a node at a new position\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n        elif operation == 'reverse':\n            # Reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operation == 'edge_swap':\n            # Edge-based swap: identify edges with high potential for improvement\n            # Calculate edge costs in both objective spaces\n            edge_costs = []\n            for i in range(n):\n                a, b = base_solution[i], base_solution[(i+1)%n]\n                cost1 = distance_matrix_1[a, b]\n                cost2 = distance_matrix_2[a, b]\n                edge_costs.append((cost1 + cost2, i))\n\n            # Sort edges by combined cost (descending) to identify worst edges\n            edge_costs.sort(reverse=True, key=lambda x: x[0])\n            worst_edges = [idx for _, idx in edge_costs[:min(3, len(edge_costs))]]\n\n            # Perform a swap between two nodes connected by worst edges\n            if len(worst_edges) >= 2:\n                i = random.choice(worst_edges)\n                j = random.choice([(i + 2) % n, (i - 2) % n])\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8215134579379005,
            0.449629008769989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a full random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a combination of edge and node operations\n        operation = random.choice(['swap', 'insert', 'reverse', 'edge_swap'])\n\n        if operation == 'swap':\n            # Random swap of two nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'insert':\n            # Randomly insert a node at a new position\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n        elif operation == 'reverse':\n            # Reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operation == 'edge_swap':\n            # Edge-based swap: identify edges with high potential for improvement\n            # Calculate edge costs in both objective spaces\n            edge_costs = []\n            for i in range(n):\n                a, b = base_solution[i], base_solution[(i+1)%n]\n                cost1 = distance_matrix_1[a, b]\n                cost2 = distance_matrix_2[a, b]\n                edge_costs.append((cost1 + cost2, i))\n\n            # Sort edges by combined cost (descending) to identify worst edges\n            edge_costs.sort(reverse=True, key=lambda x: x[0])\n            worst_edges = [idx for _, idx in edge_costs[:min(3, len(edge_costs))]]\n\n            # Perform a swap between two nodes connected by worst edges\n            if len(worst_edges) >= 2:\n                i = random.choice(worst_edges)\n                j = random.choice([(i + 2) % n, (i - 2) % n])\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to modify\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Apply a custom 3-opt-like move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour with segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap as fallback\n        new_solution = selected_solution.copy()\n        a, b = np.random.choice(range(1, n), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8677029207042536,
            0.6113306283950806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to modify\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Apply a custom 3-opt-like move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour with segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap as fallback\n        new_solution = selected_solution.copy()\n        a, b = np.random.choice(range(1, n), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_costs.mean(axis=1) + 1e-10)  # Higher weight for better solutions\n    weights = weights / weights.sum()  # Normalize weights\n    base_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a custom 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour with different combinations\n    possible_tours = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n    ]\n\n    # Evaluate all possible tours and select the best one\n    best_tour = new_solution\n    best_score = float('inf')\n\n    for tour in possible_tours:\n        # Calculate total distance for both objectives\n        total_dist1 = sum(distance_matrix_1[tour[i], tour[(i+1)%n]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[tour[i], tour[(i+1)%n]] for i in range(n))\n        total_score = total_dist1 + total_dist2\n\n        if total_score < best_score:\n            best_score = total_score\n            best_tour = tour.copy()\n\n    # Apply edge insertion to further improve the solution\n    for _ in range(2):  # Limit the number of insertions to maintain efficiency\n        u, v = sorted(random.sample(range(n), 2))\n        if v - u < 2:\n            continue\n\n        # Remove edges (u, u+1) and (v, v+1)\n        # Insert edges (u, v+1) and (v, u+1)\n        new_tour = np.concatenate([\n            best_tour[:u+1],\n            best_tour[v+1:],\n            best_tour[u+1:v+1][::-1]\n        ])\n\n        # Check if the new tour is better\n        new_dist1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        new_dist2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        new_score = new_dist1 + new_dist2\n\n        if new_score < best_score:\n            best_score = new_score\n            best_tour = new_tour.copy()\n\n    return best_tour\n\n",
        "score": [
            -0.851977440959313,
            1.0155233144760132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_costs.mean(axis=1) + 1e-10)  # Higher weight for better solutions\n    weights = weights / weights.sum()  # Normalize weights\n    base_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a custom 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour with different combinations\n    possible_tours = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n    ]\n\n    # Evaluate all possible tours and select the best one\n    best_tour = new_solution\n    best_score = float('inf')\n\n    for tour in possible_tours:\n        # Calculate total distance for both objectives\n        total_dist1 = sum(distance_matrix_1[tour[i], tour[(i+1)%n]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[tour[i], tour[(i+1)%n]] for i in range(n))\n        total_score = total_dist1 + total_dist2\n\n        if total_score < best_score:\n            best_score = total_score\n            best_tour = tour.copy()\n\n    # Apply edge insertion to further improve the solution\n    for _ in range(2):  # Limit the number of insertions to maintain efficiency\n        u, v = sorted(random.sample(range(n), 2))\n        if v - u < 2:\n            continue\n\n        # Remove edges (u, u+1) and (v, v+1)\n        # Insert edges (u, v+1) and (v, u+1)\n        new_tour = np.concatenate([\n            best_tour[:u+1],\n            best_tour[v+1:],\n            best_tour[u+1:v+1][::-1]\n        ])\n\n        # Check if the new tour is better\n        new_dist1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        new_dist2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        new_score = new_dist1 + new_dist2\n\n        if new_score < best_score:\n            best_score = new_score\n            best_tour = new_tour.copy()\n\n    return best_tour\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on non-dominated or diverse solutions\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select three distinct edges to break\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Step 2: Perform a 3-opt move (reconnect the nodes in a different order)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Step 3: Novel edge insertion - try to improve by inserting a random node elsewhere\n    if n > 4:\n        node_to_move = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-2)\n        if insert_pos == node_to_move or insert_pos == (node_to_move - 1) % n:\n            insert_pos = (insert_pos + 1) % n\n\n        # Remove the node and insert it at the new position\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is still a valid tour\n    assert len(new_solution) == len(selected_solution), \"Invalid tour length\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.8311157322648368,
            0.6163300275802612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on non-dominated or diverse solutions\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select three distinct edges to break\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Step 2: Perform a 3-opt move (reconnect the nodes in a different order)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Step 3: Novel edge insertion - try to improve by inserting a random node elsewhere\n    if n > 4:\n        node_to_move = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-2)\n        if insert_pos == node_to_move or insert_pos == (node_to_move - 1) % n:\n            insert_pos = (insert_pos + 1) % n\n\n        # Remove the node and insert it at the new position\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is still a valid tour\n    assert len(new_solution) == len(selected_solution), \"Invalid tour length\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with probability proportional to its potential for improvement\n    # Here, we consider solutions with lower costs as more promising\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / (costs + 1e-10)  # Add small epsilon to avoid division by zero\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Combine 2-opt with a novel edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel edge swap that considers both objectives\n    # Select two random edges and swap their endpoints if it improves both objectives\n    a, b, c, d = random.sample(range(n), 4)\n    a, b = sorted([a, b])\n    c, d = sorted([c, d])\n\n    # Calculate current and new costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        total = 0\n        for i in range(len(sol)):\n            total += dist_matrix[sol[i-1], sol[i]]\n        return total\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create a candidate solution with the edge swap\n    candidate = new_solution.copy()\n    candidate[a], candidate[b], candidate[c], candidate[d] = candidate[c], candidate[d], candidate[a], candidate[b]\n\n    new_cost1 = calculate_cost(candidate, distance_matrix_1)\n    new_cost2 = calculate_cost(candidate, distance_matrix_2)\n\n    # Accept the swap if both objectives improve\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        new_solution = candidate\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(set(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8577315548938982,
            0.6053345799446106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with probability proportional to its potential for improvement\n    # Here, we consider solutions with lower costs as more promising\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / (costs + 1e-10)  # Add small epsilon to avoid division by zero\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Combine 2-opt with a novel edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel edge swap that considers both objectives\n    # Select two random edges and swap their endpoints if it improves both objectives\n    a, b, c, d = random.sample(range(n), 4)\n    a, b = sorted([a, b])\n    c, d = sorted([c, d])\n\n    # Calculate current and new costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        total = 0\n        for i in range(len(sol)):\n            total += dist_matrix[sol[i-1], sol[i]]\n        return total\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create a candidate solution with the edge swap\n    candidate = new_solution.copy()\n    candidate[a], candidate[b], candidate[c], candidate[d] = candidate[c], candidate[d], candidate[a], candidate[b]\n\n    new_cost1 = calculate_cost(candidate, distance_matrix_1)\n    new_cost2 = calculate_cost(candidate, distance_matrix_2)\n\n    # Accept the swap if both objectives improve\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        new_solution = candidate\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(set(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower cost solutions)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange with cost improvement check\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Check if exchange improves both objectives\n    old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j]),\n                 (new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n    new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[j-1], new_solution[i]),\n                 (new_solution[j], new_solution[(i+1)%n]), (new_solution[i], new_solution[(j+1)%n])]\n\n    old_cost1 = sum(distance_matrix_1[a][b] for a, b in old_edges)\n    new_cost1 = sum(distance_matrix_1[a][b] for a, b in new_edges)\n    old_cost2 = sum(distance_matrix_2[a][b] for a, b in old_edges)\n    new_cost2 = sum(distance_matrix_2[a][b] for a, b in new_edges)\n\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.3:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal with cost improvement check\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    old_segment_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b], new_solution[(b+1)%n])]\n    new_segment_edges = [(new_solution[a-1], reversed_segment[0]), (reversed_segment[-1], new_solution[(b+1)%n])]\n\n    old_segment_cost1 = sum(distance_matrix_1[x][y] for x, y in old_segment_edges)\n    new_segment_cost1 = sum(distance_matrix_1[x][y] for x, y in new_segment_edges)\n    old_segment_cost2 = sum(distance_matrix_2[x][y] for x, y in old_segment_edges)\n    new_segment_cost2 = sum(distance_matrix_2[x][y] for x, y in new_segment_edges)\n\n    if (new_segment_cost1 < old_segment_cost1 and new_segment_cost2 < old_segment_cost2) or random.random() < 0.2:\n        new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8389592512723134,
            0.5401466488838196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower cost solutions)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange with cost improvement check\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Check if exchange improves both objectives\n    old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j]),\n                 (new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n    new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[j-1], new_solution[i]),\n                 (new_solution[j], new_solution[(i+1)%n]), (new_solution[i], new_solution[(j+1)%n])]\n\n    old_cost1 = sum(distance_matrix_1[a][b] for a, b in old_edges)\n    new_cost1 = sum(distance_matrix_1[a][b] for a, b in new_edges)\n    old_cost2 = sum(distance_matrix_2[a][b] for a, b in old_edges)\n    new_cost2 = sum(distance_matrix_2[a][b] for a, b in new_edges)\n\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.3:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal with cost improvement check\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    old_segment_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b], new_solution[(b+1)%n])]\n    new_segment_edges = [(new_solution[a-1], reversed_segment[0]), (reversed_segment[-1], new_solution[(b+1)%n])]\n\n    old_segment_cost1 = sum(distance_matrix_1[x][y] for x, y in old_segment_edges)\n    new_segment_cost1 = sum(distance_matrix_1[x][y] for x, y in new_segment_edges)\n    old_segment_cost2 = sum(distance_matrix_2[x][y] for x, y in old_segment_edges)\n    new_segment_cost2 = sum(distance_matrix_2[x][y] for x, y in new_segment_edges)\n\n    if (new_segment_cost1 < old_segment_cost1 and new_segment_cost2 < old_segment_cost2) or random.random() < 0.2:\n        new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weights = objective_variance / np.sum(objective_variance)\n    normalized_objectives = objectives * weights\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of node insertion and edge reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, min(start + 10, n - 1))\n\n    # Extract the segment and reverse it\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[start:end+1] = reversed_segment\n\n    # Optionally, perform a node insertion for further improvement\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution[pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.8609624005073693,
            0.5936375260353088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weights = objective_variance / np.sum(objective_variance)\n    normalized_objectives = objectives * weights\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of node insertion and edge reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, min(start + 10, n - 1))\n\n    # Extract the segment and reverse it\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[start:end+1] = reversed_segment\n\n    # Optionally, perform a node insertion for further improvement\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution[pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    if len(costs) > 0:\n        min_cost = min(costs)\n        max_cost = max(costs)\n        if max_cost > min_cost:\n            probabilities = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        else:\n            probabilities = [1.0 / len(costs) for _ in costs]\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swapping or segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Determine the type of local search to apply\n    if random.random() < 0.5:\n        # Edge swapping\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n    else:\n        # Segment reversal with a focus on improving both objectives\n        segment_length = min(n // 3, 5)\n        i = random.randint(1, n - segment_length - 1)\n        j = i + segment_length - 1\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8377859106581618,
            0.6281028985977173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    if len(costs) > 0:\n        min_cost = min(costs)\n        max_cost = max(costs)\n        if max_cost > min_cost:\n            probabilities = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        else:\n            probabilities = [1.0 / len(costs) for _ in costs]\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swapping or segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Determine the type of local search to apply\n    if random.random() < 0.5:\n        # Edge swapping\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n    else:\n        # Segment reversal with a focus on improving both objectives\n        segment_length = min(n // 3, 5)\n        i = random.randint(1, n - segment_length - 1)\n        j = i + segment_length - 1\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias toward those with lower combined cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge exchange and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful local search possible\n\n    # Randomly choose between two operators with equal probability\n    if random.random() < 0.5:\n        # Edge exchange operator\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i+1:j] = base_solution[i+1:j][::-1]\n    else:\n        # Segment reversal operator\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Ensure we're not just swapping adjacent elements\n            if abs(i - j) > 1:\n                segment = base_solution[min(i,j):max(i,j)]\n                new_solution = np.concatenate([\n                    base_solution[:min(i,j)],\n                    segment[::-1],\n                    base_solution[max(i,j):]\n                ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9102262059687326,
            0.5580214262008667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias toward those with lower combined cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge exchange and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful local search possible\n\n    # Randomly choose between two operators with equal probability\n    if random.random() < 0.5:\n        # Edge exchange operator\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i+1:j] = base_solution[i+1:j][::-1]\n    else:\n        # Segment reversal operator\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Ensure we're not just swapping adjacent elements\n            if abs(i - j) > 1:\n                segment = base_solution[min(i,j):max(i,j)]\n                new_solution = np.concatenate([\n                    base_solution[:min(i,j)],\n                    segment[::-1],\n                    base_solution[max(i,j):]\n                ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential scores based on objective values (lower is better)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential_scores = 1 - (normalized_obj[:, 0] + normalized_obj[:, 1]) / 2  # Higher score means more potential\n\n    # Select a solution with probability proportional to its potential\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: random segment inversion + node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Random segment inversion\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion: move a node to a random position\n    if n > 3:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7681027600876105,
            0.517108678817749
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential scores based on objective values (lower is better)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential_scores = 1 - (normalized_obj[:, 0] + normalized_obj[:, 1]) / 2  # Higher score means more potential\n\n    # Select a solution with probability proportional to its potential\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: random segment inversion + node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Random segment inversion\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node insertion: move a node to a random position\n    if n > 3:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by their objective values (lower is better)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% of solutions\n        top_k = max(1, int(0.3 * len(sorted_archive)))\n        selected = random.choice(sorted_archive[:top_k])\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine node insertion and segment reversal\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position\n    if n > 3:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        # Insert at a new random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 3: Check for improvement in both objectives\n    def calculate_cost(solution, dist_mat):\n        cost = 0\n        for i in range(len(solution)):\n            cost += dist_mat[solution[i-1]][solution[i]]\n        return cost\n\n    base_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    base_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # If the new solution is worse in both objectives, revert to base solution\n    if (new_cost1 > base_cost1 and new_cost2 > base_cost2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7435630204148393,
            1.0059199333190918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by their objective values (lower is better)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% of solutions\n        top_k = max(1, int(0.3 * len(sorted_archive)))\n        selected = random.choice(sorted_archive[:top_k])\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine node insertion and segment reversal\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position\n    if n > 3:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        # Insert at a new random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 3: Check for improvement in both objectives\n    def calculate_cost(solution, dist_mat):\n        cost = 0\n        for i in range(len(solution)):\n            cost += dist_mat[solution[i-1]][solution[i]]\n        return cost\n\n    base_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    base_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # If the new solution is worse in both objectives, revert to base solution\n    if (new_cost1 > base_cost1 and new_cost2 > base_cost2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in either objective\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform the 3-opt move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply a custom move: reverse a segment and insert it elsewhere\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    np.random.shuffle(segment)\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8017752183073009,
            0.5111668705940247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in either objective\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform the 3-opt move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply a custom move: reverse a segment and insert it elsewhere\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    np.random.shuffle(segment)\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between both objectives using a weighted sum\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for bi-objective optimization\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between i, j, k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel edge-swap: swap edges to potentially improve both objectives\n    if np.random.random() < 0.5:  # 50% chance to apply edge-swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and try again\n        new_solution = base_solution.copy()\n        # Apply a simpler 2-opt as fallback\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8096819593239897,
            0.4599995017051697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between both objectives using a weighted sum\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for bi-objective optimization\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between i, j, k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel edge-swap: swap edges to potentially improve both objectives\n    if np.random.random() < 0.5:  # 50% chance to apply edge-swap\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and try again\n        new_solution = base_solution.copy()\n        # Apply a simpler 2-opt as fallback\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all are dominated, select randomly\n        base_solution, _ = random.choice(archive)\n    else:\n        # Select the one with the highest sum of objectives (most \"challenging\" to improve)\n        base_solution, _ = max(non_dominated, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply 3-opt to three random segments\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Try all 8 possible 3-opt configurations\n        candidates = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n        ]\n\n        # Also consider a novel edge insertion: move a random segment to another position\n        if n > 4:\n            l = random.randint(2, min(4, n-2))\n            m = random.randint(0, n-l-1)\n            segment = new_solution[m:m+l]\n            remaining = np.concatenate([new_solution[:m], new_solution[m+l:]])\n            pos = random.randint(0, len(remaining))\n            candidates.append(np.concatenate([remaining[:pos], segment, remaining[pos:]]))\n\n        # Evaluate all candidates using a weighted sum of objectives\n        best_candidate = new_solution\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate tour length in both objectives\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n            # Use a weighted sum (could be adaptive based on problem characteristics)\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        new_solution = best_candidate.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6655115434959217,
            1.0417224764823914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all are dominated, select randomly\n        base_solution, _ = random.choice(archive)\n    else:\n        # Select the one with the highest sum of objectives (most \"challenging\" to improve)\n        base_solution, _ = max(non_dominated, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply 3-opt to three random segments\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Try all 8 possible 3-opt configurations\n        candidates = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n        ]\n\n        # Also consider a novel edge insertion: move a random segment to another position\n        if n > 4:\n            l = random.randint(2, min(4, n-2))\n            m = random.randint(0, n-l-1)\n            segment = new_solution[m:m+l]\n            remaining = np.concatenate([new_solution[:m], new_solution[m+l:]])\n            pos = random.randint(0, len(remaining))\n            candidates.append(np.concatenate([remaining[:pos], segment, remaining[pos:]]))\n\n        # Evaluate all candidates using a weighted sum of objectives\n        best_candidate = new_solution\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate tour length in both objectives\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n            # Use a weighted sum (could be adaptive based on problem characteristics)\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        new_solution = best_candidate.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement based on objective values\n    # Sort by the sum of normalized objectives to prioritize solutions that are not too dominated\n    normalized_objectives = []\n    for sol, (obj1, obj2) in archive:\n        # Normalize objectives to avoid bias towards one objective\n        if len(archive) > 1:\n            min_obj1 = min(obj[0] for _, obj in archive)\n            max_obj1 = max(obj[0] for _, obj in archive)\n            min_obj2 = min(obj[1] for _, obj in archive)\n            max_obj2 = max(obj[1] for _, obj in archive)\n\n            norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        else:\n            norm_obj1, norm_obj2 = 0.5, 0.5\n\n        normalized_objectives.append((sol, (norm_obj1, norm_obj2), obj1 + obj2))\n\n    # Sort by sum of normalized objectives (prioritize less dominated solutions)\n    normalized_objectives.sort(key=lambda x: x[2])\n    selected_sol = normalized_objectives[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # First, perform a random 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create three possible 3-opt moves and choose the best one\n        moves = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[i:j], new_solution[k:][::-1], new_solution[j:k]])\n        ]\n\n        # Evaluate each move based on both objectives\n        best_move = None\n        best_score = float('inf')\n\n        for move in moves:\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[move[i-1], move[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[move[i-1], move[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_move = move\n\n        if best_move is not None:\n            new_solution = best_move.copy()\n\n    # Then perform a custom edge swap based on both objectives\n    if n >= 4:\n        # Randomly select two edges to swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        # Create the swapped solution\n        swapped_solution = new_solution.copy()\n        if i < j:\n            swapped_solution[i:j+1] = swapped_solution[i:j+1][::-1]\n        else:\n            swapped_solution = np.concatenate([swapped_solution[j:i+1][::-1], swapped_solution[:j], swapped_solution[i+1:]])\n\n        # Evaluate the swapped solution\n        cost1_orig = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        cost2_orig = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n        cost1_swap = sum(distance_matrix_1[swapped_solution[i-1], swapped_solution[i]] for i in range(n))\n        cost2_swap = sum(distance_matrix_2[swapped_solution[i-1], swapped_solution[i]] for i in range(n))\n\n        # Accept the swap if it improves at least one objective\n        if (cost1_swap < cost1_orig) or (cost2_swap < cost2_orig):\n            new_solution = swapped_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6272339218413181,
            0.9757915139198303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement based on objective values\n    # Sort by the sum of normalized objectives to prioritize solutions that are not too dominated\n    normalized_objectives = []\n    for sol, (obj1, obj2) in archive:\n        # Normalize objectives to avoid bias towards one objective\n        if len(archive) > 1:\n            min_obj1 = min(obj[0] for _, obj in archive)\n            max_obj1 = max(obj[0] for _, obj in archive)\n            min_obj2 = min(obj[1] for _, obj in archive)\n            max_obj2 = max(obj[1] for _, obj in archive)\n\n            norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        else:\n            norm_obj1, norm_obj2 = 0.5, 0.5\n\n        normalized_objectives.append((sol, (norm_obj1, norm_obj2), obj1 + obj2))\n\n    # Sort by sum of normalized objectives (prioritize less dominated solutions)\n    normalized_objectives.sort(key=lambda x: x[2])\n    selected_sol = normalized_objectives[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # First, perform a random 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create three possible 3-opt moves and choose the best one\n        moves = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[i:j], new_solution[k:][::-1], new_solution[j:k]])\n        ]\n\n        # Evaluate each move based on both objectives\n        best_move = None\n        best_score = float('inf')\n\n        for move in moves:\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[move[i-1], move[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[move[i-1], move[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_move = move\n\n        if best_move is not None:\n            new_solution = best_move.copy()\n\n    # Then perform a custom edge swap based on both objectives\n    if n >= 4:\n        # Randomly select two edges to swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        # Create the swapped solution\n        swapped_solution = new_solution.copy()\n        if i < j:\n            swapped_solution[i:j+1] = swapped_solution[i:j+1][::-1]\n        else:\n            swapped_solution = np.concatenate([swapped_solution[j:i+1][::-1], swapped_solution[:j], swapped_solution[i+1:]])\n\n        # Evaluate the swapped solution\n        cost1_orig = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        cost2_orig = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n        cost1_swap = sum(distance_matrix_1[swapped_solution[i-1], swapped_solution[i]] for i in range(n))\n        cost2_swap = sum(distance_matrix_2[swapped_solution[i-1], swapped_solution[i]] for i in range(n))\n\n        # Accept the swap if it improves at least one objective\n        if (cost1_swap < cost1_orig) or (cost2_swap < cost2_orig):\n            new_solution = swapped_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards lower objective values\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: edge insertion with biased node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two nodes with high potential for improvement\n    # We calculate the \"improvement potential\" based on the distance matrices\n    improvement_potential = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate potential improvement by removing and reinserting the node\n        removal_cost = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                      distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        insertion_cost = distance_matrix_1[prev, next_node] + distance_matrix_2[prev, next_node]\n        improvement_potential[i] = removal_cost - insertion_cost\n\n    # Select nodes with highest improvement potential\n    top_nodes = np.argsort(improvement_potential)[-2:]\n\n    # Perform edge insertion between the two selected nodes\n    i, j = top_nodes\n    if i > j:\n        i, j = j, i\n\n    # Create the new solution by inserting the segment between i and j in reverse order\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5351505446486489,
            2.7010363936424255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards lower objective values\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: edge insertion with biased node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two nodes with high potential for improvement\n    # We calculate the \"improvement potential\" based on the distance matrices\n    improvement_potential = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate potential improvement by removing and reinserting the node\n        removal_cost = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                      distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        insertion_cost = distance_matrix_1[prev, next_node] + distance_matrix_2[prev, next_node]\n        improvement_potential[i] = removal_cost - insertion_cost\n\n    # Select nodes with highest improvement potential\n    top_nodes = np.argsort(improvement_potential)[-2:]\n\n    # Perform edge insertion between the two selected nodes\n    i, j = top_nodes\n    if i > j:\n        i, j = j, i\n\n    # Create the new solution by inserting the segment between i and j in reverse order\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a weighted combination of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Step 1: Edge insertion (randomly insert a node in a different position)\n        if n > 2:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or (j == (i + 1) % n):\n                j = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, j, new_solution[i])\n            new_solution = np.delete(new_solution, i if i < j else i + 1)\n\n        # Step 2: Node relocation (move a node to a better position)\n        if n > 2:\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            best_pos = 0\n            best_cost = float('inf')\n            for j in range(n - 1):\n                temp_solution = np.insert(new_solution, j, node)\n                cost1 = distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%(n-1)]]\n                cost2 = distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%(n-1)]]\n                total_cost = cost1 + cost2\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = j\n            new_solution = np.insert(new_solution, best_pos, node)\n\n        # Step 3: Novel swap-based operator (swap nodes that improve both objectives)\n        if n > 2:\n            i, j = np.random.randint(0, n, size=2)\n            while i == j:\n                i, j = np.random.randint(0, n, size=2)\n            # Calculate current cost of the edges involving i and j\n            current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            # Calculate new cost if i and j are swapped\n            new_solution_swap = new_solution.copy()\n            new_solution_swap[i], new_solution_swap[j] = new_solution_swap[j], new_solution_swap[i]\n            new_cost1 = (distance_matrix_1[new_solution_swap[i-1], new_solution_swap[i]] +\n                         distance_matrix_1[new_solution_swap[i], new_solution_swap[(i+1)%n]] +\n                         distance_matrix_1[new_solution_swap[j-1], new_solution_swap[j]] +\n                         distance_matrix_1[new_solution_swap[j], new_solution_swap[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution_swap[i-1], new_solution_swap[i]] +\n                         distance_matrix_2[new_solution_swap[i], new_solution_swap[(i+1)%n]] +\n                         distance_matrix_2[new_solution_swap[j-1], new_solution_swap[j]] +\n                         distance_matrix_2[new_solution_swap[j], new_solution_swap[(j+1)%n]])\n            # Accept the swap if it improves both objectives\n            if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                new_solution = new_solution_swap\n\n    return new_solution\n\n",
        "score": [
            -0.8592689936939768,
            3.4557164311408997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a weighted combination of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Step 1: Edge insertion (randomly insert a node in a different position)\n        if n > 2:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or (j == (i + 1) % n):\n                j = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, j, new_solution[i])\n            new_solution = np.delete(new_solution, i if i < j else i + 1)\n\n        # Step 2: Node relocation (move a node to a better position)\n        if n > 2:\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            best_pos = 0\n            best_cost = float('inf')\n            for j in range(n - 1):\n                temp_solution = np.insert(new_solution, j, node)\n                cost1 = distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%(n-1)]]\n                cost2 = distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%(n-1)]]\n                total_cost = cost1 + cost2\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = j\n            new_solution = np.insert(new_solution, best_pos, node)\n\n        # Step 3: Novel swap-based operator (swap nodes that improve both objectives)\n        if n > 2:\n            i, j = np.random.randint(0, n, size=2)\n            while i == j:\n                i, j = np.random.randint(0, n, size=2)\n            # Calculate current cost of the edges involving i and j\n            current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            # Calculate new cost if i and j are swapped\n            new_solution_swap = new_solution.copy()\n            new_solution_swap[i], new_solution_swap[j] = new_solution_swap[j], new_solution_swap[i]\n            new_cost1 = (distance_matrix_1[new_solution_swap[i-1], new_solution_swap[i]] +\n                         distance_matrix_1[new_solution_swap[i], new_solution_swap[(i+1)%n]] +\n                         distance_matrix_1[new_solution_swap[j-1], new_solution_swap[j]] +\n                         distance_matrix_1[new_solution_swap[j], new_solution_swap[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution_swap[i-1], new_solution_swap[i]] +\n                         distance_matrix_2[new_solution_swap[i], new_solution_swap[(i+1)%n]] +\n                         distance_matrix_2[new_solution_swap[j-1], new_solution_swap[j]] +\n                         distance_matrix_2[new_solution_swap[j], new_solution_swap[(j+1)%n]])\n            # Accept the swap if it improves both objectives\n            if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                new_solution = new_solution_swap\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to get probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: choose between edge exchange or segment relocation\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment relocation (novel operator)\n        if n > 4:\n            seg_length = random.randint(2, min(5, n//2))\n            i = random.randint(0, n - seg_length - 1)\n            j = random.randint(i + seg_length, n - 1)\n            segment = new_solution[i:i+seg_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+seg_length:j], segment, new_solution[j:]])\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated (duplicate nodes)\"\n    assert len(new_solution) == n, \"Invalid solution generated (missing nodes)\"\n\n    return new_solution\n\n",
        "score": [
            -0.8793914844609254,
            0.47216272354125977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to get probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: choose between edge exchange or segment relocation\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment relocation (novel operator)\n        if n > 4:\n            seg_length = random.randint(2, min(5, n//2))\n            i = random.randint(0, n - seg_length - 1)\n            j = random.randint(i + seg_length, n - 1)\n            segment = new_solution[i:i+seg_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+seg_length:j], segment, new_solution[j:]])\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated (duplicate nodes)\"\n    assert len(new_solution) == n, \"Invalid solution generated (missing nodes)\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (Pareto front approximation)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to avoid bias towards one objective\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Select solutions with the lowest combined normalized objective\n    combined_obj = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(combined_obj)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel segment reversal: reverse a random segment and insert it elsewhere\n    segment_start, segment_end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[segment_start:segment_end]\n    new_solution = np.concatenate([\n        new_solution[:segment_start],\n        new_solution[segment_end:],\n        segment[::-1]\n    ])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if uniqueness is violated\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6669886962023869,
            0.5332496166229248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (Pareto front approximation)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to avoid bias towards one objective\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Select solutions with the lowest combined normalized objective\n    combined_obj = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(combined_obj)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel segment reversal: reverse a random segment and insert it elsewhere\n    segment_start, segment_end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[segment_start:segment_end]\n    new_solution = np.concatenate([\n        new_solution[:segment_start],\n        new_solution[segment_end:],\n        segment[::-1]\n    ])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if uniqueness is violated\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best but not the worst)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_candidates = archive_sorted[:max(2, len(archive) // 2)]  # Consider top half or top 2\n    selected = random.choice(selection_candidates)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt-style move\n    if random.random() < 0.5:\n        # Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply a more complex edge-swap\n        segment = new_solution[i:j+1]\n        if len(segment) > 1:\n            # Rotate segment by random amount\n            shift = random.randint(1, len(segment)-1)\n            segment = np.roll(segment, shift)\n            new_solution[i:j+1] = segment\n\n    # Apply novel edge-swap between j and k\n    if random.random() < 0.3:  # 30% chance for this operation\n        # Find the best possible swap between j and k in either objective space\n        current_cost = (distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]],\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Try swapping j and k\n        temp = new_solution[j]\n        new_solution[j] = new_solution[k]\n        new_solution[k] = temp\n\n        new_cost = (distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]],\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # If the swap doesn't improve both objectives, revert\n        if (new_cost[0] > current_cost[0] and new_cost[1] > current_cost[1]) or \\\n           (new_cost[0] > current_cost[0] + 1e-6 and new_cost[1] > current_cost[1] + 1e-6):\n            temp = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8453115080085645,
            0.4606984853744507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best but not the worst)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_candidates = archive_sorted[:max(2, len(archive) // 2)]  # Consider top half or top 2\n    selected = random.choice(selection_candidates)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt-style move\n    if random.random() < 0.5:\n        # Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply a more complex edge-swap\n        segment = new_solution[i:j+1]\n        if len(segment) > 1:\n            # Rotate segment by random amount\n            shift = random.randint(1, len(segment)-1)\n            segment = np.roll(segment, shift)\n            new_solution[i:j+1] = segment\n\n    # Apply novel edge-swap between j and k\n    if random.random() < 0.3:  # 30% chance for this operation\n        # Find the best possible swap between j and k in either objective space\n        current_cost = (distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]],\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Try swapping j and k\n        temp = new_solution[j]\n        new_solution[j] = new_solution[k]\n        new_solution[k] = temp\n\n        new_cost = (distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]],\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # If the swap doesn't improve both objectives, revert\n        if (new_cost[0] > current_cost[0] and new_cost[1] > current_cost[1]) or \\\n           (new_cost[0] > current_cost[0] + 1e-6 and new_cost[1] > current_cost[1] + 1e-6):\n            temp = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) for _, obj in archive]\n    min_score = min(scores)\n    max_score = max(scores)\n\n    # Normalize scores to [0, 1] range\n    if max_score != min_score:\n        normalized_scores = [(s - min_score) / (max_score - min_score) for s in scores]\n    else:\n        normalized_scores = [1.0 for _ in scores]\n\n    # Weighted random selection\n    selected_idx = random.choices(range(len(archive)), weights=normalized_scores, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Select two random segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments don't overlap\n    if (a <= c <= b) or (a <= d <= b):\n        c, d = sorted([max(a, b) + 1, min(c, d)])\n\n    # Step 2: Reverse one segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Insert the other segment\n    segment = new_solution[c:d+1]\n    new_solution = np.concatenate([\n        new_solution[:c],\n        new_solution[d+1:],\n        segment\n    ])\n\n    # Ensure the tour is valid (visits all nodes exactly once)\n    missing = set(range(n)) - set(new_solution)\n    extra = set(new_solution) - set(range(n))\n\n    if missing or extra:\n        # Recover feasibility by reinserting missing nodes\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.7558227904846727,
            0.6964260935783386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) for _, obj in archive]\n    min_score = min(scores)\n    max_score = max(scores)\n\n    # Normalize scores to [0, 1] range\n    if max_score != min_score:\n        normalized_scores = [(s - min_score) / (max_score - min_score) for s in scores]\n    else:\n        normalized_scores = [1.0 for _ in scores]\n\n    # Weighted random selection\n    selected_idx = random.choices(range(len(archive)), weights=normalized_scores, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Select two random segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments don't overlap\n    if (a <= c <= b) or (a <= d <= b):\n        c, d = sorted([max(a, b) + 1, min(c, d)])\n\n    # Step 2: Reverse one segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Insert the other segment\n    segment = new_solution[c:d+1]\n    new_solution = np.concatenate([\n        new_solution[:c],\n        new_solution[d+1:],\n        segment\n    ])\n\n    # Ensure the tour is valid (visits all nodes exactly once)\n    missing = set(range(n)) - set(new_solution)\n    extra = set(new_solution) - set(range(n))\n\n    if missing or extra:\n        # Recover feasibility by reinserting missing nodes\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost but not dominated)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = min(len(archive) - 1, int(len(archive) * 0.3))  # Select a middle solution for exploration\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt local search\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                # Calculate current and new distances for both objectives\n                current_dist1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n\n                current_dist2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n                # Check if swap improves both objectives\n                if (new_dist1 < current_dist1 and new_dist2 < current_dist2):\n                    # Perform the swap\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Apply novel edge-swap strategy\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        current_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        # Check if swap improves both objectives\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2):\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5068049380369407,
            8.256588578224182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost but not dominated)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = min(len(archive) - 1, int(len(archive) * 0.3))  # Select a middle solution for exploration\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt local search\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                # Calculate current and new distances for both objectives\n                current_dist1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n\n                current_dist2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n                # Check if swap improves both objectives\n                if (new_dist1 < current_dist1 and new_dist2 < current_dist2):\n                    # Perform the swap\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Apply novel edge-swap strategy\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        current_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        # Check if swap improves both objectives\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2):\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank (better solutions have higher chance)\n    ranks = [i for i in range(len(archive))]\n    selected_index = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Choose one of three local search operators randomly\n    operator = random.choice(['edge_insertion', 'node_relocation', 'swap_reorder'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], [new_solution[i]], new_solution[j+1:]])\n\n    elif operator == 'node_relocation':\n        # Relocate a random node to a new position\n        i = random.randint(0, len(new_solution)-1)\n        j = random.randint(0, len(new_solution)-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operator == 'swap_reorder':\n        # Perform a swap between two nodes and then reorder the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reorder the segment between i and j to minimize the sum of distances in both objectives\n        segment = new_solution[i:j+1]\n        if len(segment) > 2:\n            # Calculate the total cost for each permutation of the segment\n            permutations = []\n            for _ in range(min(10, len(segment))):  # Limit permutations to avoid excessive computation\n                perm = np.random.permutation(segment)\n                cost1 = sum(distance_matrix_1[perm[i-1], perm[i]] for i in range(len(perm)))\n                cost2 = sum(distance_matrix_2[perm[i-1], perm[i]] for i in range(len(perm)))\n                permutations.append((perm, cost1 + cost2))\n\n            # Select the permutation with the lowest total cost\n            best_perm = min(permutations, key=lambda x: x[1])[0]\n            new_solution[i:j+1] = best_perm\n\n    return new_solution\n\n",
        "score": [
            -0.9459662680752238,
            0.3233836889266968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank (better solutions have higher chance)\n    ranks = [i for i in range(len(archive))]\n    selected_index = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Choose one of three local search operators randomly\n    operator = random.choice(['edge_insertion', 'node_relocation', 'swap_reorder'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], [new_solution[i]], new_solution[j+1:]])\n\n    elif operator == 'node_relocation':\n        # Relocate a random node to a new position\n        i = random.randint(0, len(new_solution)-1)\n        j = random.randint(0, len(new_solution)-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operator == 'swap_reorder':\n        # Perform a swap between two nodes and then reorder the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reorder the segment between i and j to minimize the sum of distances in both objectives\n        segment = new_solution[i:j+1]\n        if len(segment) > 2:\n            # Calculate the total cost for each permutation of the segment\n            permutations = []\n            for _ in range(min(10, len(segment))):  # Limit permutations to avoid excessive computation\n                perm = np.random.permutation(segment)\n                cost1 = sum(distance_matrix_1[perm[i-1], perm[i]] for i in range(len(perm)))\n                cost2 = sum(distance_matrix_2[perm[i-1], perm[i]] for i in range(len(perm)))\n                permutations.append((perm, cost1 + cost2))\n\n            # Select the permutation with the lowest total cost\n            best_perm = min(permutations, key=lambda x: x[1])[0]\n            new_solution[i:j+1] = best_perm\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or showing potential for improvement\n    selected_solutions = []\n    for sol, obj in archive:\n        # Calculate the total cost for the solution\n        cost = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost += sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        selected_solutions.append((sol, obj, cost))\n\n    # Sort solutions by cost (lower is better) and select top 20% for random selection\n    selected_solutions.sort(key=lambda x: x[2])\n    top_k = max(1, len(selected_solutions) // 5)\n    candidates = selected_solutions[:top_k]\n\n    # Randomly select a solution from the top candidates\n    base_solution, _, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two distinct segments to swap or insert\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply a modified 2-opt swap between segments [a, b] and [c, d]\n    if a != c and b != d:\n        # Swap the segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if len(missing_nodes) > 0:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.4900121619077514,
            1.0056463479995728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or showing potential for improvement\n    selected_solutions = []\n    for sol, obj in archive:\n        # Calculate the total cost for the solution\n        cost = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost += sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        selected_solutions.append((sol, obj, cost))\n\n    # Sort solutions by cost (lower is better) and select top 20% for random selection\n    selected_solutions.sort(key=lambda x: x[2])\n    top_k = max(1, len(selected_solutions) // 5)\n    candidates = selected_solutions[:top_k]\n\n    # Randomly select a solution from the top candidates\n    base_solution, _, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two distinct segments to swap or insert\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply a modified 2-opt swap between segments [a, b] and [c, d]\n    if a != c and b != d:\n        # Swap the segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if len(missing_nodes) > 0:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 - normalized_objectives.mean(axis=1)\n    weights = weights / weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge exchange\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly select segments for modification\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Apply 3-opt-like operation\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    new_solution[c:d] = base_solution[c:d][::-1]\n\n    # Custom edge exchange: swap two random edges\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8250025254865719,
            0.4912867546081543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 - normalized_objectives.mean(axis=1)\n    weights = weights / weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge exchange\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly select segments for modification\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Apply 3-opt-like operation\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    new_solution[c:d] = base_solution[c:d][::-1]\n\n    # Custom edge exchange: swap two random edges\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Edge insertion (for a randomly selected edge)\n    a, b = random.sample(range(n), 2)\n    edge_a = (new_solution[a], new_solution[(a + 1) % n])\n    edge_b = (new_solution[b], new_solution[(b + 1) % n])\n\n    # Remove edges a and b\n    temp = new_solution.copy()\n    temp = np.delete(temp, a)\n    temp = np.delete(temp, b - 1 if b > a else b)\n\n    # Reinsert the edges in reverse order\n    insert_pos = random.randint(0, len(temp) - 1)\n    new_solution = np.insert(temp, insert_pos, [edge_b[1], edge_b[0]])\n\n    # Step 2: Segment relocation (for a randomly selected segment)\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment\n    temp = np.delete(new_solution, range(segment_start, segment_start + segment_length))\n\n    # Reinsert the segment at a random position\n    insert_pos = random.randint(0, len(temp) - 1)\n    new_solution = np.insert(temp, insert_pos, segment)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to a simple swap if feasibility is violated\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8352030237603719,
            0.08811593055725098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Edge insertion (for a randomly selected edge)\n    a, b = random.sample(range(n), 2)\n    edge_a = (new_solution[a], new_solution[(a + 1) % n])\n    edge_b = (new_solution[b], new_solution[(b + 1) % n])\n\n    # Remove edges a and b\n    temp = new_solution.copy()\n    temp = np.delete(temp, a)\n    temp = np.delete(temp, b - 1 if b > a else b)\n\n    # Reinsert the edges in reverse order\n    insert_pos = random.randint(0, len(temp) - 1)\n    new_solution = np.insert(temp, insert_pos, [edge_b[1], edge_b[0]])\n\n    # Step 2: Segment relocation (for a randomly selected segment)\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment\n    temp = np.delete(new_solution, range(segment_start, segment_start + segment_length))\n\n    # Reinsert the segment at a random position\n    insert_pos = random.randint(0, len(temp) - 1)\n    new_solution = np.insert(temp, insert_pos, segment)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to a simple swap if feasibility is violated\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Edge insertion (for a randomly selected edge)\n    a, b = random.sample(range(n), 2)\n    edge_a = (new_solution[a], new_solution[(a + 1) % n])\n    edge_b = (new_solution[b], new_solution[(b + 1) % n])\n\n    # Remove edges a and b\n    temp = new_solution.copy()\n    temp = np.delete(temp, a)\n    temp = np.delete(temp, b - 1 if b > a else b)\n\n    # Reinsert the edges in reverse order\n    insert_pos = random.randint(0, len(temp) - 1)\n    new_solution = np.insert(temp, insert_pos, [edge_b[1], edge_b[0]])\n\n    # Step 2: Segment relocation (for a randomly selected segment)\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment\n    temp = np.delete(new_solution, range(segment_start, segment_start + segment_length))\n\n    # Reinsert the segment at a random position\n    insert_pos = random.randint(0, len(temp) - 1)\n    new_solution = np.insert(temp, insert_pos, segment)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to a simple swap if feasibility is violated\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8352030237603719,
            0.08811593055725098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Edge insertion (for a randomly selected edge)\n    a, b = random.sample(range(n), 2)\n    edge_a = (new_solution[a], new_solution[(a + 1) % n])\n    edge_b = (new_solution[b], new_solution[(b + 1) % n])\n\n    # Remove edges a and b\n    temp = new_solution.copy()\n    temp = np.delete(temp, a)\n    temp = np.delete(temp, b - 1 if b > a else b)\n\n    # Reinsert the edges in reverse order\n    insert_pos = random.randint(0, len(temp) - 1)\n    new_solution = np.insert(temp, insert_pos, [edge_b[1], edge_b[0]])\n\n    # Step 2: Segment relocation (for a randomly selected segment)\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment\n    temp = np.delete(new_solution, range(segment_start, segment_start + segment_length))\n\n    # Reinsert the segment at a random position\n    insert_pos = random.randint(0, len(temp) - 1)\n    new_solution = np.insert(temp, insert_pos, segment)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to a simple swap if feasibility is violated\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for other_sol, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 <= cost2) and (other_cost1 < cost1 or other_cost2 < cost2):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, (cost1, cost2)))\n\n    if not non_dominated:\n        # If all solutions are non-dominated, pick a random one\n        base_solution, _ = random.choice(archive)\n    else:\n        # Pick a solution with high variance in objectives (indicating potential for improvement)\n        base_solution, _ = max(non_dominated, key=lambda x: abs(x[1][0] - x[1][1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:\n        # Randomized 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Novel edge-swap operator: swap two edges considering both objectives\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n-1)) % n\n        k = (j + random.randint(1, n-1)) % n\n\n        # Calculate the change in both objectives\n        def calculate_change(sol, i, j, k):\n            old_edges = [\n                (sol[i-1], sol[i]),\n                (sol[j-1], sol[j]),\n                (sol[k-1], sol[k])\n            ]\n            new_edges = [\n                (sol[i-1], sol[j]),\n                (sol[j-1], sol[i]),\n                (sol[k-1], sol[k])\n            ]\n\n            delta_cost1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in old_edges)\n            delta_cost2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in old_edges)\n            return delta_cost1, delta_cost2\n\n        delta_cost1, delta_cost2 = calculate_change(new_solution, i, j, k)\n        if delta_cost1 < 0 or delta_cost2 < 0:\n            # Apply the swap if it improves at least one objective\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.33134122405856226,
            0.5977521538734436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for other_sol, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 <= cost2) and (other_cost1 < cost1 or other_cost2 < cost2):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, (cost1, cost2)))\n\n    if not non_dominated:\n        # If all solutions are non-dominated, pick a random one\n        base_solution, _ = random.choice(archive)\n    else:\n        # Pick a solution with high variance in objectives (indicating potential for improvement)\n        base_solution, _ = max(non_dominated, key=lambda x: abs(x[1][0] - x[1][1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:\n        # Randomized 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Novel edge-swap operator: swap two edges considering both objectives\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n-1)) % n\n        k = (j + random.randint(1, n-1)) % n\n\n        # Calculate the change in both objectives\n        def calculate_change(sol, i, j, k):\n            old_edges = [\n                (sol[i-1], sol[i]),\n                (sol[j-1], sol[j]),\n                (sol[k-1], sol[k])\n            ]\n            new_edges = [\n                (sol[i-1], sol[j]),\n                (sol[j-1], sol[i]),\n                (sol[k-1], sol[k])\n            ]\n\n            delta_cost1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in old_edges)\n            delta_cost2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in old_edges)\n            return delta_cost1, delta_cost2\n\n        delta_cost1, delta_cost2 = calculate_change(new_solution, i, j, k)\n        if delta_cost1 < 0 or delta_cost2 < 0:\n            # Apply the swap if it improves at least one objective\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Edge exchange (similar to 3-opt but more flexible)\n    i, j, k = sorted(random.sample(range(n), 3))\n    # Try different configurations of edge exchange\n    options = [\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]])\n    ]\n\n    # Evaluate all options and select the best one based on both objectives\n    best_option = new_solution\n    best_cost = (np.inf, np.inf)\n\n    for option in options:\n        cost1 = sum(distance_matrix_1[option[i-1], option[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[option[i-1], option[i]] for i in range(n))\n        if (cost1, cost2) < best_cost:\n            best_cost = (cost1, cost2)\n            best_option = option.copy()\n\n    new_solution = best_option\n\n    # Step 2: Node insertion (for further refinement)\n    if n > 4:\n        # Select a random node and try to reinsert it in a better position\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        candidate_solution = np.delete(new_solution, node_pos)\n\n        # Find the best insertion position\n        best_insert_pos = 0\n        best_insert_cost = (np.inf, np.inf)\n\n        for pos in range(n-1):\n            temp_solution = np.insert(candidate_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            if (cost1, cost2) < best_insert_cost:\n                best_insert_cost = (cost1, cost2)\n                best_insert_pos = pos\n\n        new_solution = np.insert(candidate_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8886192461498968,
            3.325692355632782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Edge exchange (similar to 3-opt but more flexible)\n    i, j, k = sorted(random.sample(range(n), 3))\n    # Try different configurations of edge exchange\n    options = [\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]])\n    ]\n\n    # Evaluate all options and select the best one based on both objectives\n    best_option = new_solution\n    best_cost = (np.inf, np.inf)\n\n    for option in options:\n        cost1 = sum(distance_matrix_1[option[i-1], option[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[option[i-1], option[i]] for i in range(n))\n        if (cost1, cost2) < best_cost:\n            best_cost = (cost1, cost2)\n            best_option = option.copy()\n\n    new_solution = best_option\n\n    # Step 2: Node insertion (for further refinement)\n    if n > 4:\n        # Select a random node and try to reinsert it in a better position\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        candidate_solution = np.delete(new_solution, node_pos)\n\n        # Find the best insertion position\n        best_insert_pos = 0\n        best_insert_cost = (np.inf, np.inf)\n\n        for pos in range(n-1):\n            temp_solution = np.insert(candidate_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            if (cost1, cost2) < best_insert_cost:\n                best_insert_cost = (cost1, cost2)\n                best_insert_pos = pos\n\n        new_solution = np.insert(candidate_solution, best_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combination of 3-opt and random swap\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Choose between 3-opt and random swap based on a probability\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Select three random edges to perform 3-opt\n        i, j, k = sorted(random.sample(range(1, N-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n        # Reconnect the segments in a different order\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:  # 30% chance for random swap\n        # Select two random nodes to swap\n        i, j = random.sample(range(1, N-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (closed loop)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9071745379615747,
            0.0877755880355835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combination of 3-opt and random swap\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Choose between 3-opt and random swap based on a probability\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Select three random edges to perform 3-opt\n        i, j, k = sorted(random.sample(range(1, N-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n        # Reconnect the segments in a different order\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:  # 30% chance for random swap\n        # Select two random nodes to swap\n        i, j = random.sample(range(1, N-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (closed loop)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combination of 3-opt and random swap\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Choose between 3-opt and random swap based on a probability\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Select three random edges to perform 3-opt\n        i, j, k = sorted(random.sample(range(1, N-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n        # Reconnect the segments in a different order\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:  # 30% chance for random swap\n        # Select two random nodes to swap\n        i, j = random.sample(range(1, N-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (closed loop)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9071745379615747,
            0.0877755880355835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combination of 3-opt and random swap\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Choose between 3-opt and random swap based on a probability\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Select three random edges to perform 3-opt\n        i, j, k = sorted(random.sample(range(1, N-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n        # Reconnect the segments in a different order\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:  # 30% chance for random swap\n        # Select two random nodes to swap\n        i, j = random.sample(range(1, N-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (closed loop)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with a bias towards lower-cost solutions\n    # Normalize the objectives and select with a probability proportional to (1 / (cost1 + cost2))\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probabilities\n    costs = [cost1 + cost2 for cost1, cost2 in objectives]\n    total_cost = sum(costs)\n    if total_cost == 0:\n        probabilities = [1.0 / len(solutions) for _ in solutions]\n    else:\n        probabilities = [(1.0 / cost) / sum(1.0 / c for c in costs) for cost in costs]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # With 50% probability, reverse the segment or swap edges\n    if random.random() < 0.5:\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        # Swap edges within the segment\n        if segment_length >= 3:\n            # Perform a 3-opt-like swap\n            i, j, k = sorted(random.sample(range(start, end), 3))\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Simple swap for small segments\n            if segment_length == 2:\n                new_solution[start], new_solution[start+1] = new_solution[start+1], new_solution[start]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.861071042759683,
            0.8785647749900818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with a bias towards lower-cost solutions\n    # Normalize the objectives and select with a probability proportional to (1 / (cost1 + cost2))\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probabilities\n    costs = [cost1 + cost2 for cost1, cost2 in objectives]\n    total_cost = sum(costs)\n    if total_cost == 0:\n        probabilities = [1.0 / len(solutions) for _ in solutions]\n    else:\n        probabilities = [(1.0 / cost) / sum(1.0 / c for c in costs) for cost in costs]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # With 50% probability, reverse the segment or swap edges\n    if random.random() < 0.5:\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        # Swap edges within the segment\n        if segment_length >= 3:\n            # Perform a 3-opt-like swap\n            i, j, k = sorted(random.sample(range(start, end), 3))\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Simple swap for small segments\n            if segment_length == 2:\n                new_solution[start], new_solution[start+1] = new_solution[start+1], new_solution[start]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 3-opt with dynamic edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create three possible 3-opt moves and evaluate them\n    options = [\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j][::-1], new_solution[i:k], new_solution[j:]]),\n        np.concatenate([new_solution[:j], new_solution[i:k][::-1], new_solution[j:i], new_solution[k:]])\n    ]\n\n    # Evaluate each option based on both objectives\n    best_option = None\n    best_score = float('inf')\n\n    for option in options:\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[option[i-1], option[i]] for i in range(1, n)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[i-1], option[i]] for i in range(1, n)) + distance_matrix_2[option[-1], option[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Dynamic edge selection: potentially swap nodes with high cross-objective improvement potential\n    if random.random() < 0.3:  # 30% chance to perform dynamic edge selection\n        # Find nodes with high cross-objective improvement potential\n        improvement_potential = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate current costs\n            current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Find potential neighbors with better cross-objective tradeoff\n            for j in range(n):\n                if j == i or j == i-1 or j == (i+1)%n:\n                    continue\n\n                neighbor = new_solution[j]\n                next_neighbor = new_solution[(j+1)%n]\n\n                # Calculate new costs if we swap node and neighbor\n                new_cost1 = (distance_matrix_1[prev_node, neighbor] + distance_matrix_1[neighbor, next_node] +\n                             distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, next_neighbor])\n                new_cost2 = (distance_matrix_2[prev_node, neighbor] + distance_matrix_2[neighbor, next_node] +\n                             distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, next_neighbor])\n\n                # Calculate improvement in both objectives\n                improvement1 = current_cost1 - new_cost1\n                improvement2 = current_cost2 - new_cost2\n\n                # If there's improvement in both objectives, consider this swap\n                if improvement1 > 0 and improvement2 > 0:\n                    improvement_potential.append((i, j, improvement1 + improvement2))\n\n        # If there are potential improvements, perform the best one\n        if improvement_potential:\n            best_i, best_j, _ = max(improvement_potential, key=lambda x: x[2])\n            # Perform the swap\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7169512804471123,
            2.1834300756454468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 3-opt with dynamic edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create three possible 3-opt moves and evaluate them\n    options = [\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j][::-1], new_solution[i:k], new_solution[j:]]),\n        np.concatenate([new_solution[:j], new_solution[i:k][::-1], new_solution[j:i], new_solution[k:]])\n    ]\n\n    # Evaluate each option based on both objectives\n    best_option = None\n    best_score = float('inf')\n\n    for option in options:\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[option[i-1], option[i]] for i in range(1, n)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[i-1], option[i]] for i in range(1, n)) + distance_matrix_2[option[-1], option[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Dynamic edge selection: potentially swap nodes with high cross-objective improvement potential\n    if random.random() < 0.3:  # 30% chance to perform dynamic edge selection\n        # Find nodes with high cross-objective improvement potential\n        improvement_potential = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate current costs\n            current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Find potential neighbors with better cross-objective tradeoff\n            for j in range(n):\n                if j == i or j == i-1 or j == (i+1)%n:\n                    continue\n\n                neighbor = new_solution[j]\n                next_neighbor = new_solution[(j+1)%n]\n\n                # Calculate new costs if we swap node and neighbor\n                new_cost1 = (distance_matrix_1[prev_node, neighbor] + distance_matrix_1[neighbor, next_node] +\n                             distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, next_neighbor])\n                new_cost2 = (distance_matrix_2[prev_node, neighbor] + distance_matrix_2[neighbor, next_node] +\n                             distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, next_neighbor])\n\n                # Calculate improvement in both objectives\n                improvement1 = current_cost1 - new_cost1\n                improvement2 = current_cost2 - new_cost2\n\n                # If there's improvement in both objectives, consider this swap\n                if improvement1 > 0 and improvement2 > 0:\n                    improvement_potential.append((i, j, improvement1 + improvement2))\n\n        # If there are potential improvements, perform the best one\n        if improvement_potential:\n            best_i, best_j, _ = max(improvement_potential, key=lambda x: x[2])\n            # Perform the swap\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based perturbation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt on a random segment\n    if n >= 5:\n        a, b, c = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:n-1]\n\n        # Try all possible 3-opt configurations\n        options = [\n            np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3[::-1], new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment2[::-1], segment1[::-1], segment3[::-1], new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment3[::-1], segment2[::-1], new_solution[n-1:]])\n        ]\n\n        # Evaluate all options considering both objectives\n        best_option = new_solution\n        best_score = float('inf')\n\n        for option in options:\n            total_cost = 0\n            for i in range(n):\n                total_cost += distance_matrix_1[option[i-1], option[i]] + distance_matrix_2[option[i-1], option[i]]\n            if total_cost < best_score:\n                best_score = total_cost\n                best_option = option\n\n        new_solution = best_option\n\n    # Segment-based perturbation: randomly reverse a segment of the tour\n    if n >= 3:\n        seg_start = random.randint(1, n-2)\n        seg_end = random.randint(seg_start, n-1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.824551985842922,
            0.7575047612190247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment-based perturbation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 3-opt on a random segment\n    if n >= 5:\n        a, b, c = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:n-1]\n\n        # Try all possible 3-opt configurations\n        options = [\n            np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3[::-1], new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment2[::-1], segment1[::-1], segment3[::-1], new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment3[::-1], segment2[::-1], new_solution[n-1:]])\n        ]\n\n        # Evaluate all options considering both objectives\n        best_option = new_solution\n        best_score = float('inf')\n\n        for option in options:\n            total_cost = 0\n            for i in range(n):\n                total_cost += distance_matrix_1[option[i-1], option[i]] + distance_matrix_2[option[i-1], option[i]]\n            if total_cost < best_score:\n                best_score = total_cost\n                best_option = option\n\n        new_solution = best_option\n\n    # Segment-based perturbation: randomly reverse a segment of the tour\n    if n >= 3:\n        seg_start = random.randint(1, n-2)\n        seg_end = random.randint(seg_start, n-1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (or use other criteria)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best but has room for improvement\n        candidate_idx = min(1, len(archive_sorted) - 1)  # Avoid selecting the best solution\n        base_solution = archive_sorted[candidate_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt (reverse the middle segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Novel edge-swap heuristic: swap edges based on distance improvement in both objectives\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i != j and j != (i + 1) % n:\n            # Calculate current and potential new edges\n            current_edges = [(new_solution[i], new_solution[(i+1)%n]),\n                            (new_solution[j], new_solution[(j+1)%n])]\n            new_edges = [(new_solution[i], new_solution[j]),\n                         (new_solution[(i+1)%n], new_solution[(j+1)%n])]\n\n            # Calculate cost change in both objectives\n            cost_change_1 = (distance_matrix_1[current_edges[0][0], current_edges[0][1]] +\n                           distance_matrix_1[current_edges[1][0], current_edges[1][1]] -\n                           distance_matrix_1[new_edges[0][0], new_edges[0][1]] -\n                           distance_matrix_1[new_edges[1][0], new_edges[1][1]])\n\n            cost_change_2 = (distance_matrix_2[current_edges[0][0], current_edges[0][1]] +\n                           distance_matrix_2[current_edges[1][0], current_edges[1][1]] -\n                           distance_matrix_2[new_edges[0][0], new_edges[0][1]] -\n                           distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n            # If improvement in at least one objective, accept the swap\n            if cost_change_1 < 0 or cost_change_2 < 0:\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7485551552505849,
            0.4733925461769104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (or use other criteria)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best but has room for improvement\n        candidate_idx = min(1, len(archive_sorted) - 1)  # Avoid selecting the best solution\n        base_solution = archive_sorted[candidate_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt (reverse the middle segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Novel edge-swap heuristic: swap edges based on distance improvement in both objectives\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i != j and j != (i + 1) % n:\n            # Calculate current and potential new edges\n            current_edges = [(new_solution[i], new_solution[(i+1)%n]),\n                            (new_solution[j], new_solution[(j+1)%n])]\n            new_edges = [(new_solution[i], new_solution[j]),\n                         (new_solution[(i+1)%n], new_solution[(j+1)%n])]\n\n            # Calculate cost change in both objectives\n            cost_change_1 = (distance_matrix_1[current_edges[0][0], current_edges[0][1]] +\n                           distance_matrix_1[current_edges[1][0], current_edges[1][1]] -\n                           distance_matrix_1[new_edges[0][0], new_edges[0][1]] -\n                           distance_matrix_1[new_edges[1][0], new_edges[1][1]])\n\n            cost_change_2 = (distance_matrix_2[current_edges[0][0], current_edges[0][1]] +\n                           distance_matrix_2[current_edges[1][0], current_edges[1][1]] -\n                           distance_matrix_2[new_edges[0][0], new_edges[0][1]] -\n                           distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n            # If improvement in at least one objective, accept the swap\n            if cost_change_1 < 0 or cost_change_2 < 0:\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Prefer solutions with higher costs (as they may have room for improvement)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 2. Randomly insert a node elsewhere\n    if n > 2:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8435472073990586,
            0.540663480758667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Prefer solutions with higher costs (as they may have room for improvement)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 2. Randomly insert a node elsewhere\n    if n > 2:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge swapping and segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # Edge swapping (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment reordering (move a random segment to a different position)\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8060214318674908,
            0.5410583019256592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge swapping and segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # Edge swapping (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment reordering (move a random segment to a different position)\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Randomly weigh the objectives\n    best_idx = min(range(len(archive)), key=lambda i: weights * archive[i][1][0] + (1 - weights) * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a biased random swap\n    if n >= 3:\n        # Randomly select 3 distinct positions\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n        # Apply 3-opt-like operation with a twist\n        if np.random.rand() < 0.7:  # 70% chance to do a 3-opt\n            # Create three segments and reverse one of them\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]\n        else:  # 30% chance to do a biased swap\n            # Swap nodes with a bias towards improving the worse objective\n            cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            if cost1 > cost2:\n                # More likely to swap nodes that would improve the first objective\n                if np.random.rand() < 0.6:\n                    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n            else:\n                # More likely to swap nodes that would improve the second objective\n                if np.random.rand() < 0.6:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.964133117396932,
            0.4750322699546814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Randomly weigh the objectives\n    best_idx = min(range(len(archive)), key=lambda i: weights * archive[i][1][0] + (1 - weights) * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a biased random swap\n    if n >= 3:\n        # Randomly select 3 distinct positions\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n\n        # Apply 3-opt-like operation with a twist\n        if np.random.rand() < 0.7:  # 70% chance to do a 3-opt\n            # Create three segments and reverse one of them\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]\n        else:  # 30% chance to do a biased swap\n            # Swap nodes with a bias towards improving the worse objective\n            cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            if cost1 > cost2:\n                # More likely to swap nodes that would improve the first objective\n                if np.random.rand() < 0.6:\n                    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n            else:\n                # More likely to swap nodes that would improve the second objective\n                if np.random.rand() < 0.6:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    best_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt-like move: reverse segments between i-j and j-k\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j+1:k+1] = np.flip(new_solution[j+1:k+1])\n\n    # Novel segment reversal: reverse a segment and insert it elsewhere\n    segment_length = np.random.randint(2, min(5, n//2))  # Random segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Remove the segment and insert it at a random position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6929270633070448,
            0.4749707579612732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    best_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt-like move: reverse segments between i-j and j-k\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j+1:k+1] = np.flip(new_solution[j+1:k+1])\n\n    # Novel segment reversal: reverse a segment and insert it elsewhere\n    segment_length = np.random.randint(2, min(5, n//2))  # Random segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Remove the segment and insert it at a random position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest total cost)\n    costs = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if (i < k < j < l) or (k < i < l < j):\n        # Reverse the second segment\n        new_solution[k:l] = new_solution[k:l][::-1]\n    else:\n        # Reverse both segments\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # Fallback to a simple swap if the above operation fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8929716863910838,
            0.4987725615501404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest total cost)\n    costs = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if (i < k < j < l) or (k < i < l < j):\n        # Reverse the second segment\n        new_solution[k:l] = new_solution[k:l][::-1]\n    else:\n        # Reverse both segments\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # Fallback to a simple swap if the above operation fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives in descending order\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select the top 20% of solutions\n        top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swapping heuristic\n    n = len(new_solution)\n    if n > 4:\n        # 3-opt: randomly select three edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a new order\n        new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n        new_solution = np.concatenate(new_order)\n\n        # Custom edge-swapping heuristic: swap edges based on both distance matrices\n        if random.random() < 0.5:\n            a, b = sorted(random.sample(range(n), 2))\n            cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n            cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n            cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n            cost2_after = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n            # Accept swap if it improves at least one objective\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7724298015449271,
            0.45904111862182617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives in descending order\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select the top 20% of solutions\n        top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swapping heuristic\n    n = len(new_solution)\n    if n > 4:\n        # 3-opt: randomly select three edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a new order\n        new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n        new_solution = np.concatenate(new_order)\n\n        # Custom edge-swapping heuristic: swap edges based on both distance matrices\n        if random.random() < 0.5:\n            a, b = sorted(random.sample(range(n), 2))\n            cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n            cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n            cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n            cost2_after = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n            # Accept swap if it improves at least one objective\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Select the solution with the highest sum of objectives (indicating room for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt and a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three non-consecutive indices to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt: reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel segment inversion: invert a small segment to explore new neighborhoods\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, min(seg_start + 5, n))  # Invert a small segment (up to 5 nodes)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8109369500977057,
            0.5211840271949768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Select the solution with the highest sum of objectives (indicating room for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt and a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three non-consecutive indices to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt: reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel segment inversion: invert a small segment to explore new neighborhoods\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, min(seg_start + 5, n))  # Invert a small segment (up to 5 nodes)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs] if max_cost != min_cost else [1.0 for _ in costs]\n    selected_idx = random.choices(range(len(archive)), weights=normalized_costs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (like a generalized 2-opt)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Novel edge-swap mechanism (avoids simple 2-opt)\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Swap edges between nodes i and j\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(set(new_solution)) != n:\n        # If duplicates exist, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7667192930928642,
            0.4722598195075989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs] if max_cost != min_cost else [1.0 for _ in costs]\n    selected_idx = random.choices(range(len(archive)), weights=normalized_costs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (like a generalized 2-opt)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Novel edge-swap mechanism (avoids simple 2-opt)\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Swap edges between nodes i and j\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(set(new_solution)) != n:\n        # If duplicates exist, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with higher costs in either objective space\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Edge exchange (similar to 2-opt but with a twist)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Segment rotation operator (novelty)\n    if n > 4:\n        segment_length = random.randint(2, min(5, n//3))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = random.randint(1, segment_length-1)\n        new_solution[start:start+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the base solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8530853750327845,
            0.49838632345199585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with higher costs in either objective space\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Edge exchange (similar to 2-opt but with a twist)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Segment rotation operator (novelty)\n    if n > 4:\n        segment_length = random.randint(2, min(5, n//3))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = random.randint(1, segment_length-1)\n        new_solution[start:start+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the base solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select the solution with the highest total cost (sum of both objectives)\n    costs = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: Combine 3-opt with a novel edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Perform 3-opt-like move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel edge swap: swap edges between segments to improve both objectives\n    # This is a heuristic that tries to balance both objectives\n    if random.random() < 0.5:\n        # Calculate current costs\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n\n        # Try swapping edges to improve both objectives\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            a, b = random.sample(range(1, n), 2)\n            temp_sol = new_solution.copy()\n            temp_sol[a], temp_sol[b] = temp_sol[b], temp_sol[a]\n            new_cost1, new_cost2 = calculate_cost(temp_sol)\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_sol\n                current_cost1, current_cost2 = new_cost1, new_cost2\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7921741499266349,
            0.5695735216140747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select the solution with the highest total cost (sum of both objectives)\n    costs = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: Combine 3-opt with a novel edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Perform 3-opt-like move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel edge swap: swap edges between segments to improve both objectives\n    # This is a heuristic that tries to balance both objectives\n    if random.random() < 0.5:\n        # Calculate current costs\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n\n        # Try swapping edges to improve both objectives\n        for _ in range(10):  # Limited attempts to avoid excessive computation\n            a, b = random.sample(range(1, n), 2)\n            temp_sol = new_solution.copy()\n            temp_sol[a], temp_sol[b] = temp_sol[b], temp_sol[a]\n            new_cost1, new_cost2 = calculate_cost(temp_sol)\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_sol\n                current_cost1, current_cost2 = new_cost1, new_cost2\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a biased edge swap\n    for _ in range(10):  # Number of attempts\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Create candidate solutions\n        candidates = [\n            new_solution.copy(),  # Original\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),  # 2-opt\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[k:]]),  # 3-opt\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),  # Segment swap\n            np.concatenate([new_solution[:i], new_solution[k:j:-1], new_solution[j:k], new_solution[i:]]),  # Biased swap\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            if len(set(candidate)) != n:  # Ensure validity\n                continue\n\n            # Calculate total distance for both objectives\n            total_dist1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            total_dist2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n            # Simple weighted sum for selection\n            score = total_dist1 + total_dist2\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7307051115949167,
            2.7117926478385925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a biased edge swap\n    for _ in range(10):  # Number of attempts\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Create candidate solutions\n        candidates = [\n            new_solution.copy(),  # Original\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),  # 2-opt\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[k:]]),  # 3-opt\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),  # Segment swap\n            np.concatenate([new_solution[:i], new_solution[k:j:-1], new_solution[j:k], new_solution[i:]]),  # Biased swap\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            if len(set(candidate)) != n:  # Ensure validity\n                continue\n\n            # Calculate total distance for both objectives\n            total_dist1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            total_dist2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n            # Simple weighted sum for selection\n            score = total_dist1 + total_dist2\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum = more potential)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions and pick one randomly\n        top_solutions = archive_sorted[:max(1, int(0.3 * len(archive)))]\n        selected_idx = np.random.randint(0, len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Step 1: Edge insertion (for diversification)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Remove node at position i and insert it after position j\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Step 2: Novel segment reversal (for intensification)\n    # Select a random segment and reverse it, but only if it improves the solution quality\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 2, n)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[segment_start-1], new_solution[segment_start]] + \\\n                     distance_matrix_1[new_solution[segment_end-1], new_solution[segment_end]]\n    current_cost2 = distance_matrix_2[new_solution[segment_start-1], new_solution[segment_start]] + \\\n                     distance_matrix_2[new_solution[segment_end-1], new_solution[segment_end]]\n\n    reversed_segment = new_solution[segment_start:segment_end][::-1]\n    new_cost1 = distance_matrix_1[new_solution[segment_start-1], reversed_segment[0]] + \\\n                distance_matrix_1[reversed_segment[-1], new_solution[segment_end]]\n    new_cost2 = distance_matrix_2[new_solution[segment_start-1], reversed_segment[0]] + \\\n                distance_matrix_2[reversed_segment[-1], new_solution[segment_end]]\n\n    # Only reverse if it improves at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            reversed_segment,\n            new_solution[segment_end:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9759720401130414,
            0.5207630395889282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum = more potential)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions and pick one randomly\n        top_solutions = archive_sorted[:max(1, int(0.3 * len(archive)))]\n        selected_idx = np.random.randint(0, len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Step 1: Edge insertion (for diversification)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Remove node at position i and insert it after position j\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Step 2: Novel segment reversal (for intensification)\n    # Select a random segment and reverse it, but only if it improves the solution quality\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 2, n)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[segment_start-1], new_solution[segment_start]] + \\\n                     distance_matrix_1[new_solution[segment_end-1], new_solution[segment_end]]\n    current_cost2 = distance_matrix_2[new_solution[segment_start-1], new_solution[segment_start]] + \\\n                     distance_matrix_2[new_solution[segment_end-1], new_solution[segment_end]]\n\n    reversed_segment = new_solution[segment_start:segment_end][::-1]\n    new_cost1 = distance_matrix_1[new_solution[segment_start-1], reversed_segment[0]] + \\\n                distance_matrix_1[reversed_segment[-1], new_solution[segment_end]]\n    new_cost2 = distance_matrix_2[new_solution[segment_start-1], reversed_segment[0]] + \\\n                distance_matrix_2[reversed_segment[-1], new_solution[segment_end]]\n\n    # Only reverse if it improves at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            reversed_segment,\n            new_solution[segment_end:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: sum(x[1]))  # Select the solution with the lowest combined cost\n    base_solution = selected[0][0].copy()\n\n    # Hybrid local search strategy: 3-opt with biased edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment between i and j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment between j and k\n\n    # Verify feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7134289365071688,
            0.48366934061050415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: sum(x[1]))  # Select the solution with the lowest combined cost\n    base_solution = selected[0][0].copy()\n\n    # Hybrid local search strategy: 3-opt with biased edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment between i and j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment between j and k\n\n    # Verify feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 distinct segments to perform 3-opt\n    indices = np.random.choice(range(1, n-1), size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Perform 3-opt by reversing segments\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Novel edge-swap strategy: swap edges between two random nodes\n    a, b = np.random.choice(range(1, n-1), size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.89608896572661,
            0.5106065273284912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 distinct segments to perform 3-opt\n    indices = np.random.choice(range(1, n-1), size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Perform 3-opt by reversing segments\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Novel edge-swap strategy: swap edges between two random nodes\n    a, b = np.random.choice(range(1, n-1), size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection probabilities based on Pareto dominance and objective values\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Assign higher probability to solutions with lower objective values\n    selection_probs = 1.0 / (1.0 + np.sum(normalized_obj, axis=1))\n    selection_probs /= np.sum(selection_probs)\n\n    # Select a base solution\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with a high probability\n    if random.random() < 0.7:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the middle segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the last segment\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        # Custom edge insertion: remove a random edge and reinsert it\n        i = random.randint(0, n-2)\n        node = new_solution[i]\n        # Remove the edge (i, i+1)\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        # Find the best position to reinsert the node\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n        # Reinsert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8470958174759124,
            1.3708592653274536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection probabilities based on Pareto dominance and objective values\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Assign higher probability to solutions with lower objective values\n    selection_probs = 1.0 / (1.0 + np.sum(normalized_obj, axis=1))\n    selection_probs /= np.sum(selection_probs)\n\n    # Select a base solution\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with a high probability\n    if random.random() < 0.7:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the middle segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the last segment\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        # Custom edge insertion: remove a random edge and reinsert it\n        i = random.randint(0, n-2)\n        node = new_solution[i]\n        # Remove the edge (i, i+1)\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        # Find the best position to reinsert the node\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n        # Reinsert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not too diverse)\n    archive_solutions = [sol[0] for sol in archive]\n    archive_objectives = [sol[1] for sol in archive]\n\n    # Calculate diversity of each solution (simplified measure)\n    diversity = [np.sum(np.abs(np.diff(sol))) for sol in archive_solutions]\n    avg_diversity = np.mean(diversity)\n    selected_indices = [i for i, d in enumerate(diversity) if d <= avg_diversity]\n\n    if not selected_indices:\n        selected_indices = list(range(len(archive_solutions)))\n\n    selected_idx = random.choice(selected_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: segment swap + edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to swap\n    segment_length = min(5, n // 2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract the segment and reverse it\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # Edge insertion: insert a random node in a random position\n    if n > 2:\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility: remove duplicates and ensure all nodes are present\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for missing in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, missing)\n\n    # Trim to original length if necessary\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8584057473369355,
            0.4585214853286743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not too diverse)\n    archive_solutions = [sol[0] for sol in archive]\n    archive_objectives = [sol[1] for sol in archive]\n\n    # Calculate diversity of each solution (simplified measure)\n    diversity = [np.sum(np.abs(np.diff(sol))) for sol in archive_solutions]\n    avg_diversity = np.mean(diversity)\n    selected_indices = [i for i, d in enumerate(diversity) if d <= avg_diversity]\n\n    if not selected_indices:\n        selected_indices = list(range(len(archive_solutions)))\n\n    selected_idx = random.choice(selected_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: segment swap + edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to swap\n    segment_length = min(5, n // 2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract the segment and reverse it\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # Edge insertion: insert a random node in a random position\n    if n > 2:\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility: remove duplicates and ensure all nodes are present\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for missing in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, missing)\n\n    # Trim to original length if necessary\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower costs\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / (costs + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Number of local search iterations\n        # Edge inversion (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Node relinking (swap nodes with a bias towards improving both objectives)\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Biased random walk (small perturbation to escape local optima)\n        if random.random() < 0.3:\n            k = random.randint(1, min(3, n-1))\n            segment = new_solution[-k:]\n            new_solution = np.concatenate([segment, new_solution[:-k]])\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7812875734003969,
            0.48243677616119385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower costs\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / (costs + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Number of local search iterations\n        # Edge inversion (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Node relinking (swap nodes with a bias towards improving both objectives)\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Biased random walk (small perturbation to escape local optima)\n        if random.random() < 0.3:\n            k = random.randint(1, min(3, n-1))\n            segment = new_solution[-k:]\n            new_solution = np.concatenate([segment, new_solution[:-k]])\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a bias towards those with lower costs\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a random swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt (select three random edges and reconnect them in a different way)\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create a new segment by reversing the middle part\n        segment = new_solution[i:j+1]\n        new_segment = np.concatenate([segment[:1], segment[j-i:][::-1], segment[1:j-i]])\n        new_solution[i:j+1] = new_segment\n\n    # Apply a random swap to further diversify\n    if n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7813925817417358,
            0.44559353590011597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a bias towards those with lower costs\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a random swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt (select three random edges and reconnect them in a different way)\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create a new segment by reversing the middle part\n        segment = new_solution[i:j+1]\n        new_segment = np.concatenate([segment[:1], segment[j-i:][::-1], segment[1:j-i]])\n        new_solution[i:j+1] = new_segment\n\n    # Apply a random swap to further diversify\n    if n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher costs)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (descending)\n    top_k = min(3, len(archive_sorted))  # Consider top 3 solutions\n    selected = random.choice(archive_sorted[:top_k])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three distinct edges to remove (3-opt style)\n    a, b, c = sorted(random.sample(range(n), 3))\n    removed_edges = [(new_solution[a], new_solution[b]), (new_solution[b], new_solution[c])]\n\n    # Step 2: Reconnect the tour with a novel edge insertion heuristic\n    # Find the best insertion point for the removed segment\n    segment = new_solution[b:c+1]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Evaluate potential insertions based on both objectives\n    best_insertion = None\n    min_total_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting the segment between remaining[i] and remaining[(i+1)%len(remaining)]\n        candidate = np.concatenate([\n            remaining[:i+1],\n            segment,\n            remaining[i+1:]\n        ])\n\n        # Calculate the cost of the new tour\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insertion = candidate\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution) and np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.78239147033413,
            2.3984527587890625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher costs)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (descending)\n    top_k = min(3, len(archive_sorted))  # Consider top 3 solutions\n    selected = random.choice(archive_sorted[:top_k])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three distinct edges to remove (3-opt style)\n    a, b, c = sorted(random.sample(range(n), 3))\n    removed_edges = [(new_solution[a], new_solution[b]), (new_solution[b], new_solution[c])]\n\n    # Step 2: Reconnect the tour with a novel edge insertion heuristic\n    # Find the best insertion point for the removed segment\n    segment = new_solution[b:c+1]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Evaluate potential insertions based on both objectives\n    best_insertion = None\n    min_total_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting the segment between remaining[i] and remaining[(i+1)%len(remaining)]\n        candidate = np.concatenate([\n            remaining[:i+1],\n            segment,\n            remaining[i+1:]\n        ])\n\n        # Calculate the cost of the new tour\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insertion = candidate\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution) and np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a candidate solution using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Perform a random 3-opt move\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconstruct the tour with the segments reversed\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n\n    # Step 2: Apply a novel edge-exchange mechanism\n    if n >= 4:\n        # Select two random edges and swap their connections\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure the edges are not adjacent and do not overlap\n        if abs(a - b) > 1 and abs(c - d) > 1 and not (a <= c <= b and a <= d <= b):\n            # Swap the segments between the edges\n            segment1 = new_solution[:a+1]\n            segment2 = new_solution[a+1:b]\n            segment3 = new_solution[b:c+1]\n            segment4 = new_solution[c+1:d]\n            segment5 = new_solution[d:]\n\n            new_solution = np.concatenate([segment1, segment4, segment3, segment2, segment5])\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert to base if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8714292671950612,
            0.20406699180603027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a candidate solution using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Perform a random 3-opt move\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconstruct the tour with the segments reversed\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n\n    # Step 2: Apply a novel edge-exchange mechanism\n    if n >= 4:\n        # Select two random edges and swap their connections\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure the edges are not adjacent and do not overlap\n        if abs(a - b) > 1 and abs(c - d) > 1 and not (a <= c <= b and a <= d <= b):\n            # Swap the segments between the edges\n            segment1 = new_solution[:a+1]\n            segment2 = new_solution[a+1:b]\n            segment3 = new_solution[b:c+1]\n            segment4 = new_solution[c+1:d]\n            segment5 = new_solution[d:]\n\n            new_solution = np.concatenate([segment1, segment4, segment3, segment2, segment5])\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert to base if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to modify\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    c = random.randint(b + 1, n - 1)\n\n    # Apply 3-opt-like operation (reverse a segment)\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Apply insertion-based local search\n    for _ in range(2):  # Perform 2 random insertions\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9465722354299396,
            0.46026796102523804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to modify\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    c = random.randint(b + 1, n - 1)\n\n    # Apply 3-opt-like operation (reverse a segment)\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Apply insertion-based local search\n    for _ in range(2):  # Perform 2 random insertions\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(costs) == 0:\n        selected_idx = 0\n    else:\n        # Normalize costs to get probabilities\n        normalized_costs = np.max(costs) - costs + 1e-8  # Invert and add small value to avoid division by zero\n        probabilities = normalized_costs / np.sum(normalized_costs)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge-swap operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # First, try a random 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Then, try a novel edge-swap operator that considers both objective spaces\n    if n >= 4:\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        # Swap edges (i,j) and (k,l) with (i,k) and (j,l) if it improves at least one objective\n        current_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[k], base_solution[l]]\n        new_cost1 = distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_1[base_solution[j], base_solution[l]]\n        current_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[k], base_solution[l]]\n        new_cost2 = distance_matrix_2[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[j], base_solution[l]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform the edge swap\n            new_solution = np.concatenate([\n                base_solution[:i+1],\n                [base_solution[k]],\n                base_solution[j:k],\n                [base_solution[j]],\n                base_solution[l+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.8240162474075123,
            0.19479531049728394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(costs) == 0:\n        selected_idx = 0\n    else:\n        # Normalize costs to get probabilities\n        normalized_costs = np.max(costs) - costs + 1e-8  # Invert and add small value to avoid division by zero\n        probabilities = normalized_costs / np.sum(normalized_costs)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge-swap operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # First, try a random 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Then, try a novel edge-swap operator that considers both objective spaces\n    if n >= 4:\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        # Swap edges (i,j) and (k,l) with (i,k) and (j,l) if it improves at least one objective\n        current_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[k], base_solution[l]]\n        new_cost1 = distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_1[base_solution[j], base_solution[l]]\n        current_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[k], base_solution[l]]\n        new_cost2 = distance_matrix_2[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[j], base_solution[l]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform the edge swap\n            new_solution = np.concatenate([\n                base_solution[:i+1],\n                [base_solution[k]],\n                base_solution[j:k],\n                [base_solution[j]],\n                base_solution[l+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 0:\n        return np.random.permutation(instance.shape[0])\n\n    # Intelligent selection: choose a solution with high diversity or low cost\n    selected_solution = max(archive_solutions, key=lambda sol: np.std(sol) + 0.1 * (1 / (np.sum(distance_matrix_1[sol[:-1], sol[1:]]) + np.sum(distance_matrix_2[sol[:-1], sol[1:]]))))\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a greedy insertion\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple perturbations\n        # Randomly select 3 distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment\n\n        # Greedy insertion: try to improve by moving a node to a better position\n        for node in random.sample(list(new_solution), min(3, n)):\n            # Find the best position to insert this node\n            best_pos = i\n            best_cost = float('inf')\n            for pos in range(n):\n                if pos == i or pos == j or pos == k:\n                    continue\n                # Try inserting node at position pos\n                temp_sol = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n                temp_sol = np.delete(temp_sol, np.where(temp_sol == node)[0][1])  # Remove original node\n                cost = np.sum(distance_matrix_1[temp_sol[:-1], temp_sol[1:]]) + np.sum(distance_matrix_2[temp_sol[:-1], temp_sol[1:]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Apply the best insertion\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.7915151528423131,
            9.463864505290985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 0:\n        return np.random.permutation(instance.shape[0])\n\n    # Intelligent selection: choose a solution with high diversity or low cost\n    selected_solution = max(archive_solutions, key=lambda sol: np.std(sol) + 0.1 * (1 / (np.sum(distance_matrix_1[sol[:-1], sol[1:]]) + np.sum(distance_matrix_2[sol[:-1], sol[1:]]))))\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a greedy insertion\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple perturbations\n        # Randomly select 3 distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment\n\n        # Greedy insertion: try to improve by moving a node to a better position\n        for node in random.sample(list(new_solution), min(3, n)):\n            # Find the best position to insert this node\n            best_pos = i\n            best_cost = float('inf')\n            for pos in range(n):\n                if pos == i or pos == j or pos == k:\n                    continue\n                # Try inserting node at position pos\n                temp_sol = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n                temp_sol = np.delete(temp_sol, np.where(temp_sol == node)[0][1])  # Remove original node\n                cost = np.sum(distance_matrix_1[temp_sol[:-1], temp_sol[1:]]) + np.sum(distance_matrix_2[temp_sol[:-1], temp_sol[1:]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Apply the best insertion\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate dominance ranks (simplified for this example)\n        objectives = np.array([obj for _, obj in archive])\n        dominated_count = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                              (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                    dominated_count[i] += 1\n        # Assign ranks (lower rank = more dominated = less promising)\n        ranks = np.argsort(dominated_count)\n        # Select with probability inversely proportional to rank\n        selected_idx = random.choices(range(len(archive)), weights=[1/(r+1) for r in ranks])[0]\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: Combine 2-opt with a novel segment relocation\n    if n > 3:\n        # Randomly choose between 2-opt and segment relocation with equal probability\n        if random.random() < 0.5:\n            # 2-opt move\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Segment relocation (novel operator)\n            if n > 4:\n                a, b, c = sorted(random.sample(range(n), 3))\n                segment = new_solution[a:b+1]\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # For very small tours, just swap two nodes\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9813695857835276,
            0.7943933010101318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate dominance ranks (simplified for this example)\n        objectives = np.array([obj for _, obj in archive])\n        dominated_count = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                              (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                    dominated_count[i] += 1\n        # Assign ranks (lower rank = more dominated = less promising)\n        ranks = np.argsort(dominated_count)\n        # Select with probability inversely proportional to rank\n        selected_idx = random.choices(range(len(archive)), weights=[1/(r+1) for r in ranks])[0]\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: Combine 2-opt with a novel segment relocation\n    if n > 3:\n        # Randomly choose between 2-opt and segment relocation with equal probability\n        if random.random() < 0.5:\n            # 2-opt move\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Segment relocation (novel operator)\n            if n > 4:\n                a, b, c = sorted(random.sample(range(n), 3))\n                segment = new_solution[a:b+1]\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # For very small tours, just swap two nodes\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential for improvement (lowest cost in either objective)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments to modify\n    i, j = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n    k, l = i + np.random.randint(1, n-j-1), j + np.random.randint(1, n-j-1)\n\n    # Perform segment reversal between i and j, and between k and l\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Check if the new solution is valid (no duplicates and all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the new solution is invalid\n        a, b = np.random.choice(range(n), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7254108953518718,
            0.5463306903839111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential for improvement (lowest cost in either objective)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments to modify\n    i, j = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n    k, l = i + np.random.randint(1, n-j-1), j + np.random.randint(1, n-j-1)\n\n    # Perform segment reversal between i and j, and between k and l\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Check if the new solution is valid (no duplicates and all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the new solution is invalid\n        a, b = np.random.choice(range(n), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct indices to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt move\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Randomly select two edges to exchange (edge exchange)\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.49177480077377167,
            0.4786778688430786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct indices to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt move\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Randomly select two edges to exchange (edge exchange)\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        candidates = sorted(archive, key=lambda x: x[1][0] + x[1][1])[:max(1, len(archive) // 3)]\n        base_solution = random.choice(candidates)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select two random segments to operate on\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt swap on the first segment\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Novel edge insertion: move a random segment to a different position\n        if c != d:\n            segment = new_solution[c:d]\n            new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n        # Ensure solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Additional improvement: try to find a better insertion point\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate potential improvement in both objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[j-1]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[j-1]])\n\n            # If the move improves both objectives, accept it\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7650546698405235,
            0.7132574319839478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        candidates = sorted(archive, key=lambda x: x[1][0] + x[1][1])[:max(1, len(archive) // 3)]\n        base_solution = random.choice(candidates)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select two random segments to operate on\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt swap on the first segment\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Novel edge insertion: move a random segment to a different position\n        if c != d:\n            segment = new_solution[c:d]\n            new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n        # Ensure solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Additional improvement: try to find a better insertion point\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate potential improvement in both objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[j-1]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[j-1]])\n\n            # If the move improves both objectives, accept it\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions or those with high variance)\n    candidates = []\n    for sol, obj in archive:\n        # Prioritize solutions with high variance in objectives (indicating potential for improvement)\n        variance = (obj[0] - obj[1]) ** 2\n        candidates.append((sol, obj, variance))\n\n    # Sort candidates by variance (descending) to prioritize diverse solutions\n    candidates.sort(key=lambda x: -x[2])\n    base_solution = candidates[0][0].copy()\n\n    # Hybrid local search: Combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion (to diversify the solution)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    # Remove the node and reinsert it at a random position\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid tour length.\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes detected.\"\n\n    return new_solution\n\n",
        "score": [
            -0.4745506912420313,
            0.49063920974731445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions or those with high variance)\n    candidates = []\n    for sol, obj in archive:\n        # Prioritize solutions with high variance in objectives (indicating potential for improvement)\n        variance = (obj[0] - obj[1]) ** 2\n        candidates.append((sol, obj, variance))\n\n    # Sort candidates by variance (descending) to prioritize diverse solutions\n    candidates.sort(key=lambda x: -x[2])\n    base_solution = candidates[0][0].copy()\n\n    # Hybrid local search: Combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion (to diversify the solution)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    # Remove the node and reinsert it at a random position\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid tour length.\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes detected.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weight for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with edge-swap based on dominance\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select three distinct edges\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Extract the three segments\n        seg1 = new_solution[:i+1]\n        seg2 = new_solution[i+1:j+1]\n        seg3 = new_solution[j+1:k+1]\n        seg4 = new_solution[k+1:]\n\n        # Generate all possible combinations of these segments\n        candidates = [\n            np.concatenate([seg1, seg2, seg3, seg4]),  # Original\n            np.concatenate([seg1, seg2[::-1], seg3, seg4]),  # Reverse seg2\n            np.concatenate([seg1, seg3, seg2, seg4]),  # Swap seg2 and seg3\n            np.concatenate([seg1, seg3[::-1], seg2, seg4]),  # Reverse seg3\n            np.concatenate([seg1, seg2, seg3[::-1], seg4]),  # Reverse seg3\n            np.concatenate([seg1, seg3, seg2[::-1], seg4]),  # Reverse seg2\n        ]\n\n        # Evaluate each candidate\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate objectives for the candidate\n            obj1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            obj2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            combined = weights[0] * obj1 + weights[1] * obj2\n\n            # Check if this candidate dominates the current best\n            if combined < best_score:\n                best_score = combined\n                best_candidate = candidate\n\n        # Update the solution if a better candidate was found\n        if best_candidate is not None and not np.array_equal(best_candidate, new_solution):\n            new_solution = best_candidate.copy()\n\n        # Edge-swap based on objective dominance\n        for _ in range(2):  # Perform multiple edge-swaps\n            # Select two random edges\n            a, b = np.random.choice(n, size=2, replace=False)\n            if a > b:\n                a, b = b, a\n\n            # Get the nodes involved\n            node1, node2 = new_solution[a], new_solution[(a+1)%n]\n            node3, node4 = new_solution[b], new_solution[(b+1)%n]\n\n            # Calculate original and swapped objectives\n            original_obj1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n            original_obj2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n            swapped_obj1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n            swapped_obj2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n            # Check if the swap improves both objectives\n            if (swapped_obj1 < original_obj1 and swapped_obj2 < original_obj2):\n                # Perform the swap\n                new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    return new_solution\n\n",
        "score": [
            -0.7013795551017261,
            3.6371110677719116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weight for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with edge-swap based on dominance\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select three distinct edges\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Extract the three segments\n        seg1 = new_solution[:i+1]\n        seg2 = new_solution[i+1:j+1]\n        seg3 = new_solution[j+1:k+1]\n        seg4 = new_solution[k+1:]\n\n        # Generate all possible combinations of these segments\n        candidates = [\n            np.concatenate([seg1, seg2, seg3, seg4]),  # Original\n            np.concatenate([seg1, seg2[::-1], seg3, seg4]),  # Reverse seg2\n            np.concatenate([seg1, seg3, seg2, seg4]),  # Swap seg2 and seg3\n            np.concatenate([seg1, seg3[::-1], seg2, seg4]),  # Reverse seg3\n            np.concatenate([seg1, seg2, seg3[::-1], seg4]),  # Reverse seg3\n            np.concatenate([seg1, seg3, seg2[::-1], seg4]),  # Reverse seg2\n        ]\n\n        # Evaluate each candidate\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate objectives for the candidate\n            obj1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            obj2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            combined = weights[0] * obj1 + weights[1] * obj2\n\n            # Check if this candidate dominates the current best\n            if combined < best_score:\n                best_score = combined\n                best_candidate = candidate\n\n        # Update the solution if a better candidate was found\n        if best_candidate is not None and not np.array_equal(best_candidate, new_solution):\n            new_solution = best_candidate.copy()\n\n        # Edge-swap based on objective dominance\n        for _ in range(2):  # Perform multiple edge-swaps\n            # Select two random edges\n            a, b = np.random.choice(n, size=2, replace=False)\n            if a > b:\n                a, b = b, a\n\n            # Get the nodes involved\n            node1, node2 = new_solution[a], new_solution[(a+1)%n]\n            node3, node4 = new_solution[b], new_solution[(b+1)%n]\n\n            # Calculate original and swapped objectives\n            original_obj1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n            original_obj2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n            swapped_obj1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n            swapped_obj2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n            # Check if the swap improves both objectives\n            if (swapped_obj1 < original_obj1 and swapped_obj2 < original_obj2):\n                # Perform the swap\n                new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (np.max(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    scores = np.sum(normalized_objectives, axis=1)  # Sum of normalized objectives\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to modify\n    seg1_start = np.random.randint(0, n)\n    seg1_end = np.random.randint(seg1_start + 1, n + 1)\n    seg2_start = np.random.randint(0, n)\n    seg2_end = np.random.randint(seg2_start + 1, n + 1)\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg2_start:seg2_end]\n\n    # Insert seg2 into the position of seg1 (edge insertion)\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end:]\n    ])\n\n    # Reverse a random segment to further diversify (segment reversal)\n    rev_start = np.random.randint(0, n - 1)\n    rev_end = np.random.randint(rev_start + 2, n + 1)\n    new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.869294714011147,
            0.44580352306365967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (np.max(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    scores = np.sum(normalized_objectives, axis=1)  # Sum of normalized objectives\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to modify\n    seg1_start = np.random.randint(0, n)\n    seg1_end = np.random.randint(seg1_start + 1, n + 1)\n    seg2_start = np.random.randint(0, n)\n    seg2_end = np.random.randint(seg2_start + 1, n + 1)\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end]\n    seg2 = new_solution[seg2_start:seg2_end]\n\n    # Insert seg2 into the position of seg1 (edge insertion)\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end:]\n    ])\n\n    # Reverse a random segment to further diversify (segment reversal)\n    rev_start = np.random.randint(0, n - 1)\n    rev_end = np.random.randint(rev_start + 2, n + 1)\n    new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.arange(instance.shape[0])\n\n    # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj.sum(axis=1)\n    sorted_indices = np.argsort(combined_scores)\n    selected_idx = random.choice(sorted_indices[-min(5, len(sorted_indices)):])  # Top 5 or fewer\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select two random segments to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Perform segment reversal between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Perform edge insertion between c and d\n    if c != d:\n        node = new_solution[d]\n        new_solution = np.concatenate([new_solution[:c], [node], new_solution[c:d], new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # Fallback to simple swap if the above operations cause invalidity\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.002759786574861,
            0.49659430980682373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.arange(instance.shape[0])\n\n    # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj.sum(axis=1)\n    sorted_indices = np.argsort(combined_scores)\n    selected_idx = random.choice(sorted_indices[-min(5, len(sorted_indices)):])  # Top 5 or fewer\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select two random segments to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Perform segment reversal between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Perform edge insertion between c and d\n    if c != d:\n        node = new_solution[d]\n        new_solution = np.concatenate([new_solution[:c], [node], new_solution[c:d], new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # Fallback to simple swap if the above operations cause invalidity\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.arange(instance.shape[0])\n\n    # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj.sum(axis=1)\n    sorted_indices = np.argsort(combined_scores)\n    selected_idx = random.choice(sorted_indices[-min(5, len(sorted_indices)):])  # Top 5 or fewer\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select two random segments to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Perform segment reversal between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Perform edge insertion between c and d\n    if c != d:\n        node = new_solution[d]\n        new_solution = np.concatenate([new_solution[:c], [node], new_solution[c:d], new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # Fallback to simple swap if the above operations cause invalidity\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.002759786574861,
            0.49659430980682373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.arange(instance.shape[0])\n\n    # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj.sum(axis=1)\n    sorted_indices = np.argsort(combined_scores)\n    selected_idx = random.choice(sorted_indices[-min(5, len(sorted_indices)):])  # Top 5 or fewer\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select two random segments to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Perform segment reversal between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Perform edge insertion between c and d\n    if c != d:\n        node = new_solution[d]\n        new_solution = np.concatenate([new_solution[:c], [node], new_solution[c:d], new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # Fallback to simple swap if the above operations cause invalidity\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined cost and select a random one from top 30% with highest cost\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        cutoff = max(1, int(len(sorted_archive) * 0.3))\n        selected = random.choice(sorted_archive[:cutoff])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: 3-opt move (select 3 random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect the segments in a different order\n    new_segments = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_segments)\n    new_solution = np.concatenate([new_segments[0], new_segments[1], new_segments[2], new_segments[3]])\n\n    # Step 2: Edge insertion heuristic (insert a random node in a better position)\n    insert_pos = random.randint(0, n-1)\n    node_to_insert = new_solution[insert_pos]\n    new_solution = np.delete(new_solution, insert_pos)\n\n    # Find the best insertion position for the node to improve both objectives\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(n-1):\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.572114435590946,
            3.14685195684433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined cost and select a random one from top 30% with highest cost\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        cutoff = max(1, int(len(sorted_archive) * 0.3))\n        selected = random.choice(sorted_archive[:cutoff])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: 3-opt move (select 3 random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect the segments in a different order\n    new_segments = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_segments)\n    new_solution = np.concatenate([new_segments[0], new_segments[1], new_segments[2], new_segments[3]])\n\n    # Step 2: Edge insertion heuristic (insert a random node in a better position)\n    insert_pos = random.randint(0, n-1)\n    node_to_insert = new_solution[insert_pos]\n    new_solution = np.delete(new_solution, insert_pos)\n\n    # Find the best insertion position for the node to improve both objectives\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(n-1):\n        temp_solution = np.insert(new_solution, pos, node_to_insert)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # Here, we approximate dominance rank by sorting solutions by their sum of objectives\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    ranks = {sol[0].tobytes(): i for i, sol in enumerate(sorted_archive)}\n    selected_solution = random.choices(\n        archive,\n        weights=[1 / (ranks[sol[0].tobytes()] + 1) for sol in archive],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Randomly select 3 segments to operate on\n        indices = sorted(random.sample(range(1, n), 3))\n        i, j, k = indices\n\n        # Apply 3-opt move\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Try different combinations of segments\n        candidates = [\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = new_solution.copy()\n        best_cost = (\n            sum(distance_matrix_1[best_candidate[i], best_candidate[i+1]] for i in range(n-1)) +\n            distance_matrix_1[best_candidate[-1], best_candidate[0]],\n            sum(distance_matrix_2[best_candidate[i], best_candidate[i+1]] for i in range(n-1)) +\n            distance_matrix_2[best_candidate[-1], best_candidate[0]]\n        )\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n                best_candidate = candidate.copy()\n                best_cost = (cost1, cost2)\n\n        new_solution = best_candidate\n\n        # Novel segment relocation\n        if n > 4:\n            # Select a random segment of length 2-3 nodes\n            seg_length = random.randint(2, min(3, n-2))\n            start = random.randint(0, n - seg_length - 1)\n            segment = new_solution[start:start+seg_length]\n\n            # Try inserting this segment in different positions\n            for pos in range(n - seg_length + 1):\n                if pos == start:\n                    continue\n                temp_sol = np.concatenate([\n                    new_solution[:start],\n                    new_solution[start+seg_length:pos],\n                    segment,\n                    new_solution[pos:]\n                ])\n\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n                if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n                    new_solution = temp_sol.copy()\n                    best_cost = (cost1, cost2)\n\n    return new_solution\n\n",
        "score": [
            -0.8810903457062131,
            13.469764947891235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # Here, we approximate dominance rank by sorting solutions by their sum of objectives\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    ranks = {sol[0].tobytes(): i for i, sol in enumerate(sorted_archive)}\n    selected_solution = random.choices(\n        archive,\n        weights=[1 / (ranks[sol[0].tobytes()] + 1) for sol in archive],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Randomly select 3 segments to operate on\n        indices = sorted(random.sample(range(1, n), 3))\n        i, j, k = indices\n\n        # Apply 3-opt move\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Try different combinations of segments\n        candidates = [\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = new_solution.copy()\n        best_cost = (\n            sum(distance_matrix_1[best_candidate[i], best_candidate[i+1]] for i in range(n-1)) +\n            distance_matrix_1[best_candidate[-1], best_candidate[0]],\n            sum(distance_matrix_2[best_candidate[i], best_candidate[i+1]] for i in range(n-1)) +\n            distance_matrix_2[best_candidate[-1], best_candidate[0]]\n        )\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n                best_candidate = candidate.copy()\n                best_cost = (cost1, cost2)\n\n        new_solution = best_candidate\n\n        # Novel segment relocation\n        if n > 4:\n            # Select a random segment of length 2-3 nodes\n            seg_length = random.randint(2, min(3, n-2))\n            start = random.randint(0, n - seg_length - 1)\n            segment = new_solution[start:start+seg_length]\n\n            # Try inserting this segment in different positions\n            for pos in range(n - seg_length + 1):\n                if pos == start:\n                    continue\n                temp_sol = np.concatenate([\n                    new_solution[:start],\n                    new_solution[start+seg_length:pos],\n                    segment,\n                    new_solution[pos:]\n                ])\n\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n                if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n                    new_solution = temp_sol.copy()\n                    best_cost = (cost1, cost2)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge swap strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three non-consecutive edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconstruct the tour in a new order to explore different configurations\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n    new_solution = new_order\n\n    # Step 2: Perform a novel edge swap based on objective-specific distances\n    # Select two random edges and swap them if it improves both objectives\n    i, j = sorted(random.sample(range(1, n-1), 2))\n\n    # Calculate current and potential new distances for both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution)\n\n    # Create a temporary solution with swapped edges\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n    # Accept the swap if it improves both objectives or at least one with a small trade-off\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 <= current_cost1 * 1.05 and new_cost2 <= current_cost2 * 1.05):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8535997281989234,
            0.5596463680267334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge swap strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three non-consecutive edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconstruct the tour in a new order to explore different configurations\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n    new_solution = new_order\n\n    # Step 2: Perform a novel edge swap based on objective-specific distances\n    # Select two random edges and swap them if it improves both objectives\n    i, j = sorted(random.sample(range(1, n-1), 2))\n\n    # Calculate current and potential new distances for both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution)\n\n    # Create a temporary solution with swapped edges\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n    # Accept the swap if it improves both objectives or at least one with a small trade-off\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 <= current_cost1 * 1.05 and new_cost2 <= current_cost2 * 1.05):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol[0] for sol in archive]\n    archive_objectives = [sol[1] for sol in archive]\n\n    # Calculate the relative improvement potential (normalized by current cost)\n    improvement_potentials = []\n    for i, (sol, (cost1, cost2)) in enumerate(zip(archive_solutions, archive_objectives)):\n        # Calculate current tour length\n        current_length1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        current_length2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n\n        # Estimate potential improvement (simplified)\n        potential = (cost1 + cost2) / (current_length1 + current_length2 + 1e-6)\n        improvement_potentials.append(potential)\n\n    # Select solution with highest improvement potential\n    selected_idx = np.argmax(improvement_potentials)\n    selected_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: 3-opt with biased edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three random edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (all possible combinations of reconnections)\n    # We'll try all 8 possible reconnections and keep the best one\n    current_cost1 = sum(distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n\n    best_cost = current_cost1 + current_cost2\n    best_solution = new_solution.copy()\n\n    # Try all possible 3-opt reconnections\n    for a, b, c in [(i, j, k), (i, k, j)]:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[a:b+1][::-1]\n        candidate[b:c+1] = candidate[b:c+1][::-1]\n\n        # Calculate new cost\n        new_cost1 = sum(distance_matrix_1[candidate[l], candidate[(l+1)%n]] for l in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[l], candidate[(l+1)%n]] for l in range(n))\n\n        # Update if better\n        if new_cost1 + new_cost2 < best_cost:\n            best_cost = new_cost1 + new_cost2\n            best_solution = candidate.copy()\n\n    # If no improvement, try a different local search strategy\n    if np.array_equal(best_solution, new_solution):\n        # Apply edge insertion with biased selection\n        # Select a random edge to remove and reinsert elsewhere\n        remove_idx = random.randint(0, n-2)\n        node = new_solution[remove_idx]\n        new_solution = np.delete(new_solution, remove_idx)\n\n        # Find insertion point that minimizes the sum of both objectives\n        best_insert_cost = float('inf')\n        best_insert_pos = 0\n\n        for pos in range(len(new_solution)):\n            # Create candidate solution\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate new cost\n            new_cost1 = sum(distance_matrix_1[candidate[l], candidate[(l+1)%n]] for l in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[l], candidate[(l+1)%n]] for l in range(n))\n\n            # Update if better\n            if new_cost1 + new_cost2 < best_insert_cost:\n                best_insert_cost = new_cost1 + new_cost2\n                best_insert_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8936800217729504,
            6.150713622570038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol[0] for sol in archive]\n    archive_objectives = [sol[1] for sol in archive]\n\n    # Calculate the relative improvement potential (normalized by current cost)\n    improvement_potentials = []\n    for i, (sol, (cost1, cost2)) in enumerate(zip(archive_solutions, archive_objectives)):\n        # Calculate current tour length\n        current_length1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        current_length2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n\n        # Estimate potential improvement (simplified)\n        potential = (cost1 + cost2) / (current_length1 + current_length2 + 1e-6)\n        improvement_potentials.append(potential)\n\n    # Select solution with highest improvement potential\n    selected_idx = np.argmax(improvement_potentials)\n    selected_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: 3-opt with biased edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three random edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (all possible combinations of reconnections)\n    # We'll try all 8 possible reconnections and keep the best one\n    current_cost1 = sum(distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n\n    best_cost = current_cost1 + current_cost2\n    best_solution = new_solution.copy()\n\n    # Try all possible 3-opt reconnections\n    for a, b, c in [(i, j, k), (i, k, j)]:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[a:b+1][::-1]\n        candidate[b:c+1] = candidate[b:c+1][::-1]\n\n        # Calculate new cost\n        new_cost1 = sum(distance_matrix_1[candidate[l], candidate[(l+1)%n]] for l in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[l], candidate[(l+1)%n]] for l in range(n))\n\n        # Update if better\n        if new_cost1 + new_cost2 < best_cost:\n            best_cost = new_cost1 + new_cost2\n            best_solution = candidate.copy()\n\n    # If no improvement, try a different local search strategy\n    if np.array_equal(best_solution, new_solution):\n        # Apply edge insertion with biased selection\n        # Select a random edge to remove and reinsert elsewhere\n        remove_idx = random.randint(0, n-2)\n        node = new_solution[remove_idx]\n        new_solution = np.delete(new_solution, remove_idx)\n\n        # Find insertion point that minimizes the sum of both objectives\n        best_insert_cost = float('inf')\n        best_insert_pos = 0\n\n        for pos in range(len(new_solution)):\n            # Create candidate solution\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate new cost\n            new_cost1 = sum(distance_matrix_1[candidate[l], candidate[(l+1)%n]] for l in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[l], candidate[(l+1)%n]] for l in range(n))\n\n            # Update if better\n            if new_cost1 + new_cost2 < best_insert_cost:\n                best_insert_cost = new_cost1 + new_cost2\n                best_insert_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (normalized difference between objectives)\n    potential = np.array([(obj1 - obj2) / (obj1 + obj2 + 1e-10) for obj1, obj2 in objectives])\n    potential = np.abs(potential)  # Absolute difference to consider both improvement directions\n\n    # Normalize potential to get selection probabilities\n    if np.sum(potential) > 0:\n        probs = potential / np.sum(potential)\n    else:\n        probs = np.ones(len(potential)) / len(potential)\n\n    # Select a base solution with probability proportional to potential\n    base_idx = np.random.choice(len(solutions), p=probs)\n    base_solution = solutions[base_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return base_solution  # Too small to perform meaningful operations\n\n    # Step 1: Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Novel segment reversal with objective-aware selection\n    # Choose a segment based on the objectives to potentially improve both\n    segment_length = max(2, min(n // 4, 5))  # Dynamic segment length\n    k = random.randint(0, n - segment_length)\n\n    # Decide whether to reverse based on objective differences\n    obj1, obj2 = objectives[base_idx]\n    if obj1 > obj2:\n        # More focus on improving the first objective\n        if random.random() < 0.7:  # Higher probability to act on first objective\n            new_solution[k:k+segment_length] = new_solution[k:k+segment_length][::-1]\n    else:\n        # More focus on improving the second objective\n        if random.random() < 0.7:  # Higher probability to act on second objective\n            new_solution[k:k+segment_length] = new_solution[k:k+segment_length][::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6534866966428334,
            0.5025012493133545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (normalized difference between objectives)\n    potential = np.array([(obj1 - obj2) / (obj1 + obj2 + 1e-10) for obj1, obj2 in objectives])\n    potential = np.abs(potential)  # Absolute difference to consider both improvement directions\n\n    # Normalize potential to get selection probabilities\n    if np.sum(potential) > 0:\n        probs = potential / np.sum(potential)\n    else:\n        probs = np.ones(len(potential)) / len(potential)\n\n    # Select a base solution with probability proportional to potential\n    base_idx = np.random.choice(len(solutions), p=probs)\n    base_solution = solutions[base_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return base_solution  # Too small to perform meaningful operations\n\n    # Step 1: Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Novel segment reversal with objective-aware selection\n    # Choose a segment based on the objectives to potentially improve both\n    segment_length = max(2, min(n // 4, 5))  # Dynamic segment length\n    k = random.randint(0, n - segment_length)\n\n    # Decide whether to reverse based on objective differences\n    obj1, obj2 = objectives[base_idx]\n    if obj1 > obj2:\n        # More focus on improving the first objective\n        if random.random() < 0.7:  # Higher probability to act on first objective\n            new_solution[k:k+segment_length] = new_solution[k:k+segment_length][::-1]\n    else:\n        # More focus on improving the second objective\n        if random.random() < 0.7:  # Higher probability to act on second objective\n            new_solution[k:k+segment_length] = new_solution[k:k+segment_length][::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto optimal in archive)\n    # Here, we select a solution that is not dominated by any other solution in the archive\n    non_dominated = []\n    for sol, _ in archive:\n        is_dominated = False\n        for _, (obj1, obj2) in archive:\n            if (obj1 < sol[0] and obj2 <= sol[1]) or (obj1 <= sol[0] and obj2 < sol[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        # If all solutions are dominated, select the one with the highest sum of objectives\n        base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        # Select a random non-dominated solution\n        base_solution = random.choice(non_dominated).copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge insertion: try to insert a random edge in a different position\n    if n > 3:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            # Swap nodes to create a new edge\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7895176579465737,
            1.3627626299858093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto optimal in archive)\n    # Here, we select a solution that is not dominated by any other solution in the archive\n    non_dominated = []\n    for sol, _ in archive:\n        is_dominated = False\n        for _, (obj1, obj2) in archive:\n            if (obj1 < sol[0] and obj2 <= sol[1]) or (obj1 <= sol[0] and obj2 < sol[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        # If all solutions are dominated, select the one with the highest sum of objectives\n        base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        # Select a random non-dominated solution\n        base_solution = random.choice(non_dominated).copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge insertion: try to insert a random edge in a different position\n    if n > 3:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            # Swap nodes to create a new edge\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = 0\n    best_score = float('inf')\n\n    for i, (sol, obj) in enumerate(archive):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt local search\n    new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment between a and b\n    new_solution[b:c] = new_solution[b:c][::-1]  # Reverse segment between b and c\n\n    # Apply custom edge swap to further improve\n    if np.random.rand() < 0.5:  # 50% chance to swap edges\n        x, y = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[x], new_solution[y] = new_solution[y], new_solution[x]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        x, y = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[x], new_solution[y] = new_solution[y], new_solution[x]\n\n    return new_solution\n\n",
        "score": [
            -0.7900026535746886,
            0.4492172598838806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = 0\n    best_score = float('inf')\n\n    for i, (sol, obj) in enumerate(archive):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt local search\n    new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment between a and b\n    new_solution[b:c] = new_solution[b:c][::-1]  # Reverse segment between b and c\n\n    # Apply custom edge swap to further improve\n    if np.random.rand() < 0.5:  # 50% chance to swap edges\n        x, y = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[x], new_solution[y] = new_solution[y], new_solution[x]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        x, y = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[x], new_solution[y] = new_solution[y], new_solution[x]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in edge lengths)\n    def selection_criterion(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        # Calculate the variance of edge lengths in both objectives\n        edges1 = [distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))]\n        edges2 = [distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))]\n        var1 = np.var(edges1)\n        var2 = np.var(edges2)\n        return var1 + var2  # Higher variance indicates more potential for improvement\n\n    # Sort solutions by their potential for improvement\n    sorted_archive = sorted(archive, key=selection_criterion, reverse=True)\n    base_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal (novel operator)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform an edge swap (standard operator)\n    if n > 3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8071302627873453,
            55.118989050388336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in edge lengths)\n    def selection_criterion(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        # Calculate the variance of edge lengths in both objectives\n        edges1 = [distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))]\n        edges2 = [distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))]\n        var1 = np.var(edges1)\n        var2 = np.var(edges2)\n        return var1 + var2  # Higher variance indicates more potential for improvement\n\n    # Sort solutions by their potential for improvement\n    sorted_archive = sorted(archive, key=selection_criterion, reverse=True)\n    base_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal (novel operator)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform an edge swap (standard operator)\n    if n > 3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = max(1, len(archive) // 5)\n    candidates = archive_sorted[:top_k]\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment reversal and edge swaps\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between segment reversal or edge swap\n    if np.random.random() < 0.7:\n        # Segment reversal (like a larger 2-opt)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Edge swap (like a 3-opt but simpler)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8096674926062668,
            1.1258808970451355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = max(1, len(archive) // 5)\n    candidates = archive_sorted[:top_k]\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment reversal and edge swaps\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between segment reversal or edge swap\n    if np.random.random() < 0.7:\n        # Segment reversal (like a larger 2-opt)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Edge swap (like a 3-opt but simpler)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank (higher rank = more promising)\n    weights = [1.0 / (rank + 1) for rank in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with segment inversion and swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful improvement\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt by reconnecting the edges in a different order\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Additional segment inversion for diversity\n    if random.random() < 0.5:\n        l, m = sorted(random.sample(range(1, n), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8798731038776662,
            0.4995846748352051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank (higher rank = more promising)\n    weights = [1.0 / (rank + 1) for rank in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with segment inversion and swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful improvement\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt by reconnecting the edges in a different order\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Additional segment inversion for diversity\n    if random.random() < 0.5:\n        l, m = sorted(random.sample(range(1, n), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank (higher rank = more promising)\n    weights = [1.0 / (rank + 1) for rank in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with segment inversion and swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful improvement\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt by reconnecting the edges in a different order\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Additional segment inversion for diversity\n    if random.random() < 0.5:\n        l, m = sorted(random.sample(range(1, n), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8798731038776662,
            0.4995846748352051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank (higher rank = more promising)\n    weights = [1.0 / (rank + 1) for rank in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with segment inversion and swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful improvement\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt by reconnecting the edges in a different order\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Additional segment inversion for diversity\n    if random.random() < 0.5:\n        l, m = sorted(random.sample(range(1, n), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank (higher rank = more promising)\n    weights = [1.0 / (rank + 1) for rank in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with segment inversion and swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful improvement\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt by reconnecting the edges in a different order\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Additional segment inversion for diversity\n    if random.random() < 0.5:\n        l, m = sorted(random.sample(range(1, n), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8798731038776662,
            0.4995846748352051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank (higher rank = more promising)\n    weights = [1.0 / (rank + 1) for rank in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with segment inversion and swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful improvement\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt by reconnecting the edges in a different order\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Additional segment inversion for diversity\n    if random.random() < 0.5:\n        l, m = sorted(random.sample(range(1, n), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (lower cost solutions are more likely to be selected)\n    costs = [sum(obj) for obj in objectives]\n    min_cost = min(costs)\n    weights = [1.0 / (cost - min_cost + 1e-6) for cost in costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(solutions)), weights=weights, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Reverse the segment (2-opt like move)\n    new_solution[segment_start:segment_start + segment_length] = segment[::-1]\n\n    # Edge insertion: insert a randomly selected node elsewhere in the tour\n    if n > 3:\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n - 1)\n        if insert_pos != new_solution.tolist().index(node_to_insert):\n            # Remove the node and insert it at the new position\n            new_solution = np.delete(new_solution, new_solution.tolist().index(node_to_insert))\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.7547973059758353,
            0.5446144938468933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (lower cost solutions are more likely to be selected)\n    costs = [sum(obj) for obj in objectives]\n    min_cost = min(costs)\n    weights = [1.0 / (cost - min_cost + 1e-6) for cost in costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(solutions)), weights=weights, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Reverse the segment (2-opt like move)\n    new_solution[segment_start:segment_start + segment_length] = segment[::-1]\n\n    # Edge insertion: insert a randomly selected node elsewhere in the tour\n    if n > 3:\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n - 1)\n        if insert_pos != new_solution.tolist().index(node_to_insert):\n            # Remove the node and insert it at the new position\n            new_solution = np.delete(new_solution, new_solution.tolist().index(node_to_insert))\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge-swap strategy: swap two edges with high potential for improvement\n    # Select two random nodes and swap their positions if it improves both objectives\n    a, b = random.sample(range(1, n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    # Check if the swap improves both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8981939348565325,
            0.580543041229248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge-swap strategy: swap two edges with high potential for improvement\n    # Select two random nodes and swap their positions if it improves both objectives\n    a, b = random.sample(range(1, n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    # Check if the swap improves both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge-swap strategy: swap two edges with high potential for improvement\n    # Select two random nodes and swap their positions if it improves both objectives\n    a, b = random.sample(range(1, n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    # Check if the swap improves both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8981939348565325,
            0.580543041229248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge-swap strategy: swap two edges with high potential for improvement\n    # Select two random nodes and swap their positions if it improves both objectives\n    a, b = random.sample(range(1, n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    # Check if the swap improves both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just reverse a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n    # Choose a local search operator with probability\n    operator = random.choices(\n        ['edge_swap', 'segment_reversal', 'node_insertion'],\n        weights=[0.4, 0.4, 0.2],\n        k=1\n    )[0]\n\n    if operator == 'edge_swap':\n        # Perform a 2-opt like operation but with multiple swaps\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'segment_reversal':\n        # Reverse a segment and optionally swap adjacent segments\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if random.random() < 0.5 and j < n-1:\n            k = random.randint(j+1, min(j+3, n-1))\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    elif operator == 'node_insertion':\n        # Move a random node to a different position\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8675853207115239,
            0.4543094038963318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just reverse a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n    # Choose a local search operator with probability\n    operator = random.choices(\n        ['edge_swap', 'segment_reversal', 'node_insertion'],\n        weights=[0.4, 0.4, 0.2],\n        k=1\n    )[0]\n\n    if operator == 'edge_swap':\n        # Perform a 2-opt like operation but with multiple swaps\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'segment_reversal':\n        # Reverse a segment and optionally swap adjacent segments\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if random.random() < 0.5 and j < n-1:\n            k = random.randint(j+1, min(j+3, n-1))\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    elif operator == 'node_insertion':\n        # Move a random node to a different position\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just reverse a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n    # Choose a local search operator with probability\n    operator = random.choices(\n        ['edge_swap', 'segment_reversal', 'node_insertion'],\n        weights=[0.4, 0.4, 0.2],\n        k=1\n    )[0]\n\n    if operator == 'edge_swap':\n        # Perform a 2-opt like operation but with multiple swaps\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'segment_reversal':\n        # Reverse a segment and optionally swap adjacent segments\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if random.random() < 0.5 and j < n-1:\n            k = random.randint(j+1, min(j+3, n-1))\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    elif operator == 'node_insertion':\n        # Move a random node to a different position\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8675853207115239,
            0.4543094038963318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just reverse a segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n    # Choose a local search operator with probability\n    operator = random.choices(\n        ['edge_swap', 'segment_reversal', 'node_insertion'],\n        weights=[0.4, 0.4, 0.2],\n        k=1\n    )[0]\n\n    if operator == 'edge_swap':\n        # Perform a 2-opt like operation but with multiple swaps\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'segment_reversal':\n        # Reverse a segment and optionally swap adjacent segments\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if random.random() < 0.5 and j < n-1:\n            k = random.randint(j+1, min(j+3, n-1))\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    elif operator == 'node_insertion':\n        # Move a random node to a different position\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.max(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (1 + normalized_obj.sum(axis=1))  # Prefer solutions with lower combined objectives\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversity)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            # Insert segment [i+1..j-1] after position j\n            segment = new_solution[i+1:j].copy()\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Step 2: Segment reversal with objective-aware selection\n    if n > 4:\n        # Select a segment to reverse based on both objectives\n        segment_start = random.randint(0, n-4)\n        segment_end = random.randint(segment_start+2, min(segment_start+10, n-1))  # Limit segment size\n\n        # Evaluate original and reversed segment in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(segment_start, segment_end))\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(segment_start, segment_end))\n\n        reversed_segment = new_solution[segment_start:segment_end+1][::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept if at least one objective improves\n        if reversed_cost1 < original_cost1 or reversed_cost2 < original_cost2:\n            new_solution[segment_start:segment_end+1] = reversed_segment\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8252967858900161,
            0.7063409686088562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.max(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (1 + normalized_obj.sum(axis=1))  # Prefer solutions with lower combined objectives\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversity)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            # Insert segment [i+1..j-1] after position j\n            segment = new_solution[i+1:j].copy()\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Step 2: Segment reversal with objective-aware selection\n    if n > 4:\n        # Select a segment to reverse based on both objectives\n        segment_start = random.randint(0, n-4)\n        segment_end = random.randint(segment_start+2, min(segment_start+10, n-1))  # Limit segment size\n\n        # Evaluate original and reversed segment in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(segment_start, segment_end))\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(segment_start, segment_end))\n\n        reversed_segment = new_solution[segment_start:segment_end+1][::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept if at least one objective improves\n        if reversed_cost1 < original_cost1 or reversed_cost2 < original_cost2:\n            new_solution[segment_start:segment_end+1] = reversed_segment\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions that are not dominated by others and have good diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are dominated, select the least dominated one\n        least_dominated = min(archive, key=lambda x: sum(1 for y in archive if (y[1][0] <= x[1][0] and y[1][1] <= x[1][1] and (y[1][0] < x[1][0] or y[1][1] < x[1][1]))))\n        base_solution = least_dominated[0].copy()\n    else:\n        # Select a solution with good diversity (avoid clustering)\n        diversity_scores = []\n        for sol, obj in non_dominated:\n            diversity = 0\n            for other_sol, _ in non_dominated:\n                if np.array_equal(sol, other_sol):\n                    continue\n                diversity += np.sum(sol != other_sol)\n            diversity_scores.append(diversity)\n\n        # Select the solution with the highest diversity\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n\n    # Hybrid strategy: combine 3-opt with segment reversal\n    if n >= 4:\n        # Choose 3 random indices where i < j < k\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt style move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        if random.random() < 0.5:\n            # Reverse both segments\n            new_solution[i:j] = segment1[::-1]\n            new_solution[j:k] = segment2[::-1]\n        else:\n            # Reverse one segment and swap the other\n            if random.random() < 0.5:\n                new_solution[i:j] = segment1[::-1]\n            else:\n                new_solution[j:k] = segment2[::-1]\n\n        # Apply segment reversal (novel element)\n        if n >= 6 and random.random() < 0.3:\n            # Select two non-overlapping segments and reverse each\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7998341039881122,
            4.078088283538818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions that are not dominated by others and have good diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are dominated, select the least dominated one\n        least_dominated = min(archive, key=lambda x: sum(1 for y in archive if (y[1][0] <= x[1][0] and y[1][1] <= x[1][1] and (y[1][0] < x[1][0] or y[1][1] < x[1][1]))))\n        base_solution = least_dominated[0].copy()\n    else:\n        # Select a solution with good diversity (avoid clustering)\n        diversity_scores = []\n        for sol, obj in non_dominated:\n            diversity = 0\n            for other_sol, _ in non_dominated:\n                if np.array_equal(sol, other_sol):\n                    continue\n                diversity += np.sum(sol != other_sol)\n            diversity_scores.append(diversity)\n\n        # Select the solution with the highest diversity\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n\n    # Hybrid strategy: combine 3-opt with segment reversal\n    if n >= 4:\n        # Choose 3 random indices where i < j < k\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt style move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        if random.random() < 0.5:\n            # Reverse both segments\n            new_solution[i:j] = segment1[::-1]\n            new_solution[j:k] = segment2[::-1]\n        else:\n            # Reverse one segment and swap the other\n            if random.random() < 0.5:\n                new_solution[i:j] = segment1[::-1]\n            else:\n                new_solution[j:k] = segment2[::-1]\n\n        # Apply segment reversal (novel element)\n        if n >= 6 and random.random() < 0.3:\n            # Select two non-overlapping segments and reverse each\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (inverse of current objective values)\n    potentials = [1 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping and properly ordered\n    if i < k < j < l:\n        # Extract segments\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n\n        # Reverse one of the segments with 50% probability\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n        else:\n            segment2 = segment2[::-1]\n\n        # Reconstruct the solution with modified segments\n        new_solution = np.concatenate([\n            new_solution[:i], segment1,\n            new_solution[j:k], segment2,\n            new_solution[l:]\n        ])\n\n    # Ensure the solution remains a valid tour by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler 2-opt move if segments cause duplicates\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8209298545561119,
            2.4028080105781555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (inverse of current objective values)\n    potentials = [1 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping and properly ordered\n    if i < k < j < l:\n        # Extract segments\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n\n        # Reverse one of the segments with 50% probability\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n        else:\n            segment2 = segment2[::-1]\n\n        # Reconstruct the solution with modified segments\n        new_solution = np.concatenate([\n            new_solution[:i], segment1,\n            new_solution[j:k], segment2,\n            new_solution[l:]\n        ])\n\n    # Ensure the solution remains a valid tour by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler 2-opt move if segments cause duplicates\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with potential for improvement\n    # Sort solutions by their combined objective value (sum of both objectives)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    # Select top 30% solutions with the lowest combined cost\n    top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    # Randomly select one from the top candidates\n    selected = random.choice(top_candidates)\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combines 2-opt with a novel segment reversal\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel segment reversal with probability 0.3\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        # Reverse a segment and rotate it\n        segment = new_solution[a:b+1]\n        rotate_by = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotate_by)\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.769475498513221,
            0.5056332945823669
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with potential for improvement\n    # Sort solutions by their combined objective value (sum of both objectives)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    # Select top 30% solutions with the lowest combined cost\n    top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    # Randomly select one from the top candidates\n    selected = random.choice(top_candidates)\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combines 2-opt with a novel segment reversal\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel segment reversal with probability 0.3\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        # Reverse a segment and rotate it\n        segment = new_solution[a:b+1]\n        rotate_by = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotate_by)\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    # Prefer solutions that are not too similar to each other in the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search operator: 3-opt with biased selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Select three random edges to break and reconnect\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt: reconnect edges in a way that reduces both objectives\n    # We consider all possible 3-opt moves and select the one that improves both objectives\n    best_move = None\n    best_improvement = (0, 0)\n\n    # Generate all possible 3-opt moves\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a == b:\n                continue\n            for c in [i, j, k]:\n                if a == c or b == c:\n                    continue\n                # Create candidate solution\n                candidate = new_solution.copy()\n                candidate[a:b] = new_solution[a:b][::-1]\n                candidate[b:c] = new_solution[b:c][::-1]\n                candidate[c:] = new_solution[c:][::-1]\n\n                # Calculate improvement\n                old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n                old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n\n                new_cost1 = distance_matrix_1[candidate[a-1], candidate[a]] + distance_matrix_1[candidate[b-1], candidate[b]] + distance_matrix_1[candidate[c-1], candidate[c]]\n                new_cost2 = distance_matrix_2[candidate[a-1], candidate[a]] + distance_matrix_2[candidate[b-1], candidate[b]] + distance_matrix_2[candidate[c-1], candidate[c]]\n\n                improvement1 = old_cost1 - new_cost1\n                improvement2 = old_cost2 - new_cost2\n\n                # Prefer moves that improve both objectives\n                if improvement1 > best_improvement[0] and improvement2 > best_improvement[1]:\n                    best_move = candidate\n                    best_improvement = (improvement1, improvement2)\n\n    if best_move is not None:\n        new_solution = best_move.copy()\n\n    # If no improvement found, perform a random 2-opt as fallback\n    if best_move is None:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8579988888335717,
            0.5420140624046326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    # Prefer solutions that are not too similar to each other in the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search operator: 3-opt with biased selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Select three random edges to break and reconnect\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt: reconnect edges in a way that reduces both objectives\n    # We consider all possible 3-opt moves and select the one that improves both objectives\n    best_move = None\n    best_improvement = (0, 0)\n\n    # Generate all possible 3-opt moves\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a == b:\n                continue\n            for c in [i, j, k]:\n                if a == c or b == c:\n                    continue\n                # Create candidate solution\n                candidate = new_solution.copy()\n                candidate[a:b] = new_solution[a:b][::-1]\n                candidate[b:c] = new_solution[b:c][::-1]\n                candidate[c:] = new_solution[c:][::-1]\n\n                # Calculate improvement\n                old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n                old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n\n                new_cost1 = distance_matrix_1[candidate[a-1], candidate[a]] + distance_matrix_1[candidate[b-1], candidate[b]] + distance_matrix_1[candidate[c-1], candidate[c]]\n                new_cost2 = distance_matrix_2[candidate[a-1], candidate[a]] + distance_matrix_2[candidate[b-1], candidate[b]] + distance_matrix_2[candidate[c-1], candidate[c]]\n\n                improvement1 = old_cost1 - new_cost1\n                improvement2 = old_cost2 - new_cost2\n\n                # Prefer moves that improve both objectives\n                if improvement1 > best_improvement[0] and improvement2 > best_improvement[1]:\n                    best_move = candidate\n                    best_improvement = (improvement1, improvement2)\n\n    if best_move is not None:\n        new_solution = best_move.copy()\n\n    # If no improvement found, perform a random 2-opt as fallback\n    if best_move is None:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    probabilities = [1.0 / (1.0 + cost) for cost in total_costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    for _ in range(10):  # Number of iterations\n        # Select three random edges to reconnect\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Try different combinations of reconnections\n        candidates = [\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n            np.concatenate([segment1, segment2, segment4, segment3[::-1]]),\n            np.concatenate([segment1, segment3, segment4, segment2[::-1]])\n        ]\n\n        # Evaluate candidates using both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_candidate = candidate.copy()\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Apply biased random walk to escape local optima\n        if random.random() < 0.3:  # 30% chance to perform a random walk\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9250804469926517,
            3.7716630697250366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    probabilities = [1.0 / (1.0 + cost) for cost in total_costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    for _ in range(10):  # Number of iterations\n        # Select three random edges to reconnect\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Try different combinations of reconnections\n        candidates = [\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n            np.concatenate([segment1, segment2, segment4, segment3[::-1]]),\n            np.concatenate([segment1, segment3, segment4, segment2[::-1]])\n        ]\n\n        # Evaluate candidates using both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_candidate = candidate.copy()\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Apply biased random walk to escape local optima\n        if random.random() < 0.3:  # 30% chance to perform a random walk\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    probabilities = [1.0 / (1.0 + cost) for cost in total_costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    for _ in range(10):  # Number of iterations\n        # Select three random edges to reconnect\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Try different combinations of reconnections\n        candidates = [\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n            np.concatenate([segment1, segment2, segment4, segment3[::-1]]),\n            np.concatenate([segment1, segment3, segment4, segment2[::-1]])\n        ]\n\n        # Evaluate candidates using both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_candidate = candidate.copy()\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Apply biased random walk to escape local optima\n        if random.random() < 0.3:  # 30% chance to perform a random walk\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9250804469926517,
            3.7716630697250366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    probabilities = [1.0 / (1.0 + cost) for cost in total_costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    for _ in range(10):  # Number of iterations\n        # Select three random edges to reconnect\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Try different combinations of reconnections\n        candidates = [\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n            np.concatenate([segment1, segment2, segment4, segment3[::-1]]),\n            np.concatenate([segment1, segment3, segment4, segment2[::-1]])\n        ]\n\n        # Evaluate candidates using both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_candidate = candidate.copy()\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Apply biased random walk to escape local optima\n        if random.random() < 0.3:  # 30% chance to perform a random walk\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of normalized objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion with segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert (3-opt style)\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]  # Invert the segment\n\n    # Apply edge insertion based on distance improvement in both objectives\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        if abs(i - j) < 2:\n            continue  # Skip if too close\n\n        # Calculate current and new distances in both objectives\n        current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (new_dist1 < current_dist1 * 0.95 or new_dist2 < current_dist2 * 0.95):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6552171897894565,
            0.6698871850967407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of normalized objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion with segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert (3-opt style)\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]  # Invert the segment\n\n    # Apply edge insertion based on distance improvement in both objectives\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        if abs(i - j) < 2:\n            continue  # Skip if too close\n\n        # Calculate current and new distances in both objectives\n        current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (new_dist1 < current_dist1 * 0.95 or new_dist2 < current_dist2 * 0.95):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objective values and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], random.random()))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Choose a local search operator based on a random selection\n    operator = random.choice(['edge_exchange', 'segment_relocation'])\n\n    if operator == 'edge_exchange':\n        # Perform edge exchange (similar to 2-opt but more flexible)\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j] = selected_solution[i:j][::-1]\n    else:\n        # Segment relocation: move a random segment to a new position\n        n = len(selected_solution)\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution = np.concatenate([\n            selected_solution[:a],\n            selected_solution[b:c],\n            selected_solution[a:b],\n            selected_solution[c:]\n        ])\n\n    # Ensure the solution is a valid tour\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Invalid tour generated\"\n    return new_solution\n\n",
        "score": [
            -0.8372799598259258,
            0.4984452724456787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objective values and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], random.random()))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Choose a local search operator based on a random selection\n    operator = random.choice(['edge_exchange', 'segment_relocation'])\n\n    if operator == 'edge_exchange':\n        # Perform edge exchange (similar to 2-opt but more flexible)\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j] = selected_solution[i:j][::-1]\n    else:\n        # Segment relocation: move a random segment to a new position\n        n = len(selected_solution)\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution = np.concatenate([\n            selected_solution[:a],\n            selected_solution[b:c],\n            selected_solution[a:b],\n            selected_solution[c:]\n        ])\n\n    # Ensure the solution is a valid tour\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Invalid tour generated\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel move\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Novel move: relocate a segment and reverse it\n        segment = new_solution[i:j]\n        new_segment = np.concatenate([segment[::-1], new_solution[j:k], new_solution[k:n], new_solution[:i]])\n\n        # Check feasibility and accept if better\n        if len(np.unique(new_segment)) == n:\n            new_solution = new_segment\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.802372266226995,
            0.5076236724853516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel move\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Novel move: relocate a segment and reverse it\n        segment = new_solution[i:j]\n        new_segment = np.concatenate([segment[::-1], new_solution[j:k], new_solution[k:n], new_solution[:i]])\n\n        # Check feasibility and accept if better\n        if len(np.unique(new_segment)) == n:\n            new_solution = new_segment\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective values (descending) to prioritize high-potential solutions\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to apply 3-opt\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt to the selected segment\n    segment = new_solution[i:j]\n    if len(segment) >= 3:\n        # Reverse the middle part of the segment\n        segment = np.concatenate([segment[:1], segment[1:-1][::-1], segment[-1:]])\n        new_solution[i:j] = segment\n\n    # Apply a custom edge-swap heuristic to further improve the solution\n    for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Check if swapping edges a->b and a+1->b+1 improves both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9175154215418047,
            0.5625465512275696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective values (descending) to prioritize high-potential solutions\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to apply 3-opt\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt to the selected segment\n    segment = new_solution[i:j]\n    if len(segment) >= 3:\n        # Reverse the middle part of the segment\n        segment = np.concatenate([segment[:1], segment[1:-1][::-1], segment[-1:]])\n        new_solution[i:j] = segment\n\n    # Apply a custom edge-swap heuristic to further improve the solution\n    for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Check if swapping edges a->b and a+1->b+1 improves both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solution_indices = list(range(len(archive)))\n    solution_probs = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_prob = sum(solution_probs)\n    normalized_probs = [p / total_prob for p in solution_probs]\n    selected_idx = random.choices(solution_indices, weights=normalized_probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move (reverse a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a custom move: swap two nodes if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Evaluate the move\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    temp_cost1, temp_cost2 = calculate_cost(temp_solution)\n\n    # Accept the swap if both objectives improve\n    if temp_cost1 <= original_cost1 and temp_cost2 <= original_cost2:\n        new_solution = temp_solution\n\n    # Ensure the solution remains valid\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9297789163808703,
            0.5408416986465454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solution_indices = list(range(len(archive)))\n    solution_probs = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_prob = sum(solution_probs)\n    normalized_probs = [p / total_prob for p in solution_probs]\n    selected_idx = random.choices(solution_indices, weights=normalized_probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move (reverse a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a custom move: swap two nodes if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Evaluate the move\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    temp_cost1, temp_cost2 = calculate_cost(temp_solution)\n\n    # Accept the swap if both objectives improve\n    if temp_cost1 <= original_cost1 and temp_cost2 <= original_cost2:\n        new_solution = temp_solution\n\n    # Ensure the solution remains valid\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solution_indices = list(range(len(archive)))\n    solution_probs = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_prob = sum(solution_probs)\n    normalized_probs = [p / total_prob for p in solution_probs]\n    selected_idx = random.choices(solution_indices, weights=normalized_probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move (reverse a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a custom move: swap two nodes if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Evaluate the move\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    temp_cost1, temp_cost2 = calculate_cost(temp_solution)\n\n    # Accept the swap if both objectives improve\n    if temp_cost1 <= original_cost1 and temp_cost2 <= original_cost2:\n        new_solution = temp_solution\n\n    # Ensure the solution remains valid\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9297789163808703,
            0.5408416986465454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solution_indices = list(range(len(archive)))\n    solution_probs = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_prob = sum(solution_probs)\n    normalized_probs = [p / total_prob for p in solution_probs]\n    selected_idx = random.choices(solution_indices, weights=normalized_probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move (reverse a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a custom move: swap two nodes if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    # Evaluate the move\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    temp_cost1, temp_cost2 = calculate_cost(temp_solution)\n\n    # Accept the swap if both objectives improve\n    if temp_cost1 <= original_cost1 and temp_cost2 <= original_cost2:\n        new_solution = temp_solution\n\n    # Ensure the solution remains valid\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost (sum of both objectives)\n    archive_with_costs = [(sol, cost, sum(cost)) for sol, cost in archive]\n    archive_with_costs.sort(key=lambda x: x[2])\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30% to allow some diversity\n    base_solution = archive_with_costs[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Edge Insertion with Biased Randomness\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_start = random.randint(0, n - 2)\n    segment_length = min(random.randint(2, 5), n - segment_start - 1)  # Ensure we don't go out of bounds\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Insert the segment back at a new position with bias towards better edges\n    possible_positions = list(range(len(new_solution) + 1))\n    if len(possible_positions) > 1:\n        # Calculate potential edge costs for insertion positions\n        insertion_costs = []\n        for pos in possible_positions:\n            if pos == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            elif pos == len(new_solution):\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[pos - 1]\n                next_node = new_solution[pos]\n\n            # Calculate the cost of inserting the segment at this position\n            segment_cost = 0\n            for i in range(len(segment)):\n                if i == 0:\n                    segment_cost += distance_matrix_1[prev_node, segment[i]] + distance_matrix_2[prev_node, segment[i]]\n                if i == len(segment) - 1:\n                    segment_cost += distance_matrix_1[segment[i], next_node] + distance_matrix_2[segment[i], next_node]\n                else:\n                    segment_cost += distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]\n\n            insertion_costs.append(segment_cost)\n\n        # Normalize costs and select with preference for lower costs\n        min_cost = min(insertion_costs)\n        max_cost = max(insertion_costs)\n        if max_cost != min_cost:\n            normalized_costs = [(max_cost - c) / (max_cost - min_cost) for c in insertion_costs]\n            selection_probs = [c / sum(normalized_costs) for c in normalized_costs]\n            selected_pos = random.choices(possible_positions, weights=selection_probs, k=1)[0]\n        else:\n            selected_pos = random.choice(possible_positions)\n    else:\n        selected_pos = 0\n\n    # Insert the segment back\n    new_solution = np.concatenate([new_solution[:selected_pos], segment, new_solution[selected_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7418917066550086,
            0.7699251770973206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost (sum of both objectives)\n    archive_with_costs = [(sol, cost, sum(cost)) for sol, cost in archive]\n    archive_with_costs.sort(key=lambda x: x[2])\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30% to allow some diversity\n    base_solution = archive_with_costs[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Edge Insertion with Biased Randomness\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_start = random.randint(0, n - 2)\n    segment_length = min(random.randint(2, 5), n - segment_start - 1)  # Ensure we don't go out of bounds\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Insert the segment back at a new position with bias towards better edges\n    possible_positions = list(range(len(new_solution) + 1))\n    if len(possible_positions) > 1:\n        # Calculate potential edge costs for insertion positions\n        insertion_costs = []\n        for pos in possible_positions:\n            if pos == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            elif pos == len(new_solution):\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[pos - 1]\n                next_node = new_solution[pos]\n\n            # Calculate the cost of inserting the segment at this position\n            segment_cost = 0\n            for i in range(len(segment)):\n                if i == 0:\n                    segment_cost += distance_matrix_1[prev_node, segment[i]] + distance_matrix_2[prev_node, segment[i]]\n                if i == len(segment) - 1:\n                    segment_cost += distance_matrix_1[segment[i], next_node] + distance_matrix_2[segment[i], next_node]\n                else:\n                    segment_cost += distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]\n\n            insertion_costs.append(segment_cost)\n\n        # Normalize costs and select with preference for lower costs\n        min_cost = min(insertion_costs)\n        max_cost = max(insertion_costs)\n        if max_cost != min_cost:\n            normalized_costs = [(max_cost - c) / (max_cost - min_cost) for c in insertion_costs]\n            selection_probs = [c / sum(normalized_costs) for c in normalized_costs]\n            selected_pos = random.choices(possible_positions, weights=selection_probs, k=1)[0]\n        else:\n            selected_pos = random.choice(possible_positions)\n    else:\n        selected_pos = 0\n\n    # Insert the segment back\n    new_solution = np.concatenate([new_solution[:selected_pos], segment, new_solution[selected_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined cost (promising for improvement)\n    def combined_cost(obj: Tuple[float, float]) -> float:\n        return obj[0] + obj[1]  # Simple sum, could be replaced with a weighted sum\n\n    # Sort solutions by combined cost in descending order\n    sorted_archive = sorted(archive, key=lambda x: combined_cost(x[1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure there's a segment to insert\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment-based perturbation (for intensification)\n    if n > 4:\n        # Select a random segment and reverse it\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicate nodes\"\n    assert len(new_solution) == n, \"Invalid solution: incorrect length\"\n\n    return new_solution\n\n",
        "score": [
            -0.979825472063792,
            0.5253076553344727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined cost (promising for improvement)\n    def combined_cost(obj: Tuple[float, float]) -> float:\n        return obj[0] + obj[1]  # Simple sum, could be replaced with a weighted sum\n\n    # Sort solutions by combined cost in descending order\n    sorted_archive = sorted(archive, key=lambda x: combined_cost(x[1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure there's a segment to insert\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment-based perturbation (for intensification)\n    if n > 4:\n        # Select a random segment and reverse it\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicate nodes\"\n    assert len(new_solution) == n, \"Invalid solution: incorrect length\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined cost (promising for improvement)\n    def combined_cost(obj: Tuple[float, float]) -> float:\n        return obj[0] + obj[1]  # Simple sum, could be replaced with a weighted sum\n\n    # Sort solutions by combined cost in descending order\n    sorted_archive = sorted(archive, key=lambda x: combined_cost(x[1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure there's a segment to insert\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment-based perturbation (for intensification)\n    if n > 4:\n        # Select a random segment and reverse it\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicate nodes\"\n    assert len(new_solution) == n, \"Invalid solution: incorrect length\"\n\n    return new_solution\n\n",
        "score": [
            -0.979825472063792,
            0.5253076553344727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined cost (promising for improvement)\n    def combined_cost(obj: Tuple[float, float]) -> float:\n        return obj[0] + obj[1]  # Simple sum, could be replaced with a weighted sum\n\n    # Sort solutions by combined cost in descending order\n    sorted_archive = sorted(archive, key=lambda x: combined_cost(x[1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure there's a segment to insert\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment-based perturbation (for intensification)\n    if n > 4:\n        # Select a random segment and reverse it\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicate nodes\"\n    assert len(new_solution) == n, \"Invalid solution: incorrect length\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply 3-opt: reverse the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Novel edge-swap strategy: swap edges between non-adjacent segments\n    if b + 1 < n and c + 1 < n:\n        # Swap edges between [b+1, c] and [c+1, b+1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if infeasible\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8523302803511726,
            0.46479523181915283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply 3-opt: reverse the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Novel edge-swap strategy: swap edges between non-adjacent segments\n    if b + 1 < n and c + 1 < n:\n        # Swap edges between [b+1, c] and [c+1, b+1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if infeasible\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge Insertion + Segment Relocation\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to relocate\n    segment_start = random.randint(0, n - 2)\n    segment_length = random.randint(2, min(5, n // 2))\n    segment_end = min(segment_start + segment_length, n - 1)\n\n    segment = new_solution[segment_start:segment_end + 1]\n    remaining_nodes = np.setdiff1d(new_solution, segment)\n\n    # Step 2: Find the best insertion point for the segment\n    best_insertion = None\n    best_cost = float('inf')\n\n    for i in range(len(remaining_nodes) - 1):\n        # Try inserting the segment between remaining_nodes[i] and remaining_nodes[i+1]\n        candidate = np.concatenate([\n            remaining_nodes[:i+1],\n            segment,\n            remaining_nodes[i+1:]\n        ])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n\n        # Use a weighted sum to balance both objectives\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insertion = candidate.copy()\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n\n    # Step 3: Apply edge insertion for further optimization\n    for _ in range(2):  # Limit the number of edge insertions to prevent excessive computation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Remove edge (i, i+1) and (j, j+1)\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            # Calculate cost before\n            cost_before = distance_matrix_1[a, b] + distance_matrix_1[c, d] + \\\n                         distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n            # Calculate cost after\n            cost_after = distance_matrix_1[a, c] + distance_matrix_1[b, d] + \\\n                        distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n            if cost_after < cost_before:\n                # Perform the edge insertion\n                if i < j:\n                    new_segment = np.concatenate([new_solution[i+1:j+1], new_solution[i:i+1]])\n                    new_solution = np.concatenate([new_solution[:i+1], new_segment, new_solution[j+1:]])\n                else:\n                    new_segment = np.concatenate([new_solution[j+1:i+1], new_solution[j:j+1]])\n                    new_solution = np.concatenate([new_solution[:j+1], new_segment, new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9667567799987127,
            2.332785487174988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge Insertion + Segment Relocation\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to relocate\n    segment_start = random.randint(0, n - 2)\n    segment_length = random.randint(2, min(5, n // 2))\n    segment_end = min(segment_start + segment_length, n - 1)\n\n    segment = new_solution[segment_start:segment_end + 1]\n    remaining_nodes = np.setdiff1d(new_solution, segment)\n\n    # Step 2: Find the best insertion point for the segment\n    best_insertion = None\n    best_cost = float('inf')\n\n    for i in range(len(remaining_nodes) - 1):\n        # Try inserting the segment between remaining_nodes[i] and remaining_nodes[i+1]\n        candidate = np.concatenate([\n            remaining_nodes[:i+1],\n            segment,\n            remaining_nodes[i+1:]\n        ])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n\n        # Use a weighted sum to balance both objectives\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insertion = candidate.copy()\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n\n    # Step 3: Apply edge insertion for further optimization\n    for _ in range(2):  # Limit the number of edge insertions to prevent excessive computation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Remove edge (i, i+1) and (j, j+1)\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            # Calculate cost before\n            cost_before = distance_matrix_1[a, b] + distance_matrix_1[c, d] + \\\n                         distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n            # Calculate cost after\n            cost_after = distance_matrix_1[a, c] + distance_matrix_1[b, d] + \\\n                        distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n            if cost_after < cost_before:\n                # Perform the edge insertion\n                if i < j:\n                    new_segment = np.concatenate([new_solution[i+1:j+1], new_solution[i:i+1]])\n                    new_solution = np.concatenate([new_solution[:i+1], new_segment, new_solution[j+1:]])\n                else:\n                    new_segment = np.concatenate([new_solution[j+1:i+1], new_solution[j:j+1]])\n                    new_solution = np.concatenate([new_solution[:j+1], new_segment, new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated solutions)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swapping heuristic\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_segment = np.concatenate([segment2, segment1])\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:k] = new_segment\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution.copy()\n\n        # Novel edge-swapping heuristic\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = temp_solution[a:b+1][::-1]  # Reverse the segment\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) == n:\n            # Evaluate the new solution's quality\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost = cost1 + cost2\n\n            # Accept if improvement is found\n            if new_cost < sum(archive[selected_idx][1]):\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9053038862011489,
            1.2915884852409363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated solutions)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swapping heuristic\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_segment = np.concatenate([segment2, segment1])\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:k] = new_segment\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution.copy()\n\n        # Novel edge-swapping heuristic\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = temp_solution[a:b+1][::-1]  # Reverse the segment\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) == n:\n            # Evaluate the new solution's quality\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost = cost1 + cost2\n\n            # Accept if improvement is found\n            if new_cost < sum(archive[selected_idx][1]):\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with high variance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping with segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Randomly select two non-adjacent edges to swap (similar to 2-opt but more constrained)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Perform a segment relocation (move a segment to a different position)\n    k = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - k - 1))\n    segment = new_solution[k:k+segment_length]\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - segment_length)\n    if new_pos > k:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+segment_length:new_pos], segment, new_solution[new_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:k], new_solution[k+segment_length:]])\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8916949842661364,
            0.4515454173088074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with high variance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping with segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Randomly select two non-adjacent edges to swap (similar to 2-opt but more constrained)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Perform a segment relocation (move a segment to a different position)\n    k = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - k - 1))\n    segment = new_solution[k:k+segment_length]\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - segment_length)\n    if new_pos > k:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+segment_length:new_pos], segment, new_solution[new_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:k], new_solution[k+segment_length:]])\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with high variance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping with segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Randomly select two non-adjacent edges to swap (similar to 2-opt but more constrained)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Perform a segment relocation (move a segment to a different position)\n    k = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - k - 1))\n    segment = new_solution[k:k+segment_length]\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - segment_length)\n    if new_pos > k:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+segment_length:new_pos], segment, new_solution[new_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:k], new_solution[k+segment_length:]])\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8916949842661364,
            0.4515454173088074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with high variance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping with segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Randomly select two non-adjacent edges to swap (similar to 2-opt but more constrained)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Perform a segment relocation (move a segment to a different position)\n    k = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - k - 1))\n    segment = new_solution[k:k+segment_length]\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - segment_length)\n    if new_pos > k:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+segment_length:new_pos], segment, new_solution[new_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:k], new_solution[k+segment_length:]])\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on combined objective values\n    def objective_score(solution, objective):\n        return objective[0] + objective[1]  # Simple sum for selection, can be replaced with other criteria\n\n    scored_solutions = [(objective_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    selected_sol = scored_solutions[0][1].copy()\n\n    # Hybrid local search: combination of edge insertion and node relocation\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 1)\n    end = random.randint(0, n - 1)\n    if start > end:\n        start, end = end, start\n\n    # Extract the segment and reverse it (similar to 2-opt but with segment reversal)\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Apply node relocation with probability 0.5\n    if random.random() < 0.5:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates and all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8568962178252213,
            0.4677177667617798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on combined objective values\n    def objective_score(solution, objective):\n        return objective[0] + objective[1]  # Simple sum for selection, can be replaced with other criteria\n\n    scored_solutions = [(objective_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    selected_sol = scored_solutions[0][1].copy()\n\n    # Hybrid local search: combination of edge insertion and node relocation\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 1)\n    end = random.randint(0, n - 1)\n    if start > end:\n        start, end = end, start\n\n    # Extract the segment and reverse it (similar to 2-opt but with segment reversal)\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Apply node relocation with probability 0.5\n    if random.random() < 0.5:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates and all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge exchange (2-opt variant)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment relocation (novel approach)\n    if n > 4:\n        segment_length = random.randint(2, min(4, n // 2))\n        start = random.randint(1, n - segment_length - 1)\n        segment = new_solution[start:start + segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:], segment])\n\n    # Ensure feasibility\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        # If the solution is invalid, revert to the original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.30026769019146465,
            0.44599854946136475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge exchange (2-opt variant)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment relocation (novel approach)\n    if n > 4:\n        segment_length = random.randint(2, min(4, n // 2))\n        start = random.randint(1, n - segment_length - 1)\n        segment = new_solution[start:start + segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:], segment])\n\n    # Ensure feasibility\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        # If the solution is invalid, revert to the original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge exchange (2-opt variant)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment relocation (novel approach)\n    if n > 4:\n        segment_length = random.randint(2, min(4, n // 2))\n        start = random.randint(1, n - segment_length - 1)\n        segment = new_solution[start:start + segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:], segment])\n\n    # Ensure feasibility\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        # If the solution is invalid, revert to the original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.30026769019146465,
            0.44599854946136475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge exchange (2-opt variant)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment relocation (novel approach)\n    if n > 4:\n        segment_length = random.randint(2, min(4, n // 2))\n        start = random.randint(1, n - segment_length - 1)\n        segment = new_solution[start:start + segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:], segment])\n\n    # Ensure feasibility\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        # If the solution is invalid, revert to the original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # 3-opt for the first objective\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[b:c]\n    segment3 = base_solution[c:d]\n    new_segments = [\n        np.concatenate([segment1, segment2, segment3]),\n        np.concatenate([segment1, segment3, segment2]),\n        np.concatenate([segment2, segment1, segment3]),\n        np.concatenate([segment2, segment3, segment1]),\n        np.concatenate([segment3, segment1, segment2]),\n        np.concatenate([segment3, segment2, segment1])\n    ]\n    best_cost1 = float('inf')\n    best_segment = None\n    for seg in new_segments:\n        cost1 = sum(distance_matrix_1[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n        if cost1 < best_cost1:\n            best_cost1 = cost1\n            best_segment = seg\n\n    new_solution[a:d] = best_segment\n\n    # Segment inversion for the second objective\n    x, y = sorted(random.sample(range(n), 2))\n    new_solution[x:y] = new_solution[x:y][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7611620033346733,
            0.5869377851486206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # 3-opt for the first objective\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[b:c]\n    segment3 = base_solution[c:d]\n    new_segments = [\n        np.concatenate([segment1, segment2, segment3]),\n        np.concatenate([segment1, segment3, segment2]),\n        np.concatenate([segment2, segment1, segment3]),\n        np.concatenate([segment2, segment3, segment1]),\n        np.concatenate([segment3, segment1, segment2]),\n        np.concatenate([segment3, segment2, segment1])\n    ]\n    best_cost1 = float('inf')\n    best_segment = None\n    for seg in new_segments:\n        cost1 = sum(distance_matrix_1[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n        if cost1 < best_cost1:\n            best_cost1 = cost1\n            best_segment = seg\n\n    new_solution[a:d] = best_segment\n\n    # Segment inversion for the second objective\n    x, y = sorted(random.sample(range(n), 2))\n    new_solution[x:y] = new_solution[x:y][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    if len(archive) > 1:\n        # Sort solutions by the difference in objectives (higher difference indicates more potential)\n        archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n        # Select the top 30% of the archive\n        selected_archive = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select a solution from the top candidates\n        base_solution, _ = random.choice(selected_archive)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse segment\n\n    # Apply custom edge swap: swap two non-adjacent edges\n    if n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        if abs(a - b) > 1:  # Ensure edges are not adjacent\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.540601385268445,
            0.46216875314712524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    if len(archive) > 1:\n        # Sort solutions by the difference in objectives (higher difference indicates more potential)\n        archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n        # Select the top 30% of the archive\n        selected_archive = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select a solution from the top candidates\n        base_solution, _ = random.choice(selected_archive)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse segment\n\n    # Apply custom edge swap: swap two non-adjacent edges\n    if n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        if abs(a - b) > 1:  # Ensure edges are not adjacent\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = [i for i in range(1, min(5, len(sorted_archive)))]  # Avoid the best and worst solutions\n    selected_idx = random.choice(candidate_indices) if candidate_indices else 0\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge exchange\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Apply 3-opt-like move\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n        # Custom edge exchange: swap two non-adjacent edges\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8904431575535044,
            0.6276334524154663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = [i for i in range(1, min(5, len(sorted_archive)))]  # Avoid the best and worst solutions\n    selected_idx = random.choice(candidate_indices) if candidate_indices else 0\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge exchange\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Apply 3-opt-like move\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n        # Custom edge exchange: swap two non-adjacent edges\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    if np.all(costs == costs[0]):\n        # If all costs are equal, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Normalize costs to get probabilities\n        inv_costs = 1 / (costs + 1e-6)  # Add small epsilon to avoid division by zero\n        probs = inv_costs / np.sum(inv_costs)\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Hybrid local search strategy\n    # 1. Edge swap between two random edges\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment reversal for a random segment\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure validity (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8169875013649155,
            0.6250200867652893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    if np.all(costs == costs[0]):\n        # If all costs are equal, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Normalize costs to get probabilities\n        inv_costs = 1 / (costs + 1e-6)  # Add small epsilon to avoid division by zero\n        probs = inv_costs / np.sum(inv_costs)\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Hybrid local search strategy\n    # 1. Edge swap between two random edges\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment reversal for a random segment\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure validity (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (simplified approach)\n    dominance_scores = []\n    for i in range(len(archive_objectives)):\n        dominated = 0\n        for j in range(len(archive_objectives)):\n            if i != j and (archive_objectives[i][0] >= archive_objectives[j][0] and archive_objectives[i][1] >= archive_objectives[j][1]):\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    # Select a solution with the highest dominance score (more likely to be on Pareto frontier)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply a novel move: reverse a segment and insert it elsewhere\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the reversed segment at a random position\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler move if the novel move causes duplicates\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8954096527187334,
            1.8294348120689392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (simplified approach)\n    dominance_scores = []\n    for i in range(len(archive_objectives)):\n        dominated = 0\n        for j in range(len(archive_objectives)):\n            if i != j and (archive_objectives[i][0] >= archive_objectives[j][0] and archive_objectives[i][1] >= archive_objectives[j][1]):\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    # Select a solution with the highest dominance score (more likely to be on Pareto frontier)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply a novel move: reverse a segment and insert it elsewhere\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the reversed segment at a random position\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler move if the novel move causes duplicates\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_costs = objectives / objectives.sum(axis=0)\n    probabilities = 1.0 / (1.0 + normalized_costs.sum(axis=1))\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation\n    if n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.setdiff1d(new_solution, segment)\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if segment operation causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.796256041270157,
            0.5836270451545715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_costs = objectives / objectives.sum(axis=0)\n    probabilities = 1.0 / (1.0 + normalized_costs.sum(axis=1))\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation\n    if n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.setdiff1d(new_solution, segment)\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if segment operation causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: 3-opt with edge-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # 3-opt operation\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n\n    # Reconstruct the tour in different ways\n    options = [\n        np.concatenate([new_solution[:a], segment1, segment2, segment3, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment1, segment3, segment2, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment2, segment1, segment3, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment2, segment3, segment1, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment3, segment1, segment2, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment3, segment2, segment1, new_solution[d:]])\n    ]\n\n    # Evaluate all options based on both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    best_option = new_solution\n    best_cost1 = current_cost1\n    best_cost2 = current_cost2\n\n    for option in options:\n        cost1 = sum(distance_matrix_1[option[i], option[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n))\n\n        # Pareto dominance check\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n            best_option = option\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n    new_solution = best_option.copy()\n\n    # Edge-based perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance to perturb\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:  # Ensure non-adjacent nodes\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7327900895073417,
            1.0924575328826904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: 3-opt with edge-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # 3-opt operation\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n\n    # Reconstruct the tour in different ways\n    options = [\n        np.concatenate([new_solution[:a], segment1, segment2, segment3, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment1, segment3, segment2, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment2, segment1, segment3, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment2, segment3, segment1, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment3, segment1, segment2, new_solution[d:]]),\n        np.concatenate([new_solution[:a], segment3, segment2, segment1, new_solution[d:]])\n    ]\n\n    # Evaluate all options based on both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    best_option = new_solution\n    best_cost1 = current_cost1\n    best_cost2 = current_cost2\n\n    for option in options:\n        cost1 = sum(distance_matrix_1[option[i], option[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n))\n\n        # Pareto dominance check\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n            best_option = option\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n    new_solution = best_option.copy()\n\n    # Edge-based perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance to perturb\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:  # Ensure non-adjacent nodes\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reordering\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Perform a random 3-opt move\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reorder segments in a random but feasible way\n        order = np.random.permutation(4)\n        new_segments = [segment1, segment2, segment3, segment4]\n        new_solution = np.concatenate([new_segments[order[0]], new_segments[order[1]], new_segments[order[2]], new_segments[order[3]]])\n\n    # Step 2: Apply segment reordering based on distance matrices\n    if n >= 3:\n        # Identify the most critical segments based on both objectives\n        critical_segments = []\n        for i in range(n - 1):\n            node1, node2 = new_solution[i], new_solution[i+1]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n                critical_segments.append(i)\n\n        if critical_segments:\n            # Reverse a critical segment to improve both objectives\n            idx = np.random.choice(critical_segments)\n            new_solution[idx:idx+2] = new_solution[idx:idx+2][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.8029975015504219,
            1.0734931826591492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reordering\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Perform a random 3-opt move\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reorder segments in a random but feasible way\n        order = np.random.permutation(4)\n        new_segments = [segment1, segment2, segment3, segment4]\n        new_solution = np.concatenate([new_segments[order[0]], new_segments[order[1]], new_segments[order[2]], new_segments[order[3]]])\n\n    # Step 2: Apply segment reordering based on distance matrices\n    if n >= 3:\n        # Identify the most critical segments based on both objectives\n        critical_segments = []\n        for i in range(n - 1):\n            node1, node2 = new_solution[i], new_solution[i+1]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n                critical_segments.append(i)\n\n        if critical_segments:\n            # Reverse a critical segment to improve both objectives\n            idx = np.random.choice(critical_segments)\n            new_solution[idx:idx+2] = new_solution[idx:idx+2][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective (sum of both costs)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combine 2-opt with a custom edge swap\n    if n > 3:\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are non-overlapping and valid\n        if a != b and c != d and not (a <= c <= b and a <= d <= b):\n            # Swap segments to create a new tour\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[c:d+1],\n                new_solution[b+1:],\n                new_solution[a:b+1],\n                new_solution[d+1:]\n            ])\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                return new_solution\n\n    # Fallback to a simple edge swap if the hybrid operator fails\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.5075196303094127,
            0.11636900901794434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective (sum of both costs)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combine 2-opt with a custom edge swap\n    if n > 3:\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are non-overlapping and valid\n        if a != b and c != d and not (a <= c <= b and a <= d <= b):\n            # Swap segments to create a new tour\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[c:d+1],\n                new_solution[b+1:],\n                new_solution[a:b+1],\n                new_solution[d+1:]\n            ])\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                return new_solution\n\n    # Fallback to a simple edge swap if the hybrid operator fails\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective (sum of both costs)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combine 2-opt with a custom edge swap\n    if n > 3:\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are non-overlapping and valid\n        if a != b and c != d and not (a <= c <= b and a <= d <= b):\n            # Swap segments to create a new tour\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[c:d+1],\n                new_solution[b+1:],\n                new_solution[a:b+1],\n                new_solution[d+1:]\n            ])\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                return new_solution\n\n    # Fallback to a simple edge swap if the hybrid operator fails\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.5075196303094127,
            0.11636900901794434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective (sum of both costs)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combine 2-opt with a custom edge swap\n    if n > 3:\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are non-overlapping and valid\n        if a != b and c != d and not (a <= c <= b and a <= d <= b):\n            # Swap segments to create a new tour\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[c:d+1],\n                new_solution[b+1:],\n                new_solution[a:b+1],\n                new_solution[d+1:]\n            ])\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                return new_solution\n\n    # Fallback to a simple edge swap if the hybrid operator fails\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high-cost solutions)\n    candidates = [sol for sol, _ in archive if sol.size > 3]  # Ensure solution has enough nodes for meaningful changes\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    # Randomly select a solution with a bias towards higher-cost solutions\n    weights = [1 / (cost1 + cost2 + 1e-6) for _, (cost1, cost2) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: modified 3-opt + segment insertion\n    n = len(new_solution)\n    if n >= 4:\n        # Modified 3-opt: select 3 random segments and rearrange them\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Rearrange segments in a novel way (e.g., [segment1, segment3, segment2, segment4])\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n        # Segment insertion: insert a random segment elsewhere in the tour\n        if n >= 6:\n            d, e = sorted(random.sample(range(n), 2))\n            segment_insert = new_solution[d:e]\n            remaining = np.setdiff1d(new_solution, segment_insert)\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment_insert, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7165844751149786,
            0.4891042113304138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high-cost solutions)\n    candidates = [sol for sol, _ in archive if sol.size > 3]  # Ensure solution has enough nodes for meaningful changes\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    # Randomly select a solution with a bias towards higher-cost solutions\n    weights = [1 / (cost1 + cost2 + 1e-6) for _, (cost1, cost2) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: modified 3-opt + segment insertion\n    n = len(new_solution)\n    if n >= 4:\n        # Modified 3-opt: select 3 random segments and rearrange them\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Rearrange segments in a novel way (e.g., [segment1, segment3, segment2, segment4])\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n        # Segment insertion: insert a random segment elsewhere in the tour\n        if n >= 6:\n            d, e = sorted(random.sample(range(n), 2))\n            segment_insert = new_solution[d:e]\n            remaining = np.setdiff1d(new_solution, segment_insert)\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment_insert, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment of the tour\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = base_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([\n        base_solution[:segment_start],\n        base_solution[segment_start + segment_length:]\n    ])\n\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Step 3: Apply edge insertion to further improve the solution\n    for _ in range(2):  # Limit the number of edge insertions\n        i, j = random.sample(range(1, n - 1), 2)\n        if i > j:\n            i, j = j, i\n\n        # Check if insertion improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7482426147715878,
            0.45635801553726196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment of the tour\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = base_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([\n        base_solution[:segment_start],\n        base_solution[segment_start + segment_length:]\n    ])\n\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Step 3: Apply edge insertion to further improve the solution\n    for _ in range(2):  # Limit the number of edge insertions\n        i, j = random.sample(range(1, n - 1), 2)\n        if i > j:\n            i, j = j, i\n\n        # Check if insertion improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Choose a random segment of 3-5 nodes for 3-opt\n    n = len(selected_solution)\n    segment_size = random.randint(3, 5)\n    start = random.randint(0, n - segment_size - 1)\n    segment = selected_solution[start:start + segment_size]\n\n    # Rearrange the segment in a random order\n    random.shuffle(segment)\n    new_solution = np.concatenate([\n        selected_solution[:start],\n        segment,\n        selected_solution[start + segment_size:]\n    ])\n\n    # Apply segment relocation heuristic\n    # Randomly select two segments and swap them\n    if n >= 6:\n        split1 = random.randint(1, n // 2 - 1)\n        split2 = random.randint(split1 + 1, n - 1)\n        new_solution = np.concatenate([\n            selected_solution[:split1],\n            selected_solution[split2:],\n            selected_solution[split1:split2]\n        ])\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7810422188646724,
            0.451429545879364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Choose a random segment of 3-5 nodes for 3-opt\n    n = len(selected_solution)\n    segment_size = random.randint(3, 5)\n    start = random.randint(0, n - segment_size - 1)\n    segment = selected_solution[start:start + segment_size]\n\n    # Rearrange the segment in a random order\n    random.shuffle(segment)\n    new_solution = np.concatenate([\n        selected_solution[:start],\n        segment,\n        selected_solution[start + segment_size:]\n    ])\n\n    # Apply segment relocation heuristic\n    # Randomly select two segments and swap them\n    if n >= 6:\n        split1 = random.randint(1, n // 2 - 1)\n        split2 = random.randint(split1 + 1, n - 1)\n        new_solution = np.concatenate([\n            selected_solution[:split1],\n            selected_solution[split2:],\n            selected_solution[split1:split2]\n        ])\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt first\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply segment inversion with a novel twist\n    k, l = sorted(random.sample(range(n), 2))\n    if k != i and l != j:  # Ensure we're not just undoing the 2-opt\n        segment = new_solution[k:l+1]\n        inverted = segment[::-1]\n\n        # Novel twist: only invert if it improves at least one objective\n        current_cost1 = sum(distance_matrix_1[new_solution[m], new_solution[m+1]] for m in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[m], new_solution[m+1]] for m in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[k:l+1] = inverted\n        new_cost1 = sum(distance_matrix_1[temp_solution[m], temp_solution[m+1]] for m in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[m], temp_solution[m+1]] for m in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9330272679840562,
            0.5204085111618042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt first\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply segment inversion with a novel twist\n    k, l = sorted(random.sample(range(n), 2))\n    if k != i and l != j:  # Ensure we're not just undoing the 2-opt\n        segment = new_solution[k:l+1]\n        inverted = segment[::-1]\n\n        # Novel twist: only invert if it improves at least one objective\n        current_cost1 = sum(distance_matrix_1[new_solution[m], new_solution[m+1]] for m in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[m], new_solution[m+1]] for m in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[k:l+1] = inverted\n        new_cost1 = sum(distance_matrix_1[temp_solution[m], temp_solution[m+1]] for m in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[m], temp_solution[m+1]] for m in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their average cost (higher cost indicates more room for improvement)\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2, reverse=True)\n        # Select a solution from the top 30% with the highest cost\n        selected_idx = random.randint(0, max(1, len(sorted_solutions) // 3 - 1))\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 3-opt and edge insertion\n    if n >= 6:\n        # Randomly select 6 distinct positions to perform 3-opt\n        a, b, c, d, e, f = sorted(random.sample(range(n), 6))\n        # Apply 3-opt: reverse segments [b,c], [d,e], and [f,a] (with wrap-around)\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[d:e+1] = new_solution[d:e+1][::-1]\n        new_solution[f:] = new_solution[f:][::-1]\n        new_solution[:a+1] = new_solution[:a+1][::-1]\n    else:\n        # For small instances, use a simple edge insertion heuristic\n        if n >= 3:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            # Remove edge (i, i+1) and insert between (j, j+1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid TSP tour (no duplicates, all nodes visited)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution: duplicate nodes\"\n    assert len(new_solution) == instance.shape[0], \"Invalid solution: missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.90667006174363,
            0.49199575185775757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their average cost (higher cost indicates more room for improvement)\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2, reverse=True)\n        # Select a solution from the top 30% with the highest cost\n        selected_idx = random.randint(0, max(1, len(sorted_solutions) // 3 - 1))\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 3-opt and edge insertion\n    if n >= 6:\n        # Randomly select 6 distinct positions to perform 3-opt\n        a, b, c, d, e, f = sorted(random.sample(range(n), 6))\n        # Apply 3-opt: reverse segments [b,c], [d,e], and [f,a] (with wrap-around)\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[d:e+1] = new_solution[d:e+1][::-1]\n        new_solution[f:] = new_solution[f:][::-1]\n        new_solution[:a+1] = new_solution[:a+1][::-1]\n    else:\n        # For small instances, use a simple edge insertion heuristic\n        if n >= 3:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            # Remove edge (i, i+1) and insert between (j, j+1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid TSP tour (no duplicates, all nodes visited)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution: duplicate nodes\"\n    assert len(new_solution) == instance.shape[0], \"Invalid solution: missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto-optimal)\n    # Here, we select the solution with the highest sum of objectives (simplistic but effective)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node elsewhere in the tour\n    if n > 2:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.9602559798597341,
            0.4793880581855774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto-optimal)\n    # Here, we select the solution with the highest sum of objectives (simplistic but effective)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node elsewhere in the tour\n    if n > 2:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost in either objective)\n    archive.sort(key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 3-opt followed by segment relocation\n    n = len(new_solution)\n\n    # 3-opt local search\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        # Try all 8 possible 3-opt moves\n        for move in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            a, b, c = move\n            candidate = new_solution.copy()\n            candidate[a:b] = new_solution[b-1:a-1:-1]  # Reverse segment a to b-1\n            candidate[b:c] = new_solution[c-1:b-1:-1]  # Reverse segment b to c-1\n            # Evaluate both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            # Accept if both objectives improve\n            if (cost1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) and \\\n               (cost2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n                new_solution = candidate\n                break\n\n    # Segment relocation: randomly select a segment and relocate it\n    if n > 3:\n        seg_start = random.randint(1, n-2)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))  # Small segment size\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.43402494234083583,
            4.6866870522499084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost in either objective)\n    archive.sort(key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 3-opt followed by segment relocation\n    n = len(new_solution)\n\n    # 3-opt local search\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        # Try all 8 possible 3-opt moves\n        for move in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            a, b, c = move\n            candidate = new_solution.copy()\n            candidate[a:b] = new_solution[b-1:a-1:-1]  # Reverse segment a to b-1\n            candidate[b:c] = new_solution[c-1:b-1:-1]  # Reverse segment b to c-1\n            # Evaluate both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            # Accept if both objectives improve\n            if (cost1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) and \\\n               (cost2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n                new_solution = candidate\n                break\n\n    # Segment relocation: randomly select a segment and relocate it\n    if n > 3:\n        seg_start = random.randint(1, n-2)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))  # Small segment size\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (e.g., based on objective values)\n    improvement_potential = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Apply segment reversal to the selected segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8859455913501981,
            0.48895251750946045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (e.g., based on objective values)\n    improvement_potential = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Apply segment reversal to the selected segments\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic preference for non-dominated solutions\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Edge insertion (randomly select 3 nodes and insert between them)\n    i, j, k = random.sample(range(n), 3)\n    i, j = min(i, j), max(i, j)\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[k]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Segment relocation (move a random segment to a new position)\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, min(seg_start+2, n-1))  # Small segment\n    insert_pos = random.randint(0, n-1)\n    if insert_pos > seg_start:\n        insert_pos = insert_pos - (seg_end - seg_start)\n\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9738616562905615,
            0.19764524698257446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic preference for non-dominated solutions\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Edge insertion (randomly select 3 nodes and insert between them)\n    i, j, k = random.sample(range(n), 3)\n    i, j = min(i, j), max(i, j)\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[k]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Segment relocation (move a random segment to a new position)\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, min(seg_start+2, n-1))  # Small segment\n    insert_pos = random.randint(0, n-1)\n    if insert_pos > seg_start:\n        insert_pos = insert_pos - (seg_end - seg_start)\n\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy of the base solution to modify\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search\n    n = len(new_solution)\n\n    # Step 1: Edge swap (2-opt-like but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:  # 50% chance to perform segment reversal\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n        # Calculate the change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        # Only reverse if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Step 3: Node insertion (relocate a node to a better position)\n    if np.random.rand() < 0.3:  # 30% chance to perform node insertion\n        m = np.random.randint(n)\n        node = new_solution[m]\n        # Find the best insertion position that minimizes both objectives\n        best_pos = m\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == m or pos == (m - 1) % n:\n                continue\n\n            # Remove the node from its current position\n            temp_solution = np.delete(new_solution, m)\n            # Insert the node at the new position\n            temp_solution = np.insert(temp_solution, pos, node)\n\n            # Calculate the change in both objectives\n            # For simplicity, we approximate by checking the edges affected\n            # In a real implementation, you would calculate the full tour cost\n            old_edges = [\n                (new_solution[m-1], new_solution[m]),\n                (new_solution[m], new_solution[(m+1)%n])\n            ]\n            new_edges = [\n                (temp_solution[pos-1], temp_solution[pos]),\n                (temp_solution[pos], temp_solution[(pos+1)%n])\n            ]\n\n            old_cost1 = sum(distance_matrix_1[i, j] for i, j in old_edges)\n            new_cost1 = sum(distance_matrix_1[i, j] for i, j in new_edges)\n\n            old_cost2 = sum(distance_matrix_2[i, j] for i, j in old_edges)\n            new_cost2 = sum(distance_matrix_2[i, j] for i, j in new_edges)\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Apply the best insertion\n        if best_pos != m:\n            new_solution = np.delete(new_solution, m)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8820975785309948,
            0.9078143239021301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy of the base solution to modify\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search\n    n = len(new_solution)\n\n    # Step 1: Edge swap (2-opt-like but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:  # 50% chance to perform segment reversal\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n        # Calculate the change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        # Only reverse if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Step 3: Node insertion (relocate a node to a better position)\n    if np.random.rand() < 0.3:  # 30% chance to perform node insertion\n        m = np.random.randint(n)\n        node = new_solution[m]\n        # Find the best insertion position that minimizes both objectives\n        best_pos = m\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == m or pos == (m - 1) % n:\n                continue\n\n            # Remove the node from its current position\n            temp_solution = np.delete(new_solution, m)\n            # Insert the node at the new position\n            temp_solution = np.insert(temp_solution, pos, node)\n\n            # Calculate the change in both objectives\n            # For simplicity, we approximate by checking the edges affected\n            # In a real implementation, you would calculate the full tour cost\n            old_edges = [\n                (new_solution[m-1], new_solution[m]),\n                (new_solution[m], new_solution[(m+1)%n])\n            ]\n            new_edges = [\n                (temp_solution[pos-1], temp_solution[pos]),\n                (temp_solution[pos], temp_solution[(pos+1)%n])\n            ]\n\n            old_cost1 = sum(distance_matrix_1[i, j] for i, j in old_edges)\n            new_cost1 = sum(distance_matrix_1[i, j] for i, j in new_edges)\n\n            old_cost2 = sum(distance_matrix_2[i, j] for i, j in old_edges)\n            new_cost2 = sum(distance_matrix_2[i, j] for i, j in new_edges)\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Apply the best insertion\n        if best_pos != m:\n            new_solution = np.delete(new_solution, m)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank (better solutions have higher chance)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n <= 3:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With probability 0.7, perform edge insertion\n        if random.random() < 0.7:\n            # Select a random segment to remove and reinsert\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n            # Insert segment at a random position\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n        else:\n            # With probability 0.3, perform segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8511370796363605,
            0.5098575353622437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank (better solutions have higher chance)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n <= 3:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With probability 0.7, perform edge insertion\n        if random.random() < 0.7:\n            # Select a random segment to remove and reinsert\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n            # Insert segment at a random position\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n        else:\n            # With probability 0.3, perform segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between the two objectives (using Pareto optimality)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized objectives and select the solution with the best trade-off\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - np.min(normalized_objectives, axis=0)) / (np.max(normalized_objectives, axis=0) - np.min(normalized_objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    best_idx = np.argmin(scores)\n\n    base_solution = archive_solutions[best_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    n = len(new_solution)\n    if n >= 4:\n        # Randomly select three non-consecutive edges to perform 3-opt\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment inversion: invert a random segment of the tour\n    if n >= 3:\n        start, end = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no node is skipped or revisited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        i, j = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7214984387624953,
            0.6873041391372681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between the two objectives (using Pareto optimality)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized objectives and select the solution with the best trade-off\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - np.min(normalized_objectives, axis=0)) / (np.max(normalized_objectives, axis=0) - np.min(normalized_objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    best_idx = np.argmin(scores)\n\n    base_solution = archive_solutions[best_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    n = len(new_solution)\n    if n >= 4:\n        # Randomly select three non-consecutive edges to perform 3-opt\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment inversion: invert a random segment of the tour\n    if n >= 3:\n        start, end = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no node is skipped or revisited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        i, j = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the dominance count for each solution (simplified for bi-objective)\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                # Solution i is dominated by solution j if both objectives are worse\n                if (archive_objectives[i][0] >= archive_objectives[j][0] and\n                    archive_objectives[i][1] >= archive_objectives[j][1]):\n                    dominance_counts[i] += 1\n\n    # Select a solution with moderate dominance (not too many dominators, not too few)\n    candidate_indices = np.where((dominance_counts > 0) & (dominance_counts < len(archive) - 1))[0]\n    if len(candidate_indices) == 0:\n        # Fallback: select a random solution if no candidates found\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(candidate_indices)\n\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to reverse (similar to 2-opt but more flexible)\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Additional segment reversal for more exploration\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the tour remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7977582036343072,
            0.8251137137413025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the dominance count for each solution (simplified for bi-objective)\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                # Solution i is dominated by solution j if both objectives are worse\n                if (archive_objectives[i][0] >= archive_objectives[j][0] and\n                    archive_objectives[i][1] >= archive_objectives[j][1]):\n                    dominance_counts[i] += 1\n\n    # Select a solution with moderate dominance (not too many dominators, not too few)\n    candidate_indices = np.where((dominance_counts > 0) & (dominance_counts < len(archive) - 1))[0]\n    if len(candidate_indices) == 0:\n        # Fallback: select a random solution if no candidates found\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(candidate_indices)\n\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of 2-opt and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to reverse (similar to 2-opt but more flexible)\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Additional segment reversal for more exploration\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the tour remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (lowest total cost in either objective)\n    archive.sort(key=lambda x: min(x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b]\n\n    # Step 2: Apply partial route reversal (for diversity)\n    if np.random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Step 3: Relocate the segment to a new position\n    if np.random.random() < 0.5:\n        new_pos = np.random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n        new_solution = np.concatenate([new_solution[n - len(segment):], new_solution[:n - len(segment)]])\n\n    # Step 4: Edge swap within the segment (for fine-tuning)\n    if len(segment) > 1 and np.random.random() < 0.5:\n        i, j = sorted(np.random.choice(len(segment), size=2, replace=False))\n        segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If duplicates exist due to segment relocation, repair by reinserting missing nodes\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.3670484767370584,
            0.5844512581825256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (lowest total cost in either objective)\n    archive.sort(key=lambda x: min(x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b]\n\n    # Step 2: Apply partial route reversal (for diversity)\n    if np.random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Step 3: Relocate the segment to a new position\n    if np.random.random() < 0.5:\n        new_pos = np.random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n        new_solution = np.concatenate([new_solution[n - len(segment):], new_solution[:n - len(segment)]])\n\n    # Step 4: Edge swap within the segment (for fine-tuning)\n    if len(segment) > 1 and np.random.random() < 0.5:\n        i, j = sorted(np.random.choice(len(segment), size=2, replace=False))\n        segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If duplicates exist due to segment relocation, repair by reinserting missing nodes\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential based on objective values (lower is better)\n    potential = [1.0 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    total_potential = sum(potential)\n    probabilities = [p / total_potential for p in potential]\n\n    selected_idx = random.choices(range(len(solutions)), weights=probabilities, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to operate on\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and properly ordered\n    if i == k and j == l:\n        k, l = (k + 1) % n, (l + 1) % n\n\n    # Extract segments\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[k:l+1]\n\n    # Apply hybrid operation: reverse one segment and insert the other\n    if random.random() > 0.5:\n        segment1 = segment1[::-1]\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n    # Ensure feasibility by repairing the solution if necessary\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, reconstruct a valid tour\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes present)\n    new_solution = new_solution[:n]  # Trim if too long\n    new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])  # Add missing nodes\n\n    return new_solution\n\n",
        "score": [
            -0.6546351144854008,
            0.16380953788757324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential based on objective values (lower is better)\n    potential = [1.0 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    total_potential = sum(potential)\n    probabilities = [p / total_potential for p in potential]\n\n    selected_idx = random.choices(range(len(solutions)), weights=probabilities, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to operate on\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and properly ordered\n    if i == k and j == l:\n        k, l = (k + 1) % n, (l + 1) % n\n\n    # Extract segments\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[k:l+1]\n\n    # Apply hybrid operation: reverse one segment and insert the other\n    if random.random() > 0.5:\n        segment1 = segment1[::-1]\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n    # Ensure feasibility by repairing the solution if necessary\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, reconstruct a valid tour\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes present)\n    new_solution = new_solution[:n]  # Trim if too long\n    new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])  # Add missing nodes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        weights = [1.0 / (i + 1) for i in range(len(archive))]\n        total = sum(weights)\n        weights = [w / total for w in weights]\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Edge insertion: randomly select two edges and reconnect them\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have at least one node to insert\n        segment = new_solution[i+1:j]\n        new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Segment relocation: move a random segment to a new position\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Remove the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert the segment at a new position\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8913708418838273,
            0.469476580619812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        weights = [1.0 / (i + 1) for i in range(len(archive))]\n        total = sum(weights)\n        weights = [w / total for w in weights]\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Edge insertion: randomly select two edges and reconnect them\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have at least one node to insert\n        segment = new_solution[i+1:j]\n        new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Segment relocation: move a random segment to a new position\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Remove the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert the segment at a new position\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select from top 30% of solutions\n        top_k = max(1, int(0.3 * len(sorted_archive)))\n        selected = random.choice(sorted_archive[:top_k])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and segment inversion\n    if n > 3:\n        # Randomly choose two distinct segments\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        k, l = sorted(random.sample(range(1, n-1), 2))\n\n        # Apply 2-opt between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply segment inversion between k and l\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure the solution remains a valid tour\n        if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n            new_solution = base_solution.copy()\n    else:\n        # For small instances, just swap two nodes\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8058332924785363,
            0.497572660446167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select from top 30% of solutions\n        top_k = max(1, int(0.3 * len(sorted_archive)))\n        selected = random.choice(sorted_archive[:top_k])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and segment inversion\n    if n > 3:\n        # Randomly choose two distinct segments\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        k, l = sorted(random.sample(range(1, n-1), 2))\n\n        # Apply 2-opt between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply segment inversion between k and l\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure the solution remains a valid tour\n        if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n            new_solution = base_solution.copy()\n    else:\n        # For small instances, just swap two nodes\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine edge insertion with node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (similar to Lin-Kernighan but simplified)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]  # Reverse the segment\n\n    # Step 2: Node relocation with objective-aware selection\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        # Evaluate the move based on both objectives\n        old_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                     distance_matrix_1[new_solution[l], new_solution[(k+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                     distance_matrix_2[new_solution[l], new_solution[(k+1)%n]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            # Perform the move\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            if k < l:\n                l -= 1\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8508024303453812,
            0.5775135159492493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine edge insertion with node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (similar to Lin-Kernighan but simplified)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]  # Reverse the segment\n\n    # Step 2: Node relocation with objective-aware selection\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        # Evaluate the move based on both objectives\n        old_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                     distance_matrix_1[new_solution[l], new_solution[(k+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                     distance_matrix_2[new_solution[l], new_solution[(k+1)%n]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            # Perform the move\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            if k < l:\n                l -= 1\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy combining 3-opt and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments for 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Edge insertion: randomly select an edge and reinsert it\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operations fail\n        new_solution = selected_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9581681200818266,
            0.5506910681724548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy combining 3-opt and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments for 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Edge insertion: randomly select an edge and reinsert it\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], edge])\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operations fail\n        new_solution = selected_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel operator: swap a random segment with a reversed segment from another part of the tour\n    k, l = sorted(random.sample(range(n), 2))\n    while k == i and l == j:  # Ensure different segments\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Calculate the cost difference for both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, np.roll(solution, -1)):\n            cost += distance_matrix[a, b]\n        return cost\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Apply the novel operator\n    temp_solution = new_solution.copy()\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept the change if it improves at least one objective\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9863750720706844,
            0.5420678853988647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel operator: swap a random segment with a reversed segment from another part of the tour\n    k, l = sorted(random.sample(range(n), 2))\n    while k == i and l == j:  # Ensure different segments\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Calculate the cost difference for both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, np.roll(solution, -1)):\n            cost += distance_matrix[a, b]\n        return cost\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Apply the novel operator\n    temp_solution = new_solution.copy()\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept the change if it improves at least one objective\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel operator: swap a random segment with a reversed segment from another part of the tour\n    k, l = sorted(random.sample(range(n), 2))\n    while k == i and l == j:  # Ensure different segments\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Calculate the cost difference for both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, np.roll(solution, -1)):\n            cost += distance_matrix[a, b]\n        return cost\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Apply the novel operator\n    temp_solution = new_solution.copy()\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept the change if it improves at least one objective\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9863750720706844,
            0.5420678853988647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel operator: swap a random segment with a reversed segment from another part of the tour\n    k, l = sorted(random.sample(range(n), 2))\n    while k == i and l == j:  # Ensure different segments\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Calculate the cost difference for both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, np.roll(solution, -1)):\n            cost += distance_matrix[a, b]\n        return cost\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Apply the novel operator\n    temp_solution = new_solution.copy()\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept the change if it improves at least one objective\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Edge swapping (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    # Step 2: Segment relocation (novel operator)\n    if n > 4:\n        k = random.randint(2, min(5, n // 2))  # Relocate a small segment\n        start = random.randint(0, n - k - 1)\n        segment = new_solution[start:start + k]\n        insert_pos = random.randint(0, n - k)\n        if insert_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[start + k:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[start + k:]])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9118213857444202,
            0.42916446924209595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Edge swapping (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    # Step 2: Segment relocation (novel operator)\n    if n > 4:\n        k = random.randint(2, min(5, n // 2))  # Relocate a small segment\n        start = random.randint(0, n - k - 1)\n        segment = new_solution[start:start + k]\n        insert_pos = random.randint(0, n - k)\n        if insert_pos > start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[start + k:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[start + k:]])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance\n    selected_solution = None\n    min_dominance = float('inf')\n\n    for sol, obj in archive:\n        # Calculate dominance count (simplified)\n        dominance = sum(1 for s, o in archive if (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1]))\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for 3-opt\n\n    # Select three random edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate potential changes in both objectives\n    def calculate_delta(sol, a, b, c, d):\n        # Calculate change in objective 1\n        delta1 = (distance_matrix_1[sol[a], sol[b]] + distance_matrix_1[sol[c], sol[d]] -\n                 distance_matrix_1[sol[a], sol[c]] - distance_matrix_1[sol[b], sol[d]])\n\n        # Calculate change in objective 2\n        delta2 = (distance_matrix_2[sol[a], sol[b]] + distance_matrix_2[sol[c], sol[d]] -\n                 distance_matrix_2[sol[a], sol[c]] - distance_matrix_2[sol[b], sol[d]])\n\n        return delta1, delta2\n\n    # Try all possible 3-opt configurations\n    best_delta1, best_delta2 = float('inf'), float('inf')\n    best_config = None\n\n    # Configuration 1: Reconnect a-b, c-d\n    delta1, delta2 = calculate_delta(new_solution, i, j, k, (i+1)%n)\n    if delta1 < best_delta1 or (delta1 == best_delta1 and delta2 < best_delta2):\n        best_delta1, best_delta2 = delta1, delta2\n        best_config = (i, j, k, (i+1)%n, 1)\n\n    # Configuration 2: Reconnect a-c, b-d\n    delta1, delta2 = calculate_delta(new_solution, i, k, j, (i+1)%n)\n    if delta1 < best_delta1 or (delta1 == best_delta1 and delta2 < best_delta2):\n        best_delta1, best_delta2 = delta1, delta2\n        best_config = (i, k, j, (i+1)%n, 2)\n\n    # Apply the best configuration\n    if best_config:\n        i, j, k, l, config = best_config\n        if config == 1:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n        else:\n            new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8615767341625438,
            0.5271649360656738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance\n    selected_solution = None\n    min_dominance = float('inf')\n\n    for sol, obj in archive:\n        # Calculate dominance count (simplified)\n        dominance = sum(1 for s, o in archive if (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1]))\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for 3-opt\n\n    # Select three random edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate potential changes in both objectives\n    def calculate_delta(sol, a, b, c, d):\n        # Calculate change in objective 1\n        delta1 = (distance_matrix_1[sol[a], sol[b]] + distance_matrix_1[sol[c], sol[d]] -\n                 distance_matrix_1[sol[a], sol[c]] - distance_matrix_1[sol[b], sol[d]])\n\n        # Calculate change in objective 2\n        delta2 = (distance_matrix_2[sol[a], sol[b]] + distance_matrix_2[sol[c], sol[d]] -\n                 distance_matrix_2[sol[a], sol[c]] - distance_matrix_2[sol[b], sol[d]])\n\n        return delta1, delta2\n\n    # Try all possible 3-opt configurations\n    best_delta1, best_delta2 = float('inf'), float('inf')\n    best_config = None\n\n    # Configuration 1: Reconnect a-b, c-d\n    delta1, delta2 = calculate_delta(new_solution, i, j, k, (i+1)%n)\n    if delta1 < best_delta1 or (delta1 == best_delta1 and delta2 < best_delta2):\n        best_delta1, best_delta2 = delta1, delta2\n        best_config = (i, j, k, (i+1)%n, 1)\n\n    # Configuration 2: Reconnect a-c, b-d\n    delta1, delta2 = calculate_delta(new_solution, i, k, j, (i+1)%n)\n    if delta1 < best_delta1 or (delta1 == best_delta1 and delta2 < best_delta2):\n        best_delta1, best_delta2 = delta1, delta2\n        best_config = (i, k, j, (i+1)%n, 2)\n\n    # Apply the best configuration\n    if best_config:\n        i, j, k, l, config = best_config\n        if config == 1:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n        else:\n            new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with lower costs are more likely to be selected\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt: select three edges and attempt to reconnect them in a different order\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = base_solution[:i]\n        segment2 = base_solution[i:j]\n        segment3 = base_solution[j:k]\n        segment4 = base_solution[k:]\n\n        # Try all possible reconnections (6 permutations for 3 segments)\n        candidates = [\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4])\n        ]\n\n        # Evaluate all candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_candidate = candidate.copy()\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Novel edge insertion: try to insert a random node in a new position\n        node_to_move = random.choice(base_solution)\n        current_pos = np.where(base_solution == node_to_move)[0][0]\n        possible_positions = [i for i in range(n) if i != current_pos and i != (current_pos + 1) % n]\n\n        if possible_positions:\n            new_pos = random.choice(possible_positions)\n            new_solution = np.delete(base_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7585318546334769,
            0.8357142806053162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with lower costs are more likely to be selected\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt: select three edges and attempt to reconnect them in a different order\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = base_solution[:i]\n        segment2 = base_solution[i:j]\n        segment3 = base_solution[j:k]\n        segment4 = base_solution[k:]\n\n        # Try all possible reconnections (6 permutations for 3 segments)\n        candidates = [\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4])\n        ]\n\n        # Evaluate all candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_candidate = candidate.copy()\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Novel edge insertion: try to insert a random node in a new position\n        node_to_move = random.choice(base_solution)\n        current_pos = np.where(base_solution == node_to_move)[0][0]\n        possible_positions = [i for i in range(n) if i != current_pos and i != (current_pos + 1) % n]\n\n        if possible_positions:\n            new_pos = random.choice(possible_positions)\n            new_solution = np.delete(base_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [cost for _, cost in archive]\n\n    # Sort solutions by their cost in the first objective (can be adjusted for multi-objective)\n    sorted_indices = np.argsort([cost[0] for cost in archive_costs])\n    candidates = [archive_solutions[i] for i in sorted_indices[:max(1, len(archive) // 3)]]\n\n    # Randomly select a candidate solution\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    segment_start = random.randint(0, n - 2)\n    segment_length = random.randint(1, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Find the best insertion point for the segment\n    best_insertion = -1\n    min_delta_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        # Try inserting the segment after position i\n        candidate_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n        # Calculate the change in cost for both objectives\n        delta_cost1 = (sum(distance_matrix_1[candidate_solution[i-1], candidate_solution[i]] for i in range(1, len(candidate_solution)))\n                      + sum(distance_matrix_1[candidate_solution[i], candidate_solution[i+1]] for i in range(len(candidate_solution)-1))\n                      - sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n                      - sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)))\n\n        delta_cost2 = (sum(distance_matrix_2[candidate_solution[i-1], candidate_solution[i]] for i in range(1, len(candidate_solution)))\n                      + sum(distance_matrix_2[candidate_solution[i], candidate_solution[i+1]] for i in range(len(candidate_solution)-1))\n                      - sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n                      - sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)))\n\n        # Combine the deltas (can be adjusted for different weighting)\n        combined_delta = delta_cost1 + delta_cost2\n\n        if combined_delta < min_delta_cost:\n            min_delta_cost = combined_delta\n            best_insertion = i\n\n    # Insert the segment at the best position\n    if best_insertion != -1:\n        new_solution = np.concatenate([new_solution[:best_insertion], segment, new_solution[best_insertion:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n\n    assert len(set(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6049065192263342,
            10.369121789932251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [cost for _, cost in archive]\n\n    # Sort solutions by their cost in the first objective (can be adjusted for multi-objective)\n    sorted_indices = np.argsort([cost[0] for cost in archive_costs])\n    candidates = [archive_solutions[i] for i in sorted_indices[:max(1, len(archive) // 3)]]\n\n    # Randomly select a candidate solution\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    segment_start = random.randint(0, n - 2)\n    segment_length = random.randint(1, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Find the best insertion point for the segment\n    best_insertion = -1\n    min_delta_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        # Try inserting the segment after position i\n        candidate_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n        # Calculate the change in cost for both objectives\n        delta_cost1 = (sum(distance_matrix_1[candidate_solution[i-1], candidate_solution[i]] for i in range(1, len(candidate_solution)))\n                      + sum(distance_matrix_1[candidate_solution[i], candidate_solution[i+1]] for i in range(len(candidate_solution)-1))\n                      - sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n                      - sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)))\n\n        delta_cost2 = (sum(distance_matrix_2[candidate_solution[i-1], candidate_solution[i]] for i in range(1, len(candidate_solution)))\n                      + sum(distance_matrix_2[candidate_solution[i], candidate_solution[i+1]] for i in range(len(candidate_solution)-1))\n                      - sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n                      - sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)))\n\n        # Combine the deltas (can be adjusted for different weighting)\n        combined_delta = delta_cost1 + delta_cost2\n\n        if combined_delta < min_delta_cost:\n            min_delta_cost = combined_delta\n            best_insertion = i\n\n    # Insert the segment at the best position\n    if best_insertion != -1:\n        new_solution = np.concatenate([new_solution[:best_insertion], segment, new_solution[best_insertion:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n\n    assert len(set(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = [obj for _, obj in archive]\n    objective_variance = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Generate all possible 3-opt neighbors\n    neighbors = []\n    # Case 1: Reverse the segment between i and j, then between j and k\n    neighbor1 = new_solution.copy()\n    neighbor1[i:j+1] = neighbor1[i:j+1][::-1]\n    neighbor1[j:k+1] = neighbor1[j:k+1][::-1]\n    neighbors.append(neighbor1)\n\n    # Case 2: Reverse the segment between i and k, then between i and j\n    neighbor2 = new_solution.copy()\n    neighbor2[i:k+1] = neighbor2[i:k+1][::-1]\n    neighbor2[i:j+1] = neighbor2[i:j+1][::-1]\n    neighbors.append(neighbor2)\n\n    # Case 3: Reverse the segment between i and j, then between i and k\n    neighbor3 = new_solution.copy()\n    neighbor3[i:j+1] = neighbor3[i:j+1][::-1]\n    neighbor3[i:k+1] = neighbor3[i:k+1][::-1]\n    neighbors.append(neighbor3)\n\n    # Evaluate neighbors based on both objectives\n    best_neighbor = new_solution.copy()\n    best_score = np.sum([distance_matrix_1[new_solution[i], new_solution[i-1]] for i in range(n)]) + \\\n                 np.sum([distance_matrix_2[new_solution[i], new_solution[i-1]] for i in range(n)])\n\n    for neighbor in neighbors:\n        score = np.sum([distance_matrix_1[neighbor[i], neighbor[i-1]] for i in range(n)]) + \\\n                np.sum([distance_matrix_2[neighbor[i], neighbor[i-1]] for i in range(n)])\n        if score < best_score:\n            best_score = score\n            best_neighbor = neighbor.copy()\n\n    return best_neighbor\n\n",
        "score": [
            -0.6227445003260594,
            2.270543396472931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = [obj for _, obj in archive]\n    objective_variance = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Generate all possible 3-opt neighbors\n    neighbors = []\n    # Case 1: Reverse the segment between i and j, then between j and k\n    neighbor1 = new_solution.copy()\n    neighbor1[i:j+1] = neighbor1[i:j+1][::-1]\n    neighbor1[j:k+1] = neighbor1[j:k+1][::-1]\n    neighbors.append(neighbor1)\n\n    # Case 2: Reverse the segment between i and k, then between i and j\n    neighbor2 = new_solution.copy()\n    neighbor2[i:k+1] = neighbor2[i:k+1][::-1]\n    neighbor2[i:j+1] = neighbor2[i:j+1][::-1]\n    neighbors.append(neighbor2)\n\n    # Case 3: Reverse the segment between i and j, then between i and k\n    neighbor3 = new_solution.copy()\n    neighbor3[i:j+1] = neighbor3[i:j+1][::-1]\n    neighbor3[i:k+1] = neighbor3[i:k+1][::-1]\n    neighbors.append(neighbor3)\n\n    # Evaluate neighbors based on both objectives\n    best_neighbor = new_solution.copy()\n    best_score = np.sum([distance_matrix_1[new_solution[i], new_solution[i-1]] for i in range(n)]) + \\\n                 np.sum([distance_matrix_2[new_solution[i], new_solution[i-1]] for i in range(n)])\n\n    for neighbor in neighbors:\n        score = np.sum([distance_matrix_1[neighbor[i], neighbor[i-1]] for i in range(n)]) + \\\n                np.sum([distance_matrix_2[neighbor[i], neighbor[i-1]] for i in range(n)])\n        if score < best_score:\n            best_score = score\n            best_neighbor = neighbor.copy()\n\n    return best_neighbor\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto-optimal)\n    # Here, we select a solution with the highest total cost across both objectives\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        total_costs = objectives.sum(axis=1)\n        selected_idx = np.argmax(total_costs)\n        base_solution = candidates[selected_idx].copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Dynamic edge insertion: Insert a randomly selected node at a position that minimizes the increase in total cost\n    # 2. Segment relocation: Relocate a random segment of the tour to a new position that minimizes the increase in total cost\n\n    # Step 1: Dynamic edge insertion\n    if n > 3:\n        # Randomly select a node to insert\n        node_to_insert = random.choice(new_solution)\n\n        # Find the best insertion position that minimizes the increase in total cost\n        min_cost_increase = float('inf')\n        best_pos = -1\n\n        for i in range(n):\n            if i == 0:\n                # Insert at the beginning (after the last node)\n                cost_increase = (distance_matrix_1[new_solution[-1], node_to_insert] +\n                                distance_matrix_1[node_to_insert, new_solution[0]] -\n                                distance_matrix_1[new_solution[-1], new_solution[0]]) + \\\n                               (distance_matrix_2[new_solution[-1], node_to_insert] +\n                                distance_matrix_2[node_to_insert, new_solution[0]] -\n                                distance_matrix_2[new_solution[-1], new_solution[0]])\n            else:\n                # Insert between i-1 and i\n                cost_increase = (distance_matrix_1[new_solution[i-1], node_to_insert] +\n                                distance_matrix_1[node_to_insert, new_solution[i]] -\n                                distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n                               (distance_matrix_2[new_solution[i-1], node_to_insert] +\n                                distance_matrix_2[node_to_insert, new_solution[i]] -\n                                distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n            if cost_increase < min_cost_increase:\n                min_cost_increase = cost_increase\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove the node from its current position\n            current_pos = np.where(new_solution == node_to_insert)[0][0]\n            new_solution = np.delete(new_solution, current_pos)\n\n            # Insert the node at the best position\n            if best_pos == 0:\n                new_solution = np.insert(new_solution, 0, node_to_insert)\n            else:\n                new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Step 2: Segment relocation\n    if n > 4:\n        # Randomly select a segment length (2 to 4 nodes)\n        segment_length = random.randint(2, min(4, n // 2))\n\n        # Randomly select a starting position for the segment\n        start_pos = random.randint(0, n - segment_length - 1)\n\n        # Extract the segment\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Remove the segment from the solution\n        new_solution = np.delete(new_solution, np.s_[start_pos:start_pos + segment_length])\n\n        # Find the best position to insert the segment that minimizes the increase in total cost\n        min_cost_increase = float('inf')\n        best_pos = -1\n\n        for i in range(len(new_solution) - segment_length + 1):\n            if i == 0:\n                # Insert at the beginning (after the last node)\n                cost_increase = (distance_matrix_1[new_solution[-1], segment[0]] +\n                                distance_matrix_1[segment[-1], new_solution[0]] -\n                                distance_matrix_1[new_solution[-1], new_solution[0]]) + \\\n                               (distance_matrix_2[new_solution[-1], segment[0]] +\n                                distance_matrix_2[segment[-1], new_solution[0]] -\n                                distance_matrix_2[new_solution[-1], new_solution[0]])\n            else:\n                # Insert between i-1 and i\n                cost_increase = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                                distance_matrix_1[segment[-1], new_solution[i]] -\n                                distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n                               (distance_matrix_2[new_solution[i-1], segment[0]] +\n                                distance_matrix_2[segment[-1], new_solution[i]] -\n                                distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n            if cost_increase < min_cost_increase:\n                min_cost_increase = cost_increase\n                best_pos = i\n\n        if best_pos != -1:\n            # Insert the segment at the best position\n            if best_pos == 0:\n                new_solution = np.insert(new_solution, 0, segment)\n            else:\n                new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9677588399486656,
            0.7337580323219299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto-optimal)\n    # Here, we select a solution with the highest total cost across both objectives\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        total_costs = objectives.sum(axis=1)\n        selected_idx = np.argmax(total_costs)\n        base_solution = candidates[selected_idx].copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Dynamic edge insertion: Insert a randomly selected node at a position that minimizes the increase in total cost\n    # 2. Segment relocation: Relocate a random segment of the tour to a new position that minimizes the increase in total cost\n\n    # Step 1: Dynamic edge insertion\n    if n > 3:\n        # Randomly select a node to insert\n        node_to_insert = random.choice(new_solution)\n\n        # Find the best insertion position that minimizes the increase in total cost\n        min_cost_increase = float('inf')\n        best_pos = -1\n\n        for i in range(n):\n            if i == 0:\n                # Insert at the beginning (after the last node)\n                cost_increase = (distance_matrix_1[new_solution[-1], node_to_insert] +\n                                distance_matrix_1[node_to_insert, new_solution[0]] -\n                                distance_matrix_1[new_solution[-1], new_solution[0]]) + \\\n                               (distance_matrix_2[new_solution[-1], node_to_insert] +\n                                distance_matrix_2[node_to_insert, new_solution[0]] -\n                                distance_matrix_2[new_solution[-1], new_solution[0]])\n            else:\n                # Insert between i-1 and i\n                cost_increase = (distance_matrix_1[new_solution[i-1], node_to_insert] +\n                                distance_matrix_1[node_to_insert, new_solution[i]] -\n                                distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n                               (distance_matrix_2[new_solution[i-1], node_to_insert] +\n                                distance_matrix_2[node_to_insert, new_solution[i]] -\n                                distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n            if cost_increase < min_cost_increase:\n                min_cost_increase = cost_increase\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove the node from its current position\n            current_pos = np.where(new_solution == node_to_insert)[0][0]\n            new_solution = np.delete(new_solution, current_pos)\n\n            # Insert the node at the best position\n            if best_pos == 0:\n                new_solution = np.insert(new_solution, 0, node_to_insert)\n            else:\n                new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Step 2: Segment relocation\n    if n > 4:\n        # Randomly select a segment length (2 to 4 nodes)\n        segment_length = random.randint(2, min(4, n // 2))\n\n        # Randomly select a starting position for the segment\n        start_pos = random.randint(0, n - segment_length - 1)\n\n        # Extract the segment\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Remove the segment from the solution\n        new_solution = np.delete(new_solution, np.s_[start_pos:start_pos + segment_length])\n\n        # Find the best position to insert the segment that minimizes the increase in total cost\n        min_cost_increase = float('inf')\n        best_pos = -1\n\n        for i in range(len(new_solution) - segment_length + 1):\n            if i == 0:\n                # Insert at the beginning (after the last node)\n                cost_increase = (distance_matrix_1[new_solution[-1], segment[0]] +\n                                distance_matrix_1[segment[-1], new_solution[0]] -\n                                distance_matrix_1[new_solution[-1], new_solution[0]]) + \\\n                               (distance_matrix_2[new_solution[-1], segment[0]] +\n                                distance_matrix_2[segment[-1], new_solution[0]] -\n                                distance_matrix_2[new_solution[-1], new_solution[0]])\n            else:\n                # Insert between i-1 and i\n                cost_increase = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                                distance_matrix_1[segment[-1], new_solution[i]] -\n                                distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n                               (distance_matrix_2[new_solution[i-1], segment[0]] +\n                                distance_matrix_2[segment[-1], new_solution[i]] -\n                                distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n            if cost_increase < min_cost_increase:\n                min_cost_increase = cost_increase\n                best_pos = i\n\n        if best_pos != -1:\n            # Insert the segment at the best position\n            if best_pos == 0:\n                new_solution = np.insert(new_solution, 0, segment)\n            else:\n                new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with biased random swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt (choose 3 random segments and reorder them)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reorder segments to minimize the sum of distances in both objectives\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment2, segment1, segment3, segment4]),\n        np.concatenate([segment2, segment3, segment1, segment4]),\n        np.concatenate([segment3, segment1, segment2, segment4]),\n        np.concatenate([segment3, segment2, segment1, segment4])\n    ]\n\n    # Evaluate each candidate and select the best\n    best_candidate = None\n    best_cost = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_candidate = candidate.copy()\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    # Additional biased random swap (with probability based on solution quality)\n    if np.random.rand() < 0.3:  # Higher probability for worse solutions\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9404998393234508,
            1.0176275968551636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with biased random swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt (choose 3 random segments and reorder them)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reorder segments to minimize the sum of distances in both objectives\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment2, segment1, segment3, segment4]),\n        np.concatenate([segment2, segment3, segment1, segment4]),\n        np.concatenate([segment3, segment1, segment2, segment4]),\n        np.concatenate([segment3, segment2, segment1, segment4])\n    ]\n\n    # Evaluate each candidate and select the best\n    best_candidate = None\n    best_cost = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_candidate = candidate.copy()\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    # Additional biased random swap (with probability based on solution quality)\n    if np.random.rand() < 0.3:  # Higher probability for worse solutions\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    normalized_costs = objectives / np.max(objectives, axis=0)  # Normalize each objective\n    total_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (1 + total_costs)  # Higher cost -> lower probability\n    probabilities = probabilities / np.sum(probabilities)  # Normalize to sum to 1\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel edge insertion strategy\n    # Select a random segment to remove and reinsert\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Find the best insertion point for the segment\n    best_insertion = a\n    min_cost = float('inf')\n\n    for pos in range(len(remaining)):\n        candidate = np.insert(remaining, pos, segment)\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1))\n        cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Complete the tour\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1))\n        cost2 += distance_matrix_2[candidate[-1], candidate[0]]  # Complete the tour\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = pos\n\n    new_solution = np.insert(remaining, best_insertion, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8100955813825952,
            2.223726809024811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    normalized_costs = objectives / np.max(objectives, axis=0)  # Normalize each objective\n    total_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (1 + total_costs)  # Higher cost -> lower probability\n    probabilities = probabilities / np.sum(probabilities)  # Normalize to sum to 1\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel edge insertion strategy\n    # Select a random segment to remove and reinsert\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Find the best insertion point for the segment\n    best_insertion = a\n    min_cost = float('inf')\n\n    for pos in range(len(remaining)):\n        candidate = np.insert(remaining, pos, segment)\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1))\n        cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Complete the tour\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1))\n        cost2 += distance_matrix_2[candidate[-1], candidate[0]]  # Complete the tour\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = pos\n\n    new_solution = np.insert(remaining, best_insertion, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between segment reversal or node insertion based on random selection\n        if random.random() < 0.5:\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion: remove a node and reinsert it at a new position\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8650091084141103,
            0.4364585280418396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between segment reversal or node insertion based on random selection\n        if random.random() < 0.5:\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion: remove a node and reinsert it at a new position\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a solution with a high potential for improvement (e.g., not the best in both objectives)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized objectives to identify non-dominated or promising solutions\n    normalized_obj = np.array(objectives)\n    if len(normalized_obj) > 0:\n        normalized_obj = (normalized_obj - normalized_obj.min(axis=0)) / (normalized_obj.max(axis=0) - normalized_obj.min(axis=0) + 1e-10)\n        potential_scores = normalized_obj.sum(axis=1)  # Higher score means more potential for improvement\n        selected_idx = np.argmax(potential_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion followed by node swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    if k > i and k < j:\n        pass  # No change needed\n    else:\n        # Insert the edge (i, j) at position k\n        if k < i:\n            new_solution = np.concatenate([new_solution[:k], new_solution[i:j+1], new_solution[k:i], new_solution[j+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], new_solution[i:j+1], new_solution[k+1:]])\n\n    # Step 2: Node swap (swap two random nodes)\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8995328841178255,
            0.5477645397186279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a solution with a high potential for improvement (e.g., not the best in both objectives)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized objectives to identify non-dominated or promising solutions\n    normalized_obj = np.array(objectives)\n    if len(normalized_obj) > 0:\n        normalized_obj = (normalized_obj - normalized_obj.min(axis=0)) / (normalized_obj.max(axis=0) - normalized_obj.min(axis=0) + 1e-10)\n        potential_scores = normalized_obj.sum(axis=1)  # Higher score means more potential for improvement\n        selected_idx = np.argmax(potential_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion followed by node swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    if k > i and k < j:\n        pass  # No change needed\n    else:\n        # Insert the edge (i, j) at position k\n        if k < i:\n            new_solution = np.concatenate([new_solution[:k], new_solution[i:j+1], new_solution[k:i], new_solution[j+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], new_solution[i:j+1], new_solution[k+1:]])\n\n    # Step 2: Node swap (swap two random nodes)\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Sort solutions by their non-dominated rank (simplified for this example)\n    # In practice, use a proper Pareto front ranking method\n    sorted_indices = sorted(range(len(archive_objectives)), key=lambda i: np.sum(archive_objectives[i]))\n    selected_index = random.choice(sorted_indices[:max(1, len(sorted_indices) // 2)])  # Pick from top half\n    base_solution = archive_solutions[selected_index].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(1, n - 2), 2))\n    k, l = sorted(random.sample(range(1, n - 2), 2))\n\n    # Apply segment reversal between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment insertion at position k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, revert to a simpler 2-opt move\n        a, b = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7015901143552713,
            0.5539347529411316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Sort solutions by their non-dominated rank (simplified for this example)\n    # In practice, use a proper Pareto front ranking method\n    sorted_indices = sorted(range(len(archive_objectives)), key=lambda i: np.sum(archive_objectives[i]))\n    selected_index = random.choice(sorted_indices[:max(1, len(sorted_indices) // 2)])  # Pick from top half\n    base_solution = archive_solutions[selected_index].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(1, n - 2), 2))\n    k, l = sorted(random.sample(range(1, n - 2), 2))\n\n    # Apply segment reversal between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment insertion at position k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, revert to a simpler 2-opt move\n        a, b = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Edge Insertion + Segment Relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the strategy\n\n    # Step 1: Edge Insertion (randomly select two edges and insert one between the other)\n    i, j = sorted(random.sample(range(n), 2))\n    if i + 1 == j:  # Ensure they are not adjacent\n        j = (j + 1) % n\n\n    # Insert node at j between nodes at i and i+1\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Segment Relocation (move a random segment to a new position)\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))  # Small segment for efficiency\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Find a new position to insert the segment\n    new_pos = random.randint(0, n - (seg_end - seg_start + 1))\n    if new_pos > seg_start:\n        new_pos += (seg_end - seg_start + 1)\n\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:seg_start],\n        new_solution[seg_end+1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.8309312651249109,
            0.2767142057418823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Edge Insertion + Segment Relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the strategy\n\n    # Step 1: Edge Insertion (randomly select two edges and insert one between the other)\n    i, j = sorted(random.sample(range(n), 2))\n    if i + 1 == j:  # Ensure they are not adjacent\n        j = (j + 1) % n\n\n    # Insert node at j between nodes at i and i+1\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Segment Relocation (move a random segment to a new position)\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))  # Small segment for efficiency\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Find a new position to insert the segment\n    new_pos = random.randint(0, n - (seg_end - seg_start + 1))\n    if new_pos > seg_start:\n        new_pos += (seg_end - seg_start + 1)\n\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:seg_start],\n        new_solution[seg_end+1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on quality and diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate solution quality (inverse of objective values)\n    qualities = [1 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n\n    # Normalize qualities\n    total_quality = sum(qualities)\n    if total_quality > 0:\n        selection_probs = [q / total_quality for q in qualities]\n    else:\n        selection_probs = [1 / len(archive) for _ in range(len(archive))]\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (segment reversal)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select an edge to insert elsewhere (edge insertion)\n    if n > 3:\n        edge_idx = np.random.randint(0, n-1)\n        node_to_insert = new_solution[edge_idx]\n        remaining_nodes = [node for node in new_solution if node != node_to_insert]\n\n        # Find the best insertion point that minimizes both objectives\n        best_insert_pos = 0\n        min_cost = float('inf')\n\n        for i in range(len(remaining_nodes)):\n            test_solution = np.insert(remaining_nodes, i, node_to_insert)\n            cost1 = sum(distance_matrix_1[test_solution[j], test_solution[j+1]] for j in range(n-1)) + distance_matrix_1[test_solution[-1], test_solution[0]]\n            cost2 = sum(distance_matrix_2[test_solution[j], test_solution[j+1]] for j in range(n-1)) + distance_matrix_2[test_solution[-1], test_solution[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insert_pos = i\n\n        new_solution = np.insert(remaining_nodes, best_insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.8522314263299515,
            3.5429331064224243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on quality and diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate solution quality (inverse of objective values)\n    qualities = [1 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n\n    # Normalize qualities\n    total_quality = sum(qualities)\n    if total_quality > 0:\n        selection_probs = [q / total_quality for q in qualities]\n    else:\n        selection_probs = [1 / len(archive) for _ in range(len(archive))]\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (segment reversal)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select an edge to insert elsewhere (edge insertion)\n    if n > 3:\n        edge_idx = np.random.randint(0, n-1)\n        node_to_insert = new_solution[edge_idx]\n        remaining_nodes = [node for node in new_solution if node != node_to_insert]\n\n        # Find the best insertion point that minimizes both objectives\n        best_insert_pos = 0\n        min_cost = float('inf')\n\n        for i in range(len(remaining_nodes)):\n            test_solution = np.insert(remaining_nodes, i, node_to_insert)\n            cost1 = sum(distance_matrix_1[test_solution[j], test_solution[j+1]] for j in range(n-1)) + distance_matrix_1[test_solution[-1], test_solution[0]]\n            cost2 = sum(distance_matrix_2[test_solution[j], test_solution[j+1]] for j in range(n-1)) + distance_matrix_2[test_solution[-1], test_solution[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insert_pos = i\n\n        new_solution = np.insert(remaining_nodes, best_insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with high diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Hybrid local search strategy: combination of edge insertion and partial reversal\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to prevent excessive computation\n        # Randomly select two distinct segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Create a candidate solution by inserting segment [i:j+1] into position k\n        candidate = np.concatenate([new_solution[:k], new_solution[i:j+1], new_solution[k:]])\n\n        # If the candidate is longer than the original, truncate it\n        if len(candidate) > n:\n            candidate = candidate[:n]\n\n        # Calculate candidate costs\n        candidate_cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        candidate_cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Accept the candidate if it improves both objectives\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) and (candidate_cost1 < current_cost1 or candidate_cost2 < current_cost2):\n            new_solution = candidate.copy()\n            current_cost1, current_cost2 = candidate_cost1, candidate_cost2\n            break\n\n    # Additional local improvement: partial reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        reversed_segment = new_solution[i:j+1][::-1]\n        candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n        candidate_cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        candidate_cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) and (candidate_cost1 < current_cost1 or candidate_cost2 < current_cost2):\n            new_solution = candidate.copy()\n            current_cost1, current_cost2 = candidate_cost1, candidate_cost2\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.793566564256118,
            1.029576301574707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with high diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Hybrid local search strategy: combination of edge insertion and partial reversal\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to prevent excessive computation\n        # Randomly select two distinct segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Create a candidate solution by inserting segment [i:j+1] into position k\n        candidate = np.concatenate([new_solution[:k], new_solution[i:j+1], new_solution[k:]])\n\n        # If the candidate is longer than the original, truncate it\n        if len(candidate) > n:\n            candidate = candidate[:n]\n\n        # Calculate candidate costs\n        candidate_cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        candidate_cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Accept the candidate if it improves both objectives\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) and (candidate_cost1 < current_cost1 or candidate_cost2 < current_cost2):\n            new_solution = candidate.copy()\n            current_cost1, current_cost2 = candidate_cost1, candidate_cost2\n            break\n\n    # Additional local improvement: partial reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        reversed_segment = new_solution[i:j+1][::-1]\n        candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n        candidate_cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        candidate_cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) and (candidate_cost1 < current_cost1 or candidate_cost2 < current_cost2):\n            new_solution = candidate.copy()\n            current_cost1, current_cost2 = candidate_cost1, candidate_cost2\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    candidates = sorted(archive, key=lambda x: sum(x[1]), reverse=True)[:max(3, len(archive)//5)]\n    selected = random.choice(candidates)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: apply edge insertion with segment relocation\n    for _ in range(5):  # Number of attempts\n        # Randomly select a segment to relocate\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))  # Small segment for better exploration\n\n        segment = new_solution[seg_start:seg_end+1]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Find the best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(remaining)):\n            # Insert segment at position i\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%n]] for j in range(n))\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%n]] for j in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Apply the best insertion\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6100824554374834,
            13.350898802280426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    candidates = sorted(archive, key=lambda x: sum(x[1]), reverse=True)[:max(3, len(archive)//5)]\n    selected = random.choice(candidates)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: apply edge insertion with segment relocation\n    for _ in range(5):  # Number of attempts\n        # Randomly select a segment to relocate\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))  # Small segment for better exploration\n\n        segment = new_solution[seg_start:seg_end+1]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Find the best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(remaining)):\n            # Insert segment at position i\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%n]] for j in range(n))\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%n]] for j in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Apply the best insertion\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.max(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n    base_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[base_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    if (a <= c <= b and b <= d) or (c <= a <= d and d <= b):\n        # Overlapping segments: reverse one segment\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Non-overlapping segments: insert one segment into another\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:c], new_solution[d:]])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Insert missing nodes at random positions\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Trim to original length\n\n    return new_solution\n\n",
        "score": [
            -0.8500171689637672,
            0.2651442289352417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.max(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n    base_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[base_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    if (a <= c <= b and b <= d) or (c <= a <= d and d <= b):\n        # Overlapping segments: reverse one segment\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Non-overlapping segments: insert one segment into another\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:c], new_solution[d:]])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Insert missing nodes at random positions\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Trim to original length\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    base_solution = random.choices(archive, weights=probabilities, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap: swap two non-adjacent edges\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n        k = random.randint(j+1, n-1)\n        # Swap edges (i,j) and (j,k) with (i,k) and (j,j) (which is a no-op)\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Ensure the solution remains feasible (circular permutation)\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8814497860316438,
            0.4537450671195984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    base_solution = random.choices(archive, weights=probabilities, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap: swap two non-adjacent edges\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n        k = random.randint(j+1, n-1)\n        # Swap edges (i,j) and (j,k) with (i,k) and (j,j) (which is a no-op)\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Ensure the solution remains feasible (circular permutation)\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    fitness = 1 - normalized_obj.mean(axis=1)  # Higher fitness for solutions with better balanced objectives\n    selected_idx = np.random.choice(len(archive), p=fitness/fitness.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    if n >= 4:\n        # Select three random edges to modify (3-opt like)\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Create three possible 3-opt neighbors and select the best one\n        variants = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:j], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]])\n        ]\n\n        # Evaluate all variants based on both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        best_variant = new_solution\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for variant in variants:\n            cost1 = sum(distance_matrix_1[variant[i-1], variant[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[variant[i-1], variant[i]] for i in range(n))\n\n            # Use a weighted sum to balance both objectives\n            if 0.5 * cost1 + 0.5 * cost2 < 0.5 * best_cost1 + 0.5 * best_cost2:\n                best_variant = variant\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = best_variant\n\n        # Apply novel segment inversion (invert a random segment and insert elsewhere)\n        if n >= 5:\n            seg_start, seg_end = sorted(random.sample(range(1, n), 2))\n            segment = new_solution[seg_start:seg_end]\n            remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n            insert_pos = random.randint(0, len(remaining) - 1)\n            new_solution = np.concatenate([\n                remaining[:insert_pos],\n                segment[::-1],\n                remaining[insert_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6984910983266618,
            0.5044448375701904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    fitness = 1 - normalized_obj.mean(axis=1)  # Higher fitness for solutions with better balanced objectives\n    selected_idx = np.random.choice(len(archive), p=fitness/fitness.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    if n >= 4:\n        # Select three random edges to modify (3-opt like)\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Create three possible 3-opt neighbors and select the best one\n        variants = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:j], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]])\n        ]\n\n        # Evaluate all variants based on both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        best_variant = new_solution\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for variant in variants:\n            cost1 = sum(distance_matrix_1[variant[i-1], variant[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[variant[i-1], variant[i]] for i in range(n))\n\n            # Use a weighted sum to balance both objectives\n            if 0.5 * cost1 + 0.5 * cost2 < 0.5 * best_cost1 + 0.5 * best_cost2:\n                best_variant = variant\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = best_variant\n\n        # Apply novel segment inversion (invert a random segment and insert elsewhere)\n        if n >= 5:\n            seg_start, seg_end = sorted(random.sample(range(1, n), 2))\n            segment = new_solution[seg_start:seg_end]\n            remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n            insert_pos = random.randint(0, len(remaining) - 1)\n            new_solution = np.concatenate([\n                remaining[:insert_pos],\n                segment[::-1],\n                remaining[insert_pos:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select the non-dominated solution with the highest sum of objectives (most promising for improvement)\n        base_solution = max(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    if n >= 4:\n        # 3-opt move (select 3 random edges and reconnect them)\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a different order\n        new_segments = [segment1, segment2[::-1], segment3, segment4[::-1]]\n        new_solution = np.concatenate(new_segments)\n\n        # Custom edge-swap: swap two edges that are likely to improve both objectives\n        # Find two edges that are far in one space but close in the other\n        for _ in range(5):  # Try a few times to find a beneficial swap\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:  # Ensure they're not adjacent\n                # Calculate cost before and after swap\n                old_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n                old_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n                new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                            distance_matrix_1[new_solution[a], new_solution[b]])\n                new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                            distance_matrix_2[new_solution[a], new_solution[b]])\n\n                # If swap improves both objectives, accept it\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n                   (new_cost1 <= old_cost1 and new_cost2 <= old_cost2 and (new_cost1 < old_cost1 or new_cost2 < old_cost2)):\n                    new_solution[a:b] = new_solution[a:b][::-1]\n                    break\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7015790834160403,
            0.509422779083252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select the non-dominated solution with the highest sum of objectives (most promising for improvement)\n        base_solution = max(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    if n >= 4:\n        # 3-opt move (select 3 random edges and reconnect them)\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a different order\n        new_segments = [segment1, segment2[::-1], segment3, segment4[::-1]]\n        new_solution = np.concatenate(new_segments)\n\n        # Custom edge-swap: swap two edges that are likely to improve both objectives\n        # Find two edges that are far in one space but close in the other\n        for _ in range(5):  # Try a few times to find a beneficial swap\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:  # Ensure they're not adjacent\n                # Calculate cost before and after swap\n                old_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n                old_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n                new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                            distance_matrix_1[new_solution[a], new_solution[b]])\n                new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                            distance_matrix_2[new_solution[a], new_solution[b]])\n\n                # If swap improves both objectives, accept it\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n                   (new_cost1 <= old_cost1 and new_cost2 <= old_cost2 and (new_cost1 < old_cost1 or new_cost2 < old_cost2)):\n                    new_solution[a:b] = new_solution[a:b][::-1]\n                    break\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high-cost solutions)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combination of edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion (randomly select two edges and reconnect them)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Ensure valid insertion\n    if j - i > 1:\n        # Remove segment [i+1, j-1] and insert it after j\n        segment = new_solution[i+1:j].copy()\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if hybrid fails\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9905899174217774,
            0.4631327986717224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high-cost solutions)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combination of edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion (randomly select two edges and reconnect them)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Ensure valid insertion\n    if j - i > 1:\n        # Remove segment [i+1, j-1] and insert it after j\n        segment = new_solution[i+1:j].copy()\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if hybrid fails\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high-cost solutions)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combination of edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion (randomly select two edges and reconnect them)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Ensure valid insertion\n    if j - i > 1:\n        # Remove segment [i+1, j-1] and insert it after j\n        segment = new_solution[i+1:j].copy()\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if hybrid fails\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9905899174217774,
            0.4631327986717224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high-cost solutions)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combination of edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion (randomly select two edges and reconnect them)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Ensure valid insertion\n    if j - i > 1:\n        # Remove segment [i+1, j-1] and insert it after j\n        segment = new_solution[i+1:j].copy()\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if hybrid fails\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its total cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swapping with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine the search strategy based on the current solution's quality\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        avg_cost = (current_cost1 + current_cost2) / 2\n\n        # With some probability, perform a segment reversal (more disruptive)\n        if random.random() < 0.3 or avg_cost < np.mean([sum(obj) for _, obj in archive]):\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge swapping: swap two edges to maintain feasibility\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = random.randint(0, n-1)\n            # Swap nodes i and j\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6579246101645984,
            0.502304196357727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its total cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swapping with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine the search strategy based on the current solution's quality\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        avg_cost = (current_cost1 + current_cost2) / 2\n\n        # With some probability, perform a segment reversal (more disruptive)\n        if random.random() < 0.3 or avg_cost < np.mean([sum(obj) for _, obj in archive]):\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge swapping: swap two edges to maintain feasibility\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = random.randint(0, n-1)\n            # Swap nodes i and j\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = max(1, len(sorted_archive) // 5)\n    candidates = sorted_archive[:top_k]\n    selected_idx = np.random.choice(len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to modify\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Determine the best segment to reverse based on both objectives\n    def calculate_segment_cost(solution, i, j):\n        cost1 = distance_matrix_1[solution[i-1], solution[j]] + distance_matrix_1[solution[j], solution[i]]\n        cost2 = distance_matrix_2[solution[i-1], solution[j]] + distance_matrix_2[solution[j], solution[i]]\n        return cost1 + cost2\n\n    # Evaluate possible 3-opt moves\n    possible_moves = [\n        (a, b, c),  # Reverse segment a to b\n        (b, c, a),  # Reverse segment b to c\n        (a, c, b)   # Reverse segment a to c\n    ]\n\n    best_move = None\n    best_improvement = 0\n\n    for move in possible_moves:\n        i, j, k = move\n        # Calculate current cost of the segments\n        current_cost = (calculate_segment_cost(new_solution, i, j) +\n                        calculate_segment_cost(new_solution, j, k))\n\n        # Calculate new cost if we reverse the segment\n        new_cost = (calculate_segment_cost(new_solution, i, k) +\n                    calculate_segment_cost(new_solution, k, j))\n\n        improvement = current_cost - new_cost\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = move\n\n    if best_move is not None:\n        i, j, k = best_move\n        # Apply the best move\n        if i == a and j == b and k == c:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif i == b and j == c and k == a:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif i == a and j == c and k == b:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7169934240669515,
            0.5158405900001526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = max(1, len(sorted_archive) // 5)\n    candidates = sorted_archive[:top_k]\n    selected_idx = np.random.choice(len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to modify\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Determine the best segment to reverse based on both objectives\n    def calculate_segment_cost(solution, i, j):\n        cost1 = distance_matrix_1[solution[i-1], solution[j]] + distance_matrix_1[solution[j], solution[i]]\n        cost2 = distance_matrix_2[solution[i-1], solution[j]] + distance_matrix_2[solution[j], solution[i]]\n        return cost1 + cost2\n\n    # Evaluate possible 3-opt moves\n    possible_moves = [\n        (a, b, c),  # Reverse segment a to b\n        (b, c, a),  # Reverse segment b to c\n        (a, c, b)   # Reverse segment a to c\n    ]\n\n    best_move = None\n    best_improvement = 0\n\n    for move in possible_moves:\n        i, j, k = move\n        # Calculate current cost of the segments\n        current_cost = (calculate_segment_cost(new_solution, i, j) +\n                        calculate_segment_cost(new_solution, j, k))\n\n        # Calculate new cost if we reverse the segment\n        new_cost = (calculate_segment_cost(new_solution, i, k) +\n                    calculate_segment_cost(new_solution, k, j))\n\n        improvement = current_cost - new_cost\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = move\n\n    if best_move is not None:\n        i, j, k = best_move\n        # Apply the best move\n        if i == a and j == b and k == c:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif i == b and j == c and k == a:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif i == a and j == c and k == b:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance count\n    # (simplified: here we just pick one randomly with some bias towards better solutions)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate normalized objectives (for simplicity, we use min-max normalization)\n    obj1 = np.array([o[0] for o in objectives])\n    obj2 = np.array([o[1] for o in objectives])\n\n    obj1_norm = (obj1 - obj1.min()) / (obj1.max() - obj1.min() + 1e-8)\n    obj2_norm = (obj2 - obj2.min()) / (obj2.max() - obj2.min() + 1e-8)\n\n    # Combine objectives with equal weight (could be adjusted)\n    combined_scores = obj1_norm + obj2_norm\n\n    # Select solution with probability inversely proportional to its combined score\n    probabilities = 1.0 / (combined_scores + 1e-8)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt with a biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a biased 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 or j != n-1:  # Ensure we don't break the tour\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a biased random walk to explore more neighbors\n    for _ in range(2):  # Number of random walk steps\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7:  # Higher probability to accept the move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(unique_nodes), sorted(np.arange(n))):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9252122539508477,
            0.5457407236099243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance count\n    # (simplified: here we just pick one randomly with some bias towards better solutions)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate normalized objectives (for simplicity, we use min-max normalization)\n    obj1 = np.array([o[0] for o in objectives])\n    obj2 = np.array([o[1] for o in objectives])\n\n    obj1_norm = (obj1 - obj1.min()) / (obj1.max() - obj1.min() + 1e-8)\n    obj2_norm = (obj2 - obj2.min()) / (obj2.max() - obj2.min() + 1e-8)\n\n    # Combine objectives with equal weight (could be adjusted)\n    combined_scores = obj1_norm + obj2_norm\n\n    # Select solution with probability inversely proportional to its combined score\n    probabilities = 1.0 / (combined_scores + 1e-8)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt with a biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a biased 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 or j != n-1:  # Ensure we don't break the tour\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a biased random walk to explore more neighbors\n    for _ in range(2):  # Number of random walk steps\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7:  # Higher probability to accept the move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(unique_nodes), sorted(np.arange(n))):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Inverse of combined objective as weight\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:  # 50% chance for edge exchange\n        # Select two random edges to exchange\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:  # 50% chance for segment relocation\n        # Select a segment and insert it elsewhere\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(1, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure solution remains valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7455355828719056,
            0.5521119832992554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Inverse of combined objective as weight\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:  # 50% chance for edge exchange\n        # Select two random edges to exchange\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:  # 50% chance for segment relocation\n        # Select a segment and insert it elsewhere\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(1, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure solution remains valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Edge insertion + Segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 3)\n    segment_end = np.random.randint(segment_start + 2, n - 1)\n\n    # Reverse the segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    insert_pos = np.random.randint(0, n)\n    edge_start = np.random.randint(0, n)\n    edge_end = (edge_start + 1) % n\n\n    # Ensure the insertion maintains feasibility\n    if insert_pos != edge_start and insert_pos != edge_end:\n        # Remove the edge\n        new_solution = np.delete(new_solution, edge_start)\n        # Insert the edge at the new position\n        new_solution = np.insert(new_solution, insert_pos, selected_solution[edge_start])\n\n    return new_solution\n\n",
        "score": [
            -0.34941113426734055,
            0.37824827432632446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Edge insertion + Segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 3)\n    segment_end = np.random.randint(segment_start + 2, n - 1)\n\n    # Reverse the segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    insert_pos = np.random.randint(0, n)\n    edge_start = np.random.randint(0, n)\n    edge_end = (edge_start + 1) % n\n\n    # Ensure the insertion maintains feasibility\n    if insert_pos != edge_start and insert_pos != edge_end:\n        # Remove the edge\n        new_solution = np.delete(new_solution, edge_start)\n        # Insert the edge at the new position\n        new_solution = np.insert(new_solution, insert_pos, selected_solution[edge_start])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Edge swapping (similar to 2-opt but with a twist)\n    if np.random.rand() < 0.5:\n        # Swap two edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Reverse a segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9113862553960017,
            0.44654935598373413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Edge swapping (similar to 2-opt but with a twist)\n    if np.random.rand() < 0.5:\n        # Swap two edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Reverse a segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with probability proportional to its rank\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with probabilistic node selection\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful exchange possible\n\n    # Select a segment to exchange\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Select another segment to exchange with\n    other_start = random.randint(0, n - segment_length - 1)\n    while abs(other_start - start) < segment_length:\n        other_start = random.randint(0, n - segment_length - 1)\n    other_end = other_start + segment_length\n\n    # Perform the exchange\n    segment1 = new_solution[start:end]\n    segment2 = new_solution[other_start:other_end]\n\n    # Reverse one of the segments with probability 0.5\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Insert the segments\n    new_solution[start:end] = segment2\n    new_solution[other_start:other_end] = segment1\n\n    # Ensure the solution remains valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.688926339994772,
            3.0534921288490295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with probability proportional to its rank\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with probabilistic node selection\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful exchange possible\n\n    # Select a segment to exchange\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Select another segment to exchange with\n    other_start = random.randint(0, n - segment_length - 1)\n    while abs(other_start - start) < segment_length:\n        other_start = random.randint(0, n - segment_length - 1)\n    other_end = other_start + segment_length\n\n    # Perform the exchange\n    segment1 = new_solution[start:end]\n    segment2 = new_solution[other_start:other_end]\n\n    # Reverse one of the segments with probability 0.5\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Insert the segments\n    new_solution[start:end] = segment2\n    new_solution[other_start:other_end] = segment1\n\n    # Ensure the solution remains valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_obj = selected[1]\n\n    # Calculate the total cost in both objectives\n    total_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    total_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap\n    n = len(new_solution)\n    if n >= 4:\n        # Perform 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel edge-swap: try swapping edges between two segments\n        if n >= 6:\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            if b - a >= 2:\n                segment1 = new_solution[a:b]\n                segment2 = new_solution[b:]\n                new_solution = np.concatenate([new_solution[:a], segment2, segment1])\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Verify the solution is still a valid tour\n    if len(np.unique(new_solution)) != len(instance):\n        # If still invalid, return the original solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8042167349902761,
            0.5579317808151245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_obj = selected[1]\n\n    # Calculate the total cost in both objectives\n    total_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n    total_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%len(base_solution)]] for i in range(len(base_solution)))\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap\n    n = len(new_solution)\n    if n >= 4:\n        # Perform 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel edge-swap: try swapping edges between two segments\n        if n >= 6:\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            if b - a >= 2:\n                segment1 = new_solution[a:b]\n                segment2 = new_solution[b:]\n                new_solution = np.concatenate([new_solution[:a], segment2, segment1])\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Verify the solution is still a valid tour\n    if len(np.unique(new_solution)) != len(instance):\n        # If still invalid, return the original solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on the ratio of its objectives to the average\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for sol, obj in archive:\n        score = (obj[0] / avg_obj1) + (obj[1] / avg_obj2)\n        scores.append(score)\n\n    # Normalize scores to get probabilities\n    scores = np.array(scores)\n    probs = scores / np.sum(scores)\n\n    # Select a solution based on the calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply 3-opt with probability 0.7, otherwise apply segment relocation\n        if random.random() < 0.7:\n            # 3-opt: select three non-consecutive edges and reconnect them\n            a, b, c = sorted(random.sample(range(n), 3))\n            # Create new segments by reversing the middle segment\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        else:\n            # Segment relocation: move a segment of nodes to a different position\n            seg_length = random.randint(2, min(5, n // 2))\n            start = random.randint(0, n - seg_length - 1)\n            end = start + seg_length\n            segment = new_solution[start:end]\n\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Insert the segment at a new random position\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9027255770260159,
            0.4749215841293335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on the ratio of its objectives to the average\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for sol, obj in archive:\n        score = (obj[0] / avg_obj1) + (obj[1] / avg_obj2)\n        scores.append(score)\n\n    # Normalize scores to get probabilities\n    scores = np.array(scores)\n    probs = scores / np.sum(scores)\n\n    # Select a solution based on the calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply 3-opt with probability 0.7, otherwise apply segment relocation\n        if random.random() < 0.7:\n            # 3-opt: select three non-consecutive edges and reconnect them\n            a, b, c = sorted(random.sample(range(n), 3))\n            # Create new segments by reversing the middle segment\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        else:\n            # Segment relocation: move a segment of nodes to a different position\n            seg_length = random.randint(2, min(5, n // 2))\n            start = random.randint(0, n - seg_length - 1)\n            end = start + seg_length\n            segment = new_solution[start:end]\n\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Insert the segment at a new random position\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    probabilities = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose two distinct segments to exchange or invert\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply edge exchange (swap two edges)\n    if random.random() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    # Apply segment inversion (reverse a segment)\n    else:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.819912771789953,
            0.5365256667137146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    probabilities = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose two distinct segments to exchange or invert\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply edge exchange (swap two edges)\n    if random.random() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    # Apply segment inversion (reverse a segment)\n    else:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    probabilities = [1 - (cost / total_cost) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct indices\n    i, j, k = random.sample(range(n), 3)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment between i and j\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse segment between j and k\n\n    # Custom move: swap two nodes based on distance in both objective spaces\n    if random.random() < 0.5:\n        a, b = random.sample(range(n), 2)\n        # Calculate the change in both objective spaces\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_1[new_solution[b], new_solution[(a+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_2[new_solution[b], new_solution[(a+1)%n]])\n\n        # Only swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8075301279522695,
            0.6061962246894836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    probabilities = [1 - (cost / total_cost) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct indices\n    i, j, k = random.sample(range(n), 3)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment between i and j\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse segment between j and k\n\n    # Custom move: swap two nodes based on distance in both objective spaces\n    if random.random() < 0.5:\n        a, b = random.sample(range(n), 2)\n        # Calculate the change in both objective spaces\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_1[new_solution[b], new_solution[(a+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                 distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_2[new_solution[b], new_solution[(a+1)%n]])\n\n        # Only swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not dominated by others)\n    selected = archive[0][0].copy()\n    for sol, _ in archive[1:]:\n        if np.random.rand() < 0.3:  # Randomly select a solution with 30% chance\n            selected = sol.copy()\n            break\n\n    # Apply a hybrid local search operator: combination of swap and inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply a swap or inversion based on a random choice\n    if np.random.rand() < 0.5:\n        # Swap segments\n        segment = new_solution[i:j+1].copy()\n        np.random.shuffle(segment)\n        new_solution[i:j+1] = segment\n    else:\n        # Invert a segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for d in duplicates:\n        # Find missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        # Replace duplicates with missing nodes\n        mask = new_solution == d\n        new_solution[mask] = np.random.choice(missing, size=mask.sum(), replace=False)\n\n    return new_solution\n\n",
        "score": [
            -0.8938655422044296,
            0.6047495603561401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not dominated by others)\n    selected = archive[0][0].copy()\n    for sol, _ in archive[1:]:\n        if np.random.rand() < 0.3:  # Randomly select a solution with 30% chance\n            selected = sol.copy()\n            break\n\n    # Apply a hybrid local search operator: combination of swap and inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply a swap or inversion based on a random choice\n    if np.random.rand() < 0.5:\n        # Swap segments\n        segment = new_solution[i:j+1].copy()\n        np.random.shuffle(segment)\n        new_solution[i:j+1] = segment\n    else:\n        # Invert a segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for d in duplicates:\n        # Find missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        # Replace duplicates with missing nodes\n        mask = new_solution == d\n        new_solution[mask] = np.random.choice(missing, size=mask.sum(), replace=False)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 2.5-opt with insertion-based perturbation\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a random 2.5-opt (swap 5 edges)\n    indices = np.random.choice(N, size=5, replace=False)\n    indices.sort()\n    i, j, k, l, m = indices\n\n    # Create a new path by reconnecting the edges\n    new_path = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k],\n        new_solution[m:],\n        new_solution[l:j][::-1],\n        new_solution[k:l][::-1]\n    ])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_path)) == N:\n        new_solution = new_path\n\n    # Second, apply insertion-based perturbation with adaptive intensity\n    # Choose a segment to relocate based on distance matrix\n    segment_length = np.random.randint(2, min(5, N//2))\n    start_idx = np.random.randint(0, N - segment_length)\n    segment = new_solution[start_idx:start_idx+segment_length]\n\n    # Find the best insertion point based on combined distance\n    min_cost = float('inf')\n    best_pos = start_idx\n\n    for pos in range(0, N - segment_length + 1):\n        if pos == start_idx:\n            continue\n\n        # Calculate cost of inserting segment at this position\n        cost = 0\n        if pos > 0:\n            cost += distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_2[new_solution[pos-1], segment[0]]\n        if pos + segment_length < N:\n            cost += distance_matrix_1[segment[-1], new_solution[pos+segment_length]] + distance_matrix_2[segment[-1], new_solution[pos+segment_length]]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    # Perform the insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        segment,\n        new_solution[best_pos:start_idx],\n        new_solution[start_idx+segment_length:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.4627773961032155,
            0.3729780912399292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 2.5-opt with insertion-based perturbation\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a random 2.5-opt (swap 5 edges)\n    indices = np.random.choice(N, size=5, replace=False)\n    indices.sort()\n    i, j, k, l, m = indices\n\n    # Create a new path by reconnecting the edges\n    new_path = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k],\n        new_solution[m:],\n        new_solution[l:j][::-1],\n        new_solution[k:l][::-1]\n    ])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_path)) == N:\n        new_solution = new_path\n\n    # Second, apply insertion-based perturbation with adaptive intensity\n    # Choose a segment to relocate based on distance matrix\n    segment_length = np.random.randint(2, min(5, N//2))\n    start_idx = np.random.randint(0, N - segment_length)\n    segment = new_solution[start_idx:start_idx+segment_length]\n\n    # Find the best insertion point based on combined distance\n    min_cost = float('inf')\n    best_pos = start_idx\n\n    for pos in range(0, N - segment_length + 1):\n        if pos == start_idx:\n            continue\n\n        # Calculate cost of inserting segment at this position\n        cost = 0\n        if pos > 0:\n            cost += distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_2[new_solution[pos-1], segment[0]]\n        if pos + segment_length < N:\n            cost += distance_matrix_1[segment[-1], new_solution[pos+segment_length]] + distance_matrix_2[segment[-1], new_solution[pos+segment_length]]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    # Perform the insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        segment,\n        new_solution[best_pos:start_idx],\n        new_solution[start_idx+segment_length:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a biased random walk\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconstruct the tour with modified segments\n    # Try different combinations to find the best improvement\n    candidates = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4])\n    ]\n\n    # Evaluate candidates based on both objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1 + cost2  # Simple aggregation for selection\n\n    best_candidate = min(candidates, key=evaluate)\n\n    # Apply a biased random walk to escape local optima\n    if np.random.random() < 0.3:  # 30% chance to perform a random walk\n        l, m = sorted(np.random.choice(n, size=2, replace=False))\n        best_candidate[l:m+1] = best_candidate[l:m+1][::-1]\n\n    return best_candidate\n\n",
        "score": [
            -0.9388301736674605,
            0.7946103811264038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a biased random walk\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconstruct the tour with modified segments\n    # Try different combinations to find the best improvement\n    candidates = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4])\n    ]\n\n    # Evaluate candidates based on both objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1 + cost2  # Simple aggregation for selection\n\n    best_candidate = min(candidates, key=evaluate)\n\n    # Apply a biased random walk to escape local optima\n    if np.random.random() < 0.3:  # 30% chance to perform a random walk\n        l, m = sorted(np.random.choice(n, size=2, replace=False))\n        best_candidate[l:m+1] = best_candidate[l:m+1][::-1]\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on non-dominated solutions or random selection\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (simple heuristic)\n        normalized_objectives = np.array([(obj[0] / (obj[0] + obj[1]), obj[1] / (obj[0] + obj[1])) for _, obj in archive])\n        scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmin(scores)  # Select the solution with the best balance\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of 3-opt and edge exchange\n    for _ in range(10):  # Perform multiple iterations to explore the neighborhood\n        # Randomly select three distinct edges to modify\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move (reconnect the nodes to form a valid tour)\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:] if k != 0 else np.array([])\n\n        # Reconstruct the tour with the modified edges\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n        if len(segment3) > 0:\n            new_order = np.concatenate([new_order, [new_solution[0]]])\n\n        # Check if the new solution is valid (visits each node exactly once)\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order.copy()\n\n        # Apply edge exchange (swap two edges if it improves the solution)\n        if np.random.rand() < 0.5:  # 50% chance to perform edge exchange\n            a, b = np.random.choice(n, size=2, replace=False)\n            a, b = sorted([a, b])\n\n            # Swap edges (a, a+1) and (b, b+1)\n            new_order = new_solution.copy()\n            new_order[a], new_order[b] = new_solution[b], new_solution[a]\n\n            # Check if the new solution is valid\n            if len(np.unique(new_order)) == n:\n                new_solution = new_order.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7652298344140058,
            0.6550508737564087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on non-dominated solutions or random selection\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (simple heuristic)\n        normalized_objectives = np.array([(obj[0] / (obj[0] + obj[1]), obj[1] / (obj[0] + obj[1])) for _, obj in archive])\n        scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmin(scores)  # Select the solution with the best balance\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of 3-opt and edge exchange\n    for _ in range(10):  # Perform multiple iterations to explore the neighborhood\n        # Randomly select three distinct edges to modify\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move (reconnect the nodes to form a valid tour)\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:] if k != 0 else np.array([])\n\n        # Reconstruct the tour with the modified edges\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n        if len(segment3) > 0:\n            new_order = np.concatenate([new_order, [new_solution[0]]])\n\n        # Check if the new solution is valid (visits each node exactly once)\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order.copy()\n\n        # Apply edge exchange (swap two edges if it improves the solution)\n        if np.random.rand() < 0.5:  # 50% chance to perform edge exchange\n            a, b = np.random.choice(n, size=2, replace=False)\n            a, b = sorted([a, b])\n\n            # Swap edges (a, a+1) and (b, b+1)\n            new_order = new_solution.copy()\n            new_order[a], new_order[b] = new_solution[b], new_solution[a]\n\n            # Check if the new solution is valid\n            if len(np.unique(new_order)) == n:\n                new_solution = new_order.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:  # 50% chance for edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n    else:  # 50% chance for segment inversion with node relocation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            segment = segment[::-1]  # Invert the segment\n            new_solution[i:j] = segment\n\n            # Relocate one node from the segment to a random position\n            if len(segment) > 1:\n                relocate_node = random.choice(segment)\n                new_solution = np.delete(new_solution, np.where(new_solution == relocate_node)[0])\n                insert_pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, insert_pos, relocate_node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, repair by replacing them with missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            if missing:\n                idx = np.where(new_solution == dup)[0][0]\n                new_solution[idx] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.7699925315740027,
            0.5041045546531677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:  # 50% chance for edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n    else:  # 50% chance for segment inversion with node relocation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            segment = segment[::-1]  # Invert the segment\n            new_solution[i:j] = segment\n\n            # Relocate one node from the segment to a random position\n            if len(segment) > 1:\n                relocate_node = random.choice(segment)\n                new_solution = np.delete(new_solution, np.where(new_solution == relocate_node)[0])\n                insert_pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, insert_pos, relocate_node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, repair by replacing them with missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            if missing:\n                idx = np.where(new_solution == dup)[0][0]\n                new_solution[idx] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and reinsert it at a different position\n    if n > 3:\n        node_pos = np.random.randint(1, n - 1)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Reinsert the node at a new random position\n        insert_pos = np.random.randint(1, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment reversal: reverse a random segment of the tour\n    if n > 4:\n        start = np.random.randint(1, n - 2)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7949099147863468,
            0.520336925983429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and reinsert it at a different position\n    if n > 3:\n        node_pos = np.random.randint(1, n - 1)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Reinsert the node at a new random position\n        insert_pos = np.random.randint(1, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment reversal: reverse a random segment of the tour\n    if n > 4:\n        start = np.random.randint(1, n - 2)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives to avoid bias towards larger scales\n        normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-10)\n        # Calculate diversity score (distance from centroid)\n        diversity = np.linalg.norm(normalized, axis=1)\n        # Select based on inverse diversity (prioritize less explored regions)\n        probabilities = 1 / (diversity + 1e-10)\n        probabilities = probabilities / probabilities.sum()\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply local search\n\n    # Step 1: Edge insertion (remove and reinsert a random edge)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Remove edge (i, i+1) and insert between (j, j+1)\n        removed_segment = [new_solution[i], new_solution[(i+1)%n]]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, removed_segment[0])\n\n    # Step 2: Segment relocation (move a random segment to a new position)\n    segment_length = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8811725186824478,
            0.5852310657501221
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives to avoid bias towards larger scales\n        normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-10)\n        # Calculate diversity score (distance from centroid)\n        diversity = np.linalg.norm(normalized, axis=1)\n        # Select based on inverse diversity (prioritize less explored regions)\n        probabilities = 1 / (diversity + 1e-10)\n        probabilities = probabilities / probabilities.sum()\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply local search\n\n    # Step 1: Edge insertion (remove and reinsert a random edge)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Remove edge (i, i+1) and insert between (j, j+1)\n        removed_segment = [new_solution[i], new_solution[(i+1)%n]]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, removed_segment[0])\n\n    # Step 2: Segment relocation (move a random segment to a new position)\n    segment_length = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high cost or diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Perform 3-opt on the selected segments\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel segment relocation: Move a random segment to a new position\n    if np.random.rand() < 0.5:  # 50% chance to apply this\n        segment_size = np.random.randint(2, min(5, n//2))  # Random segment size\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8071087569981407,
            0.5952605605125427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high cost or diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Perform 3-opt on the selected segments\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel segment relocation: Move a random segment to a new position\n    if np.random.rand() < 0.5:  # 50% chance to apply this\n        segment_size = np.random.randint(2, min(5, n//2))  # Random segment size\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # Solutions with lower costs are less likely to be selected\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three non-adjacent edges\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    k = random.randint(0, n-1)\n    while (abs(i-j) < 2 or abs(i-k) < 2 or abs(j-k) < 2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n\n    # Ensure order: i < j < k\n    indices = sorted([i, j, k])\n    i, j, k = indices\n\n    # Step 2: Apply 3-opt-like move\n    # Create three possible variants and choose the best one\n    variants = [\n        new_solution.copy(),\n        np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[k+1:], new_solution[i+1:j]]),\n        np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[k+1:], new_solution[j+1:i]]),\n        np.concatenate([new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]])\n    ]\n\n    # Evaluate variants based on both objectives\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        return cost1 + cost2\n\n    best_variant = min(variants, key=evaluate)\n\n    # Step 3: Apply novel edge exchange if beneficial\n    # Select two random edges and attempt to exchange them\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Create edge exchange variant\n    edge_exchange_variant = new_solution.copy()\n    edge_exchange_variant[a:b+1] = edge_exchange_variant[a:b+1][::-1]\n    edge_exchange_variant[c:d+1] = edge_exchange_variant[c:d+1][::-1]\n\n    # Compare with best variant\n    if evaluate(edge_exchange_variant) < evaluate(best_variant):\n        best_variant = edge_exchange_variant\n\n    return best_variant\n\n",
        "score": [
            -0.9174789568531104,
            1.1150500178337097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # Solutions with lower costs are less likely to be selected\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three non-adjacent edges\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    k = random.randint(0, n-1)\n    while (abs(i-j) < 2 or abs(i-k) < 2 or abs(j-k) < 2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n\n    # Ensure order: i < j < k\n    indices = sorted([i, j, k])\n    i, j, k = indices\n\n    # Step 2: Apply 3-opt-like move\n    # Create three possible variants and choose the best one\n    variants = [\n        new_solution.copy(),\n        np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[k+1:], new_solution[i+1:j]]),\n        np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[k+1:], new_solution[j+1:i]]),\n        np.concatenate([new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:k+1][::-1], new_solution[k+1:]])\n    ]\n\n    # Evaluate variants based on both objectives\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        return cost1 + cost2\n\n    best_variant = min(variants, key=evaluate)\n\n    # Step 3: Apply novel edge exchange if beneficial\n    # Select two random edges and attempt to exchange them\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Create edge exchange variant\n    edge_exchange_variant = new_solution.copy()\n    edge_exchange_variant[a:b+1] = edge_exchange_variant[a:b+1][::-1]\n    edge_exchange_variant[c:d+1] = edge_exchange_variant[c:d+1][::-1]\n\n    # Compare with best variant\n    if evaluate(edge_exchange_variant) < evaluate(best_variant):\n        best_variant = edge_exchange_variant\n\n    return best_variant\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., solutions with higher costs)\n    candidates = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))  # Sort by total cost in descending order\n    selected_solution = random.choice(candidates[:max(1, len(candidates)//3)])[0].copy()  # Select from top 1/3\n\n    # Hybrid local search operator: 3-opt with biased edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply a biased 3-opt move based on distance matrices\n    def compute_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1, cost2\n\n    current_cost = compute_cost(new_solution)\n\n    # Try all possible 3-opt configurations and keep the best one\n    best_cost = current_cost\n    best_solution = new_solution.copy()\n\n    # Generate all possible 3-opt neighbors\n    for a, b, c in [(i, j, k), (i, k, j)]:\n        candidate = new_solution.copy()\n        candidate[a:b] = np.flip(candidate[a:b])\n        candidate[b:c] = np.flip(candidate[b:c])\n\n        new_cost = compute_cost(candidate)\n        if new_cost[0] + new_cost[1] < best_cost[0] + best_cost[1]:\n            best_cost = new_cost\n            best_solution = candidate.copy()\n\n    return best_solution\n\n",
        "score": [
            -0.9668858789044172,
            0.6090154051780701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., solutions with higher costs)\n    candidates = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))  # Sort by total cost in descending order\n    selected_solution = random.choice(candidates[:max(1, len(candidates)//3)])[0].copy()  # Select from top 1/3\n\n    # Hybrid local search operator: 3-opt with biased edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply a biased 3-opt move based on distance matrices\n    def compute_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1, cost2\n\n    current_cost = compute_cost(new_solution)\n\n    # Try all possible 3-opt configurations and keep the best one\n    best_cost = current_cost\n    best_solution = new_solution.copy()\n\n    # Generate all possible 3-opt neighbors\n    for a, b, c in [(i, j, k), (i, k, j)]:\n        candidate = new_solution.copy()\n        candidate[a:b] = np.flip(candidate[a:b])\n        candidate[b:c] = np.flip(candidate[b:c])\n\n        new_cost = compute_cost(candidate)\n        if new_cost[0] + new_cost[1] < best_cost[0] + best_cost[1]:\n            best_cost = new_cost\n            best_solution = candidate.copy()\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance\n    # Higher probability for solutions with lower costs in both objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_costs = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    dominance_scores = normalized_costs[:, 0] + normalized_costs[:, 1]\n    probabilities = 1.0 / (dominance_scores + 1e-10)  # Inverse dominance\n    probabilities = probabilities / probabilities.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swapping strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select 3 distinct edges to modify (3-opt variant)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Step 2: Apply a novel edge-swapping strategy\n    # Swap edges (i,j) and (k,l) with (i,k) and (j,l) if it improves both objectives\n    l = (i + 1) % n if (i + 1) % n != j else (i + 2) % n\n    if l == k:\n        l = (l + 1) % n\n\n    # Calculate the change in both objectives\n    delta_1 = (distance_matrix_1[base_solution[i-1], base_solution[k]] +\n               distance_matrix_1[base_solution[j], base_solution[l]] -\n               distance_matrix_1[base_solution[i-1], base_solution[j]] -\n               distance_matrix_1[base_solution[k], base_solution[l]])\n\n    delta_2 = (distance_matrix_2[base_solution[i-1], base_solution[k]] +\n               distance_matrix_2[base_solution[j], base_solution[l]] -\n               distance_matrix_2[base_solution[i-1], base_solution[j]] -\n               distance_matrix_2[base_solution[k], base_solution[l]])\n\n    # Only apply if both objectives improve\n    if delta_1 < 0 and delta_2 < 0:\n        # Perform the swap\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n    else:\n        # Fallback to standard 3-opt move\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8377990803810242,
            0.5391973257064819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance\n    # Higher probability for solutions with lower costs in both objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_costs = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    dominance_scores = normalized_costs[:, 0] + normalized_costs[:, 1]\n    probabilities = 1.0 / (dominance_scores + 1e-10)  # Inverse dominance\n    probabilities = probabilities / probabilities.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swapping strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select 3 distinct edges to modify (3-opt variant)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Step 2: Apply a novel edge-swapping strategy\n    # Swap edges (i,j) and (k,l) with (i,k) and (j,l) if it improves both objectives\n    l = (i + 1) % n if (i + 1) % n != j else (i + 2) % n\n    if l == k:\n        l = (l + 1) % n\n\n    # Calculate the change in both objectives\n    delta_1 = (distance_matrix_1[base_solution[i-1], base_solution[k]] +\n               distance_matrix_1[base_solution[j], base_solution[l]] -\n               distance_matrix_1[base_solution[i-1], base_solution[j]] -\n               distance_matrix_1[base_solution[k], base_solution[l]])\n\n    delta_2 = (distance_matrix_2[base_solution[i-1], base_solution[k]] +\n               distance_matrix_2[base_solution[j], base_solution[l]] -\n               distance_matrix_2[base_solution[i-1], base_solution[j]] -\n               distance_matrix_2[base_solution[k], base_solution[l]])\n\n    # Only apply if both objectives improve\n    if delta_1 < 0 and delta_2 < 0:\n        # Perform the swap\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n    else:\n        # Fallback to standard 3-opt move\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographic order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (3-opt like operation)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Apply a node swap between two non-adjacent segments\n    if n >= 6:\n        c, d = sorted(random.sample(range(n), 2))\n        while abs(c - d) <= 1:  # Ensure non-adjacent\n            c, d = sorted(random.sample(range(n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Step 3: Edge relocation (like in Lin-Kernighan)\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 and j != n-1:\n        # Move segment [i:j] to position k\n        segment = new_solution[i:j]\n        k = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6470723789631576,
            0.16770100593566895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographic order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (3-opt like operation)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Apply a node swap between two non-adjacent segments\n    if n >= 6:\n        c, d = sorted(random.sample(range(n), 2))\n        while abs(c - d) <= 1:  # Ensure non-adjacent\n            c, d = sorted(random.sample(range(n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Step 3: Edge relocation (like in Lin-Kernighan)\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 and j != n-1:\n        # Move segment [i:j] to position k\n        segment = new_solution[i:j]\n        k = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    weights = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Perform 3-opt move\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[j:k] = base_solution[j:k][::-1]\n\n    # Custom edge-swap strategy for bi-objective optimization\n    for _ in range(2):  # Perform a few edge swaps\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        # Evaluate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 and new_cost2 <= 1.1 * old_cost2) or \\\n           (new_cost2 < old_cost2 and new_cost1 <= 1.1 * old_cost1):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8998551963249937,
            0.5102596879005432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    weights = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Perform 3-opt move\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[j:k] = base_solution[j:k][::-1]\n\n    # Custom edge-swap strategy for bi-objective optimization\n    for _ in range(2):  # Perform a few edge swaps\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        # Evaluate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 and new_cost2 <= 1.1 * old_cost2) or \\\n           (new_cost2 < old_cost2 and new_cost1 <= 1.1 * old_cost1):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)  # Normalize to sum to 1\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine node insertion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a node to remove\n    remove_idx = random.randint(0, n - 1)\n    removed_node = new_solution[remove_idx]\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Step 2: Find the best insertion point for the removed node\n    best_insertion = None\n    min_cost = float('inf')\n\n    for i in range(n - 1):\n        # Try inserting the node between i and i+1\n        candidate = np.insert(new_solution, i, removed_node)\n        cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Combine costs with a bias towards the objective with higher variance\n        cost = cost1 + cost2 * (np.std(distance_matrix_1) / np.std(distance_matrix_2))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_insertion = i\n\n    if best_insertion is not None:\n        new_solution = np.insert(new_solution, best_insertion, removed_node)\n    else:\n        # If no improvement, revert to the original solution\n        new_solution = np.insert(new_solution, remove_idx, removed_node)\n\n    # Step 3: Apply a biased random walk to escape local optima\n    if random.random() < 0.3:  # 30% chance to apply the walk\n        walk_length = random.randint(1, min(3, n // 2))\n        for _ in range(walk_length):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.858001419181597,
            5.827972173690796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)  # Normalize to sum to 1\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine node insertion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a node to remove\n    remove_idx = random.randint(0, n - 1)\n    removed_node = new_solution[remove_idx]\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Step 2: Find the best insertion point for the removed node\n    best_insertion = None\n    min_cost = float('inf')\n\n    for i in range(n - 1):\n        # Try inserting the node between i and i+1\n        candidate = np.insert(new_solution, i, removed_node)\n        cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Combine costs with a bias towards the objective with higher variance\n        cost = cost1 + cost2 * (np.std(distance_matrix_1) / np.std(distance_matrix_2))\n\n        if cost < min_cost:\n            min_cost = cost\n            best_insertion = i\n\n    if best_insertion is not None:\n        new_solution = np.insert(new_solution, best_insertion, removed_node)\n    else:\n        # If no improvement, revert to the original solution\n        new_solution = np.insert(new_solution, remove_idx, removed_node)\n\n    # Step 3: Apply a biased random walk to escape local optima\n    if random.random() < 0.3:  # 30% chance to apply the walk\n        walk_length = random.randint(1, min(3, n // 2))\n        for _ in range(walk_length):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weights for both objectives (can be adjusted)\n    archive_scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    best_idx = np.argmin(archive_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion heuristic\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select three non-consecutive edges to perform 3-opt\n    i, j, k = np.random.choice(np.arange(1, n_nodes - 2), 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Perform 3-opt: reverse the middle segment and reconnect edges\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Custom edge insertion heuristic: try to insert a node in a better position\n    if n_nodes > 3:\n        node_to_move = np.random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = np.random.choice([p for p in range(n_nodes) if p != current_pos])\n        new_solution = np.insert(np.delete(new_solution, current_pos), new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n_nodes, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6473930343415621,
            0.5375838279724121
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weights for both objectives (can be adjusted)\n    archive_scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    best_idx = np.argmin(archive_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion heuristic\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select three non-consecutive edges to perform 3-opt\n    i, j, k = np.random.choice(np.arange(1, n_nodes - 2), 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Perform 3-opt: reverse the middle segment and reconnect edges\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Custom edge insertion heuristic: try to insert a node in a better position\n    if n_nodes > 3:\n        node_to_move = np.random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = np.random.choice([p for p in range(n_nodes) if p != current_pos])\n        new_solution = np.insert(np.delete(new_solution, current_pos), new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n_nodes, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographic order)\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge replacement strategy\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt swap\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Novel edge replacement: replace two edges with two new edges\n            k, l = sorted(random.sample(range(n), 2))\n            if k != l and abs(k - l) > 1:\n                new_solution = np.concatenate([\n                    new_solution[:k],\n                    new_solution[l:l+1],\n                    new_solution[k+1:l],\n                    new_solution[k:k+1],\n                    new_solution[l+1:]\n                ])\n\n        # Ensure feasibility by checking for duplicates\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9129787392318808,
            0.47302883863449097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographic order)\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge replacement strategy\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt swap\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Novel edge replacement: replace two edges with two new edges\n            k, l = sorted(random.sample(range(n), 2))\n            if k != l and abs(k - l) > 1:\n                new_solution = np.concatenate([\n                    new_solution[:k],\n                    new_solution[l:l+1],\n                    new_solution[k+1:l],\n                    new_solution[k:k+1],\n                    new_solution[l+1:]\n                ])\n\n        # Ensure feasibility by checking for duplicates\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly from top 30% of solutions)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Randomly choose between edge swap, segment inversion, or node insertion\n    operator = random.choice(['edge_swap', 'segment_inversion', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Edge swap: randomly select two edges and swap their connections\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'segment_inversion':\n        # Segment inversion: invert a random segment of the tour\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    elif operator == 'node_insertion':\n        # Node insertion: remove a random node and reinsert it at a different position\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n        new_solution = np.delete(new_solution, idx)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6819989521065802,
            0.49312806129455566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly from top 30% of solutions)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Randomly choose between edge swap, segment inversion, or node insertion\n    operator = random.choice(['edge_swap', 'segment_inversion', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Edge swap: randomly select two edges and swap their connections\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'segment_inversion':\n        # Segment inversion: invert a random segment of the tour\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    elif operator == 'node_insertion':\n        # Node insertion: remove a random node and reinsert it at a different position\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n        new_solution = np.delete(new_solution, idx)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the Pareto front)\n    # Here, we randomly select among the top 30% solutions in the archive\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    candidate_indices = range(min(3, len(sorted_archive)), len(sorted_archive))  # Top 30% or all if <3\n    selected_idx = random.choice(candidate_indices)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Perform a random 3-opt move (ensuring feasibility)\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # 2. Perform an edge insertion move (ensuring feasibility)\n    if n >= 4:\n        # Remove a random edge and reinsert it\n        u = random.randint(0, n-1)\n        v = (u + 1) % n\n        # Remove edge (u, v)\n        removed_node = new_solution[v]\n        new_solution = np.concatenate([new_solution[:v], new_solution[v+1:]])\n        # Reinsert removed_node at a random position\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Ensure the solution remains a valid tour (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n    assert len(new_solution) == len(base_solution), \"Invalid tour length\"\n\n    return new_solution\n\n",
        "score": [
            -0.7601178795965178,
            0.48234206438064575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the Pareto front)\n    # Here, we randomly select among the top 30% solutions in the archive\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    candidate_indices = range(min(3, len(sorted_archive)), len(sorted_archive))  # Top 30% or all if <3\n    selected_idx = random.choice(candidate_indices)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Perform a random 3-opt move (ensuring feasibility)\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # 2. Perform an edge insertion move (ensuring feasibility)\n    if n >= 4:\n        # Remove a random edge and reinsert it\n        u = random.randint(0, n-1)\n        v = (u + 1) % n\n        # Remove edge (u, v)\n        removed_node = new_solution[v]\n        new_solution = np.concatenate([new_solution[:v], new_solution[v+1:]])\n        # Reinsert removed_node at a random position\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Ensure the solution remains a valid tour (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n    assert len(new_solution) == len(base_solution), \"Invalid tour length\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank (better solutions more likely)\n    ranks = np.argsort([sum(obj) for _, obj in archive])\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 non-consecutive edges to modify\n    edges = list(range(n))\n    random.shuffle(edges)\n    i, j, k = edges[:3]\n\n    # Ensure we don't have consecutive indices (to avoid trivial cases)\n    while (abs(i - j) == 1) or (abs(j - k) == 1) or (abs(k - i) == 1):\n        random.shuffle(edges)\n        i, j, k = edges[:3]\n\n    # Reorder the selected nodes to create a new segment\n    segment = new_solution[[i, j, k]]\n    np.random.shuffle(segment)\n    new_solution[[i, j, k]] = segment\n\n    # Custom edge swap: swap edges between two random nodes\n    a, b = np.random.choice(range(n), 2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7906219945160599,
            0.541907012462616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank (better solutions more likely)\n    ranks = np.argsort([sum(obj) for _, obj in archive])\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 non-consecutive edges to modify\n    edges = list(range(n))\n    random.shuffle(edges)\n    i, j, k = edges[:3]\n\n    # Ensure we don't have consecutive indices (to avoid trivial cases)\n    while (abs(i - j) == 1) or (abs(j - k) == 1) or (abs(k - i) == 1):\n        random.shuffle(edges)\n        i, j, k = edges[:3]\n\n    # Reorder the selected nodes to create a new segment\n    segment = new_solution[[i, j, k]]\n    np.random.shuffle(segment)\n    new_solution[[i, j, k]] = segment\n\n    # Custom edge swap: swap edges between two random nodes\n    a, b = np.random.choice(range(n), 2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their Pareto dominance (simplified for this example)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution with a high probability of being non-dominated\n        selected_idx = min(int(len(sorted_archive) * 0.7), len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Step 2: Reverse the segment (similar to 2-opt)\n    new_solution[a:b] = segment[::-1]\n\n    # Step 3: Apply a novel edge insertion heuristic\n    # Randomly select two non-adjacent edges and reconnect them\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) > 1:\n        # Reconnect edges by inserting a new edge between i and j\n        new_segment = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n        new_solution = new_segment\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.9528455132873304,
            0.49740469455718994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their Pareto dominance (simplified for this example)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution with a high probability of being non-dominated\n        selected_idx = min(int(len(sorted_archive) * 0.7), len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Step 2: Reverse the segment (similar to 2-opt)\n    new_solution[a:b] = segment[::-1]\n\n    # Step 3: Apply a novel edge insertion heuristic\n    # Randomly select two non-adjacent edges and reconnect them\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) > 1:\n        # Reconnect edges by inserting a new edge between i and j\n        new_segment = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n        new_solution = new_segment\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Segment relocation with edge exchange\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Randomly swap two nodes to further diversify\n    if random.random() < 0.5 and n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not (len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)):\n        new_solution = base_solution.copy()\n        # Fallback to edge exchange if segment relocation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8873722329334119,
            0.46408289670944214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Segment relocation with edge exchange\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Randomly swap two nodes to further diversify\n    if random.random() < 0.5 and n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not (len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)):\n        new_solution = base_solution.copy()\n        # Fallback to edge exchange if segment relocation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias toward those with better combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    if len(objectives) > 0:\n        probs = (max(objectives) - objectives + 1e-6) / sum(max(objectives) - objectives + 1e-6)\n    else:\n        probs = np.ones(len(archive)) / len(archive)\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reversing segments)\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    if random.random() < 0.5:\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge swap: swap edges between non-adjacent nodes\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8340066211072952,
            0.5286814570426941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias toward those with better combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    if len(objectives) > 0:\n        probs = (max(objectives) - objectives + 1e-6) / sum(max(objectives) - objectives + 1e-6)\n    else:\n        probs = np.ones(len(archive)) / len(archive)\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reversing segments)\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    if random.random() < 0.5:\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge swap: swap edges between non-adjacent nodes\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, _ in archive:\n        dominated = False\n        for other_sol, _ in archive:\n            if (np.allclose(sol, other_sol)):\n                continue\n            # Check if sol is dominated by other_sol\n            cost1_sol = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2_sol = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost1_other = sum(distance_matrix_1[other_sol[i], other_sol[i+1]] for i in range(len(other_sol)-1)) + distance_matrix_1[other_sol[-1], other_sol[0]]\n            cost2_other = sum(distance_matrix_2[other_sol[i], other_sol[i+1]] for i in range(len(other_sol)-1)) + distance_matrix_2[other_sol[-1], other_sol[0]]\n            if (cost1_sol >= cost1_other and cost2_sol >= cost2_other) and (cost1_sol > cost1_other or cost2_sol > cost2_other):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of 2-opt and node insertion with diversification\n    for _ in range(5):  # Number of local search iterations\n        # Randomly choose a segment to perturb\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Apply 2-opt within the segment\n        if len(segment) > 2:\n            k, l = sorted(random.sample(range(len(segment)), 2))\n            segment[k:l+1] = segment[k:l+1][::-1]\n\n        # Reinsert the segment at a random position\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8547206814637804,
            14.52001839876175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, _ in archive:\n        dominated = False\n        for other_sol, _ in archive:\n            if (np.allclose(sol, other_sol)):\n                continue\n            # Check if sol is dominated by other_sol\n            cost1_sol = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2_sol = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost1_other = sum(distance_matrix_1[other_sol[i], other_sol[i+1]] for i in range(len(other_sol)-1)) + distance_matrix_1[other_sol[-1], other_sol[0]]\n            cost2_other = sum(distance_matrix_2[other_sol[i], other_sol[i+1]] for i in range(len(other_sol)-1)) + distance_matrix_2[other_sol[-1], other_sol[0]]\n            if (cost1_sol >= cost1_other and cost2_sol >= cost2_other) and (cost1_sol > cost1_other or cost2_sol > cost2_other):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of 2-opt and node insertion with diversification\n    for _ in range(5):  # Number of local search iterations\n        # Randomly choose a segment to perturb\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Apply 2-opt within the segment\n        if len(segment) > 2:\n            k, l = sorted(random.sample(range(len(segment)), 2))\n            segment[k:l+1] = segment[k:l+1][::-1]\n\n        # Reinsert the segment at a random position\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its dominance\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt move with edge insertion heuristic\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Create three possible 3-opt configurations\n        configs = [\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]])\n        ]\n\n        # Evaluate each configuration using both objectives\n        best_config = configs[0]\n        best_score = float('inf')\n\n        for config in configs:\n            # Calculate total distance for both objectives\n            total_dist_1 = sum(distance_matrix_1[config[i], config[(i+1)%n]] for i in range(n))\n            total_dist_2 = sum(distance_matrix_2[config[i], config[(i+1)%n]] for i in range(n))\n            score = total_dist_1 + total_dist_2  # Combined score\n\n            if score < best_score:\n                best_score = score\n                best_config = config\n\n        new_solution = best_config\n\n        # Edge insertion heuristic to further improve the solution\n        for _ in range(2):  # Perform a few insertions\n            # Select a random node and remove it\n            idx = random.randint(0, n-1)\n            node = new_solution[idx]\n            temp_solution = np.delete(new_solution, idx)\n\n            # Find the best position to insert it back\n            best_pos = 0\n            best_gain = float('-inf')\n\n            for pos in range(len(temp_solution)):\n                # Try inserting at position pos\n                candidate = np.insert(temp_solution, pos, node)\n                # Calculate gain for both objectives\n                gain_1 = (distance_matrix_1[candidate[pos-1], candidate[pos]] +\n                          distance_matrix_1[candidate[pos], candidate[(pos+1)%n]] -\n                          distance_matrix_1[candidate[pos-1], candidate[(pos+1)%n]])\n                gain_2 = (distance_matrix_2[candidate[pos-1], candidate[pos]] +\n                          distance_matrix_2[candidate[pos], candidate[(pos+1)%n]] -\n                          distance_matrix_2[candidate[pos-1], candidate[(pos+1)%n]])\n                total_gain = gain_1 + gain_2\n\n                if total_gain < best_gain:\n                    best_gain = total_gain\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7873779039553466,
            1.8603017330169678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its dominance\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt move with edge insertion heuristic\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Create three possible 3-opt configurations\n        configs = [\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]])\n        ]\n\n        # Evaluate each configuration using both objectives\n        best_config = configs[0]\n        best_score = float('inf')\n\n        for config in configs:\n            # Calculate total distance for both objectives\n            total_dist_1 = sum(distance_matrix_1[config[i], config[(i+1)%n]] for i in range(n))\n            total_dist_2 = sum(distance_matrix_2[config[i], config[(i+1)%n]] for i in range(n))\n            score = total_dist_1 + total_dist_2  # Combined score\n\n            if score < best_score:\n                best_score = score\n                best_config = config\n\n        new_solution = best_config\n\n        # Edge insertion heuristic to further improve the solution\n        for _ in range(2):  # Perform a few insertions\n            # Select a random node and remove it\n            idx = random.randint(0, n-1)\n            node = new_solution[idx]\n            temp_solution = np.delete(new_solution, idx)\n\n            # Find the best position to insert it back\n            best_pos = 0\n            best_gain = float('-inf')\n\n            for pos in range(len(temp_solution)):\n                # Try inserting at position pos\n                candidate = np.insert(temp_solution, pos, node)\n                # Calculate gain for both objectives\n                gain_1 = (distance_matrix_1[candidate[pos-1], candidate[pos]] +\n                          distance_matrix_1[candidate[pos], candidate[(pos+1)%n]] -\n                          distance_matrix_1[candidate[pos-1], candidate[(pos+1)%n]])\n                gain_2 = (distance_matrix_2[candidate[pos-1], candidate[pos]] +\n                          distance_matrix_2[candidate[pos], candidate[(pos+1)%n]] -\n                          distance_matrix_2[candidate[pos-1], candidate[(pos+1)%n]])\n                total_gain = gain_1 + gain_2\n\n                if total_gain < best_gain:\n                    best_gain = total_gain\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: select solutions with lower costs more often\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply a novel operator: swap a random segment with its reverse\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then, apply 2-opt to refine the solution\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n):\n            for j in range(i + 2, n):\n                # Calculate current and new distances\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n                # If both objectives improve, perform the swap\n                if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n                    new_solution[i:j] = new_solution[i:j][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9073252072666811,
            8.755461513996124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: select solutions with lower costs more often\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply a novel operator: swap a random segment with its reverse\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then, apply 2-opt to refine the solution\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n):\n            for j in range(i + 2, n):\n                # Calculate current and new distances\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n                # If both objectives improve, perform the swap\n                if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n                    new_solution[i:j] = new_solution[i:j][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weights = variance / np.sum(variance) if np.sum(variance) != 0 else np.ones(2) / 2\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion strategy\n    if n >= 4:\n        # Randomly select two distinct segments\n        i1, i2 = sorted(np.random.choice(range(n), size=2, replace=False))\n        j1, j2 = sorted(np.random.choice(range(n), size=2, replace=False))\n\n        # Ensure segments are distinct and valid\n        if i1 != i2 and j1 != j2:\n            # Apply 3-opt like move\n            segment1 = new_solution[i1:i2]\n            segment2 = new_solution[j1:j2]\n\n            # Invert one of the segments with probability 0.5\n            if np.random.rand() < 0.5:\n                segment1 = segment1[::-1]\n\n            # Merge segments in a way that maintains feasibility\n            new_solution = np.concatenate([\n                new_solution[:i1],\n                segment1,\n                new_solution[i2:j1],\n                segment2,\n                new_solution[j2:]\n            ])\n\n            # Ensure the tour remains a valid cycle\n            if len(new_solution) != n:\n                # If segments overlap, use a different approach\n                new_solution = base_solution.copy()\n                # Novel segment inversion: reverse a random segment\n                start, end = sorted(np.random.choice(range(n), size=2, replace=False))\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9113344542557601,
            0.5765447020530701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weights = variance / np.sum(variance) if np.sum(variance) != 0 else np.ones(2) / 2\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion strategy\n    if n >= 4:\n        # Randomly select two distinct segments\n        i1, i2 = sorted(np.random.choice(range(n), size=2, replace=False))\n        j1, j2 = sorted(np.random.choice(range(n), size=2, replace=False))\n\n        # Ensure segments are distinct and valid\n        if i1 != i2 and j1 != j2:\n            # Apply 3-opt like move\n            segment1 = new_solution[i1:i2]\n            segment2 = new_solution[j1:j2]\n\n            # Invert one of the segments with probability 0.5\n            if np.random.rand() < 0.5:\n                segment1 = segment1[::-1]\n\n            # Merge segments in a way that maintains feasibility\n            new_solution = np.concatenate([\n                new_solution[:i1],\n                segment1,\n                new_solution[i2:j1],\n                segment2,\n                new_solution[j2:]\n            ])\n\n            # Ensure the tour remains a valid cycle\n            if len(new_solution) != n:\n                # If segments overlap, use a different approach\n                new_solution = base_solution.copy()\n                # Novel segment inversion: reverse a random segment\n                start, end = sorted(np.random.choice(range(n), size=2, replace=False))\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs]\n        probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a novel hybrid local search operator (3-opt-like with randomized segment selection)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three non-consecutive edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a novel way (e.g., segment1 -> segment3 -> segment2 -> segment4)\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # Fallback to swap if invalid (should not happen with proper segment selection)\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7845231689807795,
            0.47232586145401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs]\n        probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a novel hybrid local search operator (3-opt-like with randomized segment selection)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three non-consecutive edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a novel way (e.g., segment1 -> segment3 -> segment2 -> segment4)\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # Fallback to swap if invalid (should not happen with proper segment selection)\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objectives (e.g., Pareto dominance or crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a novel edge-swap strategy to further improve the solution\n    if j - i > 2:\n        k = np.random.randint(i + 1, j)\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.824763130371158,
            0.47524893283843994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objectives (e.g., Pareto dominance or crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a novel edge-swap strategy to further improve the solution\n    if j - i > 2:\n        k = np.random.randint(i + 1, j)\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 20% solutions)\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_k = max(1, len(sorted_archive) // 5)\n    selected = random.choice(sorted_archive[:top_k])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    if a == c and b == d:\n        c, d = (c + 1) % n, (d + 1) % n\n\n    # Extract segments and reverse them\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reverse segments (segment reversal)\n    new_solution[a:b+1] = segment1[::-1]\n    new_solution[c:d+1] = segment2[::-1]\n\n    # Edge insertion: move a random edge from one position to another\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above operations cause duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7227830675258653,
            0.4957743287086487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 20% solutions)\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_k = max(1, len(sorted_archive) // 5)\n    selected = random.choice(sorted_archive[:top_k])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    if a == c and b == d:\n        c, d = (c + 1) % n, (d + 1) % n\n\n    # Extract segments and reverse them\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reverse segments (segment reversal)\n    new_solution[a:b+1] = segment1[::-1]\n    new_solution[c:d+1] = segment2[::-1]\n\n    # Edge insertion: move a random edge from one position to another\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above operations cause duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    seg1_start, seg1_end = sorted(np.random.choice(n, 2, replace=False))\n    seg2_start, seg2_end = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are non-overlapping and of reasonable size\n    if seg1_start >= seg2_end or seg2_start >= seg1_end:\n        # Reverse the selected segments\n        new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n        new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n    else:\n        # If segments overlap, perform a single segment reversal\n        seg_start, seg_end = min(seg1_start, seg2_start), max(seg1_end, seg2_end)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Additional improvement: apply a novel \"swap and reverse\" operation\n    if np.random.rand() < 0.3:  # 30% chance to apply this operation\n        swap_pos1, swap_pos2 = np.random.choice(n, 2, replace=False)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n        # Reverse a segment between the swapped nodes\n        seg_start, seg_end = sorted([swap_pos1, swap_pos2])\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8040758844834562,
            0.4811989665031433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    seg1_start, seg1_end = sorted(np.random.choice(n, 2, replace=False))\n    seg2_start, seg2_end = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are non-overlapping and of reasonable size\n    if seg1_start >= seg2_end or seg2_start >= seg1_end:\n        # Reverse the selected segments\n        new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n        new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n    else:\n        # If segments overlap, perform a single segment reversal\n        seg_start, seg_end = min(seg1_start, seg2_start), max(seg1_end, seg2_end)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Additional improvement: apply a novel \"swap and reverse\" operation\n    if np.random.rand() < 0.3:  # 30% chance to apply this operation\n        swap_pos1, swap_pos2 = np.random.choice(n, 2, replace=False)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n        # Reverse a segment between the swapped nodes\n        seg_start, seg_end = sorted([swap_pos1, swap_pos2])\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    probabilities = [1.0 / (1.0 + cost) for cost in total_costs]  # Higher probability for lower costs\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge exchange + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge exchange (similar to 2-opt but more general)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random segment reversal to escape local optima\n    seg_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the above causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8440902889496641,
            0.4749634265899658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    probabilities = [1.0 / (1.0 + cost) for cost in total_costs]  # Higher probability for lower costs\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge exchange + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge exchange (similar to 2-opt but more general)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random segment reversal to escape local optima\n    seg_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the above causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost)\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion (to further improve the solution)\n    # Randomly select a node and insert it in a new position\n    node_to_move = np.random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes included)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8793518223736565,
            0.6116814613342285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost)\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion (to further improve the solution)\n    # Randomly select a node and insert it in a new position\n    node_to_move = np.random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes included)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weights = objective_variance / np.sum(objective_variance) if np.sum(objective_variance) > 0 else np.ones(2) / 2\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)  # Prefer solutions with high variance (potential for improvement)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt + custom insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(np.arange(1, N), size=3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect the segments in a different order (one of 4 possible 3-opt moves)\n    move_type = np.random.randint(0, 4)\n    if move_type == 0:\n        new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n    elif move_type == 1:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    elif move_type == 2:\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3, segment4])\n    else:\n        # Custom insertion: remove segment2 and reinsert it in a different position\n        new_solution = np.concatenate([segment1, segment3, segment4, segment2])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to base solution (fallback)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8694962029099441,
            0.7749832272529602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weights = objective_variance / np.sum(objective_variance) if np.sum(objective_variance) > 0 else np.ones(2) / 2\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)  # Prefer solutions with high variance (potential for improvement)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt + custom insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(np.arange(1, N), size=3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect the segments in a different order (one of 4 possible 3-opt moves)\n    move_type = np.random.randint(0, 4)\n    if move_type == 0:\n        new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n    elif move_type == 1:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    elif move_type == 2:\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3, segment4])\n    else:\n        # Custom insertion: remove segment2 and reinsert it in a different position\n        new_solution = np.concatenate([segment1, segment3, segment4, segment2])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != N:\n        # If invalid, revert to base solution (fallback)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge swaps with path reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path reversal with a small segment\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        new_solution = np.unique(new_solution, return_index=True)[1]\n        new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])\n\n    return new_solution\n\n",
        "score": [
            -0.7619261674811174,
            0.752166748046875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge swaps with path reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path reversal with a small segment\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        new_solution = np.unique(new_solution, return_index=True)[1]\n        new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 118,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Inverse of combined objective\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select three edges to modify (3-opt)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create all possible 3-opt configurations\n    possible_solutions = []\n    for config in [\n        [new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:k+1], new_solution[k+1:]],\n        [new_solution[:i+1], new_solution[j+1:k+1], new_solution[i+1:j+1][::-1], new_solution[k+1:]],\n        [new_solution[:i+1], new_solution[j+1:k+1][::-1], new_solution[i+1:j+1], new_solution[k+1:]],\n        [new_solution[:i+1], new_solution[j+1:k+1], new_solution[i+1:j+1], new_solution[k+1:][::-1]],\n        [new_solution[:i+1], new_solution[i+1:j+1], new_solution[k+1:], new_solution[j+1:k+1][::-1]],\n        [new_solution[:i+1], new_solution[k+1:], new_solution[i+1:j+1], new_solution[j+1:k+1][::-1]]\n    ]:\n        candidate = np.concatenate(config)\n        # Ensure it's a valid tour (visits all nodes exactly once)\n        if len(np.unique(candidate)) == n:\n            possible_solutions.append(candidate)\n\n    if possible_solutions:\n        new_solution = random.choice(possible_solutions)\n\n    # Step 2: Custom edge insertion based on distance improvement\n    for _ in range(2):  # Limit the number of insertions to avoid excessive computation\n        # Select a random node to remove and reinsert\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n\n        # Remove the node\n        temp_solution = np.delete(new_solution, idx)\n\n        # Find the best insertion point for the node\n        best_insert_pos = 0\n        best_improvement = 0\n\n        for pos in range(n-1):\n            # Calculate cost difference for both objectives\n            prev_node = temp_solution[pos-1] if pos > 0 else temp_solution[-1]\n            next_node = temp_solution[pos]\n\n            old_cost = (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node])\n            new_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            improvement = old_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8089725424575379,
            1.0804675221443176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Inverse of combined objective\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select three edges to modify (3-opt)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create all possible 3-opt configurations\n    possible_solutions = []\n    for config in [\n        [new_solution[:i+1], new_solution[i+1:j+1][::-1], new_solution[j+1:k+1], new_solution[k+1:]],\n        [new_solution[:i+1], new_solution[j+1:k+1], new_solution[i+1:j+1][::-1], new_solution[k+1:]],\n        [new_solution[:i+1], new_solution[j+1:k+1][::-1], new_solution[i+1:j+1], new_solution[k+1:]],\n        [new_solution[:i+1], new_solution[j+1:k+1], new_solution[i+1:j+1], new_solution[k+1:][::-1]],\n        [new_solution[:i+1], new_solution[i+1:j+1], new_solution[k+1:], new_solution[j+1:k+1][::-1]],\n        [new_solution[:i+1], new_solution[k+1:], new_solution[i+1:j+1], new_solution[j+1:k+1][::-1]]\n    ]:\n        candidate = np.concatenate(config)\n        # Ensure it's a valid tour (visits all nodes exactly once)\n        if len(np.unique(candidate)) == n:\n            possible_solutions.append(candidate)\n\n    if possible_solutions:\n        new_solution = random.choice(possible_solutions)\n\n    # Step 2: Custom edge insertion based on distance improvement\n    for _ in range(2):  # Limit the number of insertions to avoid excessive computation\n        # Select a random node to remove and reinsert\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n\n        # Remove the node\n        temp_solution = np.delete(new_solution, idx)\n\n        # Find the best insertion point for the node\n        best_insert_pos = 0\n        best_improvement = 0\n\n        for pos in range(n-1):\n            # Calculate cost difference for both objectives\n            prev_node = temp_solution[pos-1] if pos > 0 else temp_solution[-1]\n            next_node = temp_solution[pos]\n\n            old_cost = (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node])\n            new_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            improvement = old_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 119,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    if random.random() < 0.3:\n        # Edge insertion with bias towards improving both objectives\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n - 1:\n            return new_solution  # No change if trying to insert start/end\n\n        # Calculate potential improvement for both objectives\n        def improvement(a, b, c, d):\n            delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d] -\n                     (distance_matrix_1[a, c] + distance_matrix_1[b, d]))\n            delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d] -\n                     (distance_matrix_2[a, c] + distance_matrix_2[b, d]))\n            return delta1 + delta2\n\n        best_improvement = 0\n        best_insert = None\n\n        for k in range(i, j):\n            # Try inserting node k between i and j\n            if improvement(new_solution[i-1], new_solution[k], new_solution[i], new_solution[k+1]) < best_improvement:\n                best_improvement = improvement(new_solution[i-1], new_solution[k], new_solution[i], new_solution[k+1])\n                best_insert = k\n\n        if best_insert is not None:\n            # Perform the insertion\n            node = new_solution[best_insert]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:best_insert], new_solution[best_insert+1:]])\n\n    elif random.random() < 0.6:\n        # Segment reversal with objective-aware selection\n        i, j = sorted(random.sample(range(1, n-1), 2))\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        if delta1 + delta2 < 0:  # Only reverse if improves both objectives\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    else:\n        # Novel segment swapping operation\n        i, j, k, l = sorted(random.sample(range(1, n-1), 4))\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[j], new_solution[l+1]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[l+1]] +\n                 distance_matrix_1[new_solution[k-1], new_solution[j+1]] +\n                 distance_matrix_1[new_solution[i], new_solution[l]] -\n                 distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                 distance_matrix_1[new_solution[l], new_solution[l+1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[j], new_solution[l+1]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[l+1]] +\n                 distance_matrix_2[new_solution[k-1], new_solution[j+1]] +\n                 distance_matrix_2[new_solution[i], new_solution[l]] -\n                 distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                 distance_matrix_2[new_solution[l], new_solution[l+1]])\n\n        if delta1 + delta2 < 0:  # Only swap if improves both objectives\n            # Perform the swap\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([\n                new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]\n            ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.846298381078106,
            0.6889556050300598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    if random.random() < 0.3:\n        # Edge insertion with bias towards improving both objectives\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n - 1:\n            return new_solution  # No change if trying to insert start/end\n\n        # Calculate potential improvement for both objectives\n        def improvement(a, b, c, d):\n            delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d] -\n                     (distance_matrix_1[a, c] + distance_matrix_1[b, d]))\n            delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d] -\n                     (distance_matrix_2[a, c] + distance_matrix_2[b, d]))\n            return delta1 + delta2\n\n        best_improvement = 0\n        best_insert = None\n\n        for k in range(i, j):\n            # Try inserting node k between i and j\n            if improvement(new_solution[i-1], new_solution[k], new_solution[i], new_solution[k+1]) < best_improvement:\n                best_improvement = improvement(new_solution[i-1], new_solution[k], new_solution[i], new_solution[k+1])\n                best_insert = k\n\n        if best_insert is not None:\n            # Perform the insertion\n            node = new_solution[best_insert]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:best_insert], new_solution[best_insert+1:]])\n\n    elif random.random() < 0.6:\n        # Segment reversal with objective-aware selection\n        i, j = sorted(random.sample(range(1, n-1), 2))\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        if delta1 + delta2 < 0:  # Only reverse if improves both objectives\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    else:\n        # Novel segment swapping operation\n        i, j, k, l = sorted(random.sample(range(1, n-1), 4))\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[j], new_solution[l+1]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[l+1]] +\n                 distance_matrix_1[new_solution[k-1], new_solution[j+1]] +\n                 distance_matrix_1[new_solution[i], new_solution[l]] -\n                 distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                 distance_matrix_1[new_solution[l], new_solution[l+1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[j], new_solution[l+1]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[l+1]] +\n                 distance_matrix_2[new_solution[k-1], new_solution[j+1]] +\n                 distance_matrix_2[new_solution[i], new_solution[l]] -\n                 distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                 distance_matrix_2[new_solution[l], new_solution[l+1]])\n\n        if delta1 + delta2 < 0:  # Only swap if improves both objectives\n            # Perform the swap\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([\n                new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]\n            ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 120,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank (simplified)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance ranks (simplified: lower cost in both objectives is better)\n    ranks = [sum(obj) for obj in objectives]  # Sum of objectives as a proxy for rank\n    total_rank = sum(ranks)\n    probabilities = [1 - (rank / total_rank) for rank in ranks]  # Higher probability for better solutions\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize\n\n    selected_solution = random.choices(solutions, weights=probabilities, k=1)[0].copy()\n\n    # Hybrid local search: combine 2-opt with a custom edge-swap heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt with a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom edge-swap heuristic: swap edges that improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure valid edges and no overlap\n        if a == b or c == d or {a, b} == {c, d}:\n            continue\n\n        # Calculate current and new costs\n        current_cost1 = distance_matrix_1[selected_solution[a], selected_solution[b]] + distance_matrix_1[selected_solution[c], selected_solution[d]]\n        new_cost1 = distance_matrix_1[selected_solution[a], selected_solution[c]] + distance_matrix_1[selected_solution[b], selected_solution[d]]\n\n        current_cost2 = distance_matrix_2[selected_solution[a], selected_solution[b]] + distance_matrix_2[selected_solution[c], selected_solution[d]]\n        new_cost2 = distance_matrix_2[selected_solution[a], selected_solution[c]] + distance_matrix_2[selected_solution[b], selected_solution[d]]\n\n        # Accept if both objectives improve\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8568927181231738,
            0.5244059562683105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank (simplified)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance ranks (simplified: lower cost in both objectives is better)\n    ranks = [sum(obj) for obj in objectives]  # Sum of objectives as a proxy for rank\n    total_rank = sum(ranks)\n    probabilities = [1 - (rank / total_rank) for rank in ranks]  # Higher probability for better solutions\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize\n\n    selected_solution = random.choices(solutions, weights=probabilities, k=1)[0].copy()\n\n    # Hybrid local search: combine 2-opt with a custom edge-swap heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt with a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom edge-swap heuristic: swap edges that improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure valid edges and no overlap\n        if a == b or c == d or {a, b} == {c, d}:\n            continue\n\n        # Calculate current and new costs\n        current_cost1 = distance_matrix_1[selected_solution[a], selected_solution[b]] + distance_matrix_1[selected_solution[c], selected_solution[d]]\n        new_cost1 = distance_matrix_1[selected_solution[a], selected_solution[c]] + distance_matrix_1[selected_solution[b], selected_solution[d]]\n\n        current_cost2 = distance_matrix_2[selected_solution[a], selected_solution[b]] + distance_matrix_2[selected_solution[c], selected_solution[d]]\n        new_cost2 = distance_matrix_2[selected_solution[a], selected_solution[c]] + distance_matrix_2[selected_solution[b], selected_solution[d]]\n\n        # Accept if both objectives improve\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple selection criterion\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(base_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select a segment to reverse or insert\n        i, j = sorted(random.sample(range(n), 2))\n        segment = base_solution[i:j+1]\n\n        # Option 1: Reverse the segment\n        reversed_segment = segment[::-1]\n        candidate1 = np.concatenate([base_solution[:i], reversed_segment, base_solution[j+1:]])\n\n        # Option 2: Insert the segment at a different position\n        k = random.randint(0, n-1)\n        if k < i or k > j:\n            candidate2 = np.concatenate([base_solution[:k], segment, base_solution[k:]])\n        else:\n            candidate2 = base_solution.copy()\n\n        # Select the better candidate based on both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        if calculate_cost(candidate1) < calculate_cost(candidate2):\n            new_solution = candidate1\n        else:\n            new_solution = candidate2\n\n        # Early exit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            break\n        base_solution = new_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.895992350629481,
            0.8028308153152466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple selection criterion\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(base_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select a segment to reverse or insert\n        i, j = sorted(random.sample(range(n), 2))\n        segment = base_solution[i:j+1]\n\n        # Option 1: Reverse the segment\n        reversed_segment = segment[::-1]\n        candidate1 = np.concatenate([base_solution[:i], reversed_segment, base_solution[j+1:]])\n\n        # Option 2: Insert the segment at a different position\n        k = random.randint(0, n-1)\n        if k < i or k > j:\n            candidate2 = np.concatenate([base_solution[:k], segment, base_solution[k:]])\n        else:\n            candidate2 = base_solution.copy()\n\n        # Select the better candidate based on both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        if calculate_cost(candidate1) < calculate_cost(candidate2):\n            new_solution = candidate1\n        else:\n            new_solution = candidate2\n\n        # Early exit if no improvement\n        if np.array_equal(new_solution, base_solution):\n            break\n        base_solution = new_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 122,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower total cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = np.exp(-costs / np.max(costs)) / np.sum(np.exp(-costs / np.max(costs)))\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Step 2: Apply 3-opt-like operation (reorder the segment between i and k)\n    segment = new_solution[i:k+1]\n    np.random.shuffle(segment)\n    new_solution[i:k+1] = segment\n\n    # Step 3: Apply segment inversion with probability 0.5\n    if np.random.rand() < 0.5:\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Step 4: Apply swap with probability 0.3\n    if np.random.rand() < 0.3:\n        l, m = np.random.choice(n, size=2, replace=False)\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and apply a simple 2-opt\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.850344148403906,
            0.4895150065422058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower total cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = np.exp(-costs / np.max(costs)) / np.sum(np.exp(-costs / np.max(costs)))\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Step 2: Apply 3-opt-like operation (reorder the segment between i and k)\n    segment = new_solution[i:k+1]\n    np.random.shuffle(segment)\n    new_solution[i:k+1] = segment\n\n    # Step 3: Apply segment inversion with probability 0.5\n    if np.random.rand() < 0.5:\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Step 4: Apply swap with probability 0.3\n    if np.random.rand() < 0.3:\n        l, m = np.random.choice(n, size=2, replace=False)\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and apply a simple 2-opt\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 123,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its dominance rank\n    # Higher rank (better solutions) have higher selection probability\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0)[:, 0] + np.argsort(objectives, axis=0)[:, 1])\n    selection_probs = np.exp(-ranks)  # Exponential decay for selection probability\n    selection_probs = selection_probs / np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move (select three random edges and reconnect them)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Create all possible 3-opt reconnections\n        candidates = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment2, segment4, segment3]),\n            np.concatenate([segment1, segment2[::-1], segment4, segment3]),\n            np.concatenate([segment1, segment3, segment4, segment2]),\n            np.concatenate([segment1, segment3[::-1], segment4, segment2]),\n            np.concatenate([segment1, segment4, segment2, segment3]),\n            np.concatenate([segment1, segment4, segment2[::-1], segment3]),\n            np.concatenate([segment1, segment4, segment3, segment2]),\n            np.concatenate([segment1, segment4, segment3[::-1], segment2]),\n        ]\n\n        # Evaluate all candidates based on both objectives\n        def evaluate(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            return (cost1, cost2)\n\n        # Select the best candidate based on Pareto dominance\n        best_candidate = None\n        best_cost = None\n        for candidate in candidates:\n            current_cost = evaluate(candidate)\n            if best_candidate is None:\n                best_candidate = candidate\n                best_cost = current_cost\n            else:\n                # Check if current candidate dominates the best so far\n                if (current_cost[0] < best_cost[0] and current_cost[1] <= best_cost[1]) or \\\n                   (current_cost[0] <= best_cost[0] and current_cost[1] < best_cost[1]):\n                    best_candidate = candidate\n                    best_cost = current_cost\n\n        new_solution = best_candidate\n\n    # Novel segment relocation heuristic\n    if n >= 5:\n        # Select a random segment of length 2-3\n        segment_length = random.randint(2, 3)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Try inserting the segment in different positions\n        best_insert_pos = start\n        best_insert_cost = None\n\n        for pos in range(0, len(remaining)):\n            candidate = np.concatenate([\n                remaining[:pos],\n                segment,\n                remaining[pos:]\n            ])\n\n            current_cost = evaluate(candidate)\n            if best_insert_cost is None:\n                best_insert_cost = current_cost\n                best_insert_pos = pos\n            else:\n                if (current_cost[0] < best_insert_cost[0] and current_cost[1] <= best_insert_cost[1]) or \\\n                   (current_cost[0] <= best_insert_cost[0] and current_cost[1] < best_insert_cost[1]):\n                    best_insert_cost = current_cost\n                    best_insert_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            remaining[:best_insert_pos],\n            segment,\n            remaining[best_insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9246664660510127,
            4.270352363586426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its dominance rank\n    # Higher rank (better solutions) have higher selection probability\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0)[:, 0] + np.argsort(objectives, axis=0)[:, 1])\n    selection_probs = np.exp(-ranks)  # Exponential decay for selection probability\n    selection_probs = selection_probs / np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move (select three random edges and reconnect them)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Create all possible 3-opt reconnections\n        candidates = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment2, segment4, segment3]),\n            np.concatenate([segment1, segment2[::-1], segment4, segment3]),\n            np.concatenate([segment1, segment3, segment4, segment2]),\n            np.concatenate([segment1, segment3[::-1], segment4, segment2]),\n            np.concatenate([segment1, segment4, segment2, segment3]),\n            np.concatenate([segment1, segment4, segment2[::-1], segment3]),\n            np.concatenate([segment1, segment4, segment3, segment2]),\n            np.concatenate([segment1, segment4, segment3[::-1], segment2]),\n        ]\n\n        # Evaluate all candidates based on both objectives\n        def evaluate(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            return (cost1, cost2)\n\n        # Select the best candidate based on Pareto dominance\n        best_candidate = None\n        best_cost = None\n        for candidate in candidates:\n            current_cost = evaluate(candidate)\n            if best_candidate is None:\n                best_candidate = candidate\n                best_cost = current_cost\n            else:\n                # Check if current candidate dominates the best so far\n                if (current_cost[0] < best_cost[0] and current_cost[1] <= best_cost[1]) or \\\n                   (current_cost[0] <= best_cost[0] and current_cost[1] < best_cost[1]):\n                    best_candidate = candidate\n                    best_cost = current_cost\n\n        new_solution = best_candidate\n\n    # Novel segment relocation heuristic\n    if n >= 5:\n        # Select a random segment of length 2-3\n        segment_length = random.randint(2, 3)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Try inserting the segment in different positions\n        best_insert_pos = start\n        best_insert_cost = None\n\n        for pos in range(0, len(remaining)):\n            candidate = np.concatenate([\n                remaining[:pos],\n                segment,\n                remaining[pos:]\n            ])\n\n            current_cost = evaluate(candidate)\n            if best_insert_cost is None:\n                best_insert_cost = current_cost\n                best_insert_pos = pos\n            else:\n                if (current_cost[0] < best_insert_cost[0] and current_cost[1] <= best_insert_cost[1]) or \\\n                   (current_cost[0] <= best_insert_cost[0] and current_cost[1] < best_insert_cost[1]):\n                    best_insert_cost = current_cost\n                    best_insert_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            remaining[:best_insert_pos],\n            segment,\n            remaining[best_insert_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 124,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection to pick a promising solution\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: sum(x[1]))  # Select solution with lowest total cost\n    base_solution = selected[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 3-opt and node insertion\n    if n > 3:\n        # 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Try all possible reconnections\n        variants = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4])\n        ]\n\n        # Evaluate all variants based on both objectives\n        best_variant = new_solution\n        best_score = sum(selected[0][1])\n\n        for variant in variants:\n            cost1 = sum(distance_matrix_1[variant[i], variant[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[variant[i], variant[(i+1)%n]] for i in range(n))\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_variant = variant.copy()\n\n        new_solution = best_variant\n\n        # Node insertion for further improvement\n        if n > 4:\n            node_to_move = random.randint(0, n-1)\n            insertion_pos = random.randint(0, n-2)\n            if insertion_pos >= node_to_move:\n                insertion_pos += 1\n\n            temp_solution = np.concatenate([\n                new_solution[:node_to_move],\n                new_solution[node_to_move+1:]\n            ])\n            new_solution = np.insert(temp_solution, insertion_pos, new_solution[node_to_move])\n\n    return new_solution\n\n",
        "score": [
            -0.6840531037610202,
            0.7442983984947205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection to pick a promising solution\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected.sort(key=lambda x: sum(x[1]))  # Select solution with lowest total cost\n    base_solution = selected[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 3-opt and node insertion\n    if n > 3:\n        # 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Try all possible reconnections\n        variants = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4])\n        ]\n\n        # Evaluate all variants based on both objectives\n        best_variant = new_solution\n        best_score = sum(selected[0][1])\n\n        for variant in variants:\n            cost1 = sum(distance_matrix_1[variant[i], variant[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[variant[i], variant[(i+1)%n]] for i in range(n))\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_variant = variant.copy()\n\n        new_solution = best_variant\n\n        # Node insertion for further improvement\n        if n > 4:\n            node_to_move = random.randint(0, n-1)\n            insertion_pos = random.randint(0, n-2)\n            if insertion_pos >= node_to_move:\n                insertion_pos += 1\n\n            temp_solution = np.concatenate([\n                new_solution[:node_to_move],\n                new_solution[node_to_move+1:]\n            ])\n            new_solution = np.insert(temp_solution, insertion_pos, new_solution[node_to_move])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 125,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, min(start + 4, n - 1))\n\n    # Edge exchange (swap two non-adjacent edges)\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(start, end), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node insertion (move a node to a different position)\n    else:\n        i = random.randint(start, end)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(selected_solution)\n    assert np.array_equal(np.sort(new_solution), np.sort(selected_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.6690138257572272,
            0.663309633731842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, min(start + 4, n - 1))\n\n    # Edge exchange (swap two non-adjacent edges)\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(start, end), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node insertion (move a node to a different position)\n    else:\n        i = random.randint(start, end)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(selected_solution)\n    assert np.array_equal(np.sort(new_solution), np.sort(selected_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 126,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a biased random move\n    N = len(selected_solution)\n    if N < 3:\n        return new_solution  # Too small for meaningful operations\n\n    # Select three random segments to modify\n    i, j, k = sorted(random.sample(range(1, N), 3))\n\n    # Apply a 3-opt like move with randomness\n    if random.random() < 0.5:\n        # Reverse segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Rotate segment between i and j\n        shift = random.randint(1, j-i)\n        new_solution[i:j] = np.roll(new_solution[i:j], shift)\n\n    # Apply a biased random move to improve both objectives\n    if random.random() < 0.3:\n        # Swap a node with its neighbor based on which objective has higher distance\n        for idx in range(1, N-1):\n            d1 = distance_matrix_1[new_solution[idx-1], new_solution[idx]] + distance_matrix_1[new_solution[idx], new_solution[idx+1]]\n            d2 = distance_matrix_2[new_solution[idx-1], new_solution[idx]] + distance_matrix_2[new_solution[idx], new_solution[idx+1]]\n\n            if d1 > d2 and random.random() < 0.7:\n                # Prefer swapping if first objective is worse\n                new_solution[idx], new_solution[idx+1] = new_solution[idx+1], new_solution[idx]\n            elif d2 > d1 and random.random() < 0.7:\n                # Prefer swapping if second objective is worse\n                new_solution[idx], new_solution[idx-1] = new_solution[idx-1], new_solution[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3564822026942681,
            0.7037273049354553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a biased random move\n    N = len(selected_solution)\n    if N < 3:\n        return new_solution  # Too small for meaningful operations\n\n    # Select three random segments to modify\n    i, j, k = sorted(random.sample(range(1, N), 3))\n\n    # Apply a 3-opt like move with randomness\n    if random.random() < 0.5:\n        # Reverse segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Rotate segment between i and j\n        shift = random.randint(1, j-i)\n        new_solution[i:j] = np.roll(new_solution[i:j], shift)\n\n    # Apply a biased random move to improve both objectives\n    if random.random() < 0.3:\n        # Swap a node with its neighbor based on which objective has higher distance\n        for idx in range(1, N-1):\n            d1 = distance_matrix_1[new_solution[idx-1], new_solution[idx]] + distance_matrix_1[new_solution[idx], new_solution[idx+1]]\n            d2 = distance_matrix_2[new_solution[idx-1], new_solution[idx]] + distance_matrix_2[new_solution[idx], new_solution[idx+1]]\n\n            if d1 > d2 and random.random() < 0.7:\n                # Prefer swapping if first objective is worse\n                new_solution[idx], new_solution[idx+1] = new_solution[idx+1], new_solution[idx]\n            elif d2 > d1 and random.random() < 0.7:\n                # Prefer swapping if second objective is worse\n                new_solution[idx], new_solution[idx-1] = new_solution[idx-1], new_solution[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 127,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a higher chance for lower-cost solutions\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    combined_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (combined_costs + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 3-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 4 distinct indices (for 3-opt)\n    if n >= 4:\n        i, j, k, l = np.random.choice(n, size=4, replace=False)\n        i, j, k, l = sorted([i, j, k, l])\n\n        # 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Try different permutations\n        permutations = [\n            np.concatenate([new_solution[:i], segment1, segment2, segment3, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment1, segment3, segment2, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment2, segment1, segment3, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment2, segment3, segment1, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment3, segment1, segment2, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment3, segment2, segment1, new_solution[l:]])\n        ]\n\n        # Evaluate all permutations using both objectives\n        best_perm = None\n        best_score = float('inf')\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_score:\n                best_score = combined_cost\n                best_perm = perm\n\n        if best_perm is not None:\n            new_solution = best_perm.copy()\n\n    # Edge exchange (swap two edges if it improves the solution)\n    if n >= 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Try swapping edges (i,i+1) and (j,j+1) with (i,j) and (i+1,j+1)\n        new_solution = new_solution.copy()\n        temp = new_solution[i+1]\n        new_solution[i+1] = new_solution[j]\n        new_solution[j] = temp\n\n        # Verify feasibility (all nodes are visited exactly once)\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8800231282481493,
            0.9482765197753906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a higher chance for lower-cost solutions\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    combined_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (combined_costs + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 3-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 4 distinct indices (for 3-opt)\n    if n >= 4:\n        i, j, k, l = np.random.choice(n, size=4, replace=False)\n        i, j, k, l = sorted([i, j, k, l])\n\n        # 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Try different permutations\n        permutations = [\n            np.concatenate([new_solution[:i], segment1, segment2, segment3, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment1, segment3, segment2, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment2, segment1, segment3, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment2, segment3, segment1, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment3, segment1, segment2, new_solution[l:]]),\n            np.concatenate([new_solution[:i], segment3, segment2, segment1, new_solution[l:]])\n        ]\n\n        # Evaluate all permutations using both objectives\n        best_perm = None\n        best_score = float('inf')\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_score:\n                best_score = combined_cost\n                best_perm = perm\n\n        if best_perm is not None:\n            new_solution = best_perm.copy()\n\n    # Edge exchange (swap two edges if it improves the solution)\n    if n >= 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        # Try swapping edges (i,i+1) and (j,j+1) with (i,j) and (i+1,j+1)\n        new_solution = new_solution.copy()\n        temp = new_solution[i+1]\n        new_solution[i+1] = new_solution[j]\n        new_solution[j] = temp\n\n        # Verify feasibility (all nodes are visited exactly once)\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 128,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    total_rank = np.sum(ranks, axis=1)\n    probabilities = 1 / (total_rank + 1)  # Add 1 to avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but with additional checks)\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Novel segment reversal and insertion\n        if n >= 4:\n            # Select two non-overlapping segments\n            seg1_start, seg1_end = sorted(random.sample(range(n-1), 2))\n            seg2_start, seg2_end = sorted(random.sample(range(n-1), 2))\n\n            # Ensure segments don't overlap\n            if seg1_end < seg2_start or seg2_end < seg1_start:\n                # Extract segments\n                seg1 = new_solution[seg1_start:seg1_end+1]\n                seg2 = new_solution[seg2_start:seg2_end+1]\n\n                # Remove segments from solution\n                remaining = np.concatenate([\n                    new_solution[:seg1_start],\n                    new_solution[seg1_end+1:seg2_start],\n                    new_solution[seg2_end+1:]\n                ])\n\n                # Insert segments in reverse order\n                insert_pos = random.randint(0, len(remaining))\n                new_solution = np.concatenate([\n                    remaining[:insert_pos],\n                    seg2[::-1],\n                    seg1[::-1],\n                    remaining[insert_pos:]\n                ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8398925979281564,
            0.6278128027915955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    total_rank = np.sum(ranks, axis=1)\n    probabilities = 1 / (total_rank + 1)  # Add 1 to avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but with additional checks)\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Novel segment reversal and insertion\n        if n >= 4:\n            # Select two non-overlapping segments\n            seg1_start, seg1_end = sorted(random.sample(range(n-1), 2))\n            seg2_start, seg2_end = sorted(random.sample(range(n-1), 2))\n\n            # Ensure segments don't overlap\n            if seg1_end < seg2_start or seg2_end < seg1_start:\n                # Extract segments\n                seg1 = new_solution[seg1_start:seg1_end+1]\n                seg2 = new_solution[seg2_start:seg2_end+1]\n\n                # Remove segments from solution\n                remaining = np.concatenate([\n                    new_solution[:seg1_start],\n                    new_solution[seg1_end+1:seg2_start],\n                    new_solution[seg2_end+1:]\n                ])\n\n                # Insert segments in reverse order\n                insert_pos = random.randint(0, len(remaining))\n                new_solution = np.concatenate([\n                    remaining[:insert_pos],\n                    seg2[::-1],\n                    seg1[::-1],\n                    remaining[insert_pos:]\n                ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its rank (better solutions are more likely to be selected)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0)[:, 0])  # Rank based on first objective\n    probabilities = 1 / (ranks + 1)  # Inverse rank probabilities\n    probabilities = probabilities / np.sum(probabilities)  # Normalize\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion and node relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n    while k == i or k == j:\n        k = random.randint(0, n - 1)\n\n    # Create new solution by inserting node k between i and j\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[k]], new_solution[i+1:j], [new_solution[k]], new_solution[j:]])\n\n    # Ensure uniqueness (remove duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Step 2: Node relocation (move a node to a better position)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        k = random.randint(0, n - 1)\n        current_node = new_solution[k]\n        # Find the best position to insert the node\n        best_cost = float('inf')\n        best_pos = k\n        for i in range(n):\n            if i == k or i == (k + 1) % n:\n                continue\n            # Calculate cost of inserting node at position i\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[i]\n            cost = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node] - distance_matrix_1[prev_node, next_node]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = i\n        if best_cost < 0:\n            # Perform the move\n            new_solution = np.concatenate([new_solution[:best_pos], [current_node], new_solution[best_pos:k], new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8749437333118568,
            1.2218745350837708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its rank (better solutions are more likely to be selected)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0)[:, 0])  # Rank based on first objective\n    probabilities = 1 / (ranks + 1)  # Inverse rank probabilities\n    probabilities = probabilities / np.sum(probabilities)  # Normalize\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion and node relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n    while k == i or k == j:\n        k = random.randint(0, n - 1)\n\n    # Create new solution by inserting node k between i and j\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[k]], new_solution[i+1:j], [new_solution[k]], new_solution[j:]])\n\n    # Ensure uniqueness (remove duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Step 2: Node relocation (move a node to a better position)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        k = random.randint(0, n - 1)\n        current_node = new_solution[k]\n        # Find the best position to insert the node\n        best_cost = float('inf')\n        best_pos = k\n        for i in range(n):\n            if i == k or i == (k + 1) % n:\n                continue\n            # Calculate cost of inserting node at position i\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[i]\n            cost = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node] - distance_matrix_1[prev_node, next_node]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = i\n        if best_cost < 0:\n            # Perform the move\n            new_solution = np.concatenate([new_solution[:best_pos], [current_node], new_solution[best_pos:k], new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 130,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total cost (promising for improvement)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Segment relocation: move a random segment to a new position\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility: check for duplicates and fix if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for pos, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[pos] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.946829513342976,
            0.5444061756134033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total cost (promising for improvement)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Segment relocation: move a random segment to a new position\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility: check for duplicates and fix if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for pos, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[pos] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 131,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a probability weighted by its Pareto dominance\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])  # Higher weight for earlier (better) solutions\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge insertion + segment relocation\n    if n > 3:\n        # Edge insertion: randomly select two edges and reconnect them differently\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure valid insertion points\n        if i < j and k < l and i != k and j != l:\n            # Create a new segment by relocating nodes between i and j to position k\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Additional improvement: try to swap nodes that reduce both objectives\n    improved = False\n    for _ in range(5):  # Limited attempts to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Evaluate the swap\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        swapped_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if swapped_cost < original_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            improved = True\n            break\n\n    if not improved:\n        # Fallback to a simple 2-opt if no improvement found\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7805284921105862,
            0.2027837634086609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a probability weighted by its Pareto dominance\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])  # Higher weight for earlier (better) solutions\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge insertion + segment relocation\n    if n > 3:\n        # Edge insertion: randomly select two edges and reconnect them differently\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure valid insertion points\n        if i < j and k < l and i != k and j != l:\n            # Create a new segment by relocating nodes between i and j to position k\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Additional improvement: try to swap nodes that reduce both objectives\n    improved = False\n    for _ in range(5):  # Limited attempts to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Evaluate the swap\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        swapped_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if swapped_cost < original_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            improved = True\n            break\n\n    if not improved:\n        # Fallback to a simple 2-opt if no improvement found\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 132,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., with low total cost or high diversity)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move (e.g., segment reversal with insertion)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose a segment to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverse the middle segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a custom move: insert a node from the middle segment elsewhere\n    if b + 1 < n:\n        node_to_insert = new_solution[b]\n        new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(new_solution) != n or len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the move fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7135325174173641,
            0.9465897083282471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., with low total cost or high diversity)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move (e.g., segment reversal with insertion)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose a segment to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverse the middle segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a custom move: insert a node from the middle segment elsewhere\n    if b + 1 < n:\n        node_to_insert = new_solution[b]\n        new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(new_solution) != n or len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the move fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 133,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a combination of objectives\n    def evaluate_solution(solution, obj):\n        # Normalize objectives to avoid bias towards larger values\n        norm_obj1 = obj[0] / (np.max(distance_matrix_1) * len(solution))\n        norm_obj2 = obj[1] / (np.max(distance_matrix_2) * len(solution))\n        return norm_obj1 + norm_obj2\n\n    # Sort solutions by their normalized combined objective\n    archive_sorted = sorted(archive, key=lambda x: evaluate_solution(x[0], x[1]))\n\n    # Select top 30% of solutions for random selection\n    top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform a hybrid move: 2-opt + edge swap\n        if i < j and k < l:\n            # 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            # Edge swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7800243450650618,
            0.7228446006774902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a combination of objectives\n    def evaluate_solution(solution, obj):\n        # Normalize objectives to avoid bias towards larger values\n        norm_obj1 = obj[0] / (np.max(distance_matrix_1) * len(solution))\n        norm_obj2 = obj[1] / (np.max(distance_matrix_2) * len(solution))\n        return norm_obj1 + norm_obj2\n\n    # Sort solutions by their normalized combined objective\n    archive_sorted = sorted(archive, key=lambda x: evaluate_solution(x[0], x[1]))\n\n    # Select top 30% of solutions for random selection\n    top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform a hybrid move: 2-opt + edge swap\n        if i < j and k < l:\n            # 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            # Edge swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = weights[0] * archive[0][1][0] + weights[1] * archive[0][1][1]\n\n    for i, (_, objective) in enumerate(archive[1:]):\n        score = weights[0] * objective[0] + weights[1] * objective[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i + 1\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge insertion: insert a randomly selected edge from another part of the tour\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        l = np.random.randint(0, n)\n        while l == k or l == k + 1 or l == i or l == j:\n            l = np.random.randint(0, n)\n\n        # Insert the segment between k and l\n        if l < k:\n            new_solution = np.concatenate((new_solution[:l], new_solution[k:l:-1], new_solution[l:k], new_solution[l+1:]))\n        else:\n            new_solution = np.concatenate((new_solution[:k], new_solution[l:k:-1], new_solution[k:l], new_solution[l+1:]))\n\n    return new_solution\n\n",
        "score": [
            -0.7799483761206131,
            0.08883386850357056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = weights[0] * archive[0][1][0] + weights[1] * archive[0][1][1]\n\n    for i, (_, objective) in enumerate(archive[1:]):\n        score = weights[0] * objective[0] + weights[1] * objective[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i + 1\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge insertion: insert a randomly selected edge from another part of the tour\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        l = np.random.randint(0, n)\n        while l == k or l == k + 1 or l == i or l == j:\n            l = np.random.randint(0, n)\n\n        # Insert the segment between k and l\n        if l < k:\n            new_solution = np.concatenate((new_solution[:l], new_solution[k:l:-1], new_solution[l:k], new_solution[l+1:]))\n        else:\n            new_solution = np.concatenate((new_solution[:k], new_solution[l:k:-1], new_solution[k:l], new_solution[l+1:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = weights[0] * archive[0][1][0] + weights[1] * archive[0][1][1]\n\n    for i, (_, objective) in enumerate(archive[1:]):\n        score = weights[0] * objective[0] + weights[1] * objective[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i + 1\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge insertion: insert a randomly selected edge from another part of the tour\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        l = np.random.randint(0, n)\n        while l == k or l == k + 1 or l == i or l == j:\n            l = np.random.randint(0, n)\n\n        # Insert the segment between k and l\n        if l < k:\n            new_solution = np.concatenate((new_solution[:l], new_solution[k:l:-1], new_solution[l:k], new_solution[l+1:]))\n        else:\n            new_solution = np.concatenate((new_solution[:k], new_solution[l:k:-1], new_solution[k:l], new_solution[l+1:]))\n\n    return new_solution\n\n",
        "score": [
            -0.7799483761206131,
            0.08883386850357056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = weights[0] * archive[0][1][0] + weights[1] * archive[0][1][1]\n\n    for i, (_, objective) in enumerate(archive[1:]):\n        score = weights[0] * objective[0] + weights[1] * objective[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i + 1\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge insertion: insert a randomly selected edge from another part of the tour\n    if j - i > 2:\n        k = np.random.randint(i, j)\n        l = np.random.randint(0, n)\n        while l == k or l == k + 1 or l == i or l == j:\n            l = np.random.randint(0, n)\n\n        # Insert the segment between k and l\n        if l < k:\n            new_solution = np.concatenate((new_solution[:l], new_solution[k:l:-1], new_solution[l:k], new_solution[l+1:]))\n        else:\n            new_solution = np.concatenate((new_solution[:k], new_solution[l:k:-1], new_solution[k:l], new_solution[l+1:]))\n\n    return new_solution\n\n"
    }
]