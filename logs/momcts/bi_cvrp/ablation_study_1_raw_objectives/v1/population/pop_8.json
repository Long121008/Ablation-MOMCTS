[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging to improve the solution while ensuring feasibility. It randomly selects two routes, relocates a segment between them if capacity allows, or merges them if possible, and checks feasibility before returning the new solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Relocate a segment between routes or merge two routes\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:  # Need at least one customer to relocate\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5333262969216688,
            0.22810059785842896
        ],
        "raw_score": [
            37.52143125387771,
            4.577189938048067
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with balanced makespan and distance, then applies a hybrid local search combining spatial-aware route merging and demand-aware customer redistribution. It first clusters routes by spatial proximity, merging feasible routes or redistributing customers between nearby clusters, followed by balancing demand imbalances by transferring customers between routes while maintaining capacity constraints. The approach prioritizes spatial proximity for merging and demand balance for redistribution, ensuring feasible solutions while targeting simultaneous improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial-aware route clustering\n    if len(new_solution) > 1:\n        # Calculate centroids for each route\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n\n        # Pair routes with closest centroids\n        route_pairs = []\n        used = set()\n        for i in range(len(centroids)):\n            if i in used:\n                continue\n            min_dist = float('inf')\n            best_j = -1\n            for j in range(i+1, len(centroids)):\n                if j not in used:\n                    dist = np.linalg.norm(centroids[i] - centroids[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_j = j\n            if best_j != -1:\n                route_pairs.append((i, best_j))\n                used.add(i)\n                used.add(best_j)\n\n        # For each pair, try merging if capacity allows\n        for i, j in route_pairs:\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution[j] = np.array([0])  # Mark for removal\n            else:\n                # Redistribute customers based on spatial proximity\n                customers = list(route1[1:-1]) + list(route2[1:-1])\n                centroid1 = centroids[i]\n                centroid2 = centroids[j]\n\n                # Split customers between routes\n                route1_customers = []\n                route2_customers = []\n                for customer in customers:\n                    dist1 = np.linalg.norm(coords[customer] - centroid1)\n                    dist2 = np.linalg.norm(coords[customer] - centroid2)\n                    if dist1 < dist2:\n                        route1_customers.append(customer)\n                    else:\n                        route2_customers.append(customer)\n\n                # Rebuild routes with new customers\n                if sum(demand[node] for node in route1_customers) <= capacity:\n                    new_solution[i] = np.concatenate([[0], route1_customers, [0]])\n                if sum(demand[node] for node in route2_customers) <= capacity:\n                    new_solution[j] = np.concatenate([[0], route2_customers, [0]])\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 2: Demand-aware customer redistribution\n    if len(new_solution) > 1:\n        # Find the most imbalanced route (highest demand deviation from average)\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n        imbalances = [abs(d - avg_demand) for d in route_demands]\n        source_idx = imbalances.index(max(imbalances))\n\n        # Find the most compatible route to receive customers\n        target_idx = min(range(len(new_solution)), key=lambda i: abs(sum(demand[node] for node in new_solution[i][1:-1]) - avg_demand) if i != source_idx else float('inf'))\n\n        source_route = new_solution[source_idx]\n        target_route = new_solution[target_idx]\n\n        # Try to transfer customers from source to target\n        source_customers = list(source_route[1:-1])\n        target_customers = list(target_route[1:-1])\n        transferred = False\n\n        for customer in source_customers:\n            if sum(demand[node] for node in target_customers) + demand[customer] <= capacity:\n                target_customers.append(customer)\n                source_customers.remove(customer)\n                transferred = True\n\n        if transferred:\n            # Rebuild routes\n            new_solution[source_idx] = np.concatenate([[0], source_customers, [0]])\n            new_solution[target_idx] = np.concatenate([[0], target_customers, [0]])\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8311703624804405,
            1.0237776935100555
        ],
        "raw_score": [
            58.3023752816847,
            7.88680034130579
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging, while also incorporating a novel \"route splitting\" mechanism (with a 30% chance) to improve solutions while ensuring feasibility. It intelligently selects routes, segments, and insertion points, checks capacity constraints, and reverts to the original solution if feasibility is violated. The algorithm balances exploration (random selection) and exploitation (prioritization) of high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n        # Novel route splitting mechanism\n        if len(new_solution) < len(base_solution) and random.random() < 0.3:  # 30% chance to split a route\n            long_route = max(new_solution, key=lambda r: len(r))\n            if len(long_route) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(long_route) - 3)\n                first_part = np.concatenate([long_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check capacity constraints for both parts\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution.remove(long_route)\n                    new_solution.append(first_part)\n                    new_solution.append(second_part)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7624629018001627,
            0.2549241781234741
        ],
        "raw_score": [
            36.91533735728953,
            4.559352320583427
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing lower makespan (with total distance as a tiebreaker), then applies a hybrid local search that randomly inverts a route segment (if feasible) and may split the route into two (if both resulting routes are capacity-feasible). The method ensures feasibility by reverting changes if capacity constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize solutions with lower makespan, then total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Invert a segment within a route or split a route into two\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Need at least one customer to invert or split\n            # Invert a segment within the route\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            inverted_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Check if the inverted route is feasible\n            if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                new_solution[route_idx] = route  # Revert if infeasible\n            else:\n                # Try splitting the route if inversion is successful\n                split_pos = random.randint(1, len(new_route) - 2)\n                first_part = np.concatenate([[0], new_route[1:split_pos + 1], [0]])\n                second_part = np.concatenate([[0], new_route[split_pos + 1:-1], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9001978421599203,
            1.1289136409759521
        ],
        "raw_score": [
            68.28775165670466,
            2.6695998127591607
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of makespan (70%) and total distance (30%), then applies a hybrid local search that combines route merging (when feasible), demand-balanced route splitting (to balance capacity), and adaptive 3-opt (on the longest route) to improve both objectives while maintaining feasibility. It prioritizes reducing makespan early by favoring solutions with shorter longest routes, while also optimizing total distance through intelligent route restructuring.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (0.7 * x[1][1] + 0.3 * x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging, demand-balanced splitting, and adaptive 3-opt\n    if len(new_solution) > 1:\n        # Route merging: try to merge two routes if their combined demand is within capacity\n        for _ in range(min(3, len(new_solution) - 1)):\n            route1_idx, route2_idx = sorted(random.sample(range(len(new_solution)), 2))\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if sum(demand[node] for node in route1) + sum(demand[node] for node in route2) <= capacity:\n                # Merge routes by connecting them at the closest pair of nodes\n                min_dist = float('inf')\n                best_pair = (None, None)\n\n                for i in range(1, len(route1) - 1):\n                    for j in range(1, len(route2) - 1):\n                        dist = distance_matrix[route1[i]][route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (i, j)\n\n                if best_pair[0] is not None:\n                    # Create merged route\n                    merged_route = np.concatenate([\n                        route1[:best_pair[0] + 1],\n                        route2[best_pair[1]:],\n                        route1[best_pair[0] + 1:]\n                    ])\n                    new_solution[route1_idx] = merged_route\n                    new_solution.pop(route2_idx)\n                    break\n\n        # Demand-balanced route splitting: split routes that are too long\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:\n                total_demand = sum(demand[node] for node in route[1:-1])\n                if total_demand > capacity:\n                    # Find optimal split point to balance demand\n                    cumulative_demand = np.cumsum([demand[node] for node in route[1:-1]])\n                    target_demand = total_demand / 2\n                    split_point = np.argmin(np.abs(cumulative_demand - target_demand)) + 1\n\n                    # Create new route from split point\n                    new_route = np.concatenate([[0], route[split_point:-1], [0]])\n                    new_solution[i] = np.concatenate([[0], route[1:split_point+1], [0]])\n                    new_solution.append(new_route)\n\n        # Adaptive 3-opt: perform 3-opt on the longest route\n        if len(new_solution) > 0:\n            longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n            route = new_solution[longest_route_idx]\n\n            if len(route) > 5:  # Need at least 6 nodes for 3-opt\n                # Select three edges to reconnect\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n\n                # Generate all possible 3-opt configurations\n                configs = [\n                    (route[:i+1], route[i+1:j+1][::-1], route[j+1:k+1][::-1], route[k+1:]),\n                    (route[:i+1], route[j+1:k+1], route[i+1:j+1][::-1], route[k+1:]),\n                    (route[:j+1], route[i+1:k+1][::-1], route[j+1:i+1][::-1], route[k+1:])\n                ]\n\n                # Find the best configuration that maintains capacity constraints\n                best_config = None\n                min_cost = float('inf')\n\n                for config in configs:\n                    # Check capacity for each segment\n                    valid = True\n                    for segment in config[1:-1]:\n                        if sum(demand[node] for node in segment) > capacity:\n                            valid = False\n                            break\n\n                    if valid:\n                        # Calculate total cost of the configuration\n                        total_cost = 0\n                        prev_node = 0\n                        for segment in config:\n                            for node in segment:\n                                total_cost += distance_matrix[prev_node][node]\n                                prev_node = node\n\n                        if total_cost < min_cost:\n                            min_cost = total_cost\n                            best_config = config\n\n                if best_config is not None:\n                    # Apply the best configuration\n                    new_route = np.concatenate(best_config)\n                    new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4455812537469833,
            0.23222047090530396
        ],
        "raw_score": [
            51.52299102153323,
            6.576942519958482
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest makespan (prioritized over total distance) from the archive and applies a hybrid local search combining inter-route customer transfers, capacity-aware 2-opt within routes, and route splitting to handle capacity violations, ensuring feasibility and potential multi-objective improvements. The method favors routes with lower makespan and total distance, while the local search intelligently explores inter-route and intra-route moves to balance both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting, inter-route insertion, and capacity-aware 2-opt\n    if len(new_solution) > 1:\n        # Randomly select two routes for inter-route operations\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Inter-route insertion: try to move a customer from route1 to route2\n        if len(route1) > 2:\n            # Select a random customer from route1 (excluding depots)\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Check if moving this customer to route2 is feasible\n            current_load = sum(demand[node] for node in route2)\n            if current_load + demand[customer] <= capacity:\n                # Remove customer from route1\n                new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Insert customer into route2 (try different positions)\n                best_position = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route2)):\n                    # Calculate insertion cost\n                    cost = distance_matrix[route2[pos-1]][customer] + distance_matrix[customer][route2[pos]] - distance_matrix[route2[pos-1]][route2[pos]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_position = pos\n\n                # Insert the customer\n                new_route2 = np.concatenate([route2[:best_position], [customer], route2[best_position:]])\n                new_solution[route2_idx] = new_route2\n\n        # Capacity-aware 2-opt within a route\n        for route in new_solution:\n            if len(route) > 4:  # Need at least 4 nodes to perform 2-opt\n                # Select two edges to reverse\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n\n                # Check capacity constraint for the new segment\n                segment_demand = sum(demand[node] for node in route[i:j+1])\n                if segment_demand <= capacity:\n                    # Reverse the segment\n                    route[i:j+1] = route[i:j+1][::-1]\n\n    # Route splitting if a route is too long\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # If route has more than just depots\n            # Calculate cumulative demand\n            cumulative_demand = np.cumsum([demand[node] for node in route[1:-1]])\n            split_pos = np.where(cumulative_demand > capacity)[0]\n\n            if len(split_pos) > 0:\n                # Split at the first position where capacity is exceeded\n                split_point = split_pos[0] + 1  # +1 because we want to split after this customer\n\n                # Create new route from the split point\n                new_route = np.concatenate([[0], route[split_point:-1], [0]])\n                new_solution[i] = np.concatenate([[0], route[1:split_point+1], [0]])\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5896292014551943,
            0.2732754051685333
        ],
        "raw_score": [
            45.66104831782705,
            4.913209142017411
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan from the archive, applies a hybrid local search that splits overloaded routes to balance demand, and reallocates customers between routes to reduce total distance while maintaining feasibility. It prioritizes makespan reduction through route splitting and distance optimization through customer reallocation, ensuring vehicle capacity constraints are always satisfied.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Check if splitting the route can improve makespan\n        total_demand = sum(demand[customer] for customer in route[1:-1])\n        if total_demand <= capacity:\n            continue  # Route is already feasible\n\n        # Find the best split point to balance demand\n        best_split = -1\n        min_max_load = float('inf')\n        current_load = 0\n\n        for j in range(1, len(route)-1):\n            current_load += demand[route[j]]\n            remaining_load = total_demand - current_load\n            max_load = max(current_load, remaining_load)\n\n            if max_load < min_max_load:\n                min_max_load = max_load\n                best_split = j\n\n        if best_split != -1:\n            # Split the route at best_split\n            new_route1 = np.concatenate([route[:best_split+1], [0]])\n            new_route2 = np.concatenate([[0], route[best_split+1:]])\n\n            # Replace the original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Reallocate customers to improve distance while maintaining feasibility\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to move customers to other routes if it reduces total distance\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            current_route_index = i\n\n            # Find the best route to move the customer to\n            best_route_index = -1\n            best_distance_reduction = 0\n\n            for k in range(len(new_solution)):\n                if k == current_route_index:\n                    continue\n\n                other_route = new_solution[k]\n                if sum(demand[customer] for customer in other_route[1:-1]) + demand[customer] > capacity:\n                    continue  # Skip if adding customer exceeds capacity\n\n                # Calculate distance reduction if moved\n                # Distance before: distance from predecessor to customer and customer to successor in current route\n                pred = route[j-1]\n                succ = route[j+1]\n                original_distance = distance_matrix[pred, customer] + distance_matrix[customer, succ]\n\n                # Distance after: distance from last node in other route to customer and customer to depot\n                last_node = other_route[-2]\n                new_distance = distance_matrix[last_node, customer] + distance_matrix[customer, 0]\n\n                distance_reduction = original_distance - new_distance\n\n                if distance_reduction > best_distance_reduction:\n                    best_distance_reduction = distance_reduction\n                    best_route_index = k\n\n            if best_route_index != -1:\n                # Move the customer to the best route\n                customer = route[j]\n                new_solution[best_route_index] = np.concatenate([new_solution[best_route_index][:-1], [customer], [0]])\n\n                # Remove the customer from the original route\n                new_solution[current_route_index] = np.concatenate([route[:j], route[j+1:]])\n\n                # If the original route is now empty, remove it\n                if len(new_solution[current_route_index]) == 2:\n                    del new_solution[current_route_index]\n                    break  # Restart the loop since the list has changed\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8197619970622914,
            4.295692175626755
        ],
        "raw_score": [
            58.032952507921905,
            7.675296988668824
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (prioritizing those with makespan/distance ratio close to 1) and applies a hybrid local search combining spatial-aware route contraction (removing farthest customers) and demand-aware reallocation (transferring customers between routes to balance demand), while ensuring feasibility and multi-objective improvement. The key design ideas are spatial clustering for makespan reduction and demand balancing for distance efficiency, with dynamic capacity checks and route contraction/expansion operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route contraction and expansion operator\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 2:\n            continue\n\n        # Contract route by removing redundant customers (those far from centroid)\n        centroid = np.mean(coords[route[1:-1]], axis=0)\n        distances = [np.linalg.norm(coords[node] - centroid) for node in route[1:-1]]\n        threshold = np.percentile(distances, 75)  # Remove top 25% farthest customers\n        contracted_route = [node for i, node in enumerate(route[1:-1]) if distances[i] <= threshold]\n\n        # Check capacity constraint\n        if sum(demand[node] for node in contracted_route) <= capacity:\n            new_solution[route_idx] = np.concatenate([[0], contracted_route, [0]])\n        else:\n            # If contraction violates capacity, try to expand by adding nearby customers\n            expanded_route = list(contracted_route)\n            remaining_customers = [node for node in route[1:-1] if node not in contracted_route]\n\n            for customer in remaining_customers:\n                if sum(demand[node] for node in expanded_route) + demand[customer] <= capacity:\n                    expanded_route.append(customer)\n\n            new_solution[route_idx] = np.concatenate([[0], expanded_route, [0]])\n\n    # Demand-aware customer reallocation between routes\n    if len(new_solution) > 1:\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n\n        # Find the most underutilized and overutilized routes\n        underutilized_idx = min(range(len(new_solution)), key=lambda i: abs(route_demands[i] - avg_demand))\n        overutilized_idx = max(range(len(new_solution)), key=lambda i: abs(route_demands[i] - avg_demand) if i != underutilized_idx else -float('inf'))\n\n        underutilized_route = new_solution[underutilized_idx]\n        overutilized_route = new_solution[overutilized_idx]\n\n        # Try to transfer customers from overutilized to underutilized route\n        transferred = False\n        for customer in overutilized_route[1:-1]:\n            if sum(demand[node] for node in underutilized_route[1:-1]) + demand[customer] <= capacity:\n                underutilized_route = np.concatenate([[0], underutilized_route[1:-1], [customer], [0]])\n                overutilized_route = np.concatenate([[0], [node for node in overutilized_route[1:-1] if node != customer], [0]])\n                transferred = True\n                break\n\n        if transferred:\n            new_solution[underutilized_idx] = underutilized_route\n            new_solution[overutilized_idx] = overutilized_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7914997323761224,
            1.2943596839904785
        ],
        "raw_score": [
            58.04524629029159,
            7.768080352776303
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive (prioritizing those with shorter makespan) and applies a hybrid local search combining route fragmentation (splitting long routes) with a demand-aware 2-opt operator (reversing segments to reduce distance while respecting capacity constraints). It ensures feasibility by checking capacity constraints at each step and splitting routes if violated. The focus is on balancing distance and makespan minimization while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance and crowding distance\n    selected_idx = 0\n    min_makespan = float('inf')\n    for i, (sol, (dist, ms)) in enumerate(archive):\n        if ms < min_makespan:\n            min_makespan = ms\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + demand-aware 2-opt\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Can be split\n            split_pos = len(longest_route) // 2\n            route1 = longest_route[:split_pos + 1]\n            route2 = longest_route[split_pos:]\n\n            # Check capacity constraints\n            if (sum(demand[route1[1:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.pop(longest_route_idx)\n                new_solution.append(route1)\n                new_solution.append(route2)\n\n    # Step 2: Demand-aware 2-opt - improve routes by considering demand patterns\n    for route in new_solution:\n        if len(route) > 3:\n            improved = True\n            while improved:\n                improved = False\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        # Calculate current and new distances\n                        current_dist = (distance_matrix[route[i-1]][route[i]] +\n                                       distance_matrix[route[j]][route[j+1]])\n                        new_dist = (distance_matrix[route[i-1]][route[j]] +\n                                   distance_matrix[route[i]][route[j+1]])\n\n                        # Calculate current and new demands\n                        segment = route[i:j+1]\n                        current_demand = sum(demand[segment])\n                        reversed_demand = sum(demand[segment[::-1]])\n\n                        if new_dist < current_dist and reversed_demand <= capacity:\n                            # Reverse the segment to improve distance\n                            route[i:j+1] = route[j:i-1:-1]\n                            improved = True\n                            break\n                    if improved:\n                        break\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If capacity is violated, split the route\n            split_pos = 1\n            current_load = 0\n            for i in range(1, len(route)-1):\n                if current_load + demand[route[i]] > capacity:\n                    # Split before this node\n                    new_route = route[:i] + [0]\n                    remaining_route = [0] + route[i:]\n                    new_solution.remove(route)\n                    new_solution.append(new_route)\n                    new_solution.append(remaining_route)\n                    break\n                current_load += demand[route[i]]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7590913293379504,
            11.036344200372696
        ],
        "raw_score": [
            58.470635245599155,
            7.780710701920874
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower total distance), then applies a hybrid local search combining route merging, capacity-aware customer relocation, and adaptive 3-opt within routes, ensuring feasibility while balancing multi-objective improvements by favoring lower-distance and makespan routes. It also includes route splitting if a route exceeds capacity, with random sampling to explore diverse neighborhoods. The key design priorities are minimizing total distance first, then makespan, with capacity constraints strictly enforced.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging, relocation, and adaptive 3-opt\n    if len(new_solution) > 1:\n        # Route merging: try to merge two routes if their total demand is within capacity\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand = sum(demand[node] for node in route1) + sum(demand[node] for node in route2) - 2 * demand[0]  # subtract depot demands\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n        # Capacity-aware relocation: move a customer from one route to another\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2:\n                customer_idx = random.randint(1, len(route1) - 2)\n                customer = route1[customer_idx]\n\n                current_load = sum(demand[node] for node in route2)\n                if current_load + demand[customer] <= capacity:\n                    # Remove customer from route1\n                    new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    # Insert customer into route2 (try different positions)\n                    best_position = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        cost = distance_matrix[route2[pos-1]][customer] + distance_matrix[customer][route2[pos]] - distance_matrix[route2[pos-1]][route2[pos]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_position = pos\n\n                    new_route2 = np.concatenate([route2[:best_position], [customer], route2[best_position:]])\n                    new_solution[route2_idx] = new_route2\n\n        # Adaptive 3-opt within a route\n        for route in new_solution:\n            if len(route) > 5:  # Need at least 5 nodes to perform 3-opt\n                # Select three edges to reconnect\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n\n                # Check capacity constraint for the new segments\n                segment1_demand = sum(demand[node] for node in route[i:j+1])\n                segment2_demand = sum(demand[node] for node in route[j+1:k+1])\n                if segment1_demand + segment2_demand <= capacity:\n                    # Perform 3-opt: reconnect the segments in a different order\n                    new_order = [\n                        route[:i+1],\n                        route[j+1:k+1],\n                        route[i+1:j+1],\n                        route[k+1:]\n                    ]\n                    new_route = np.concatenate(new_order)\n                    route[:] = new_route\n\n    # Route splitting if a route is too long\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:\n            cumulative_demand = np.cumsum([demand[node] for node in route[1:-1]])\n            split_pos = np.where(cumulative_demand > capacity)[0]\n\n            if len(split_pos) > 0:\n                split_point = split_pos[0] + 1\n                new_route = np.concatenate([[0], route[split_point:-1], [0]])\n                new_solution[i] = np.concatenate([[0], route[1:split_point+1], [0]])\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5310623954032111,
            0.31460678577423096
        ],
        "raw_score": [
            45.81541026602657,
            5.520292339835818
        ]
    }
]