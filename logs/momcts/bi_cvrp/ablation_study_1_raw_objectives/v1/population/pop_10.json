[
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with balanced makespan and distance, then applies a hybrid local search combining spatial-aware route merging and demand-aware customer redistribution. It first clusters routes by spatial proximity, merging feasible routes or redistributing customers between nearby clusters, followed by balancing demand imbalances by transferring customers between routes while maintaining capacity constraints. The approach prioritizes spatial proximity for merging and demand balance for redistribution, ensuring feasible solutions while targeting simultaneous improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial-aware route clustering\n    if len(new_solution) > 1:\n        # Calculate centroids for each route\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n\n        # Pair routes with closest centroids\n        route_pairs = []\n        used = set()\n        for i in range(len(centroids)):\n            if i in used:\n                continue\n            min_dist = float('inf')\n            best_j = -1\n            for j in range(i+1, len(centroids)):\n                if j not in used:\n                    dist = np.linalg.norm(centroids[i] - centroids[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_j = j\n            if best_j != -1:\n                route_pairs.append((i, best_j))\n                used.add(i)\n                used.add(best_j)\n\n        # For each pair, try merging if capacity allows\n        for i, j in route_pairs:\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution[j] = np.array([0])  # Mark for removal\n            else:\n                # Redistribute customers based on spatial proximity\n                customers = list(route1[1:-1]) + list(route2[1:-1])\n                centroid1 = centroids[i]\n                centroid2 = centroids[j]\n\n                # Split customers between routes\n                route1_customers = []\n                route2_customers = []\n                for customer in customers:\n                    dist1 = np.linalg.norm(coords[customer] - centroid1)\n                    dist2 = np.linalg.norm(coords[customer] - centroid2)\n                    if dist1 < dist2:\n                        route1_customers.append(customer)\n                    else:\n                        route2_customers.append(customer)\n\n                # Rebuild routes with new customers\n                if sum(demand[node] for node in route1_customers) <= capacity:\n                    new_solution[i] = np.concatenate([[0], route1_customers, [0]])\n                if sum(demand[node] for node in route2_customers) <= capacity:\n                    new_solution[j] = np.concatenate([[0], route2_customers, [0]])\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 2: Demand-aware customer redistribution\n    if len(new_solution) > 1:\n        # Find the most imbalanced route (highest demand deviation from average)\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n        imbalances = [abs(d - avg_demand) for d in route_demands]\n        source_idx = imbalances.index(max(imbalances))\n\n        # Find the most compatible route to receive customers\n        target_idx = min(range(len(new_solution)), key=lambda i: abs(sum(demand[node] for node in new_solution[i][1:-1]) - avg_demand) if i != source_idx else float('inf'))\n\n        source_route = new_solution[source_idx]\n        target_route = new_solution[target_idx]\n\n        # Try to transfer customers from source to target\n        source_customers = list(source_route[1:-1])\n        target_customers = list(target_route[1:-1])\n        transferred = False\n\n        for customer in source_customers:\n            if sum(demand[node] for node in target_customers) + demand[customer] <= capacity:\n                target_customers.append(customer)\n                source_customers.remove(customer)\n                transferred = True\n\n        if transferred:\n            # Rebuild routes\n            new_solution[source_idx] = np.concatenate([[0], source_customers, [0]])\n            new_solution[target_idx] = np.concatenate([[0], target_customers, [0]])\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8311703624804405,
            1.0237776935100555
        ],
        "raw_score": [
            58.3023752816847,
            7.88680034130579
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging, while also incorporating a novel \"route splitting\" mechanism (with a 30% chance) to improve solutions while ensuring feasibility. It intelligently selects routes, segments, and insertion points, checks capacity constraints, and reverts to the original solution if feasibility is violated. The algorithm balances exploration (random selection) and exploitation (prioritization) of high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n        # Novel route splitting mechanism\n        if len(new_solution) < len(base_solution) and random.random() < 0.3:  # 30% chance to split a route\n            long_route = max(new_solution, key=lambda r: len(r))\n            if len(long_route) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(long_route) - 3)\n                first_part = np.concatenate([long_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check capacity constraints for both parts\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution.remove(long_route)\n                    new_solution.append(first_part)\n                    new_solution.append(second_part)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7624629018001627,
            0.2549241781234741
        ],
        "raw_score": [
            36.91533735728953,
            4.559352320583427
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing lower makespan (with total distance as a tiebreaker), then applies a hybrid local search that randomly inverts a route segment (if feasible) and may split the route into two (if both resulting routes are capacity-feasible). The method ensures feasibility by reverting changes if capacity constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize solutions with lower makespan, then total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Invert a segment within a route or split a route into two\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Need at least one customer to invert or split\n            # Invert a segment within the route\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            inverted_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Check if the inverted route is feasible\n            if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                new_solution[route_idx] = route  # Revert if infeasible\n            else:\n                # Try splitting the route if inversion is successful\n                split_pos = random.randint(1, len(new_route) - 2)\n                first_part = np.concatenate([[0], new_route[1:split_pos + 1], [0]])\n                second_part = np.concatenate([[0], new_route[split_pos + 1:-1], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9001978421599203,
            1.1289136409759521
        ],
        "raw_score": [
            68.28775165670466,
            2.6695998127591607
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower makespan, then applies a hybrid local search combining demand-clustered route splitting, spatial-aware customer reallocation, and segment inversion, while ensuring feasibility through capacity checks. It dynamically selects routes and customers for modification, balancing distance and makespan objectives through strategic segment operations and spatial proximity considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize lower makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Demand-clustered splitting\n            customers = route[1:-1]\n            if len(customers) > 1:\n                split_pos = random.randint(1, len(customers) - 1)\n                first_part = np.concatenate([[0], customers[:split_pos], [0]])\n                second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    route = new_solution[-1]  # Focus on the new route\n\n            # Spatial-aware reallocation\n            if len(new_solution) > 1 and len(route) > 3:\n                other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                other_route = new_solution[other_route_idx]\n\n                # Find closest customer in the current route to the other route's depot\n                depot_coords = coords[0]\n                closest_customer = min(route[1:-1], key=lambda x: np.linalg.norm(coords[x] - depot_coords))\n\n                if sum(demand[node] for node in other_route[1:-1]) + demand[closest_customer] <= capacity:\n                    # Insert closest customer into other route\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.concatenate([other_route[:insert_pos], [closest_customer], other_route[insert_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove from current route\n                    new_route = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                               route[np.where(route == closest_customer)[0][0] + 1:]])\n                    new_solution[route_idx] = new_route\n\n            # Segment inversion\n            if len(route) > 3:\n                segment_start = random.randint(1, len(route) - 2)\n                segment_end = random.randint(segment_start, len(route) - 2)\n                inverted_segment = route[segment_start:segment_end + 1][::-1]\n                new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7958546958714325,
            0.5512029230594635
        ],
        "raw_score": [
            62.771142253628895,
            5.684504530286869
        ]
    },
    {
        "algorithm": "The algorithm selects a solution with the lowest combined total distance and makespan from the archive, then applies a hybrid local search combining demand-clustered route splitting (randomly dividing high-demand routes) and spatial-aware customer reallocation (moving depot-proximal customers between routes while respecting capacity constraints). It prioritizes solutions with balanced objectives and uses randomized operations to explore the solution space while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-clustered splitting\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            customers = route[1:-1]\n            if len(customers) > 1:\n                split_pos = random.randint(1, len(customers) - 1)\n                first_part = np.concatenate([[0], customers[:split_pos], [0]])\n                second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    route = new_solution[-1]\n\n        # Spatial-aware reallocation\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            depot_coords = coords[0]\n            closest_customer = min(route[1:-1], key=lambda x: np.linalg.norm(coords[x] - depot_coords))\n\n            if sum(demand[node] for node in other_route[1:-1]) + demand[closest_customer] <= capacity:\n                insert_pos = random.randint(1, len(other_route) - 1)\n                new_other_route = np.concatenate([other_route[:insert_pos], [closest_customer], other_route[insert_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                new_route = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                           route[np.where(route == closest_customer)[0][0] + 1:]])\n                new_solution[route_idx] = new_route\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.6393687239905992,
            0.18348291516304016
        ],
        "raw_score": [
            55.530776053518665,
            5.9390028569596165
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance (with makespan as a tiebreaker) from the archive, then applies a hybrid local search combining route inversion, segment relocation, and merging to generate feasible neighbors while balancing both objectives. It probabilistically selects one of three operations to modify routes, ensuring capacity constraints are met, and falls back to the original solution if feasibility is violated. The approach intelligently explores the solution space by combining novel route transformations while maintaining solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0], x[1][1]))  # Prioritize solutions with lower total distance, then makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Randomly choose one of three operations: invert, relocate, or merge\n        operation = random.choice(['invert', 'relocate', 'merge'])\n\n        if operation == 'invert' and len(new_solution) > 0:\n            # Select a random route and invert a segment\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                segment_start = random.randint(1, len(route) - 2)\n                segment_end = random.randint(segment_start, len(route) - 2)\n                inverted_segment = route[segment_start:segment_end + 1][::-1]\n                new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        elif operation == 'relocate' and len(new_solution) > 1:\n            # Relocate a segment between two different routes\n            src_route_idx = random.randint(0, len(new_solution) - 1)\n            dst_route_idx = random.randint(0, len(new_solution) - 1)\n            if src_route_idx != dst_route_idx:\n                src_route = new_solution[src_route_idx]\n                dst_route = new_solution[dst_route_idx]\n                if len(src_route) > 3 and len(dst_route) > 2:\n                    segment_start = random.randint(1, len(src_route) - 2)\n                    segment_end = random.randint(segment_start, len(src_route) - 2)\n                    relocated_segment = src_route[segment_start:segment_end + 1]\n                    new_src_route = np.concatenate([src_route[:segment_start], src_route[segment_end + 1:]])\n                    new_dst_route = np.concatenate([dst_route[:1], relocated_segment, dst_route[1:]])\n\n                    if (sum(demand[node] for node in new_src_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in new_dst_route[1:-1]) <= capacity):\n                        new_solution[src_route_idx] = new_src_route\n                        new_solution[dst_route_idx] = new_dst_route\n\n        elif operation == 'merge' and len(new_solution) > 1:\n            # Merge two routes if their combined demand is feasible\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 2 and len(route2) > 2:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                if sum(demand[node] for node in merged_route[1:-1]) <= capacity:\n                    new_solution.pop(max(route1_idx, route2_idx))\n                    new_solution.pop(min(route1_idx, route2_idx))\n                    new_solution.append(merged_route)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5183306671620231,
            0.2092544138431549
        ],
        "raw_score": [
            35.40889539301948,
            4.49321926746614
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan from the archive, applies a hybrid local search that splits overloaded routes to balance demand, and reallocates customers between routes to reduce total distance while maintaining feasibility. It prioritizes makespan reduction through route splitting and distance optimization through customer reallocation, ensuring vehicle capacity constraints are always satisfied.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Split long routes and reallocate customers\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Check if splitting the route can improve makespan\n        total_demand = sum(demand[customer] for customer in route[1:-1])\n        if total_demand <= capacity:\n            continue  # Route is already feasible\n\n        # Find the best split point to balance demand\n        best_split = -1\n        min_max_load = float('inf')\n        current_load = 0\n\n        for j in range(1, len(route)-1):\n            current_load += demand[route[j]]\n            remaining_load = total_demand - current_load\n            max_load = max(current_load, remaining_load)\n\n            if max_load < min_max_load:\n                min_max_load = max_load\n                best_split = j\n\n        if best_split != -1:\n            # Split the route at best_split\n            new_route1 = np.concatenate([route[:best_split+1], [0]])\n            new_route2 = np.concatenate([[0], route[best_split+1:]])\n\n            # Replace the original route with the two new routes\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Reallocate customers to improve distance while maintaining feasibility\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to move customers to other routes if it reduces total distance\n        for j in range(1, len(route)-1):\n            customer = route[j]\n            current_route_index = i\n\n            # Find the best route to move the customer to\n            best_route_index = -1\n            best_distance_reduction = 0\n\n            for k in range(len(new_solution)):\n                if k == current_route_index:\n                    continue\n\n                other_route = new_solution[k]\n                if sum(demand[customer] for customer in other_route[1:-1]) + demand[customer] > capacity:\n                    continue  # Skip if adding customer exceeds capacity\n\n                # Calculate distance reduction if moved\n                # Distance before: distance from predecessor to customer and customer to successor in current route\n                pred = route[j-1]\n                succ = route[j+1]\n                original_distance = distance_matrix[pred, customer] + distance_matrix[customer, succ]\n\n                # Distance after: distance from last node in other route to customer and customer to depot\n                last_node = other_route[-2]\n                new_distance = distance_matrix[last_node, customer] + distance_matrix[customer, 0]\n\n                distance_reduction = original_distance - new_distance\n\n                if distance_reduction > best_distance_reduction:\n                    best_distance_reduction = distance_reduction\n                    best_route_index = k\n\n            if best_route_index != -1:\n                # Move the customer to the best route\n                customer = route[j]\n                new_solution[best_route_index] = np.concatenate([new_solution[best_route_index][:-1], [customer], [0]])\n\n                # Remove the customer from the original route\n                new_solution[current_route_index] = np.concatenate([route[:j], route[j+1:]])\n\n                # If the original route is now empty, remove it\n                if len(new_solution[current_route_index]) == 2:\n                    del new_solution[current_route_index]\n                    break  # Restart the loop since the list has changed\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8197619970622914,
            4.295692175626755
        ],
        "raw_score": [
            58.032952507921905,
            7.675296988668824
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive (prioritizing shorter makespan and then distance), clusters customers by demand and spatial proximity using hierarchical clustering, creates new routes from these clusters while ensuring capacity constraints, and merges routes when possible to reduce makespan while maintaining feasibility. The key innovations are the demand-aware clustering and capacity-aware merging of routes, which balance both objectives more effectively than standard methods.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize makespan then distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Cluster customers by demand and spatial proximity\n    all_customers = []\n    for route in new_solution:\n        all_customers.extend(route[1:-1])\n\n    if not all_customers:\n        return new_solution\n\n    # Hierarchical clustering based on demand and coordinates\n    from scipy.cluster.hierarchy import fcluster, linkage\n    features = np.column_stack([demand[all_customers], coords[all_customers].mean(axis=1)])\n    Z = linkage(features, method='ward')\n    clusters = fcluster(Z, t=len(new_solution), criterion='maxclust')\n\n    # Create new routes from clusters\n    clustered_routes = []\n    for cluster_id in np.unique(clusters):\n        cluster_customers = [all_customers[i] for i, cid in enumerate(clusters) if cid == cluster_id]\n        if not cluster_customers:\n            continue\n\n        # Sort customers by spatial proximity to depot for initial insertion\n        depot_distances = distance_matrix[0, cluster_customers]\n        sorted_customers = [x for _, x in sorted(zip(depot_distances, cluster_customers))]\n\n        current_route = [0]\n        current_load = 0\n        for customer in sorted_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                clustered_routes.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n        current_route.append(0)\n        clustered_routes.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_routes = []\n    for route in clustered_routes:\n        merged = False\n        for i, existing_route in enumerate(merged_routes):\n            if sum(demand[node] for node in existing_route[1:-1]) + sum(demand[node] for node in route[1:-1]) <= capacity:\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_routes[i] = merged_route\n                merged = True\n                break\n        if not merged:\n            merged_routes.append(route.copy())\n\n    # Ensure feasibility\n    for route in merged_routes:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return merged_routes\n\n",
        "metric_score": [
            -0.7524873362882889,
            3.8157619535923004
        ],
        "raw_score": [
            45.36526439136858,
            8.893762437653463
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of objectives (60% distance, 40% makespan), then applies a hybrid local search combining demand-aware route segment relocation and demand-balanced route merging, prioritizing routes with high demand to improve both objectives while maintaining feasibility through capacity checks. It intelligently selects segments based on demand concentration and merges compatible routes to balance demands and reduce makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Adaptive route selection based on demand imbalance\n        route_weights = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        total_demand = sum(route_weights)\n        if total_demand > 0:\n            route_probs = [w / total_demand for w in route_weights]\n        else:\n            route_probs = [1.0 / len(new_solution)] * len(new_solution)\n\n        # Select routes with probability proportional to their demand\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, p=route_probs, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Demand-aware segment selection\n        if len(route1) > 3:\n            # Calculate demand distribution in route1\n            demands = [demand[node] for node in route1[1:-1]]\n            cumulative = np.cumsum(demands)\n            total = cumulative[-1]\n\n            # Select segment with high demand concentration\n            segment_start = 1\n            segment_end = len(route1) - 2\n            if total > 0:\n                threshold = random.uniform(0.3, 0.7) * total\n                segment_start = np.searchsorted(cumulative, threshold, side='right') + 1\n                segment_end = min(segment_start + random.randint(1, 3), len(route1) - 2)\n\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demands[segment_start-1:segment_end])\n\n            # Try to insert in route2\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                # Find optimal insertion point based on distance reduction\n                min_distance = float('inf')\n                best_pos = 1\n                for pos in range(1, len(route2)):\n                    dist = (distance_matrix[route2[pos-1], segment[0]] +\n                            distance_matrix[segment[-1], route2[pos]] -\n                            distance_matrix[route2[pos-1], route2[pos]])\n                    if dist < min_distance:\n                        min_distance = dist\n                        best_pos = pos\n\n                new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Demand-balanced route merging\n        if len(new_solution) < len(base_solution) and random.random() < 0.4:\n            # Find routes with complementary demand patterns\n            sorted_routes = sorted(new_solution, key=lambda r: sum(demand[node] for node in r[1:-1]))\n            for i in range(len(sorted_routes)):\n                for j in range(i+1, len(sorted_routes)):\n                    r1 = sorted_routes[i]\n                    r2 = sorted_routes[j]\n                    total = sum(demand[node] for node in r1[1:-1]) + sum(demand[node] for node in r2[1:-1])\n                    if total <= capacity and total > 0.8 * capacity:\n                        # Merge routes with optimal insertion point\n                        min_distance = float('inf')\n                        best_pos = len(r1) - 1\n                        for pos in range(1, len(r1)):\n                            dist = (distance_matrix[r1[pos-1], r2[1]] +\n                                    distance_matrix[r2[-2], r1[pos]] -\n                                    distance_matrix[r1[pos-1], r1[pos]])\n                            if dist < min_distance:\n                                min_distance = dist\n                                best_pos = pos\n\n                        merged_route = np.concatenate([r1[:best_pos], r2[1:-1], r1[best_pos:]])\n                        new_solution.remove(r1)\n                        new_solution.remove(r2)\n                        new_solution.append(merged_route)\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6564062428983491,
            0.5214219689369202
        ],
        "raw_score": [
            36.679638618345294,
            4.82435507757929
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest total distance (prioritizing makespan as a tiebreaker) from the archive, then applies a hybrid local search that randomly swaps segments between two routes while ensuring feasibility by reverting infeasible changes and conditionally merging routes if needed. It prioritizes load-balanced routes by checking capacity constraints and reverts to the original solution if any route exceeds capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0], x[1][1]))  # Prioritize solutions with lower total distance, then makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Swap segments between two routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments from both routes\n            seg1_start, seg1_end = sorted(random.sample(range(1, len(route1) - 1), 2))\n            seg2_start, seg2_end = sorted(random.sample(range(1, len(route2) - 1), 2))\n\n            # Create new routes by swapping segments\n            new_route1 = np.concatenate([route1[:seg1_start], route2[seg2_start:seg2_end + 1], route1[seg1_end + 1:]])\n            new_route2 = np.concatenate([route2[:seg2_start], route1[seg1_start:seg1_end + 1], route2[seg2_end + 1:]])\n\n            # Check feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n            else:\n                # Conditional merging if swapping fails\n                merged_route = np.concatenate([route1, route2[1:-1], [0]])\n                if sum(demand[node] for node in merged_route[1:-1]) <= capacity:\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6393399640001438,
            0.24897456169128418
        ],
        "raw_score": [
            34.66491860488229,
            4.428994547812563
        ]
    }
]