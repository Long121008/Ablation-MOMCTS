[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted trade-off between distance (60%) and makespan (40%), then applies a hybrid local search that first clusters customers by demand imbalance to create new routes, followed by spatial-aware segment inversion to optimize route distances, while ensuring all operations maintain vehicle capacity constraints. The method prioritizes routes with high demand variability and long segments for improvement, with feasibility checks that revert to the original solution if constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Identify route with highest demand imbalance\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            # Demand-aware route clustering\n            if len(route) > 4:\n                # Group customers by demand similarity\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                # Split into high and low demand groups\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    # Create new routes for each group\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]  # Focus on the new route\n\n            # Spatial-aware segment inversion\n            if len(route) > 3:\n                # Find the most distant segment\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                # Invert the most distant segment\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8070185825262003,
            0.1717846393585205
        ],
        "raw_score": [
            58.04923532146222,
            7.751749039460872
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search combining route segment reversal and demand-aware insertion, and includes a 70% chance to split large routes while ensuring capacity constraints are met. It intelligently selects promising solutions from the archive, modifies them through creative local search operators, and reverts to the original if feasibility is violated. The method balances exploration and exploitation by combining segment reversal, inter-route customer transfers, and conditional route splitting.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: x[1][0])  # Prioritize solutions with lower total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose one route at random\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx]\n\n        # Reverse a segment in the route\n        if len(route) > 3:\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            reversed_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], reversed_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Insert a customer from another route if demands allow\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 2:\n                insert_pos = random.randint(1, len(other_route) - 1)\n                insert_node = other_route[insert_pos]\n                if sum(demand[node] for node in new_route[1:-1]) + demand[insert_node] <= capacity:\n                    new_route = np.concatenate([new_route, [insert_node]])\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = np.concatenate([other_route[:insert_pos], other_route[insert_pos + 1:]])\n\n        # Novel route splitting mechanism\n        if len(new_solution) < 3 and random.random() < 0.7:  # 70% chance to split\n            # Find a route with high demand that can be split\n            for route in new_solution:\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand > capacity * 0.7:  # Split routes with demand > 70% of capacity\n                    split_pos = random.randint(1, len(route) - 2)\n                    new_route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos + 1:-1], [0]])\n                    if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                        sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                        new_solution.remove(route)\n                        new_solution.extend([new_route1, new_route2])\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4472340025984207,
            0.13136020302772522
        ],
        "raw_score": [
            34.81157256184183,
            4.406394682854535
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / archive[i][1][0]) if archive[i][1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-aware route balancing operator\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        target_demand = total_demand / len(new_solution)\n\n        # Identify overloaded and underloaded routes\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * target_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.8 * target_demand]\n\n        if overloaded and underloaded:\n            source_idx = random.choice(overloaded)\n            target_idx = random.choice(underloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customer in source route that can be moved to target route\n            for customer in source_route[1:-1]:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial-aware route optimization\n        if len(new_solution) > 1 and random.random() < 0.5:\n            # Select two routes and find the most distant customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is farthest from its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n                            # Remove empty routes\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9439601555489117,
            0.2223522961139679
        ],
        "raw_score": [
            29.898382424010755,
            3.4346545212883317
        ]
    },
    {
        "algorithm": "The algorithm implements a three-phase hybrid local search for the Bi-CVRP, first merging low-demand routes to reduce makespan, then applying a demand-weighted 3-opt operator to optimize spatial arrangements while respecting capacity constraints, and finally probabilistically reversing routes to balance distance and makespan improvements, with all steps ensuring feasibility through continuous demand validation. The selection prioritizes solutions with potential for balanced improvement across objectives, and the spatial optimization particularly focuses on high-demand customers through weighted evaluations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][1] - x[1][0]) * (1 - sum(demand[np.concatenate([r[1:-1] for r in x[0]])]) / (len(x[0]) * capacity)))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        # Sort routes by demand (ascending)\n        routes_with_demand = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        routes_with_demand.sort(key=lambda x: x[1])\n\n        # Try to merge the two least demanding routes if they're close in space\n        route1_idx, route2_idx = routes_with_demand[0][0], routes_with_demand[1][0]\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Check if merging is feasible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Find closest customers between routes\n                min_dist = float('inf')\n                best_pair = (None, None)\n\n                for c1 in route1[1:-1]:\n                    for c2 in route2[1:-1]:\n                        if distance_matrix[c1, c2] < min_dist:\n                            min_dist = distance_matrix[c1, c2]\n                            best_pair = (c1, c2)\n\n                if best_pair[0] is not None:\n                    # Create merged route\n                    new_route = np.concatenate([\n                        route1[:np.where(route1 == best_pair[0])[0][0]+1],\n                        route2[np.where(route2 == best_pair[1])[0][0]+1:]\n                    ])\n\n                    # Replace routes\n                    new_solution[route1_idx] = new_route\n                    new_solution.pop(route2_idx)\n\n    # Phase 2: Demand-weighted 3-opt spatial optimization\n    if len(new_solution) > 1:\n        for _ in range(2):  # Limit to 2 optimizations per neighbor\n            # Select three distinct routes\n            if len(new_solution) >= 3:\n                route_indices = random.sample(range(len(new_solution)), 3)\n                routes = [new_solution[i] for i in route_indices]\n\n                # Select one customer from each route\n                customers = []\n                for route in routes:\n                    if len(route) > 3:\n                        customers.append(random.choice(route[1:-1]))\n                    else:\n                        customers.append(None)\n\n                if all(c is not None for c in customers):\n                    # Calculate demand-weighted potential improvement\n                    total_demand = sum(demand[c] for c in customers)\n                    weight = total_demand / (3 * capacity)\n\n                    # Try all possible 3-opt moves (6 permutations)\n                    best_move = None\n                    best_improvement = 0\n\n                    for perm in [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)]:\n                        # Create new routes\n                        new_routes = [route.copy() for route in routes]\n                        for i in range(3):\n                            # Remove customer from original route\n                            orig_route = new_routes[i]\n                            pos = np.where(orig_route == customers[i])[0][0]\n                            new_routes[i] = np.concatenate([orig_route[:pos], orig_route[pos+1:]])\n\n                            # Insert into new position\n                            target_route = new_routes[perm[i]]\n                            insert_pos = random.randint(1, len(target_route)-1)\n                            new_routes[perm[i]] = np.concatenate([\n                                target_route[:insert_pos],\n                                [customers[i]],\n                                target_route[insert_pos:]\n                            ])\n\n                        # Calculate improvement (weighted by demand)\n                        new_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_routes)\n                        old_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in routes)\n                        improvement = (old_distance - new_distance) * weight\n\n                        # Check feasibility\n                        feasible = True\n                        for route in new_routes:\n                            if sum(demand[route[1:-1]]) > capacity:\n                                feasible = False\n                                break\n\n                        if feasible and improvement > best_improvement:\n                            best_improvement = improvement\n                            best_move = (new_routes, perm)\n\n                    if best_move is not None:\n                        for i in range(3):\n                            new_solution[route_indices[i]] = best_move[0][i]\n\n    # Phase 3: Probabilistic route inversion with bi-objective consideration\n    for route_idx in range(len(new_solution)):\n        if random.random() < 0.3 and len(new_solution[route_idx]) > 4:\n            route = new_solution[route_idx]\n            original_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n            reversed_route = np.concatenate([[0], route[-2:0:-1], [0]])\n            reversed_dist = sum(distance_matrix[reversed_route[i], reversed_route[i+1]] for i in range(len(reversed_route)-1))\n\n            # Accept if distance improves or makespan decreases significantly\n            current_makespan = max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution)\n            new_makespan = max(\n                max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution if not np.array_equal(r, route)),\n                reversed_dist\n            )\n\n            if (reversed_dist < original_dist) or (new_makespan < 0.9 * current_makespan):\n                new_solution[route_idx] = reversed_route\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return [route for route in new_solution if len(route) > 2]\n\n",
        "metric_score": [
            -0.9925782688968133,
            2.0045274794101715
        ],
        "raw_score": [
            30.587086179861792,
            4.059153338378613
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a hybrid approach that prioritizes routes with high demand imbalance, splits them based on demand thresholds, and applies a spatial reallocation of high-demand customers to balance distance and makespan while ensuring feasibility. It then performs a demand-aware 2-opt variant on the longest segments and reallocates customers to reduce distance increases. The method intelligently combines demand-aware clustering, spatial reallocation, and a modified 2-opt to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.8279111475333072,
            0.17557817697525024
        ],
        "raw_score": [
            58.28974426347028,
            7.701728566749342
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a normalized objective ratio (makespan/total distance), then applies a demand- and spatial-aware clustering and reallocation strategy to improve the solution. It prioritizes routes with high demand variance, reallocates incompatible customers to better-fitting routes, and ensures feasibility through demand checks. The method combines K-means clustering with spatial and demand-based route optimization to balance the bi-objective trade-off.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][1] / x[1][0]) if x[1][0] > 0 else float('-inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate demand and spatial characteristics\n    all_customers = []\n    for route in new_solution:\n        all_customers.extend(route[1:-1])\n    if not all_customers:\n        return new_solution\n\n    # Demand-driven route splitting\n    from sklearn.cluster import KMeans\n    demands = demand[all_customers]\n    coords_customers = coords[all_customers]\n\n    # Cluster based on demand and spatial proximity\n    n_clusters = min(3, len(all_customers))\n    if n_clusters < 2:\n        return new_solution\n\n    # Normalize features for clustering\n    demand_norm = (demands - np.mean(demands)) / (np.std(demands) + 1e-6)\n    coords_norm = (coords_customers - np.mean(coords_customers, axis=0)) / (np.std(coords_customers, axis=0) + 1e-6)\n    features = np.hstack([demand_norm.reshape(-1, 1), coords_norm])\n\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(features)\n    clusters = [[] for _ in range(n_clusters)]\n    for i, label in enumerate(kmeans.labels_):\n        clusters[label].append(all_customers[i])\n\n    # Create new routes from clusters\n    temp_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n        # Sort by distance to depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0, x])\n        current_route = [0]\n        current_demand = 0\n\n        for customer in cluster_sorted:\n            if current_demand + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_demand = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n    # Spatial-aware reallocation\n    if len(temp_solution) > 1:\n        # Identify routes with high demand variance\n        demand_variances = [np.var([demand[node] for node in route[1:-1]]) for route in temp_solution]\n        target_route_idx = np.argmax(demand_variances)\n        target_route = temp_solution[target_route_idx]\n\n        if len(target_route) > 3:\n            # Find customer with most incompatible demand\n            route_demand = sum(demand[target_route[1:-1]])\n            avg_demand = route_demand / (len(target_route) - 2)\n            incompatible_customer = max(target_route[1:-1], key=lambda x: abs(demand[x] - avg_demand))\n\n            # Find best route to reallocate to\n            best_route_idx = -1\n            best_improvement = 0\n            for i, route in enumerate(temp_solution):\n                if i == target_route_idx:\n                    continue\n                if sum(demand[route[1:-1]]) + demand[incompatible_customer] <= capacity:\n                    # Calculate potential improvement\n                    original_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                    new_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1) if route[i] != incompatible_customer)\n                    improvement = original_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = i\n\n            if best_route_idx != -1:\n                # Perform reallocation\n                best_route = temp_solution[best_route_idx]\n                # Find best insertion position\n                min_increase = float('inf')\n                best_pos = -1\n                for pos in range(1, len(best_route)):\n                    prev_node = best_route[pos-1]\n                    next_node = best_route[pos]\n                    dist_increase = (distance_matrix[prev_node, incompatible_customer] +\n                                   distance_matrix[incompatible_customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                if best_pos != -1:\n                    new_best_route = np.concatenate([best_route[:best_pos], [incompatible_customer], best_route[best_pos:]])\n                    new_target_route = np.array([node for node in target_route if node != incompatible_customer])\n                    temp_solution[target_route_idx] = new_target_route\n                    temp_solution[best_route_idx] = new_best_route\n\n                    # Remove empty routes\n                    temp_solution = [route for route in temp_solution if len(route) > 2]\n\n    # Ensure feasibility\n    feasible = True\n    for route in temp_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            feasible = False\n            break\n\n    if feasible:\n        new_solution = temp_solution\n    else:\n        # Fallback to original solution if infeasible\n        pass\n\n    return new_solution\n\n",
        "metric_score": [
            -0.908829049741932,
            2.265538215637207
        ],
        "raw_score": [
            34.64735196012461,
            6.0177783875976205
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted trade-off between distance and makespan (prioritizing distance 70% and makespan 30%), then applies a hybrid local search combining demand-aware route clustering (splitting high/low-demand groups) and spatial-aware segment inversion (reversing the longest segment in a route), while ensuring all operations maintain vehicle capacity constraints. The method prioritizes routes with high demand imbalance and long segments for improvement, balancing both distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Identify route with highest demand imbalance\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            # Demand-aware route clustering\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                # Split into high and low demand groups\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    # Create new routes for each group\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]  # Focus on the new route\n\n            # Spatial-aware segment inversion\n            if len(route) > 3:\n                # Find the most distant segment\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                # Invert the most distant segment\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6930308390160672,
            0.17587050795555115
        ],
        "raw_score": [
            57.86313415711755,
            7.681834147386303
        ]
    },
    {
        "algorithm": "The algorithm combines hierarchical demand clustering with dynamic route construction, prioritizing high-demand customers first and refining clusters by spatial proximity, while using an adaptive insertion heuristic to balance distance and makespan objectives through weighted scoring. It ensures feasibility by checking capacity constraints during route merging/splitting and handles remaining customers individually. The selection of the base solution is weighted based on normalized objectives, and the neighbor solution is generated through iterative refinement of clustered routes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([s[1] for s in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Step 1: Hierarchical demand clustering\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n\n        if len(all_customers) > 0:\n            # Initialize clusters with high-demand customers\n            demands = demand[all_customers]\n            avg_demand = np.mean(demands)\n            high_demand = [node for node, d in zip(all_customers, demands) if d > avg_demand]\n            low_demand = [node for node, d in zip(all_customers, demands) if d <= avg_demand]\n\n            # Create initial clusters\n            clusters = []\n            if len(high_demand) > 0:\n                clusters.append(high_demand)\n            if len(low_demand) > 0:\n                clusters.append(low_demand)\n\n            # Refine clusters by spatial proximity\n            refined_clusters = []\n            for cluster in clusters:\n                if len(cluster) > 1:\n                    # Find centroid of the cluster\n                    cluster_coords = coords[cluster]\n                    centroid = np.mean(cluster_coords, axis=0)\n\n                    # Split into two sub-clusters based on distance to centroid\n                    distances = np.linalg.norm(cluster_coords - centroid, axis=1)\n                    median_dist = np.median(distances)\n                    cluster1 = [node for node, dist in zip(cluster, distances) if dist <= median_dist]\n                    cluster2 = [node for node, dist in zip(cluster, distances) if dist > median_dist]\n\n                    if len(cluster1) > 0:\n                        refined_clusters.append(cluster1)\n                    if len(cluster2) > 0:\n                        refined_clusters.append(cluster2)\n                else:\n                    refined_clusters.append(cluster)\n\n            # Step 2: Dynamic route construction\n            new_solution = []\n            remaining_customers = set(all_customers)\n\n            for cluster in refined_clusters:\n                best_route = None\n                best_score = float('inf')\n\n                # Try inserting into existing routes\n                for route in new_solution:\n                    if sum(demand[route[1:-1]]) + sum(demand[cluster]) <= capacity:\n                        # Calculate best insertion point\n                        min_increase = float('inf')\n                        best_pos = -1\n\n                        for pos in range(1, len(route)):\n                            prev_node = route[pos-1]\n                            next_node = route[pos]\n\n                            # Calculate total distance increase\n                            dist_increase = 0\n                            last_node = prev_node\n                            for node in cluster:\n                                dist_increase += distance_matrix[last_node, node]\n                                last_node = node\n                            dist_increase += distance_matrix[last_node, next_node] - distance_matrix[prev_node, next_node]\n\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Calculate score (weighted distance and makespan)\n                            new_route = np.concatenate([route[:best_pos], cluster, route[best_pos:]])\n                            new_dist = sum(distance_matrix[new_route[i], new_route[i+1]] for i in range(len(new_route)-1))\n                            old_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                            score = 0.5 * (new_dist - old_dist) + 0.5 * (new_dist - old_dist)  # Simplified scoring\n\n                            if score < best_score:\n                                best_score = score\n                                best_route = new_route\n\n                if best_route is not None:\n                    # Update the best route found\n                    for i in range(len(new_solution)):\n                        if np.array_equal(new_solution[i], route):\n                            new_solution[i] = best_route\n                            break\n                else:\n                    # Create new route if no suitable insertion found\n                    if sum(demand[cluster]) <= capacity:\n                        new_route = np.concatenate([[0], cluster, [0]])\n                        new_solution.append(new_route)\n\n                # Remove assigned customers\n                remaining_customers -= set(cluster)\n\n            # Step 3: Handle remaining customers\n            if len(remaining_customers) > 0:\n                for node in remaining_customers:\n                    best_route = None\n                    best_pos = -1\n                    best_increase = float('inf')\n\n                    for route in new_solution:\n                        if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                            for pos in range(1, len(route)):\n                                prev_node = route[pos-1]\n                                next_node = route[pos]\n                                dist_increase = (distance_matrix[prev_node, node] +\n                                               distance_matrix[node, next_node] -\n                                               distance_matrix[prev_node, next_node])\n\n                                if dist_increase < best_increase:\n                                    best_increase = dist_increase\n                                    best_pos = pos\n                                    best_route = route\n\n                    if best_route is not None and best_pos != -1:\n                        new_route = np.concatenate([best_route[:best_pos], [node], best_route[best_pos:]])\n                        for i in range(len(new_solution)):\n                            if np.array_equal(new_solution[i], best_route):\n                                new_solution[i] = new_route\n                                break\n                    else:\n                        new_route = np.array([0, node, 0])\n                        new_solution.append(new_route)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.8015736043015038,
            0.2213154435157776
        ],
        "raw_score": [
            58.180067296321624,
            7.719017121854956
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing lower makespan (with total distance as a tiebreaker), then applies a hybrid local search that randomly inverts a route segment (if feasible) and may split the route into two (if both resulting routes are capacity-feasible). The method ensures feasibility by reverting changes if capacity constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize solutions with lower makespan, then total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Invert a segment within a route or split a route into two\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Need at least one customer to invert or split\n            # Invert a segment within the route\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            inverted_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Check if the inverted route is feasible\n            if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                new_solution[route_idx] = route  # Revert if infeasible\n            else:\n                # Try splitting the route if inversion is successful\n                split_pos = random.randint(1, len(new_route) - 2)\n                first_part = np.concatenate([[0], new_route[1:split_pos + 1], [0]])\n                second_part = np.concatenate([[0], new_route[split_pos + 1:-1], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9001978421599203,
            1.1289136409759521
        ],
        "raw_score": [
            68.28775165670466,
            2.6695998127591607
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with high makespan-to-distance ratios, applies demand-balanced route fusion to merge small routes while dynamically adjusting capacity thresholds based on makespan variance, and employs spatial-aware customer redistribution with a 60% chance to create new routes for demand imbalances, all while ensuring feasibility through capacity checks. The critical design ideas include prioritizing high-potential solutions, balancing route demands, and spatially optimizing customer assignments, with dynamic adjustments based on solution characteristics.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][1] / x[1][0]) if x[1][0] > 0 else float('-inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate makespan variance\n    makespans = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    makespan_mean = sum(makespans) / len(makespans)\n    makespan_variance = sum((m - makespan_mean) ** 2 for m in makespans) / len(makespans)\n\n    # Dynamic capacity threshold\n    capacity_threshold = capacity * (0.8 + 0.2 * (1 - min(1, makespan_variance / (makespan_mean ** 2))))\n\n    # Demand-balanced route fusion\n    if len(new_solution) > 2:\n        # Select routes to potentially merge\n        route_indices = sorted(range(len(new_solution)), key=lambda i: sum(demand[new_solution[i][1:-1]]))\n        for i in range(len(route_indices)-1):\n            for j in range(i+1, len(route_indices)):\n                route1 = new_solution[route_indices[i]]\n                route2 = new_solution[route_indices[j]]\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n                if total_demand <= capacity_threshold:\n                    # Merge routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution = [r for idx, r in enumerate(new_solution) if idx not in [route_indices[i], route_indices[j]]]\n                    new_solution.append(merged_route)\n                    break\n\n    # Spatial-aware customer redistribution\n    if len(new_solution) > 1 and random.random() < 0.6:\n        # Select a route with high demand variance\n        demand_variances = [np.var([demand[node] for node in route[1:-1]]) for route in new_solution]\n        target_route_idx = np.argmax(demand_variances)\n        target_route = new_solution[target_route_idx]\n\n        if len(target_route) > 3:\n            # Find customer with most incompatible demand\n            route_demand = sum(demand[target_route[1:-1]])\n            avg_demand = route_demand / (len(target_route) - 2)\n            incompatible_customer = max(target_route[1:-1], key=lambda x: abs(demand[x] - avg_demand))\n\n            # Find best route to reallocate to\n            best_route_idx = -1\n            best_improvement = 0\n            for i, route in enumerate(new_solution):\n                if i == target_route_idx:\n                    continue\n                if sum(demand[route[1:-1]]) + demand[incompatible_customer] <= capacity_threshold:\n                    # Calculate potential improvement\n                    original_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                    new_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1) if route[i] != incompatible_customer)\n                    improvement = original_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = i\n\n            if best_route_idx != -1:\n                # Perform reallocation\n                best_route = new_solution[best_route_idx]\n                # Find best insertion position\n                min_increase = float('inf')\n                best_pos = -1\n                for pos in range(1, len(best_route)):\n                    prev_node = best_route[pos-1]\n                    next_node = best_route[pos]\n                    dist_increase = (distance_matrix[prev_node, incompatible_customer] +\n                                   distance_matrix[incompatible_customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                if best_pos != -1:\n                    new_best_route = np.concatenate([best_route[:best_pos], [incompatible_customer], best_route[best_pos:]])\n                    new_target_route = np.array([node for node in target_route if node != incompatible_customer])\n                    new_solution[target_route_idx] = new_target_route\n                    new_solution[best_route_idx] = new_best_route\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8522050236140318,
            0.5603249967098236
        ],
        "raw_score": [
            58.477260611698995,
            7.843729392838613
        ]
    }
]