[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted trade-off between distance (60%) and makespan (40%), then applies a hybrid local search that first clusters customers by demand imbalance to create new routes, followed by spatial-aware segment inversion to optimize route distances, while ensuring all operations maintain vehicle capacity constraints. The method prioritizes routes with high demand variability and long segments for improvement, with feasibility checks that revert to the original solution if constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Identify route with highest demand imbalance\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            # Demand-aware route clustering\n            if len(route) > 4:\n                # Group customers by demand similarity\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                # Split into high and low demand groups\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    # Create new routes for each group\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]  # Focus on the new route\n\n            # Spatial-aware segment inversion\n            if len(route) > 3:\n                # Find the most distant segment\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                # Invert the most distant segment\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8070185825262003,
            0.1717846393585205
        ],
        "raw_score": [
            58.04923532146222,
            7.751749039460872
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search combining route segment reversal and demand-aware insertion, and includes a 70% chance to split large routes while ensuring capacity constraints are met. It intelligently selects promising solutions from the archive, modifies them through creative local search operators, and reverts to the original if feasibility is violated. The method balances exploration and exploitation by combining segment reversal, inter-route customer transfers, and conditional route splitting.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: x[1][0])  # Prioritize solutions with lower total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose one route at random\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx]\n\n        # Reverse a segment in the route\n        if len(route) > 3:\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            reversed_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], reversed_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Insert a customer from another route if demands allow\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 2:\n                insert_pos = random.randint(1, len(other_route) - 1)\n                insert_node = other_route[insert_pos]\n                if sum(demand[node] for node in new_route[1:-1]) + demand[insert_node] <= capacity:\n                    new_route = np.concatenate([new_route, [insert_node]])\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = np.concatenate([other_route[:insert_pos], other_route[insert_pos + 1:]])\n\n        # Novel route splitting mechanism\n        if len(new_solution) < 3 and random.random() < 0.7:  # 70% chance to split\n            # Find a route with high demand that can be split\n            for route in new_solution:\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand > capacity * 0.7:  # Split routes with demand > 70% of capacity\n                    split_pos = random.randint(1, len(route) - 2)\n                    new_route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos + 1:-1], [0]])\n                    if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                        sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                        new_solution.remove(route)\n                        new_solution.extend([new_route1, new_route2])\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4472340025984207,
            0.13136020302772522
        ],
        "raw_score": [
            34.81157256184183,
            4.406394682854535
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / archive[i][1][0]) if archive[i][1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-aware route balancing operator\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        target_demand = total_demand / len(new_solution)\n\n        # Identify overloaded and underloaded routes\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * target_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.8 * target_demand]\n\n        if overloaded and underloaded:\n            source_idx = random.choice(overloaded)\n            target_idx = random.choice(underloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customer in source route that can be moved to target route\n            for customer in source_route[1:-1]:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial-aware route optimization\n        if len(new_solution) > 1 and random.random() < 0.5:\n            # Select two routes and find the most distant customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is farthest from its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n                            # Remove empty routes\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9439601555489117,
            0.2223522961139679
        ],
        "raw_score": [
            29.898382424010755,
            3.4346545212883317
        ]
    },
    {
        "algorithm": "The algorithm selects a solution with the lowest combined total distance and makespan from the archive, then applies a hybrid local search combining demand-clustered route splitting (randomly dividing high-demand routes) and spatial-aware customer reallocation (moving depot-proximal customers between routes while respecting capacity constraints). It prioritizes solutions with balanced objectives and uses randomized operations to explore the solution space while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-clustered splitting\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            customers = route[1:-1]\n            if len(customers) > 1:\n                split_pos = random.randint(1, len(customers) - 1)\n                first_part = np.concatenate([[0], customers[:split_pos], [0]])\n                second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    route = new_solution[-1]\n\n        # Spatial-aware reallocation\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            depot_coords = coords[0]\n            closest_customer = min(route[1:-1], key=lambda x: np.linalg.norm(coords[x] - depot_coords))\n\n            if sum(demand[node] for node in other_route[1:-1]) + demand[closest_customer] <= capacity:\n                insert_pos = random.randint(1, len(other_route) - 1)\n                new_other_route = np.concatenate([other_route[:insert_pos], [closest_customer], other_route[insert_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                new_route = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                           route[np.where(route == closest_customer)[0][0] + 1:]])\n                new_solution[route_idx] = new_route\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.6393687239905992,
            0.18348291516304016
        ],
        "raw_score": [
            55.530776053518665,
            5.9390028569596165
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (prioritizing those with makespan/distance ratios close to 1) and applies a hybrid local search combining demand-based hierarchical route splitting and spatial-aware customer reallocation, ensuring feasibility through capacity checks while intelligently balancing the bi-objective trade-offs. The selection criterion emphasizes solutions where makespan and distance are relatively balanced, while the search operator prioritizes demand clustering and spatial proximity to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-clustered hierarchical splitting\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            customers = route[1:-1]\n            if len(customers) > 1:\n                # Hierarchical clustering based on demand\n                demand_values = demand[customers]\n                sorted_indices = np.argsort(demand_values)\n                split_pos = len(customers) // 2\n\n                first_part = np.concatenate([[0], customers[sorted_indices[:split_pos]], [0]])\n                second_part = np.concatenate([[0], customers[sorted_indices[split_pos:]], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    route = new_solution[-1]\n\n        # Spatial-aware reallocation\n        if len(new_solution) > 1 and len(route) > 3:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Find customer in current route closest to other route's centroid\n            other_route_coords = coords[other_route[1:-1]]\n            other_centroid = np.mean(other_route_coords, axis=0)\n            closest_customer = min(route[1:-1], key=lambda x: np.linalg.norm(coords[x] - other_centroid))\n\n            if sum(demand[node] for node in other_route[1:-1]) + demand[closest_customer] <= capacity:\n                # Insert closest customer into other route at position closest to its coordinates\n                other_route_coords = coords[other_route[1:-1]]\n                distances = [np.linalg.norm(coords[closest_customer] - coord) for coord in other_route_coords]\n                insert_pos = np.argmin(distances) + 1\n\n                new_other_route = np.concatenate([other_route[:insert_pos], [closest_customer], other_route[insert_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                new_route = np.concatenate([route[:np.where(route == closest_customer)[0][0]],\n                                           route[np.where(route == closest_customer)[0][0] + 1:]])\n                new_solution[route_idx] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.6645379240643329,
            0.1927325427532196
        ],
        "raw_score": [
            58.79058686924157,
            5.575881036470572
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][1]/x[1][0] if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-balanced route splitting\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        avg_demand = sum(route_demands)/len(route_demands)\n\n        # Find route with demand > 1.2*avg and another with demand < 0.8*avg\n        source_idx = max(range(len(route_demands)), key=lambda i: route_demands[i] if route_demands[i] > 1.2*avg_demand else -float('inf'))\n        target_idx = min(range(len(route_demands)), key=lambda i: route_demands[i] if route_demands[i] < 0.8*avg_demand else float('inf'))\n\n        if source_idx != target_idx:\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customer in source that can be moved to target\n            for customer in source_route[1:-1]:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                        distance_matrix[customer, next_node] -\n                                        distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source = np.array([node for node in source_route if node != customer])\n\n                        # Update solution\n                        new_solution[source_idx] = new_source\n                        new_solution[target_idx] = new_target\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial-optimized customer reallocation\n        if len(new_solution) > 1:\n            # Select two routes and find the most distant customer in one\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 with highest distance from neighbors\n                max_dist = -1\n                best_cust = None\n                for i in range(1, len(route1)-1):\n                    dist = distance_matrix[route1[i-1], route1[i]] + distance_matrix[route1[i], route1[i+1]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_cust = i\n\n                if best_cust is not None:\n                    customer = route1[best_cust]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7829379049228578,
            0.2152787744998932
        ],
        "raw_score": [
            32.130644895573404,
            3.9373306502179997
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with balanced makespan and distance, then applies a hybrid local search combining spatial-aware route merging and demand-aware customer redistribution. It first clusters routes by spatial proximity, merging feasible routes or redistributing customers between nearby clusters, followed by balancing demand imbalances by transferring customers between routes while maintaining capacity constraints. The approach prioritizes spatial proximity for merging and demand balance for redistribution, ensuring feasible solutions while targeting simultaneous improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / (1 + archive[i][1][0] / archive[i][1][1])))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial-aware route clustering\n    if len(new_solution) > 1:\n        # Calculate centroids for each route\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n\n        # Pair routes with closest centroids\n        route_pairs = []\n        used = set()\n        for i in range(len(centroids)):\n            if i in used:\n                continue\n            min_dist = float('inf')\n            best_j = -1\n            for j in range(i+1, len(centroids)):\n                if j not in used:\n                    dist = np.linalg.norm(centroids[i] - centroids[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_j = j\n            if best_j != -1:\n                route_pairs.append((i, best_j))\n                used.add(i)\n                used.add(best_j)\n\n        # For each pair, try merging if capacity allows\n        for i, j in route_pairs:\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = merged_route\n                new_solution[j] = np.array([0])  # Mark for removal\n            else:\n                # Redistribute customers based on spatial proximity\n                customers = list(route1[1:-1]) + list(route2[1:-1])\n                centroid1 = centroids[i]\n                centroid2 = centroids[j]\n\n                # Split customers between routes\n                route1_customers = []\n                route2_customers = []\n                for customer in customers:\n                    dist1 = np.linalg.norm(coords[customer] - centroid1)\n                    dist2 = np.linalg.norm(coords[customer] - centroid2)\n                    if dist1 < dist2:\n                        route1_customers.append(customer)\n                    else:\n                        route2_customers.append(customer)\n\n                # Rebuild routes with new customers\n                if sum(demand[node] for node in route1_customers) <= capacity:\n                    new_solution[i] = np.concatenate([[0], route1_customers, [0]])\n                if sum(demand[node] for node in route2_customers) <= capacity:\n                    new_solution[j] = np.concatenate([[0], route2_customers, [0]])\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 2: Demand-aware customer redistribution\n    if len(new_solution) > 1:\n        # Find the most imbalanced route (highest demand deviation from average)\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n        imbalances = [abs(d - avg_demand) for d in route_demands]\n        source_idx = imbalances.index(max(imbalances))\n\n        # Find the most compatible route to receive customers\n        target_idx = min(range(len(new_solution)), key=lambda i: abs(sum(demand[node] for node in new_solution[i][1:-1]) - avg_demand) if i != source_idx else float('inf'))\n\n        source_route = new_solution[source_idx]\n        target_route = new_solution[target_idx]\n\n        # Try to transfer customers from source to target\n        source_customers = list(source_route[1:-1])\n        target_customers = list(target_route[1:-1])\n        transferred = False\n\n        for customer in source_customers:\n            if sum(demand[node] for node in target_customers) + demand[customer] <= capacity:\n                target_customers.append(customer)\n                source_customers.remove(customer)\n                transferred = True\n\n        if transferred:\n            # Rebuild routes\n            new_solution[source_idx] = np.concatenate([[0], source_customers, [0]])\n            new_solution[target_idx] = np.concatenate([[0], target_customers, [0]])\n\n            # Remove empty routes\n            new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8311703624804405,
            1.0237776935100555
        ],
        "raw_score": [
            58.3023752816847,
            7.88680034130579
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing lower makespan (with total distance as a tiebreaker), then applies a hybrid local search that randomly inverts a route segment (if feasible) and may split the route into two (if both resulting routes are capacity-feasible). The method ensures feasibility by reverting changes if capacity constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))  # Prioritize solutions with lower makespan, then total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Invert a segment within a route or split a route into two\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Need at least one customer to invert or split\n            # Invert a segment within the route\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            inverted_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Check if the inverted route is feasible\n            if sum(demand[node] for node in new_route[1:-1]) > capacity:\n                new_solution[route_idx] = route  # Revert if infeasible\n            else:\n                # Try splitting the route if inversion is successful\n                split_pos = random.randint(1, len(new_route) - 2)\n                first_part = np.concatenate([[0], new_route[1:split_pos + 1], [0]])\n                second_part = np.concatenate([[0], new_route[split_pos + 1:-1], [0]])\n\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9001978421599203,
            1.1289136409759521
        ],
        "raw_score": [
            68.28775165670466,
            2.6695998127591607
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (prioritizing similar distance and makespan) and applies a hybrid operator that first splits routes into demand-balanced clusters using hierarchical clustering, then with 60% probability reallocates customers to the nearest feasible route to minimize both objectives while maintaining capacity constraints. It prioritizes demand balance in clustering and spatial proximity in reallocation, with a fallback to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hierarchical demand clustering and spatial reallocation\n    if len(new_solution) > 1:\n        # Step 1: Split routes into demand-balanced clusters\n        for i, route in enumerate(new_solution):\n            if len(route) > 3:\n                customers = route[1:-1]\n                customer_demands = demand[customers]\n                total_demand = sum(customer_demands)\n                target_demand = total_demand / 2  # Split into roughly two parts\n\n                # Find split point to balance demand\n                cumulative_demand = 0\n                split_pos = 1\n                for j in range(len(customers)):\n                    cumulative_demand += customer_demands[j]\n                    if cumulative_demand >= target_demand:\n                        split_pos = j + 1\n                        break\n\n                # Create two new routes\n                new_route1 = np.concatenate([[0], customers[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], customers[split_pos:], [0]])\n\n                # Check feasibility\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.append(new_route2)\n                    break\n\n        # Step 2: Spatial reallocation with 60% probability\n        if random.random() < 0.6:\n            # Collect all unassigned customers\n            assigned_customers = set()\n            for route in new_solution:\n                assigned_customers.update(route[1:-1])\n            unassigned_customers = [i for i in range(1, len(coords)) if i not in assigned_customers]\n\n            # Reallocate unassigned customers to nearest feasible route\n            for customer in unassigned_customers:\n                best_route = None\n                best_distance_increase = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    if sum(demand[node] for node in route[1:-1]) + demand[customer] <= capacity:\n                        # Find insertion position that minimizes distance increase\n                        for pos in range(1, len(route)):\n                            prev_node = route[pos - 1]\n                            next_node = route[pos]\n                            distance_increase = (distance_matrix[prev_node][customer] +\n                                               distance_matrix[customer][next_node] -\n                                               distance_matrix[prev_node][next_node])\n\n                            if distance_increase < best_distance_increase:\n                                best_distance_increase = distance_increase\n                                best_route = i\n                                best_pos = pos\n\n                if best_route is not None:\n                    route = new_solution[best_route]\n                    new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                    new_solution[best_route] = new_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7990306733619257,
            0.5694008469581604
        ],
        "raw_score": [
            57.550427578952394,
            7.695480070160018
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high makespan-to-distance ratios, then applies a hybrid local search that first merges routes based on demand similarity and spatial proximity, followed by probabilistic demand-balanced splitting of high-imbalance routes while ensuring feasibility. It prioritizes demand balance over pure distance optimization and uses a fallback mechanism to revert to the original solution if capacity constraints are violated. The algorithm balances both objectives by explicitly targeting demand imbalance during splitting and applying spatial checks during merging.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][1] / x[1][0] if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-aware route merging\n        routes_with_demand = [(i, sum(demand[route[1:-1]]), route) for i, route in enumerate(new_solution)]\n        routes_with_demand.sort(key=lambda x: x[1])  # Sort by ascending demand\n\n        merged = True\n        while merged and len(new_solution) > 1:\n            merged = False\n            for i in range(len(new_solution)):\n                if merged:\n                    break\n                for j in range(i + 1, len(new_solution)):\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n\n                    if total_demand <= capacity:\n                        # Check spatial proximity\n                        last_i = route_i[-2]\n                        first_j = route_j[1]\n                        avg_distance = (distance_matrix[last_i][0] + distance_matrix[0][first_j]) / 2\n\n                        if avg_distance < 1.5 * np.mean(distance_matrix):\n                            # Merge routes\n                            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            merged = True\n                            break\n\n        # Demand-balanced route splitting with probability\n        if random.random() < 0.7 and len(new_solution) > 1:\n            # Select route with highest demand imbalance\n            routes_with_imbalance = [(i, abs(sum(demand[route[1:-1]]) - capacity/2)) for i, route in enumerate(new_solution)]\n            routes_with_imbalance.sort(key=lambda x: -x[1])\n            target_route_idx = routes_with_imbalance[0][0]\n\n            route = new_solution[target_route_idx]\n            if len(route) > 3:\n                customers = route[1:-1]\n                customer_demands = demand[customers]\n                total_demand = sum(customer_demands)\n                target_demand = total_demand / 2\n\n                # Find split point to balance demand\n                cumulative_demand = 0\n                split_pos = 1\n                for j in range(len(customers)):\n                    cumulative_demand += customer_demands[j]\n                    if cumulative_demand >= target_demand:\n                        split_pos = j + 1\n                        break\n\n                # Create two new routes\n                new_route1 = np.concatenate([[0], customers[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], customers[split_pos:], [0]])\n\n                # Check feasibility\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[target_route_idx] = new_route1\n                    new_solution.append(new_route2)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8209697779193043,
            0.6283632814884186
        ],
        "raw_score": [
            57.88719642189683,
            7.567787093941891
        ]
    }
]