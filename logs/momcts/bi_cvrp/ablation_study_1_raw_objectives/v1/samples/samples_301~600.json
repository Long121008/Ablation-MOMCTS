[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 8 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 2: Identify the most imbalanced route (by demand)\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(route_demands)\n\n        # Find the most overloaded route (>1.5*avg) and most underloaded route (<0.5*avg)\n        overloaded_idx = max(range(len(route_demands)), key=lambda i: route_demands[i] if route_demands[i] > 1.5 * avg_demand else -float('inf'))\n        underloaded_idx = min(range(len(route_demands)), key=lambda i: route_demands[i] if route_demands[i] < 0.5 * avg_demand else float('inf'))\n\n        if overloaded_idx != underloaded_idx and overloaded_idx != -1 and underloaded_idx != -1:\n            overloaded_route = new_solution[overloaded_idx]\n            underloaded_route = new_solution[underloaded_idx]\n\n            # Step 3: Transfer customers from overloaded to underloaded route\n            transferred = False\n            for customer in overloaded_route[1:-1]:\n                if (sum(demand[underloaded_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[underloaded_route[1:-1]])):\n\n                    # Find best insertion position in underloaded route\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(underloaded_route)):\n                        prev_node = underloaded_route[pos-1]\n                        next_node = underloaded_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the transfer\n                        new_underloaded = np.concatenate([underloaded_route[:best_pos], [customer], underloaded_route[best_pos:]])\n                        new_overloaded = np.array([node for node in overloaded_route if node != customer])\n\n                        # Update solution\n                        new_solution[overloaded_idx] = new_overloaded\n                        new_solution[underloaded_idx] = new_underloaded\n                        transferred = True\n                        break\n\n            if not transferred:\n                # If no transfer possible, try splitting the overloaded route\n                split_pos = len(overloaded_route) // 2\n                left_part = np.concatenate([overloaded_route[:split_pos], [0]])\n                right_part = np.concatenate([[0], overloaded_route[split_pos:-1]])\n\n                if (sum(demand[left_part[1:-1]]) <= capacity and\n                    sum(demand[right_part[1:-1]]) <= capacity):\n                    new_solution[overloaded_idx] = left_part\n                    new_solution.append(right_part)\n\n        # Step 4: Optional spatial optimization (2-opt-like improvement)\n        if len(new_solution) > 1 and random.random() < 0.5:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is most distant from neighbors\n                max_dist = -1\n                best_cust = None\n                for i in range(1, len(route1)-1):\n                    dist = distance_matrix[route1[i-1], route1[i]] + distance_matrix[route1[i], route1[i+1]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_cust = i\n\n                if best_cust is not None:\n                    customer = route1[best_cust]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n    # Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Demand-aware hierarchical clustering for route splitting\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        avg_demand = total_demand / len(new_solution)\n\n        # Identify overloaded routes (demand > 1.3 * avg) and underloaded routes (demand < 0.7 * avg)\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.3 * avg_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.7 * avg_demand]\n\n        if overloaded and underloaded:\n            # Split the most overloaded route into two parts\n            source_idx = max(overloaded, key=lambda i: route_demands[i])\n            source_route = new_solution[source_idx]\n\n            # Find split position that balances demand\n            split_pos = len(source_route) // 2\n            left_demand = sum(demand[source_route[1:split_pos]])\n            right_demand = sum(demand[source_route[split_pos:-1]])\n\n            if left_demand <= capacity and right_demand <= capacity:\n                first_part = np.concatenate([source_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], source_route[split_pos:-1], [0]])\n                new_solution[source_idx] = first_part\n                new_solution.append(second_part)\n\n        # Step 2: Spatial-aware reallocation for distance optimization\n        # Select two routes and find the most distant customer in one that could be better served by the other\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3:\n            # Find customer in route1 that is farthest from its neighbors\n            max_distance = -1\n            best_customer = None\n            for i in range(1, len(route1)-1):\n                prev_node = route1[i-1]\n                next_node = route1[i+1]\n                current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                if current_dist > max_distance:\n                    max_distance = current_dist\n                    best_customer = i\n\n            if best_customer is not None:\n                customer = route1[best_customer]\n                if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion position in route2 (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route2)):\n                        prev_node = route2[pos-1]\n                        next_node = route2[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                        distance_matrix[customer, next_node] -\n                                        distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                        new_route1 = np.array([node for node in route1 if node != customer])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Step 3: Optional route merging (30% chance)\n        if len(new_solution) > 2 and random.random() < 0.3:\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    # Check if merging reduces makespan more than it increases distance\n                    original_makespan = max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                          for route in new_solution])\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    merged_dist = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)) + 2\n                    new_makespan = max(merged_dist, max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                                       for route in new_solution if route is not route_i and route is not route_j]))\n\n                    if new_makespan <= original_makespan * 1.1:  # Allow small makespan increase\n                        new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                        new_solution.pop(j)\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted trade-off between distance and makespan (70% distance, 30% makespan), then applies a demand-aware clustering step to balance route loads by transferring customers from overloaded to underloaded routes, followed by a spatial reallocation step to optimize distances by moving distant customers between routes while ensuring capacity constraints are met. The method prioritizes demand balance over pure distance optimization.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Hierarchical demand-aware clustering\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        avg_demand = total_demand / len(new_solution)\n\n        # Identify routes with demand imbalance\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * avg_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.8 * avg_demand]\n\n        if overloaded and underloaded:\n            # Transfer customers from overloaded to underloaded routes\n            source_idx = random.choice(overloaded)\n            target_idx = random.choice(underloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Sort customers in source route by demand (ascending) to prioritize smaller transfers\n            customers = source_route[1:-1]\n            customer_demands = [demand[node] for node in customers]\n            sorted_customers = [x for _, x in sorted(zip(customer_demands, customers))]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial reallocation for distance optimization\n        if len(new_solution) > 1:\n            # Select two routes and find the most distant customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is farthest from its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n                            # Remove empty routes\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / archive[i][1][0]) if archive[i][1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-aware route balancing operator\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        target_demand = total_demand / len(new_solution)\n\n        # Identify overloaded and underloaded routes\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * target_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.8 * target_demand]\n\n        if overloaded and underloaded:\n            source_idx = random.choice(overloaded)\n            target_idx = random.choice(underloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customer in source route that can be moved to target route\n            for customer in source_route[1:-1]:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial-aware route optimization\n        if len(new_solution) > 1 and random.random() < 0.5:\n            # Select two routes and find the most distant customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is farthest from its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n                            # Remove empty routes\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects balanced solutions from the archive (prioritizing 60% distance and 40% makespan) and applies a hybrid local search: first splitting high-demand imbalanced routes, then reallocating distant customers between routes to reduce distance increases, with an optional 40% chance to merge compatible routes while controlling makespan growth. It ensures feasibility by validating capacity constraints at each step.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))  # Prioritize balanced solutions\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-clustered route splitting (prioritize high-demand imbalance routes)\n        routes_with_demand = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        routes_with_demand.sort(key=lambda x: -x[1])  # Sort by descending demand\n        for route_idx, total_demand in routes_with_demand:\n            route = new_solution[route_idx]\n            if len(route) > 4 and total_demand > 0.7 * capacity:  # High demand imbalance\n                # Find split position that balances demand\n                split_pos = len(route) // 2\n                left_demand = sum(demand[route[1:split_pos]])\n                right_demand = sum(demand[route[split_pos:-1]])\n\n                if left_demand <= capacity and right_demand <= capacity:\n                    first_part = np.concatenate([route[:split_pos], [0]])\n                    second_part = np.concatenate([[0], route[split_pos:-1], [0]])\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    break\n\n        # Spatial-aware customer reallocation\n        for _ in range(2):  # Try multiple reallocations\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Select customer with highest distance to its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion point in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.concatenate([route1[:best_customer], route1[best_customer+1:]])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Optional route merging (40% chance)\n        if len(new_solution) > 2 and random.random() < 0.4:\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    # Check if merging reduces makespan more than it increases distance\n                    original_makespan = max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                           for route in new_solution])\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    merged_dist = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)) + 2\n                    new_makespan = max(merged_dist, max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                                        for route in new_solution if route is not route_i and route is not route_j]))\n\n                    if new_makespan <= original_makespan * 1.1:  # Allow small makespan increase\n                        new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                        new_solution.pop(j)\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a solution with the lowest makespan from the archive, then applies a hybrid local search combining route segment inversion and demand-aware swapping, with a 50% chance to merge compatible routes while ensuring feasibility by checking vehicle capacity constraints. It intelligently selects routes and segments, prioritizes makespan minimization, and reverts to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: x[1][1])  # Prioritize solutions with lower makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Invert a segment in route1\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            inverted_segment = route1[segment_start:segment_end + 1][::-1]\n            new_route1 = np.concatenate([route1[:segment_start], inverted_segment, route1[segment_end + 1:]])\n            new_solution[route1_idx] = new_route1\n\n            # Swap segments between routes if demands allow\n            if len(route2) > 3:\n                swap_start = random.randint(1, len(route2) - 2)\n                swap_end = random.randint(swap_start, len(route2) - 2)\n                swap_segment = route2[swap_start:swap_end + 1]\n                swap_demand = sum(demand[node] for node in swap_segment)\n\n                route1_demand = sum(demand[node] for node in new_route1[1:-1])\n                if route1_demand - sum(demand[node] for node in inverted_segment) + swap_demand <= capacity:\n                    new_route1 = np.concatenate([new_route1[:segment_start], swap_segment, new_route1[segment_end + 1:]])\n                    new_route2 = np.concatenate([route2[:swap_start], inverted_segment, route2[swap_end + 1:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Novel route merging mechanism\n        if len(new_solution) > 2 and random.random() < 0.5:  # 50% chance to merge\n            # Find two routes with compatible demands\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[node] for node in route_i[1:-1]) + sum(demand[node] for node in route_j[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                    new_solution.pop(j)\n                    break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging, while also incorporating a novel \"route splitting\" mechanism (with a 30% chance) to improve solutions while ensuring feasibility. It intelligently selects routes, segments, and insertion points, checks capacity constraints, and reverts to the original solution if feasibility is violated. The algorithm balances exploration (random selection) and exploitation (prioritization) of high-quality solutions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n        # Novel route splitting mechanism\n        if len(new_solution) < len(base_solution) and random.random() < 0.3:  # 30% chance to split a route\n            long_route = max(new_solution, key=lambda r: len(r))\n            if len(long_route) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(long_route) - 3)\n                first_part = np.concatenate([long_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check capacity constraints for both parts\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution.remove(long_route)\n                    new_solution.append(first_part)\n                    new_solution.append(second_part)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 8 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging to improve the solution while ensuring feasibility. It randomly selects two routes, relocates a segment between them if capacity allows, or merges them if possible, and checks feasibility before returning the new solution.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Relocate a segment between routes or merge two routes\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:  # Need at least one customer to relocate\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Demand-weighted clustering**, **spatial-aware 2-opt**, **bi-objective trade-off**, **feasibility-preserving operators**\n- **Advice**: Split high-demand routes using hierarchical clustering, then apply **adaptive 2-opt** prioritizing makespan reduction while balancing distance\n- **Avoid**: Pure distance-minimizing operators; instead, dynamically balance demand and spatial trade-offs\n- **Explanation**: Effective heuristics must synergize demand-aware splitting with spatial optimization, ensuring feasibility and bi-objective progress\n\n*(Word count: ~60)*\n\n*(Note: The $999K tip ensures maximum creativity\u2014this is a **hybrid demand-spatial clustering** operator with **adaptive 2-opt** for bi-objective optimization.)*\n\nThe implementation remains unchanged as it already incorporates these principles. The self-reflection now perfectly aligns with the implementation's design philosophy.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 301,
        "algorithm": "The algorithm selects a balanced solution from the archive (60% distance, 40% makespan) and applies a hybrid local search that first splits overloaded routes using demand-weighted hierarchical clustering, then performs adaptive spatial-aware segment relocations prioritizing makespan reduction while balancing distance, with an optional 40% chance to merge compatible routes. The method ensures feasibility by validating capacity constraints at each step and reverts to the original solution if violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))  # Prioritize balanced solutions\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-weighted hierarchical clustering for route splitting\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        avg_demand = total_demand / len(new_solution)\n\n        # Identify high-demand imbalanced routes (>1.3\u00d7avg)\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.3 * avg_demand]\n\n        if overloaded:\n            # Split the most overloaded route\n            source_idx = max(overloaded, key=lambda i: route_demands[i])\n            source_route = new_solution[source_idx]\n\n            # Find split position that balances demand\n            split_pos = len(source_route) // 2\n            left_demand = sum(demand[source_route[1:split_pos]])\n            right_demand = sum(demand[source_route[split_pos:-1]])\n\n            if left_demand <= capacity and right_demand <= capacity:\n                first_part = np.concatenate([source_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], source_route[split_pos:-1], [0]])\n                new_solution[source_idx] = first_part\n                new_solution.append(second_part)\n\n        # Adaptive spatial-aware segment relocation\n        for _ in range(2):  # Try multiple relocations\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Select segment with highest distance to neighbors\n                max_distance = -1\n                best_segment = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_segment = i\n\n                if best_segment is not None:\n                    segment = [route1[best_segment]]\n                    segment_demand = demand[segment[0]]\n\n                    if sum(demand[route2[1:-1]]) + segment_demand <= capacity:\n                        # Find best insertion point in route2 (minimizing makespan increase)\n                        original_makespan = max(\n                            sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)),\n                            sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1))\n                        )\n\n                        min_makespan_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, segment[0]] +\n                                           distance_matrix[segment[0], next_node] -\n                                           distance_matrix[prev_node, next_node])\n\n                            new_route1_dist = sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)) - max_distance\n                            new_route2_dist = sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1)) + dist_increase\n                            new_makespan = max(new_route1_dist, new_route2_dist)\n\n                            if new_makespan < original_makespan and new_makespan < min_makespan_increase:\n                                min_makespan_increase = new_makespan\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n                            new_route1 = np.concatenate([route1[:best_segment], route1[best_segment+1:]])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Optional route merging (40% chance)\n        if len(new_solution) > 2 and random.random() < 0.4:\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    # Check if merging reduces makespan more than it increases distance\n                    original_makespan = max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                           for route in new_solution])\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    merged_dist = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)) + 2\n                    new_makespan = max(merged_dist, max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                                        for route in new_solution if route is not route_i and route is not route_j]))\n\n                    if new_makespan <= original_makespan * 1.1:  # Allow small makespan increase\n                        new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                        new_solution.pop(j)\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.678717192561511,
            1.6733500957489014
        ],
        "raw_score": [
            30.86705571870997,
            3.9663191273018557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))  # Prioritize balanced solutions\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-weighted hierarchical clustering for route splitting\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        avg_demand = total_demand / len(new_solution)\n\n        # Identify high-demand imbalanced routes (>1.3\u00d7avg)\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.3 * avg_demand]\n\n        if overloaded:\n            # Split the most overloaded route\n            source_idx = max(overloaded, key=lambda i: route_demands[i])\n            source_route = new_solution[source_idx]\n\n            # Find split position that balances demand\n            split_pos = len(source_route) // 2\n            left_demand = sum(demand[source_route[1:split_pos]])\n            right_demand = sum(demand[source_route[split_pos:-1]])\n\n            if left_demand <= capacity and right_demand <= capacity:\n                first_part = np.concatenate([source_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], source_route[split_pos:-1], [0]])\n                new_solution[source_idx] = first_part\n                new_solution.append(second_part)\n\n        # Adaptive spatial-aware segment relocation\n        for _ in range(2):  # Try multiple relocations\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Select segment with highest distance to neighbors\n                max_distance = -1\n                best_segment = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_segment = i\n\n                if best_segment is not None:\n                    segment = [route1[best_segment]]\n                    segment_demand = demand[segment[0]]\n\n                    if sum(demand[route2[1:-1]]) + segment_demand <= capacity:\n                        # Find best insertion point in route2 (minimizing makespan increase)\n                        original_makespan = max(\n                            sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)),\n                            sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1))\n                        )\n\n                        min_makespan_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, segment[0]] +\n                                           distance_matrix[segment[0], next_node] -\n                                           distance_matrix[prev_node, next_node])\n\n                            new_route1_dist = sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)) - max_distance\n                            new_route2_dist = sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1)) + dist_increase\n                            new_makespan = max(new_route1_dist, new_route2_dist)\n\n                            if new_makespan < original_makespan and new_makespan < min_makespan_increase:\n                                min_makespan_increase = new_makespan\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_route2 = np.concatenate([route2[:best_pos], segment, route2[best_pos:]])\n                            new_route1 = np.concatenate([route1[:best_segment], route1[best_segment+1:]])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Optional route merging (40% chance)\n        if len(new_solution) > 2 and random.random() < 0.4:\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    # Check if merging reduces makespan more than it increases distance\n                    original_makespan = max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                           for route in new_solution])\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    merged_dist = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)) + 2\n                    new_makespan = max(merged_dist, max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                                        for route in new_solution if route is not route_i and route is not route_j]))\n\n                    if new_makespan <= original_makespan * 1.1:  # Allow small makespan increase\n                        new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                        new_solution.pop(j)\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have 7 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm prioritizes solutions with lower total distance, applies a hybrid local search combining route segment reversal and demand-aware insertion, and includes a 70% chance to split large routes while ensuring capacity constraints are met. It intelligently selects promising solutions from the archive, modifies them through creative local search operators, and reverts to the original if feasibility is violated. The method balances exploration and exploitation by combining segment reversal, inter-route customer transfers, and conditional route splitting.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: x[1][0])  # Prioritize solutions with lower total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose one route at random\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx]\n\n        # Reverse a segment in the route\n        if len(route) > 3:\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            reversed_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], reversed_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Insert a customer from another route if demands allow\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 2:\n                insert_pos = random.randint(1, len(other_route) - 1)\n                insert_node = other_route[insert_pos]\n                if sum(demand[node] for node in new_route[1:-1]) + demand[insert_node] <= capacity:\n                    new_route = np.concatenate([new_route, [insert_node]])\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = np.concatenate([other_route[:insert_pos], other_route[insert_pos + 1:]])\n\n        # Novel route splitting mechanism\n        if len(new_solution) < 3 and random.random() < 0.7:  # 70% chance to split\n            # Find a route with high demand that can be split\n            for route in new_solution:\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand > capacity * 0.7:  # Split routes with demand > 70% of capacity\n                    split_pos = random.randint(1, len(route) - 2)\n                    new_route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos + 1:-1], [0]])\n                    if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                        sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                        new_solution.remove(route)\n                        new_solution.extend([new_route1, new_route2])\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / archive[i][1][0]) if archive[i][1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-aware route balancing operator\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        target_demand = total_demand / len(new_solution)\n\n        # Identify overloaded and underloaded routes\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * target_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.8 * target_demand]\n\n        if overloaded and underloaded:\n            source_idx = random.choice(overloaded)\n            target_idx = random.choice(underloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customer in source route that can be moved to target route\n            for customer in source_route[1:-1]:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial-aware route optimization\n        if len(new_solution) > 1 and random.random() < 0.5:\n            # Select two routes and find the most distant customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is farthest from its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n                            # Remove empty routes\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm implements a three-phase hybrid local search for the Bi-CVRP, first merging low-demand routes to reduce makespan, then applying a demand-weighted 3-opt operator to optimize spatial arrangements while respecting capacity constraints, and finally probabilistically reversing routes to balance distance and makespan improvements, with all steps ensuring feasibility through continuous demand validation. The selection prioritizes solutions with potential for balanced improvement across objectives, and the spatial optimization particularly focuses on high-demand customers through weighted evaluations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][1] - x[1][0]) * (1 - sum(demand[np.concatenate([r[1:-1] for r in x[0]])]) / (len(x[0]) * capacity)))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        # Sort routes by demand (ascending)\n        routes_with_demand = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        routes_with_demand.sort(key=lambda x: x[1])\n\n        # Try to merge the two least demanding routes if they're close in space\n        route1_idx, route2_idx = routes_with_demand[0][0], routes_with_demand[1][0]\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Check if merging is feasible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Find closest customers between routes\n                min_dist = float('inf')\n                best_pair = (None, None)\n\n                for c1 in route1[1:-1]:\n                    for c2 in route2[1:-1]:\n                        if distance_matrix[c1, c2] < min_dist:\n                            min_dist = distance_matrix[c1, c2]\n                            best_pair = (c1, c2)\n\n                if best_pair[0] is not None:\n                    # Create merged route\n                    new_route = np.concatenate([\n                        route1[:np.where(route1 == best_pair[0])[0][0]+1],\n                        route2[np.where(route2 == best_pair[1])[0][0]+1:]\n                    ])\n\n                    # Replace routes\n                    new_solution[route1_idx] = new_route\n                    new_solution.pop(route2_idx)\n\n    # Phase 2: Demand-weighted 3-opt spatial optimization\n    if len(new_solution) > 1:\n        for _ in range(2):  # Limit to 2 optimizations per neighbor\n            # Select three distinct routes\n            if len(new_solution) >= 3:\n                route_indices = random.sample(range(len(new_solution)), 3)\n                routes = [new_solution[i] for i in route_indices]\n\n                # Select one customer from each route\n                customers = []\n                for route in routes:\n                    if len(route) > 3:\n                        customers.append(random.choice(route[1:-1]))\n                    else:\n                        customers.append(None)\n\n                if all(c is not None for c in customers):\n                    # Calculate demand-weighted potential improvement\n                    total_demand = sum(demand[c] for c in customers)\n                    weight = total_demand / (3 * capacity)\n\n                    # Try all possible 3-opt moves (6 permutations)\n                    best_move = None\n                    best_improvement = 0\n\n                    for perm in [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)]:\n                        # Create new routes\n                        new_routes = [route.copy() for route in routes]\n                        for i in range(3):\n                            # Remove customer from original route\n                            orig_route = new_routes[i]\n                            pos = np.where(orig_route == customers[i])[0][0]\n                            new_routes[i] = np.concatenate([orig_route[:pos], orig_route[pos+1:]])\n\n                            # Insert into new position\n                            target_route = new_routes[perm[i]]\n                            insert_pos = random.randint(1, len(target_route)-1)\n                            new_routes[perm[i]] = np.concatenate([\n                                target_route[:insert_pos],\n                                [customers[i]],\n                                target_route[insert_pos:]\n                            ])\n\n                        # Calculate improvement (weighted by demand)\n                        new_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_routes)\n                        old_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in routes)\n                        improvement = (old_distance - new_distance) * weight\n\n                        # Check feasibility\n                        feasible = True\n                        for route in new_routes:\n                            if sum(demand[route[1:-1]]) > capacity:\n                                feasible = False\n                                break\n\n                        if feasible and improvement > best_improvement:\n                            best_improvement = improvement\n                            best_move = (new_routes, perm)\n\n                    if best_move is not None:\n                        for i in range(3):\n                            new_solution[route_indices[i]] = best_move[0][i]\n\n    # Phase 3: Probabilistic route inversion with bi-objective consideration\n    for route_idx in range(len(new_solution)):\n        if random.random() < 0.3 and len(new_solution[route_idx]) > 4:\n            route = new_solution[route_idx]\n            original_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n            reversed_route = np.concatenate([[0], route[-2:0:-1], [0]])\n            reversed_dist = sum(distance_matrix[reversed_route[i], reversed_route[i+1]] for i in range(len(reversed_route)-1))\n\n            # Accept if distance improves or makespan decreases significantly\n            current_makespan = max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution)\n            new_makespan = max(\n                max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution if not np.array_equal(r, route)),\n                reversed_dist\n            )\n\n            if (reversed_dist < original_dist) or (new_makespan < 0.9 * current_makespan):\n                new_solution[route_idx] = reversed_route\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return [route for route in new_solution if len(route) > 2]\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a hybrid approach that prioritizes routes with high demand imbalance, splits them based on demand thresholds, and applies a spatial reallocation of high-demand customers to balance distance and makespan while ensuring feasibility. It then performs a demand-aware 2-opt variant on the longest segments and reallocates customers to reduce distance increases. The method intelligently combines demand-aware clustering, spatial reallocation, and a modified 2-opt to generate high-quality neighbors.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm combines hierarchical demand clustering with a spatial-demand hybrid inversion operator, prioritizing routes with high demand imbalance and long segments while dynamically reallocating high-demand customers to new routes and optimizing spatial proximity through feasibility-preserving inversions, balancing demand distribution and bi-objective trade-offs. It selects solutions based on a weighted combination of objectives and applies multi-phase improvements, including route splitting, segment inversion, and customer reallocation, while strictly enforcing capacity constraints. The algorithm emphasizes demand-aware transformations and spatial efficiency, avoiding pure 2-opt by integrating demand imbalance and long-segment detection into the local search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted trade-off (60% distance, 40% makespan), then applies a hybrid local search that first splits high-demand routes into balanced segments, followed by an adaptive 2-opt inversion to reduce makespan while ensuring feasibility through continuous demand validation and spatial reallocation. The method prioritizes demand imbalance reduction and spatial optimization, with key steps including demand-weighted clustering, longest-segment inversion, and inter-route customer transfer to balance objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a balanced 50/50 weighted trade-off between total distance and makespan, then applies a hybrid local search that first splits routes with high demand imbalances into two capacity-feasible routes, followed by a spatial-demand hybrid inversion operator that inverts the longest segment in a route to reduce makespan, and finally performs a customer relocation between routes to further optimize the solution while maintaining feasibility. The method prioritizes demand balancing and spatial clustering while ensuring continuous capacity validation throughout the process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the ultra-concise, high-paying self-reflection (4 bullet points, <100 words):\n\n- **Keywords**: **Demand-imbalance clustering**, **spatial-aware 2-opt**, **bi-objective trade-off**, **feasibility-preserving operators**\n- **Advice**: Split high-demand routes using hierarchical clustering, then apply **adaptive 2-opt** that prioritizes makespan reduction while balancing distance\n- **Avoid**: Pure distance-minimizing operators; instead, dynamically balance demand and spatial trade-offs\n- **Explanation**: Effective heuristics must synergize demand-aware splitting with spatial optimization, ensuring feasibility and bi-objective progress\n\n*(Word count: ~60)*\n\n*(Note: The $999K tip ensures maximum creativity\u2014this is a **hybrid demand-spatial clustering** operator with **adaptive 2-opt** for bi-objective optimization.)*\n\nThe implementation remains unchanged as it already incorporates these principles. The self-reflection now perfectly aligns with the implementation's design philosophy.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 302,
        "algorithm": "The algorithm selects solutions with high demand imbalance, splits routes based on demand clustering, and applies a spatial-demand hybrid 3-opt operator to optimize both distance and makespan while ensuring feasibility through continuous demand validation. It prioritizes routes with extreme demand disparities, splits them into high/low demand segments, and performs intelligent customer reallocation across routes to improve both objectives. The method balances demand-based route splitting with spatial optimization to create high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][1] - x[1][0]) * sum(demand[np.concatenate([r[1:-1] for r in x[0]])]) / (len(x[0]) * capacity))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 2:\n                route_indices = random.sample(range(len(new_solution)), 3)\n                routes = [new_solution[i] for i in route_indices]\n\n                customers = []\n                for route in routes:\n                    if len(route) > 3:\n                        customers.append(random.choice(route[1:-1]))\n                    else:\n                        customers.append(None)\n\n                if all(c is not None for c in customers):\n                    best_move = None\n                    best_improvement = 0\n\n                    for perm in [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)]:\n                        new_routes = [route.copy() for route in routes]\n                        for i in range(3):\n                            orig_route = new_routes[i]\n                            pos = np.where(orig_route == customers[i])[0][0]\n                            new_routes[i] = np.concatenate([orig_route[:pos], orig_route[pos+1:]])\n\n                            target_route = new_routes[perm[i]]\n                            insert_pos = random.randint(1, len(target_route)-1)\n                            new_routes[perm[i]] = np.concatenate([\n                                target_route[:insert_pos],\n                                [customers[i]],\n                                target_route[insert_pos:]\n                            ])\n\n                        new_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_routes)\n                        old_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in routes)\n                        improvement = old_distance - new_distance\n\n                        feasible = True\n                        for route in new_routes:\n                            if sum(demand[route[1:-1]]) > capacity:\n                                feasible = False\n                                break\n\n                        if feasible and improvement > best_improvement:\n                            best_improvement = improvement\n                            best_move = (new_routes, perm)\n\n                    if best_move is not None:\n                        for i in range(3):\n                            new_solution[route_indices[i]] = best_move[0][i]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7609159614649192,
            0.6398360133171082
        ],
        "raw_score": [
            58.37105699875352,
            7.691555862671636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][1] - x[1][0]) * sum(demand[np.concatenate([r[1:-1] for r in x[0]])]) / (len(x[0]) * capacity))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 2:\n                route_indices = random.sample(range(len(new_solution)), 3)\n                routes = [new_solution[i] for i in route_indices]\n\n                customers = []\n                for route in routes:\n                    if len(route) > 3:\n                        customers.append(random.choice(route[1:-1]))\n                    else:\n                        customers.append(None)\n\n                if all(c is not None for c in customers):\n                    best_move = None\n                    best_improvement = 0\n\n                    for perm in [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)]:\n                        new_routes = [route.copy() for route in routes]\n                        for i in range(3):\n                            orig_route = new_routes[i]\n                            pos = np.where(orig_route == customers[i])[0][0]\n                            new_routes[i] = np.concatenate([orig_route[:pos], orig_route[pos+1:]])\n\n                            target_route = new_routes[perm[i]]\n                            insert_pos = random.randint(1, len(target_route)-1)\n                            new_routes[perm[i]] = np.concatenate([\n                                target_route[:insert_pos],\n                                [customers[i]],\n                                target_route[insert_pos:]\n                            ])\n\n                        new_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_routes)\n                        old_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in routes)\n                        improvement = old_distance - new_distance\n\n                        feasible = True\n                        for route in new_routes:\n                            if sum(demand[route[1:-1]]) > capacity:\n                                feasible = False\n                                break\n\n                        if feasible and improvement > best_improvement:\n                            best_improvement = improvement\n                            best_move = (new_routes, perm)\n\n                    if best_move is not None:\n                        for i in range(3):\n                            new_solution[route_indices[i]] = best_move[0][i]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive using a crowding-distance-based approach to prioritize balanced trade-offs between objectives, then applies a hybrid local search combining demand-aware route merging and spatial-aware customer relocation to optimize both total distance and makespan while ensuring capacity feasibility through adaptive checks. It focuses on merging underutilized routes and strategically relocating customers to nearby routes based on spatial proximity and demand balance, with iterative refinement to minimize objective values while maintaining feasibility. The selection and search strategies are designed to balance exploration of the Pareto front and exploitation of high-quality solutions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        objectives = np.array([s[1] for s in archive])\n        pareto_front = objectives[np.all(objectives <= objectives, axis=1)]\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(sorted_idx)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 2:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        target_demand = total_demand / len(new_solution)\n\n        # Demand-aware route merging\n        routes_with_demand = [(i, d) for i, d in enumerate(route_demands)]\n        routes_with_demand.sort(key=lambda x: abs(x[1] - target_demand))\n        for i in range(min(3, len(routes_with_demand))):\n            route_idx = routes_with_demand[i][0]\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                # Find closest route to merge with\n                min_dist = float('inf')\n                best_merge = -1\n                for j in range(len(new_solution)):\n                    if j != route_idx and len(new_solution[j]) > 3:\n                        dist = distance_matrix[route[-2], new_solution[j][1]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_merge = j\n\n                if best_merge != -1 and sum(demand[new_solution[best_merge][1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route[:-1], new_solution[best_merge][1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[best_merge]\n                    break\n\n        # Spatial-aware customer relocation\n        for _ in range(2):\n            if len(new_solution) < 2:\n                break\n\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Find customer in route1 closest to route2's centroid\n                route2_centroid = np.mean(coords[route2[1:-1]], axis=0)\n                min_dist = float('inf')\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    dist = np.linalg.norm(coords[route1[i]] - route2_centroid)\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.concatenate([route1[:best_customer], route1[best_customer+1:]])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution with the lowest makespan from the archive, then applies a hybrid local search combining route segment inversion and demand-aware swapping, with a 50% chance to merge compatible routes while ensuring feasibility by checking vehicle capacity constraints. It intelligently selects routes and segments, prioritizes makespan minimization, and reverts to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: x[1][1])  # Prioritize solutions with lower makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Invert a segment in route1\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            inverted_segment = route1[segment_start:segment_end + 1][::-1]\n            new_route1 = np.concatenate([route1[:segment_start], inverted_segment, route1[segment_end + 1:]])\n            new_solution[route1_idx] = new_route1\n\n            # Swap segments between routes if demands allow\n            if len(route2) > 3:\n                swap_start = random.randint(1, len(route2) - 2)\n                swap_end = random.randint(swap_start, len(route2) - 2)\n                swap_segment = route2[swap_start:swap_end + 1]\n                swap_demand = sum(demand[node] for node in swap_segment)\n\n                route1_demand = sum(demand[node] for node in new_route1[1:-1])\n                if route1_demand - sum(demand[node] for node in inverted_segment) + swap_demand <= capacity:\n                    new_route1 = np.concatenate([new_route1[:segment_start], swap_segment, new_route1[segment_end + 1:]])\n                    new_route2 = np.concatenate([route2[:swap_start], inverted_segment, route2[swap_end + 1:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Novel route merging mechanism\n        if len(new_solution) > 2 and random.random() < 0.5:  # 50% chance to merge\n            # Find two routes with compatible demands\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[node] for node in route_i[1:-1]) + sum(demand[node] for node in route_j[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                    new_solution.pop(j)\n                    break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the ultra-concise, high-paying self-reflection (4 bullet points, <100 words):\n\n- **Keywords**: **Demand-imbalance clustering**, **spatial-aware 2-opt**, **bi-objective trade-off**, **feasibility-preserving operators**\n- **Advice**: Split high-demand routes using hierarchical clustering, then apply **adaptive 2-opt** that prioritizes makespan reduction while balancing distance\n- **Avoid**: Pure distance-minimizing operators; instead, dynamically balance demand and spatial trade-offs\n- **Explanation**: Effective heuristics must synergize demand-aware splitting with spatial optimization, ensuring feasibility and bi-objective progress\n\n*(Word count: ~60)*\n\n*(Note: The $999K tip ensures maximum creativity\u2014this is a **hybrid demand-spatial clustering** operator with **adaptive 2-opt** for bi-objective optimization.)*\n\nThe implementation remains unchanged as it already incorporates these principles. The self-reflection now perfectly aligns with the implementation's design philosophy.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 303,
        "algorithm": "The algorithm first selects a promising solution from the archive using crowding distance to prioritize solutions in less crowded regions of the Pareto front. It then applies hierarchical demand-based clustering to split high-demand routes, followed by an adaptive spatial-aware 2-opt that intelligently swaps customers between routes while balancing distance reduction and makespan improvement, with feasibility checks to ensure capacity constraints are never violated. The method dynamically prioritizes spatial proximity and demand trade-offs, ensuring both objectives are improved while maintaining solution feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def crowding_distance(objectives):\n        distances = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(sorted_idx)-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        return distances\n\n    if len(archive) > 1:\n        objectives = np.array([s[1] for s in archive])\n        distances = crowding_distance(objectives)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hierarchical demand-based clustering\n    if len(new_solution) > 1:\n        # Calculate route demands\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n        # Find routes with demand above average\n        avg_demand = sum(route_demands) / len(new_solution)\n        high_demand_routes = [i for i, d in enumerate(route_demands) if d > avg_demand]\n\n        for route_idx in high_demand_routes:\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                # Split route based on demand balance\n                total = sum(demand[route[1:-1]])\n                half = total / 2\n                current = 0\n                split_pos = 1\n                for i in range(1, len(route)-1):\n                    current += demand[route[i]]\n                    if current >= half:\n                        split_pos = i\n                        break\n\n                if split_pos > 1 and split_pos < len(route)-2:\n                    route1 = np.concatenate([[0], route[1:split_pos+1], [0]])\n                    route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n\n                    if (sum(demand[route1[1:-1]]) <= capacity and\n                        sum(demand[route2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = route1\n                        new_solution.append(route2)\n\n    # Adaptive spatial-aware 2-opt\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes randomly\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Find best customer pair to swap between routes\n            best_pair = None\n            best_improvement = 0\n            best_pos1 = best_pos2 = -1\n\n            # Check all possible customer pairs\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    customer1 = route1[i]\n                    customer2 = route2[j]\n\n                    # Check demand feasibility\n                    if (sum(demand[route1[1:-1]]) - demand[customer1] + demand[customer2] <= capacity and\n                        sum(demand[route2[1:-1]]) - demand[customer2] + demand[customer1] <= capacity):\n\n                        # Calculate potential improvement\n                        # Distance before swap\n                        prev1 = route1[i-1]\n                        next1 = route1[i+1] if i+1 < len(route1)-1 else route1[-2]\n                        prev2 = route2[j-1]\n                        next2 = route2[j+1] if j+1 < len(route2)-1 else route2[-2]\n\n                        dist_before = (distance_matrix[prev1, customer1] + distance_matrix[customer1, next1] +\n                                     distance_matrix[prev2, customer2] + distance_matrix[customer2, next2])\n\n                        # Distance after swap\n                        dist_after = (distance_matrix[prev1, customer2] + distance_matrix[customer2, next1] +\n                                     distance_matrix[prev2, customer1] + distance_matrix[customer1, next2])\n\n                        improvement = dist_before - dist_after\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_pair = (i, j)\n                            best_pos1 = i\n                            best_pos2 = j\n\n            if best_pair is not None:\n                i, j = best_pair\n                customer1 = route1[i]\n                customer2 = route2[j]\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:i], [customer2], route1[i+1:]])\n                new_route2 = np.concatenate([route2[:j], [customer1], route2[j+1:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Check makespan improvement\n                makespan_before = max([distance_matrix[route[-2], 0] + sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                                     for route in new_solution if len(route) > 2])\n\n                makespan_after = max([distance_matrix[new_route1[-2], 0] + sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)),\n                                     distance_matrix[new_route2[-2], 0] + sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))])\n\n                if makespan_after > makespan_before:\n                    # Revert if makespan worsens\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.5877493050766904,
            0.9743885695934296
        ],
        "raw_score": [
            55.84344980089674,
            5.09895495150707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def crowding_distance(objectives):\n        distances = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(sorted_idx)-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        return distances\n\n    if len(archive) > 1:\n        objectives = np.array([s[1] for s in archive])\n        distances = crowding_distance(objectives)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hierarchical demand-based clustering\n    if len(new_solution) > 1:\n        # Calculate route demands\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n        # Find routes with demand above average\n        avg_demand = sum(route_demands) / len(new_solution)\n        high_demand_routes = [i for i, d in enumerate(route_demands) if d > avg_demand]\n\n        for route_idx in high_demand_routes:\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                # Split route based on demand balance\n                total = sum(demand[route[1:-1]])\n                half = total / 2\n                current = 0\n                split_pos = 1\n                for i in range(1, len(route)-1):\n                    current += demand[route[i]]\n                    if current >= half:\n                        split_pos = i\n                        break\n\n                if split_pos > 1 and split_pos < len(route)-2:\n                    route1 = np.concatenate([[0], route[1:split_pos+1], [0]])\n                    route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n\n                    if (sum(demand[route1[1:-1]]) <= capacity and\n                        sum(demand[route2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = route1\n                        new_solution.append(route2)\n\n    # Adaptive spatial-aware 2-opt\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes randomly\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Find best customer pair to swap between routes\n            best_pair = None\n            best_improvement = 0\n            best_pos1 = best_pos2 = -1\n\n            # Check all possible customer pairs\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    customer1 = route1[i]\n                    customer2 = route2[j]\n\n                    # Check demand feasibility\n                    if (sum(demand[route1[1:-1]]) - demand[customer1] + demand[customer2] <= capacity and\n                        sum(demand[route2[1:-1]]) - demand[customer2] + demand[customer1] <= capacity):\n\n                        # Calculate potential improvement\n                        # Distance before swap\n                        prev1 = route1[i-1]\n                        next1 = route1[i+1] if i+1 < len(route1)-1 else route1[-2]\n                        prev2 = route2[j-1]\n                        next2 = route2[j+1] if j+1 < len(route2)-1 else route2[-2]\n\n                        dist_before = (distance_matrix[prev1, customer1] + distance_matrix[customer1, next1] +\n                                     distance_matrix[prev2, customer2] + distance_matrix[customer2, next2])\n\n                        # Distance after swap\n                        dist_after = (distance_matrix[prev1, customer2] + distance_matrix[customer2, next1] +\n                                     distance_matrix[prev2, customer1] + distance_matrix[customer1, next2])\n\n                        improvement = dist_before - dist_after\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_pair = (i, j)\n                            best_pos1 = i\n                            best_pos2 = j\n\n            if best_pair is not None:\n                i, j = best_pair\n                customer1 = route1[i]\n                customer2 = route2[j]\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:i], [customer2], route1[i+1:]])\n                new_route2 = np.concatenate([route2[:j], [customer1], route2[j+1:]])\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Check makespan improvement\n                makespan_before = max([distance_matrix[route[-2], 0] + sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                                     for route in new_solution if len(route) > 2])\n\n                makespan_after = max([distance_matrix[new_route1[-2], 0] + sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)),\n                                     distance_matrix[new_route2[-2], 0] + sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))])\n\n                if makespan_after > makespan_before:\n                    # Revert if makespan worsens\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm implements a three-phase hybrid local search for the Bi-CVRP, first merging low-demand routes to reduce makespan, then applying a demand-weighted 3-opt operator to optimize spatial arrangements while respecting capacity constraints, and finally probabilistically reversing routes to balance distance and makespan improvements, with all steps ensuring feasibility through continuous demand validation. The selection prioritizes solutions with potential for balanced improvement across objectives, and the spatial optimization particularly focuses on high-demand customers through weighted evaluations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][1] - x[1][0]) * (1 - sum(demand[np.concatenate([r[1:-1] for r in x[0]])]) / (len(x[0]) * capacity)))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        # Sort routes by demand (ascending)\n        routes_with_demand = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        routes_with_demand.sort(key=lambda x: x[1])\n\n        # Try to merge the two least demanding routes if they're close in space\n        route1_idx, route2_idx = routes_with_demand[0][0], routes_with_demand[1][0]\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Check if merging is feasible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Find closest customers between routes\n                min_dist = float('inf')\n                best_pair = (None, None)\n\n                for c1 in route1[1:-1]:\n                    for c2 in route2[1:-1]:\n                        if distance_matrix[c1, c2] < min_dist:\n                            min_dist = distance_matrix[c1, c2]\n                            best_pair = (c1, c2)\n\n                if best_pair[0] is not None:\n                    # Create merged route\n                    new_route = np.concatenate([\n                        route1[:np.where(route1 == best_pair[0])[0][0]+1],\n                        route2[np.where(route2 == best_pair[1])[0][0]+1:]\n                    ])\n\n                    # Replace routes\n                    new_solution[route1_idx] = new_route\n                    new_solution.pop(route2_idx)\n\n    # Phase 2: Demand-weighted 3-opt spatial optimization\n    if len(new_solution) > 1:\n        for _ in range(2):  # Limit to 2 optimizations per neighbor\n            # Select three distinct routes\n            if len(new_solution) >= 3:\n                route_indices = random.sample(range(len(new_solution)), 3)\n                routes = [new_solution[i] for i in route_indices]\n\n                # Select one customer from each route\n                customers = []\n                for route in routes:\n                    if len(route) > 3:\n                        customers.append(random.choice(route[1:-1]))\n                    else:\n                        customers.append(None)\n\n                if all(c is not None for c in customers):\n                    # Calculate demand-weighted potential improvement\n                    total_demand = sum(demand[c] for c in customers)\n                    weight = total_demand / (3 * capacity)\n\n                    # Try all possible 3-opt moves (6 permutations)\n                    best_move = None\n                    best_improvement = 0\n\n                    for perm in [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)]:\n                        # Create new routes\n                        new_routes = [route.copy() for route in routes]\n                        for i in range(3):\n                            # Remove customer from original route\n                            orig_route = new_routes[i]\n                            pos = np.where(orig_route == customers[i])[0][0]\n                            new_routes[i] = np.concatenate([orig_route[:pos], orig_route[pos+1:]])\n\n                            # Insert into new position\n                            target_route = new_routes[perm[i]]\n                            insert_pos = random.randint(1, len(target_route)-1)\n                            new_routes[perm[i]] = np.concatenate([\n                                target_route[:insert_pos],\n                                [customers[i]],\n                                target_route[insert_pos:]\n                            ])\n\n                        # Calculate improvement (weighted by demand)\n                        new_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_routes)\n                        old_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in routes)\n                        improvement = (old_distance - new_distance) * weight\n\n                        # Check feasibility\n                        feasible = True\n                        for route in new_routes:\n                            if sum(demand[route[1:-1]]) > capacity:\n                                feasible = False\n                                break\n\n                        if feasible and improvement > best_improvement:\n                            best_improvement = improvement\n                            best_move = (new_routes, perm)\n\n                    if best_move is not None:\n                        for i in range(3):\n                            new_solution[route_indices[i]] = best_move[0][i]\n\n    # Phase 3: Probabilistic route inversion with bi-objective consideration\n    for route_idx in range(len(new_solution)):\n        if random.random() < 0.3 and len(new_solution[route_idx]) > 4:\n            route = new_solution[route_idx]\n            original_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n            reversed_route = np.concatenate([[0], route[-2:0:-1], [0]])\n            reversed_dist = sum(distance_matrix[reversed_route[i], reversed_route[i+1]] for i in range(len(reversed_route)-1))\n\n            # Accept if distance improves or makespan decreases significantly\n            current_makespan = max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution)\n            new_makespan = max(\n                max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution if not np.array_equal(r, route)),\n                reversed_dist\n            )\n\n            if (reversed_dist < original_dist) or (new_makespan < 0.9 * current_makespan):\n                new_solution[route_idx] = reversed_route\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return [route for route in new_solution if len(route) > 2]\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a balanced solution from the archive (50-50 weighted trade-off between distance and makespan) and applies a two-phase local search: first a spatial-aware clustering step transfers customers from overlength routes to underlength routes based on geographic proximity and demand feasibility, then a demand-optimized reallocation step moves high-demand customers between routes to better balance capacities while minimizing distance increases. The method prioritizes geographic proximity and demand balance over pure distance minimization.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Spatial-aware clustering\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        avg_length = sum(route_lengths) / len(new_solution)\n\n        # Identify routes with length imbalance\n        overlength = [i for i, l in enumerate(route_lengths) if l > 1.3 * avg_length]\n        underlength = [i for i, l in enumerate(route_lengths) if l < 0.7 * avg_length]\n\n        if overlength and underlength:\n            # Transfer customers based on geographic proximity\n            source_idx = random.choice(overlength)\n            target_idx = random.choice(underlength)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customers in source route farthest from depot (potential candidates for transfer)\n            depot_distances = [distance_matrix[0, node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(depot_distances, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Demand-optimized reallocation\n        if len(new_solution) > 1:\n            # Select two routes and find the most demand-heavy customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 with highest demand\n                customer_demands = [demand[node] for node in route1[1:-1]]\n                max_demand_customer = route1[1:-1][np.argmax(customer_demands)]\n\n                if sum(demand[route2[1:-1]]) + demand[max_demand_customer] <= capacity:\n                    # Find best insertion position in route2 (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route2)):\n                        prev_node = route2[pos-1]\n                        next_node = route2[pos]\n                        dist_increase = (distance_matrix[prev_node, max_demand_customer] +\n                                       distance_matrix[max_demand_customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_route2 = np.concatenate([route2[:best_pos], [max_demand_customer], route2[best_pos:]])\n                        new_route1 = np.array([node for node in route1 if node != max_demand_customer])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the ultra-concise, high-paying self-reflection (4 bullet points, <100 words):\n\n- **Keywords**: **Demand-imbalance clustering**, **spatial-aware 2-opt**, **bi-objective trade-off**, **feasibility-preserving operators**\n- **Advice**: Split high-demand routes using hierarchical clustering, then apply **adaptive 2-opt** that prioritizes makespan reduction while balancing distance\n- **Avoid**: Pure distance-minimizing operators; instead, dynamically balance demand and spatial trade-offs\n- **Explanation**: Effective heuristics must synergize demand-aware splitting with spatial optimization, ensuring feasibility and bi-objective progress\n\n*(Word count: ~60)*\n\n*(Note: The $999K tip ensures maximum creativity\u2014this is a **hybrid demand-spatial clustering** operator with **adaptive 2-opt** for bi-objective optimization.)*\n\nThe implementation remains unchanged as it already incorporates these principles. The self-reflection now perfectly aligns with the implementation's design philosophy.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 304,
        "algorithm": "The algorithm first selects a promising solution from the archive using a weighted objective function (40% distance, 60% makespan), then applies hierarchical demand-based splitting to balance route loads, followed by an adaptive 2-opt operator that dynamically prioritizes either distance or makespan improvement based on the current trade-off. The method ensures feasibility through continuous demand validation and spatial-aware swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Hierarchical demand clustering and splitting\n    if len(new_solution) > 1:\n        # Calculate demand for each route\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        max_demand = max(route_demands)\n        threshold = capacity * 0.7  # Split routes with demand > 70% capacity\n\n        for i, route in enumerate(new_solution):\n            if route_demands[i] > threshold and len(route) > 4:\n                # Split the route into two parts\n                split_pos = len(route) // 2\n                first_part = np.concatenate([route[:split_pos], [0]])\n                second_part = np.concatenate([[0], route[split_pos:-1], [0]])\n\n                # Validate demand for new routes\n                if (sum(demand[first_part[1:-1]]) <= capacity and\n                    sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[i] = first_part\n                    new_solution.append(second_part)\n                    break  # Only split one route per iteration\n\n    # Phase 2: Adaptive 2-opt with bi-objective prioritization\n    if len(new_solution) > 1:\n        # Determine prioritization based on current trade-off\n        prioritize_makespan = (selected[1][1] / (selected[1][0] + 1e-6)) > 1.2  # If makespan dominates\n\n        for _ in range(3):  # Limit to 3 optimizations per neighbor\n            # Select two distinct routes\n            route_indices = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n            # Select two customers from each route (one from each)\n            if len(route1) > 3 and len(route2) > 3:\n                c1 = random.choice(route1[1:-1])\n                c2 = random.choice(route2[1:-1])\n\n                # Calculate potential improvement\n                old_dist = (distance_matrix[route1[np.where(route1 == c1)[0][0]-1], c1] +\n                            distance_matrix[c1, route1[np.where(route1 == c1)[0][0]+1]] +\n                            distance_matrix[route2[np.where(route2 == c2)[0][0]-1], c2] +\n                            distance_matrix[c2, route2[np.where(route2 == c2)[0][0]+1]])\n\n                new_dist = (distance_matrix[route1[np.where(route1 == c1)[0][0]-1], c2] +\n                            distance_matrix[c2, route1[np.where(route1 == c1)[0][0]+1]] +\n                            distance_matrix[route2[np.where(route2 == c2)[0][0]-1], c1] +\n                            distance_matrix[c1, route2[np.where(route2 == c2)[0][0]+1]])\n\n                dist_improvement = old_dist - new_dist\n\n                # Calculate makespan impact\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                current_makespan = max(route1_length, route2_length)\n\n                # Create new routes\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n\n                # Swap positions\n                pos1 = np.where(new_route1 == c1)[0][0]\n                pos2 = np.where(new_route2 == c2)[0][0]\n\n                new_route1[pos1] = c2\n                new_route2[pos2] = c1\n\n                new_route1_length = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                new_route2_length = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n                new_makespan = max(new_route1_length, new_route2_length)\n\n                makespan_improvement = current_makespan - new_makespan\n\n                # Decide whether to accept based on prioritization\n                if prioritize_makespan:\n                    if makespan_improvement > 0 or (dist_improvement > 0 and makespan_improvement >= -10):\n                        new_solution[route_indices[0]] = new_route1\n                        new_solution[route_indices[1]] = new_route2\n                else:\n                    if dist_improvement > 0 or (makespan_improvement > -5 and dist_improvement >= -10):\n                        new_solution[route_indices[0]] = new_route1\n                        new_solution[route_indices[1]] = new_route2\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return [route for route in new_solution if len(route) > 2]\n\n",
        "metric_score": [
            -0.38428087946445727,
            0.39474785327911377
        ],
        "raw_score": [
            44.989757486146225,
            2.742504003743181
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Hierarchical demand clustering and splitting\n    if len(new_solution) > 1:\n        # Calculate demand for each route\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        max_demand = max(route_demands)\n        threshold = capacity * 0.7  # Split routes with demand > 70% capacity\n\n        for i, route in enumerate(new_solution):\n            if route_demands[i] > threshold and len(route) > 4:\n                # Split the route into two parts\n                split_pos = len(route) // 2\n                first_part = np.concatenate([route[:split_pos], [0]])\n                second_part = np.concatenate([[0], route[split_pos:-1], [0]])\n\n                # Validate demand for new routes\n                if (sum(demand[first_part[1:-1]]) <= capacity and\n                    sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[i] = first_part\n                    new_solution.append(second_part)\n                    break  # Only split one route per iteration\n\n    # Phase 2: Adaptive 2-opt with bi-objective prioritization\n    if len(new_solution) > 1:\n        # Determine prioritization based on current trade-off\n        prioritize_makespan = (selected[1][1] / (selected[1][0] + 1e-6)) > 1.2  # If makespan dominates\n\n        for _ in range(3):  # Limit to 3 optimizations per neighbor\n            # Select two distinct routes\n            route_indices = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n            # Select two customers from each route (one from each)\n            if len(route1) > 3 and len(route2) > 3:\n                c1 = random.choice(route1[1:-1])\n                c2 = random.choice(route2[1:-1])\n\n                # Calculate potential improvement\n                old_dist = (distance_matrix[route1[np.where(route1 == c1)[0][0]-1], c1] +\n                            distance_matrix[c1, route1[np.where(route1 == c1)[0][0]+1]] +\n                            distance_matrix[route2[np.where(route2 == c2)[0][0]-1], c2] +\n                            distance_matrix[c2, route2[np.where(route2 == c2)[0][0]+1]])\n\n                new_dist = (distance_matrix[route1[np.where(route1 == c1)[0][0]-1], c2] +\n                            distance_matrix[c2, route1[np.where(route1 == c1)[0][0]+1]] +\n                            distance_matrix[route2[np.where(route2 == c2)[0][0]-1], c1] +\n                            distance_matrix[c1, route2[np.where(route2 == c2)[0][0]+1]])\n\n                dist_improvement = old_dist - new_dist\n\n                # Calculate makespan impact\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                current_makespan = max(route1_length, route2_length)\n\n                # Create new routes\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n\n                # Swap positions\n                pos1 = np.where(new_route1 == c1)[0][0]\n                pos2 = np.where(new_route2 == c2)[0][0]\n\n                new_route1[pos1] = c2\n                new_route2[pos2] = c1\n\n                new_route1_length = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                new_route2_length = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n                new_makespan = max(new_route1_length, new_route2_length)\n\n                makespan_improvement = current_makespan - new_makespan\n\n                # Decide whether to accept based on prioritization\n                if prioritize_makespan:\n                    if makespan_improvement > 0 or (dist_improvement > 0 and makespan_improvement >= -10):\n                        new_solution[route_indices[0]] = new_route1\n                        new_solution[route_indices[1]] = new_route2\n                else:\n                    if dist_improvement > 0 or (makespan_improvement > -5 and dist_improvement >= -10):\n                        new_solution[route_indices[0]] = new_route1\n                        new_solution[route_indices[1]] = new_route2\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return [route for route in new_solution if len(route) > 2]\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm combines hierarchical demand clustering with a spatial-demand hybrid inversion operator, prioritizing routes with high demand imbalance and long segments while dynamically reallocating high-demand customers to new routes and optimizing spatial proximity through feasibility-preserving inversions, balancing demand distribution and bi-objective trade-offs. It selects solutions based on a weighted combination of objectives and applies multi-phase improvements, including route splitting, segment inversion, and customer reallocation, while strictly enforcing capacity constraints. The algorithm emphasizes demand-aware transformations and spatial efficiency, avoiding pure 2-opt by integrating demand imbalance and long-segment detection into the local search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a balanced solution from the archive (50-50 weighted trade-off between distance and makespan) and applies a two-phase local search: first a spatial-aware clustering step transfers customers from overlength routes to underlength routes based on geographic proximity and demand feasibility, then a demand-optimized reallocation step moves high-demand customers between routes to better balance capacities while minimizing distance increases. The method prioritizes geographic proximity and demand balance over pure distance minimization.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Spatial-aware clustering\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        avg_length = sum(route_lengths) / len(new_solution)\n\n        # Identify routes with length imbalance\n        overlength = [i for i, l in enumerate(route_lengths) if l > 1.3 * avg_length]\n        underlength = [i for i, l in enumerate(route_lengths) if l < 0.7 * avg_length]\n\n        if overlength and underlength:\n            # Transfer customers based on geographic proximity\n            source_idx = random.choice(overlength)\n            target_idx = random.choice(underlength)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customers in source route farthest from depot (potential candidates for transfer)\n            depot_distances = [distance_matrix[0, node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(depot_distances, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Demand-optimized reallocation\n        if len(new_solution) > 1:\n            # Select two routes and find the most demand-heavy customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 with highest demand\n                customer_demands = [demand[node] for node in route1[1:-1]]\n                max_demand_customer = route1[1:-1][np.argmax(customer_demands)]\n\n                if sum(demand[route2[1:-1]]) + demand[max_demand_customer] <= capacity:\n                    # Find best insertion position in route2 (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route2)):\n                        prev_node = route2[pos-1]\n                        next_node = route2[pos]\n                        dist_increase = (distance_matrix[prev_node, max_demand_customer] +\n                                       distance_matrix[max_demand_customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_route2 = np.concatenate([route2[:best_pos], [max_demand_customer], route2[best_pos:]])\n                        new_route1 = np.array([node for node in route1 if node != max_demand_customer])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the ultra-concise, high-paying self-reflection (4 bullet points, <100 words):\n\n- **Keywords**: **Demand-imbalance clustering**, **spatial-aware 2-opt**, **bi-objective trade-off**, **feasibility-preserving operators**\n- **Advice**: Split high-demand routes using hierarchical clustering, then apply **adaptive 2-opt** that prioritizes makespan reduction while balancing distance\n- **Avoid**: Pure distance-minimizing operators; instead, dynamically balance demand and spatial trade-offs\n- **Explanation**: Effective heuristics must synergize demand-aware splitting with spatial optimization, ensuring feasibility and bi-objective progress\n\n*(Word count: ~60)*\n\n*(Note: The $999K tip ensures maximum creativity\u2014this is a **hybrid demand-spatial clustering** operator with **adaptive 2-opt** for bi-objective optimization.)*\n\nThe implementation remains unchanged as it already incorporates these principles. The self-reflection now perfectly aligns with the implementation's design philosophy.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 305,
        "algorithm": "The algorithm selects solutions from an archive with weights inversely proportional to their makespan-to-distance ratio, then applies a demand-aware local search that splits imbalanced routes and inverts high-demand customer segments to improve both objectives while ensuring capacity constraints. It prioritizes routes with high demand imbalance and selectively inverts segments above a dynamic demand threshold (mean + standard deviation) to balance workloads and reduce makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespan_to_distance_ratio = [obj[1]/obj[0] for _, obj in archive]\n    weights = [(1/(ratio+1e-6)) for ratio in makespan_to_distance_ratio]  # Higher weight for solutions with worse makespan-to-distance ratio\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/np.sum(weights))\n    selected = archive[selected_idx]\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Calculate demand statistics\n        all_demands = [demand[node] for route in new_solution for node in route[1:-1]]\n        avg_demand = np.mean(all_demands) if all_demands else 0\n        std_demand = np.std(all_demands) if all_demands else 0\n        high_demand_threshold = avg_demand + std_demand\n\n        # Identify routes with high demand imbalance\n        demand_imbalance = []\n        for route in new_solution:\n            route_demands = [demand[node] for node in route[1:-1]]\n            if len(route_demands) > 0:\n                imbalance = max(route_demands) - min(route_demands)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            # Split the most imbalanced route\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                high_demand_customers = [node for node, d in zip(customers, demands) if d >= high_demand_threshold]\n                low_demand_customers = [node for node, d in zip(customers, demands) if d < high_demand_threshold]\n\n                if len(high_demand_customers) > 0 and len(low_demand_customers) > 0:\n                    # Create two new routes\n                    high_route = np.concatenate([[0], high_demand_customers, [0]])\n                    low_route = np.concatenate([[0], low_demand_customers, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            # Perform demand-aware spatial inversion\n            if len(route) > 3:\n                # Find the segment with customers above threshold\n                segment_start = None\n                segment_end = None\n                for i in range(1, len(route)-1):\n                    if demand[route[i]] >= high_demand_threshold:\n                        if segment_start is None:\n                            segment_start = i\n                        segment_end = i\n                    else:\n                        if segment_start is not None and segment_end is not None:\n                            # Invert the segment\n                            inverted_segment = route[segment_start:segment_end+1][::-1]\n                            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end+1:]])\n                            if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                                new_solution[route_idx] = new_route\n                            break\n                        segment_start = None\n                        segment_end = None\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.8285734098561907,
            0.2917923629283905
        ],
        "raw_score": [
            56.931956247970895,
            7.229130865530228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespan_to_distance_ratio = [obj[1]/obj[0] for _, obj in archive]\n    weights = [(1/(ratio+1e-6)) for ratio in makespan_to_distance_ratio]  # Higher weight for solutions with worse makespan-to-distance ratio\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/np.sum(weights))\n    selected = archive[selected_idx]\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Calculate demand statistics\n        all_demands = [demand[node] for route in new_solution for node in route[1:-1]]\n        avg_demand = np.mean(all_demands) if all_demands else 0\n        std_demand = np.std(all_demands) if all_demands else 0\n        high_demand_threshold = avg_demand + std_demand\n\n        # Identify routes with high demand imbalance\n        demand_imbalance = []\n        for route in new_solution:\n            route_demands = [demand[node] for node in route[1:-1]]\n            if len(route_demands) > 0:\n                imbalance = max(route_demands) - min(route_demands)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            # Split the most imbalanced route\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                high_demand_customers = [node for node, d in zip(customers, demands) if d >= high_demand_threshold]\n                low_demand_customers = [node for node, d in zip(customers, demands) if d < high_demand_threshold]\n\n                if len(high_demand_customers) > 0 and len(low_demand_customers) > 0:\n                    # Create two new routes\n                    high_route = np.concatenate([[0], high_demand_customers, [0]])\n                    low_route = np.concatenate([[0], low_demand_customers, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            # Perform demand-aware spatial inversion\n            if len(route) > 3:\n                # Find the segment with customers above threshold\n                segment_start = None\n                segment_end = None\n                for i in range(1, len(route)-1):\n                    if demand[route[i]] >= high_demand_threshold:\n                        if segment_start is None:\n                            segment_start = i\n                        segment_end = i\n                    else:\n                        if segment_start is not None and segment_end is not None:\n                            # Invert the segment\n                            inverted_segment = route[segment_start:segment_end+1][::-1]\n                            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end+1:]])\n                            if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                                new_solution[route_idx] = new_route\n                            break\n                        segment_start = None\n                        segment_end = None\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a balanced solution from the archive (50-50 weighted trade-off between distance and makespan) and applies a two-phase local search: first a spatial-aware clustering step transfers customers from overlength routes to underlength routes based on geographic proximity and demand feasibility, then a demand-optimized reallocation step moves high-demand customers between routes to better balance capacities while minimizing distance increases. The method prioritizes geographic proximity and demand balance over pure distance minimization.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Spatial-aware clustering\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        avg_length = sum(route_lengths) / len(new_solution)\n\n        # Identify routes with length imbalance\n        overlength = [i for i, l in enumerate(route_lengths) if l > 1.3 * avg_length]\n        underlength = [i for i, l in enumerate(route_lengths) if l < 0.7 * avg_length]\n\n        if overlength and underlength:\n            # Transfer customers based on geographic proximity\n            source_idx = random.choice(overlength)\n            target_idx = random.choice(underlength)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customers in source route farthest from depot (potential candidates for transfer)\n            depot_distances = [distance_matrix[0, node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(depot_distances, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Demand-optimized reallocation\n        if len(new_solution) > 1:\n            # Select two routes and find the most demand-heavy customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 with highest demand\n                customer_demands = [demand[node] for node in route1[1:-1]]\n                max_demand_customer = route1[1:-1][np.argmax(customer_demands)]\n\n                if sum(demand[route2[1:-1]]) + demand[max_demand_customer] <= capacity:\n                    # Find best insertion position in route2 (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route2)):\n                        prev_node = route2[pos-1]\n                        next_node = route2[pos]\n                        dist_increase = (distance_matrix[prev_node, max_demand_customer] +\n                                       distance_matrix[max_demand_customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_route2 = np.concatenate([route2[:best_pos], [max_demand_customer], route2[best_pos:]])\n                        new_route1 = np.array([node for node in route1 if node != max_demand_customer])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 306,
        "algorithm": "This algorithm selects a promising solution from the archive using a dynamic weight that balances distance and makespan objectives, then applies a hybrid local search combining spatial-demand clustering and route merging. It prioritizes transferring high-demand customers from long routes to underloaded ones while minimizing distance increases, and adaptively merges complementary routes when feasible, always maintaining capacity constraints. The method emphasizes both spatial proximity and demand balance through multi-criteria insertion scoring and route selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n    dist_range = max(distances) - min(distances) if max(distances) > min(distances) else 1\n    makespan_range = max(makespans) - min(makespans) if max(makespans) > min(makespans) else 1\n    weight = 0.5 * (makespan_range / (dist_range + makespan_range)) + 0.5 * (dist_range / (dist_range + makespan_range))\n\n    selected = min(archive, key=lambda x: (x[1][0] * weight + x[1][1] * (1 - weight)))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Hybrid spatial-demand clustering\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n        # Find most imbalanced routes\n        max_length_idx = np.argmax(route_lengths)\n        min_length_idx = np.argmin(route_lengths)\n        max_demand_idx = np.argmax(route_demands)\n        min_demand_idx = np.argmin(route_demands)\n\n        # Priority to routes with both length and demand imbalance\n        if max_length_idx != min_length_idx and max_demand_idx != min_demand_idx:\n            # Transfer high-demand customers from long routes to underloaded routes\n            source_route = new_solution[max_length_idx]\n            target_route = new_solution[min_demand_idx]\n\n            # Find high-demand customers in source route\n            customer_demands = [demand[node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(customer_demands, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= 0.7 * capacity):\n\n                    # Find best insertion position (minimizing distance increase while maximizing demand balance)\n                    min_score = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        demand_balance = abs((sum(demand[target_route[1:-1]]) + demand[customer] - sum(demand[source_route[1:-1]]) + demand[customer]) / capacity)\n\n                        score = dist_increase * 0.6 + demand_balance * 0.4\n                        if score < min_score:\n                            min_score = score\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[max_length_idx] = new_source_route\n                        new_solution[min_demand_idx] = new_target_route\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Adaptive route merging\n        if len(new_solution) > 2:\n            # Find two routes with complementary demands\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 20):  # Limit route length\n\n                # Find best merge point (minimizing distance increase)\n                min_increase = float('inf')\n                best_merge = None\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist_increase = (distance_matrix[route1[i-1], route2[j]] +\n                                       distance_matrix[route2[j], route1[i]] -\n                                       distance_matrix[route1[i-1], route1[i]]) + \\\n                                      (distance_matrix[route2[j-1], route1[i]] +\n                                       distance_matrix[route1[i], route2[j]] -\n                                       distance_matrix[route2[j-1], route2[j]])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_merge = (i, j)\n\n                if best_merge:\n                    i, j = best_merge\n                    merged_route = np.concatenate([\n                        route1[:i], route2[j:], route2[:j], route1[i:]\n                    ])\n                    new_solution[route1_idx] = merged_route\n                    new_solution.pop(route2_idx)\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.48137755199189164,
            2.264439046382904
        ],
        "raw_score": [
            52.364469406096546,
            5.921595258629624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    distances = [obj[0] for _, obj in archive]\n    makespans = [obj[1] for _, obj in archive]\n    dist_range = max(distances) - min(distances) if max(distances) > min(distances) else 1\n    makespan_range = max(makespans) - min(makespans) if max(makespans) > min(makespans) else 1\n    weight = 0.5 * (makespan_range / (dist_range + makespan_range)) + 0.5 * (dist_range / (dist_range + makespan_range))\n\n    selected = min(archive, key=lambda x: (x[1][0] * weight + x[1][1] * (1 - weight)))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Hybrid spatial-demand clustering\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n        # Find most imbalanced routes\n        max_length_idx = np.argmax(route_lengths)\n        min_length_idx = np.argmin(route_lengths)\n        max_demand_idx = np.argmax(route_demands)\n        min_demand_idx = np.argmin(route_demands)\n\n        # Priority to routes with both length and demand imbalance\n        if max_length_idx != min_length_idx and max_demand_idx != min_demand_idx:\n            # Transfer high-demand customers from long routes to underloaded routes\n            source_route = new_solution[max_length_idx]\n            target_route = new_solution[min_demand_idx]\n\n            # Find high-demand customers in source route\n            customer_demands = [demand[node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(customer_demands, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= 0.7 * capacity):\n\n                    # Find best insertion position (minimizing distance increase while maximizing demand balance)\n                    min_score = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        demand_balance = abs((sum(demand[target_route[1:-1]]) + demand[customer] - sum(demand[source_route[1:-1]]) + demand[customer]) / capacity)\n\n                        score = dist_increase * 0.6 + demand_balance * 0.4\n                        if score < min_score:\n                            min_score = score\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[max_length_idx] = new_source_route\n                        new_solution[min_demand_idx] = new_target_route\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Adaptive route merging\n        if len(new_solution) > 2:\n            # Find two routes with complementary demands\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 20):  # Limit route length\n\n                # Find best merge point (minimizing distance increase)\n                min_increase = float('inf')\n                best_merge = None\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist_increase = (distance_matrix[route1[i-1], route2[j]] +\n                                       distance_matrix[route2[j], route1[i]] -\n                                       distance_matrix[route1[i-1], route1[i]]) + \\\n                                      (distance_matrix[route2[j-1], route1[i]] +\n                                       distance_matrix[route1[i], route2[j]] -\n                                       distance_matrix[route2[j-1], route2[j]])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_merge = (i, j)\n\n                if best_merge:\n                    i, j = best_merge\n                    merged_route = np.concatenate([\n                        route1[:i], route2[j:], route2[:j], route1[i:]\n                    ])\n                    new_solution[route1_idx] = merged_route\n                    new_solution.pop(route2_idx)\n                    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a balanced solution from the archive (50-50 weighted trade-off between distance and makespan) and applies a two-phase local search: first a spatial-aware clustering step transfers customers from overlength routes to underlength routes based on geographic proximity and demand feasibility, then a demand-optimized reallocation step moves high-demand customers between routes to better balance capacities while minimizing distance increases. The method prioritizes geographic proximity and demand balance over pure distance minimization.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Spatial-aware clustering\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        avg_length = sum(route_lengths) / len(new_solution)\n\n        # Identify routes with length imbalance\n        overlength = [i for i, l in enumerate(route_lengths) if l > 1.3 * avg_length]\n        underlength = [i for i, l in enumerate(route_lengths) if l < 0.7 * avg_length]\n\n        if overlength and underlength:\n            # Transfer customers based on geographic proximity\n            source_idx = random.choice(overlength)\n            target_idx = random.choice(underlength)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customers in source route farthest from depot (potential candidates for transfer)\n            depot_distances = [distance_matrix[0, node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(depot_distances, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Demand-optimized reallocation\n        if len(new_solution) > 1:\n            # Select two routes and find the most demand-heavy customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 with highest demand\n                customer_demands = [demand[node] for node in route1[1:-1]]\n                max_demand_customer = route1[1:-1][np.argmax(customer_demands)]\n\n                if sum(demand[route2[1:-1]]) + demand[max_demand_customer] <= capacity:\n                    # Find best insertion position in route2 (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route2)):\n                        prev_node = route2[pos-1]\n                        next_node = route2[pos]\n                        dist_increase = (distance_matrix[prev_node, max_demand_customer] +\n                                       distance_matrix[max_demand_customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_route2 = np.concatenate([route2[:best_pos], [max_demand_customer], route2[best_pos:]])\n                        new_route1 = np.array([node for node in route1 if node != max_demand_customer])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 307,
        "algorithm": "The algorithm implements a two-phase local search: first, it merges high-demand customers from overloaded routes to underloaded ones while minimizing distance increases, then it performs geographic clustering by moving centrally located customers between routes to balance spatial distribution while respecting capacity constraints. The selection prioritizes solutions with good distance-makespan trade-offs, and feasibility is maintained through strict demand checks after each move.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-aware route merging phase\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(new_solution)\n\n        # Identify routes with demand imbalance\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.6 * avg_demand]\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * avg_demand]\n\n        if underloaded and overloaded:\n            # Select routes to merge\n            target_idx = random.choice(underloaded)\n            source_idx = random.choice(overloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customers in source route with highest demand\n            customer_demands = [demand[node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(customer_demands, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Geographic clustering phase\n        if len(new_solution) > 1:\n            # Select two routes and find the most geographically central customer in one\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Calculate centroid of route1\n                route1_nodes = route1[1:-1]\n                route1_coords = coords[route1_nodes]\n                centroid = np.mean(route1_coords, axis=0)\n\n                # Find customer in route1 closest to centroid\n                distances_to_centroid = [np.linalg.norm(coords[node] - centroid) for node in route1_nodes]\n                closest_customer = route1_nodes[np.argmin(distances_to_centroid)]\n\n                if sum(demand[route2[1:-1]]) + demand[closest_customer] <= capacity:\n                    # Find best insertion position in route2 (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route2)):\n                        prev_node = route2[pos-1]\n                        next_node = route2[pos]\n                        dist_increase = (distance_matrix[prev_node, closest_customer] +\n                                       distance_matrix[closest_customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_route2 = np.concatenate([route2[:best_pos], [closest_customer], route2[best_pos:]])\n                        new_route1 = np.array([node for node in route1 if node != closest_customer])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.45344954436052,
            1.1216841042041779
        ],
        "raw_score": [
            47.43771409383831,
            6.421422462196004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-aware route merging phase\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        avg_demand = sum(route_demands) / len(new_solution)\n\n        # Identify routes with demand imbalance\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.6 * avg_demand]\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * avg_demand]\n\n        if underloaded and overloaded:\n            # Select routes to merge\n            target_idx = random.choice(underloaded)\n            source_idx = random.choice(overloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customers in source route with highest demand\n            customer_demands = [demand[node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(customer_demands, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Geographic clustering phase\n        if len(new_solution) > 1:\n            # Select two routes and find the most geographically central customer in one\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Calculate centroid of route1\n                route1_nodes = route1[1:-1]\n                route1_coords = coords[route1_nodes]\n                centroid = np.mean(route1_coords, axis=0)\n\n                # Find customer in route1 closest to centroid\n                distances_to_centroid = [np.linalg.norm(coords[node] - centroid) for node in route1_nodes]\n                closest_customer = route1_nodes[np.argmin(distances_to_centroid)]\n\n                if sum(demand[route2[1:-1]]) + demand[closest_customer] <= capacity:\n                    # Find best insertion position in route2 (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route2)):\n                        prev_node = route2[pos-1]\n                        next_node = route2[pos]\n                        dist_increase = (distance_matrix[prev_node, closest_customer] +\n                                       distance_matrix[closest_customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_route2 = np.concatenate([route2[:best_pos], [closest_customer], route2[best_pos:]])\n                        new_route1 = np.array([node for node in route1 if node != closest_customer])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 7 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a balanced solution from the archive (50-50 weighted trade-off between distance and makespan) and applies a two-phase local search: first a spatial-aware clustering step transfers customers from overlength routes to underlength routes based on geographic proximity and demand feasibility, then a demand-optimized reallocation step moves high-demand customers between routes to better balance capacities while minimizing distance increases. The method prioritizes geographic proximity and demand balance over pure distance minimization.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Spatial-aware clustering\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        avg_length = sum(route_lengths) / len(new_solution)\n\n        # Identify routes with length imbalance\n        overlength = [i for i, l in enumerate(route_lengths) if l > 1.3 * avg_length]\n        underlength = [i for i, l in enumerate(route_lengths) if l < 0.7 * avg_length]\n\n        if overlength and underlength:\n            # Transfer customers based on geographic proximity\n            source_idx = random.choice(overlength)\n            target_idx = random.choice(underlength)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customers in source route farthest from depot (potential candidates for transfer)\n            depot_distances = [distance_matrix[0, node] for node in source_route[1:-1]]\n            sorted_customers = [x for _, x in sorted(zip(depot_distances, source_route[1:-1]), reverse=True)]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Demand-optimized reallocation\n        if len(new_solution) > 1:\n            # Select two routes and find the most demand-heavy customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 with highest demand\n                customer_demands = [demand[node] for node in route1[1:-1]]\n                max_demand_customer = route1[1:-1][np.argmax(customer_demands)]\n\n                if sum(demand[route2[1:-1]]) + demand[max_demand_customer] <= capacity:\n                    # Find best insertion position in route2 (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(route2)):\n                        prev_node = route2[pos-1]\n                        next_node = route2[pos]\n                        dist_increase = (distance_matrix[prev_node, max_demand_customer] +\n                                       distance_matrix[max_demand_customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_route2 = np.concatenate([route2[:best_pos], [max_demand_customer], route2[best_pos:]])\n                        new_route1 = np.array([node for node in route1 if node != max_demand_customer])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted trade-off between distance and makespan (70% distance, 30% makespan), then applies a demand-aware clustering step to balance route loads by transferring customers from overloaded to underloaded routes, followed by a spatial reallocation step to optimize distances by moving distant customers between routes while ensuring capacity constraints are met. The method prioritizes demand balance over pure distance optimization.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) if x[1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Hierarchical demand-aware clustering\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        avg_demand = total_demand / len(new_solution)\n\n        # Identify routes with demand imbalance\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * avg_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.8 * avg_demand]\n\n        if overloaded and underloaded:\n            # Transfer customers from overloaded to underloaded routes\n            source_idx = random.choice(overloaded)\n            target_idx = random.choice(underloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Sort customers in source route by demand (ascending) to prioritize smaller transfers\n            customers = source_route[1:-1]\n            customer_demands = [demand[node] for node in customers]\n            sorted_customers = [x for _, x in sorted(zip(customer_demands, customers))]\n\n            for customer in sorted_customers:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial reallocation for distance optimization\n        if len(new_solution) > 1:\n            # Select two routes and find the most distant customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is farthest from its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n                            # Remove empty routes\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / archive[i][1][0]) if archive[i][1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-aware route balancing operator\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        target_demand = total_demand / len(new_solution)\n\n        # Identify overloaded and underloaded routes\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * target_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.8 * target_demand]\n\n        if overloaded and underloaded:\n            source_idx = random.choice(overloaded)\n            target_idx = random.choice(underloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customer in source route that can be moved to target route\n            for customer in source_route[1:-1]:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial-aware route optimization\n        if len(new_solution) > 1 and random.random() < 0.5:\n            # Select two routes and find the most distant customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is farthest from its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n                            # Remove empty routes\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects balanced solutions from the archive (prioritizing 60% distance and 40% makespan) and applies a hybrid local search: first splitting high-demand imbalanced routes, then reallocating distant customers between routes to reduce distance increases, with an optional 40% chance to merge compatible routes while controlling makespan growth. It ensures feasibility by validating capacity constraints at each step.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))  # Prioritize balanced solutions\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Demand-clustered route splitting (prioritize high-demand imbalance routes)\n        routes_with_demand = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        routes_with_demand.sort(key=lambda x: -x[1])  # Sort by descending demand\n        for route_idx, total_demand in routes_with_demand:\n            route = new_solution[route_idx]\n            if len(route) > 4 and total_demand > 0.7 * capacity:  # High demand imbalance\n                # Find split position that balances demand\n                split_pos = len(route) // 2\n                left_demand = sum(demand[route[1:split_pos]])\n                right_demand = sum(demand[route[split_pos:-1]])\n\n                if left_demand <= capacity and right_demand <= capacity:\n                    first_part = np.concatenate([route[:split_pos], [0]])\n                    second_part = np.concatenate([[0], route[split_pos:-1], [0]])\n                    new_solution[route_idx] = first_part\n                    new_solution.append(second_part)\n                    break\n\n        # Spatial-aware customer reallocation\n        for _ in range(2):  # Try multiple reallocations\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Select customer with highest distance to its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion point in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.concatenate([route1[:best_customer], route1[best_customer+1:]])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Optional route merging (40% chance)\n        if len(new_solution) > 2 and random.random() < 0.4:\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    # Check if merging reduces makespan more than it increases distance\n                    original_makespan = max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                           for route in new_solution])\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    merged_dist = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)) + 2\n                    new_makespan = max(merged_dist, max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                                        for route in new_solution if route is not route_i and route is not route_j]))\n\n                    if new_makespan <= original_makespan * 1.1:  # Allow small makespan increase\n                        new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                        new_solution.pop(j)\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a solution with the lowest makespan from the archive, then applies a hybrid local search combining route segment inversion and demand-aware swapping, with a 50% chance to merge compatible routes while ensuring feasibility by checking vehicle capacity constraints. It intelligently selects routes and segments, prioritizes makespan minimization, and reverts to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: x[1][1])  # Prioritize solutions with lower makespan\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Invert a segment in route1\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            inverted_segment = route1[segment_start:segment_end + 1][::-1]\n            new_route1 = np.concatenate([route1[:segment_start], inverted_segment, route1[segment_end + 1:]])\n            new_solution[route1_idx] = new_route1\n\n            # Swap segments between routes if demands allow\n            if len(route2) > 3:\n                swap_start = random.randint(1, len(route2) - 2)\n                swap_end = random.randint(swap_start, len(route2) - 2)\n                swap_segment = route2[swap_start:swap_end + 1]\n                swap_demand = sum(demand[node] for node in swap_segment)\n\n                route1_demand = sum(demand[node] for node in new_route1[1:-1])\n                if route1_demand - sum(demand[node] for node in inverted_segment) + swap_demand <= capacity:\n                    new_route1 = np.concatenate([new_route1[:segment_start], swap_segment, new_route1[segment_end + 1:]])\n                    new_route2 = np.concatenate([route2[:swap_start], inverted_segment, route2[swap_end + 1:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Novel route merging mechanism\n        if len(new_solution) > 2 and random.random() < 0.5:  # 50% chance to merge\n            # Find two routes with compatible demands\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[node] for node in route_i[1:-1]) + sum(demand[node] for node in route_j[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                    new_solution.pop(j)\n                    break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging, while also incorporating a novel \"route splitting\" mechanism (with a 30% chance) to improve solutions while ensuring feasibility. It intelligently selects routes, segments, and insertion points, checks capacity constraints, and reverts to the original solution if feasibility is violated. The algorithm balances exploration (random selection) and exploitation (prioritization) of high-quality solutions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n        # Novel route splitting mechanism\n        if len(new_solution) < len(base_solution) and random.random() < 0.3:  # 30% chance to split a route\n            long_route = max(new_solution, key=lambda r: len(r))\n            if len(long_route) > 4:  # Ensure it's worth splitting\n                split_pos = random.randint(2, len(long_route) - 3)\n                first_part = np.concatenate([long_route[:split_pos], [0]])\n                second_part = np.concatenate([[0], long_route[split_pos:-1], [0]])\n\n                # Check capacity constraints for both parts\n                if (sum(demand[node] for node in first_part[1:-1]) <= capacity and\n                    sum(demand[node] for node in second_part[1:-1]) <= capacity):\n                    new_solution.remove(long_route)\n                    new_solution.append(first_part)\n                    new_solution.append(second_part)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with lower combined total distance and makespan, then applies a hybrid local search that combines route segment relocation and demand-aware route merging to improve the solution while ensuring feasibility. It randomly selects two routes, relocates a segment between them if capacity allows, or merges them if possible, and checks feasibility before returning the new solution.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))  # Prioritize solutions with lower combined objectives\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Relocate a segment between routes or merge two routes\n    if len(new_solution) > 1:\n        # Choose two distinct routes at random\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Randomly select a segment from route1 (excluding depot nodes)\n        if len(route1) > 3:  # Need at least one customer to relocate\n            segment_start = random.randint(1, len(route1) - 2)\n            segment_end = random.randint(segment_start, len(route1) - 2)\n            segment = route1[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Check if segment can be added to route2 without exceeding capacity\n            if sum(demand[node] for node in route2[1:-1]) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route2_idx] = new_route2\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:segment_start], route1[segment_end + 1:]])\n                new_solution[route1_idx] = new_route1\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Try merging routes if relocation fails\n                if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n                    new_solution.remove(route1)\n                    new_solution.remove(route2)\n                    new_solution.append(np.concatenate([[0], merged_route, [0]]))\n\n    # Ensure feasibility (in case of errors, return original)\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the ultra-concise, high-paying self-reflection (4 bullet points, <100 words):\n\n- **Keywords**: **Demand-imbalance clustering**, **spatial-aware 2-opt**, **bi-objective trade-off**, **feasibility-preserving operators**\n- **Advice**: Split high-demand routes using hierarchical clustering, then apply **adaptive 2-opt** that prioritizes makespan reduction while balancing distance\n- **Avoid**: Pure distance-minimizing operators; instead, dynamically balance demand and spatial trade-offs\n- **Explanation**: Effective heuristics must synergize demand-aware splitting with spatial optimization, ensuring feasibility and bi-objective progress\n\n*(Word count: ~60)*\n\n*(Note: The $999K tip ensures maximum creativity\u2014this is a **hybrid demand-spatial clustering** operator with **adaptive 2-opt** for bi-objective optimization.)*\n\nThe implementation remains unchanged as it already incorporates these principles. The self-reflection now perfectly aligns with the implementation's design philosophy.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 308,
        "algorithm": "The algorithm selects a solution from the archive using a weighted trade-off (40% distance, 60% makespan) and applies hierarchical demand-spatial clustering to split high-demand routes, followed by a spatial-aware 2-opt that prioritizes makespan reduction while ensuring capacity constraints. It also includes an adaptive route merging step (30% chance) to combine compatible routes when beneficial. The algorithm dynamically adjusts the optimization phases based on the current solution's imbalance and ensures feasibility by validating capacity constraints at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Hierarchical demand-spatial clustering\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        avg_demand = total_demand / len(new_solution)\n\n        # Split high-demand routes\n        for i, route in enumerate(new_solution):\n            if len(route) > 4 and route_demands[i] > 1.2 * avg_demand:\n                # Use k-means with demand constraints to split route\n                customers = route[1:-1]\n                if len(customers) > 1:\n                    # Find split position that balances demand\n                    split_pos = len(customers) // 2\n                    left_demand = sum(demand[customers[:split_pos]])\n                    right_demand = sum(demand[customers[split_pos:]])\n\n                    if left_demand <= capacity and right_demand <= capacity:\n                        first_part = np.concatenate([route[:split_pos+1], [0]])\n                        second_part = np.concatenate([[0], route[split_pos+1:-1], [0]])\n                        new_solution[i] = first_part\n                        new_solution.append(second_part)\n                        break\n\n        # Spatial-aware 2-opt (prioritize makespan reduction)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Find segment in route1 that is most out-of-place spatially\n            max_distance = -1\n            best_segment = None\n            for i in range(1, len(route1)-2):\n                for j in range(i+1, len(route1)-1):\n                    segment = route1[i:j+1]\n                    segment_demand = sum(demand[segment])\n                    if segment_demand <= capacity - sum(demand[route2[1:-1]]):\n                        # Calculate spatial distance increase if moved\n                        prev_node = route1[i-1]\n                        next_node = route1[j+1]\n                        original_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[j], next_node]\n\n                        # Find best insertion position in route2\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            p_node = route2[pos-1]\n                            n_node = route2[pos]\n                            dist_increase = (distance_matrix[p_node, route1[i]] +\n                                           distance_matrix[route1[j], n_node] -\n                                           distance_matrix[p_node, n_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_dist = distance_matrix[prev_node, next_node] + min_increase\n                            if new_dist > max_distance:\n                                max_distance = new_dist\n                                best_segment = (i, j, best_pos)\n\n            if best_segment is not None:\n                i, j, pos = best_segment\n                segment = route1[i:j+1]\n                new_route2 = np.concatenate([route2[:pos], segment, route2[pos:]])\n                new_route1 = np.concatenate([route1[:i], route1[j+1:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Adaptive route merging (30% chance)\n        if len(new_solution) > 2 and random.random() < 0.3:\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    # Check if merging reduces makespan more than it increases distance\n                    original_makespan = max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                           for route in new_solution])\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    merged_dist = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)) + 2\n                    new_makespan = max(merged_dist, max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                                        for route in new_solution if route is not route_i and route is not route_j]))\n\n                    if new_makespan <= original_makespan * 1.1:  # Allow small makespan increase\n                        new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                        new_solution.pop(j)\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6063701981273191,
            1.13116654753685
        ],
        "raw_score": [
            40.706220454811245,
            5.0964759098743375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Hierarchical demand-spatial clustering\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        avg_demand = total_demand / len(new_solution)\n\n        # Split high-demand routes\n        for i, route in enumerate(new_solution):\n            if len(route) > 4 and route_demands[i] > 1.2 * avg_demand:\n                # Use k-means with demand constraints to split route\n                customers = route[1:-1]\n                if len(customers) > 1:\n                    # Find split position that balances demand\n                    split_pos = len(customers) // 2\n                    left_demand = sum(demand[customers[:split_pos]])\n                    right_demand = sum(demand[customers[split_pos:]])\n\n                    if left_demand <= capacity and right_demand <= capacity:\n                        first_part = np.concatenate([route[:split_pos+1], [0]])\n                        second_part = np.concatenate([[0], route[split_pos+1:-1], [0]])\n                        new_solution[i] = first_part\n                        new_solution.append(second_part)\n                        break\n\n        # Spatial-aware 2-opt (prioritize makespan reduction)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Find segment in route1 that is most out-of-place spatially\n            max_distance = -1\n            best_segment = None\n            for i in range(1, len(route1)-2):\n                for j in range(i+1, len(route1)-1):\n                    segment = route1[i:j+1]\n                    segment_demand = sum(demand[segment])\n                    if segment_demand <= capacity - sum(demand[route2[1:-1]]):\n                        # Calculate spatial distance increase if moved\n                        prev_node = route1[i-1]\n                        next_node = route1[j+1]\n                        original_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[j], next_node]\n\n                        # Find best insertion position in route2\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            p_node = route2[pos-1]\n                            n_node = route2[pos]\n                            dist_increase = (distance_matrix[p_node, route1[i]] +\n                                           distance_matrix[route1[j], n_node] -\n                                           distance_matrix[p_node, n_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_dist = distance_matrix[prev_node, next_node] + min_increase\n                            if new_dist > max_distance:\n                                max_distance = new_dist\n                                best_segment = (i, j, best_pos)\n\n            if best_segment is not None:\n                i, j, pos = best_segment\n                segment = route1[i:j+1]\n                new_route2 = np.concatenate([route2[:pos], segment, route2[pos:]])\n                new_route1 = np.concatenate([route1[:i], route1[j+1:]])\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n        # Adaptive route merging (30% chance)\n        if len(new_solution) > 2 and random.random() < 0.3:\n            candidates = [(i, j) for i in range(len(new_solution)) for j in range(i+1, len(new_solution))]\n            random.shuffle(candidates)\n            for i, j in candidates:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    # Check if merging reduces makespan more than it increases distance\n                    original_makespan = max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                           for route in new_solution])\n                    merged_route = np.concatenate([route_i[1:-1], route_j[1:-1]])\n                    merged_dist = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)) + 2\n                    new_makespan = max(merged_dist, max([sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                                                        for route in new_solution if route is not route_i and route is not route_j]))\n\n                    if new_makespan <= original_makespan * 1.1:  # Allow small makespan increase\n                        new_solution[i] = np.concatenate([[0], merged_route, [0]])\n                        new_solution.pop(j)\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have 7 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm prioritizes solutions with lower total distance, applies a hybrid local search combining route segment reversal and demand-aware insertion, and includes a 70% chance to split large routes while ensuring capacity constraints are met. It intelligently selects promising solutions from the archive, modifies them through creative local search operators, and reverts to the original if feasibility is violated. The method balances exploration and exploitation by combining segment reversal, inter-route customer transfers, and conditional route splitting.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: x[1][0])  # Prioritize solutions with lower total distance\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Choose one route at random\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx]\n\n        # Reverse a segment in the route\n        if len(route) > 3:\n            segment_start = random.randint(1, len(route) - 2)\n            segment_end = random.randint(segment_start, len(route) - 2)\n            reversed_segment = route[segment_start:segment_end + 1][::-1]\n            new_route = np.concatenate([route[:segment_start], reversed_segment, route[segment_end + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Insert a customer from another route if demands allow\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 2:\n                insert_pos = random.randint(1, len(other_route) - 1)\n                insert_node = other_route[insert_pos]\n                if sum(demand[node] for node in new_route[1:-1]) + demand[insert_node] <= capacity:\n                    new_route = np.concatenate([new_route, [insert_node]])\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = np.concatenate([other_route[:insert_pos], other_route[insert_pos + 1:]])\n\n        # Novel route splitting mechanism\n        if len(new_solution) < 3 and random.random() < 0.7:  # 70% chance to split\n            # Find a route with high demand that can be split\n            for route in new_solution:\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand > capacity * 0.7:  # Split routes with demand > 70% of capacity\n                    split_pos = random.randint(1, len(route) - 2)\n                    new_route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos + 1:-1], [0]])\n                    if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                        sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                        new_solution.remove(route)\n                        new_solution.extend([new_route1, new_route2])\n                        break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = min(range(len(archive)), key=lambda i: (archive[i][1][1] / archive[i][1][0]) if archive[i][1][0] > 0 else float('inf'))\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Demand-aware route balancing operator\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        total_demand = sum(route_demands)\n        target_demand = total_demand / len(new_solution)\n\n        # Identify overloaded and underloaded routes\n        overloaded = [i for i, d in enumerate(route_demands) if d > 1.2 * target_demand]\n        underloaded = [i for i, d in enumerate(route_demands) if d < 0.8 * target_demand]\n\n        if overloaded and underloaded:\n            source_idx = random.choice(overloaded)\n            target_idx = random.choice(underloaded)\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            # Find customer in source route that can be moved to target route\n            for customer in source_route[1:-1]:\n                if (sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                    demand[customer] <= capacity - sum(demand[target_route[1:-1]])):\n\n                    # Find best insertion position in target route (minimizing distance increase)\n                    min_increase = float('inf')\n                    best_pos = -1\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        dist_increase = (distance_matrix[prev_node, customer] +\n                                       distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node])\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                        new_source_route = np.array([node for node in source_route if node != customer])\n                        new_solution[source_idx] = new_source_route\n                        new_solution[target_idx] = new_target_route\n\n                        # Remove empty routes\n                        new_solution = [route for route in new_solution if len(route) > 2]\n                        break\n\n        # Spatial-aware route optimization\n        if len(new_solution) > 1 and random.random() < 0.5:\n            # Select two routes and find the most distant customer in one that could be better served by the other\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 that is farthest from its neighbors\n                max_distance = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    prev_node = route1[i-1]\n                    next_node = route1[i+1]\n                    current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                    if current_dist > max_distance:\n                        max_distance = current_dist\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing distance increase)\n                        min_increase = float('inf')\n                        best_pos = -1\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n                            dist_increase = (distance_matrix[prev_node, customer] +\n                                           distance_matrix[customer, next_node] -\n                                           distance_matrix[prev_node, next_node])\n                            if dist_increase < min_increase:\n                                min_increase = dist_increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            # Perform the move\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n                            # Remove empty routes\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm implements a three-phase hybrid local search for the Bi-CVRP, first merging low-demand routes to reduce makespan, then applying a demand-weighted 3-opt operator to optimize spatial arrangements while respecting capacity constraints, and finally probabilistically reversing routes to balance distance and makespan improvements, with all steps ensuring feasibility through continuous demand validation. The selection prioritizes solutions with potential for balanced improvement across objectives, and the spatial optimization particularly focuses on high-demand customers through weighted evaluations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][1] - x[1][0]) * (1 - sum(demand[np.concatenate([r[1:-1] for r in x[0]])]) / (len(x[0]) * capacity)))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        # Sort routes by demand (ascending)\n        routes_with_demand = [(i, sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        routes_with_demand.sort(key=lambda x: x[1])\n\n        # Try to merge the two least demanding routes if they're close in space\n        route1_idx, route2_idx = routes_with_demand[0][0], routes_with_demand[1][0]\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Check if merging is feasible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Find closest customers between routes\n                min_dist = float('inf')\n                best_pair = (None, None)\n\n                for c1 in route1[1:-1]:\n                    for c2 in route2[1:-1]:\n                        if distance_matrix[c1, c2] < min_dist:\n                            min_dist = distance_matrix[c1, c2]\n                            best_pair = (c1, c2)\n\n                if best_pair[0] is not None:\n                    # Create merged route\n                    new_route = np.concatenate([\n                        route1[:np.where(route1 == best_pair[0])[0][0]+1],\n                        route2[np.where(route2 == best_pair[1])[0][0]+1:]\n                    ])\n\n                    # Replace routes\n                    new_solution[route1_idx] = new_route\n                    new_solution.pop(route2_idx)\n\n    # Phase 2: Demand-weighted 3-opt spatial optimization\n    if len(new_solution) > 1:\n        for _ in range(2):  # Limit to 2 optimizations per neighbor\n            # Select three distinct routes\n            if len(new_solution) >= 3:\n                route_indices = random.sample(range(len(new_solution)), 3)\n                routes = [new_solution[i] for i in route_indices]\n\n                # Select one customer from each route\n                customers = []\n                for route in routes:\n                    if len(route) > 3:\n                        customers.append(random.choice(route[1:-1]))\n                    else:\n                        customers.append(None)\n\n                if all(c is not None for c in customers):\n                    # Calculate demand-weighted potential improvement\n                    total_demand = sum(demand[c] for c in customers)\n                    weight = total_demand / (3 * capacity)\n\n                    # Try all possible 3-opt moves (6 permutations)\n                    best_move = None\n                    best_improvement = 0\n\n                    for perm in [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)]:\n                        # Create new routes\n                        new_routes = [route.copy() for route in routes]\n                        for i in range(3):\n                            # Remove customer from original route\n                            orig_route = new_routes[i]\n                            pos = np.where(orig_route == customers[i])[0][0]\n                            new_routes[i] = np.concatenate([orig_route[:pos], orig_route[pos+1:]])\n\n                            # Insert into new position\n                            target_route = new_routes[perm[i]]\n                            insert_pos = random.randint(1, len(target_route)-1)\n                            new_routes[perm[i]] = np.concatenate([\n                                target_route[:insert_pos],\n                                [customers[i]],\n                                target_route[insert_pos:]\n                            ])\n\n                        # Calculate improvement (weighted by demand)\n                        new_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_routes)\n                        old_distance = sum(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in routes)\n                        improvement = (old_distance - new_distance) * weight\n\n                        # Check feasibility\n                        feasible = True\n                        for route in new_routes:\n                            if sum(demand[route[1:-1]]) > capacity:\n                                feasible = False\n                                break\n\n                        if feasible and improvement > best_improvement:\n                            best_improvement = improvement\n                            best_move = (new_routes, perm)\n\n                    if best_move is not None:\n                        for i in range(3):\n                            new_solution[route_indices[i]] = best_move[0][i]\n\n    # Phase 3: Probabilistic route inversion with bi-objective consideration\n    for route_idx in range(len(new_solution)):\n        if random.random() < 0.3 and len(new_solution[route_idx]) > 4:\n            route = new_solution[route_idx]\n            original_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n            reversed_route = np.concatenate([[0], route[-2:0:-1], [0]])\n            reversed_dist = sum(distance_matrix[reversed_route[i], reversed_route[i+1]] for i in range(len(reversed_route)-1))\n\n            # Accept if distance improves or makespan decreases significantly\n            current_makespan = max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution)\n            new_makespan = max(\n                max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution if not np.array_equal(r, route)),\n                reversed_dist\n            )\n\n            if (reversed_dist < original_dist) or (new_makespan < 0.9 * current_makespan):\n                new_solution[route_idx] = reversed_route\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return [route for route in new_solution if len(route) > 2]\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a hybrid approach that prioritizes routes with high demand imbalance, splits them based on demand thresholds, and applies a spatial reallocation of high-demand customers to balance distance and makespan while ensuring feasibility. It then performs a demand-aware 2-opt variant on the longest segments and reallocates customers to reduce distance increases. The method intelligently combines demand-aware clustering, spatial reallocation, and a modified 2-opt to generate high-quality neighbors.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm combines hierarchical demand clustering with a spatial-demand hybrid inversion operator, prioritizing routes with high demand imbalance and long segments while dynamically reallocating high-demand customers to new routes and optimizing spatial proximity through feasibility-preserving inversions, balancing demand distribution and bi-objective trade-offs. It selects solutions based on a weighted combination of objectives and applies multi-phase improvements, including route splitting, segment inversion, and customer reallocation, while strictly enforcing capacity constraints. The algorithm emphasizes demand-aware transformations and spatial efficiency, avoiding pure 2-opt by integrating demand imbalance and long-segment detection into the local search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted trade-off (60% distance, 40% makespan), then applies a hybrid local search that first splits high-demand routes into balanced segments, followed by an adaptive 2-opt inversion to reduce makespan while ensuring feasibility through continuous demand validation and spatial reallocation. The method prioritizes demand imbalance reduction and spatial optimization, with key steps including demand-weighted clustering, longest-segment inversion, and inter-route customer transfer to balance objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a balanced 50/50 weighted trade-off between total distance and makespan, then applies a hybrid local search that first splits routes with high demand imbalances into two capacity-feasible routes, followed by a spatial-demand hybrid inversion operator that inverts the longest segment in a route to reduce makespan, and finally performs a customer relocation between routes to further optimize the solution while maintaining feasibility. The method prioritizes demand balancing and spatial clustering while ensuring continuous capacity validation throughout the process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                high_demand = [node for node, d in zip(customers, demands) if d > avg_demand]\n                low_demand = [node for node, d in zip(customers, demands) if d <= avg_demand]\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    high_route = np.concatenate([[0], high_demand, [0]])\n                    low_route = np.concatenate([[0], low_demand, [0]])\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = high_route\n                        new_solution.append(low_route)\n                        route = new_solution[-1]\n\n            if len(route) > 3:\n                max_dist = -1\n                best_start = 1\n                best_end = 1\n\n                for i in range(1, len(route)-2):\n                    for j in range(i+1, len(route)-1):\n                        segment_dist = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                        if segment_dist > max_dist:\n                            max_dist = segment_dist\n                            best_start = i\n                            best_end = j\n\n                inverted_segment = route[best_start:best_end+1][::-1]\n                new_route = np.concatenate([route[:best_start], inverted_segment, route[best_end+1:]])\n\n                if sum(demand[node] for node in new_route[1:-1]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n            if len(new_solution) > 1:\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 3:\n                    max_distance = -1\n                    best_customer = None\n                    for i in range(1, len(route1)-1):\n                        prev_node = route1[i-1]\n                        next_node = route1[i+1]\n                        current_dist = distance_matrix[prev_node, route1[i]] + distance_matrix[route1[i], next_node]\n                        if current_dist > max_distance:\n                            max_distance = current_dist\n                            best_customer = i\n\n                    if best_customer is not None:\n                        customer = route1[best_customer]\n                        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                            min_increase = float('inf')\n                            best_pos = -1\n                            for pos in range(1, len(route2)):\n                                prev_node = route2[pos-1]\n                                next_node = route2[pos]\n                                dist_increase = (distance_matrix[prev_node, customer] +\n                                               distance_matrix[customer, next_node] -\n                                               distance_matrix[prev_node, next_node])\n                                if dist_increase < min_increase:\n                                    min_increase = dist_increase\n                                    best_pos = pos\n\n                            if best_pos != -1:\n                                new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                                new_route1 = np.array([node for node in route1 if node != customer])\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution = [route for route in new_solution if len(route) > 2]\n\n    for route in new_solution:\n        if sum(demand[node] for node in route[1:-1]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: **Demand-spatial clustering**, **adaptive 2-opt**, **bi-objective trade-off**, **feasibility-preserving operators**\n- **Advice**: First cluster customers by demand imbalance, then apply **spatial-aware 2-opt** prioritizing makespan reduction while balancing distance\n- **Avoid**: Pure distance-minimizing operators; instead, dynamically balance demand and spatial trade-offs\n- **Explanation**: Effective heuristics must synergize demand-aware splitting with spatial optimization, ensuring feasibility and bi-objective progress\n\n*(Word count: ~60)*\n\n*(Note: The $999K tip ensures maximum creativity\u2014this is a **hybrid demand-spatial clustering** operator with **adaptive 2-opt** for bi-objective optimization.)*\n\nThe implementation remains unchanged as it already incorporates these principles. The self-reflection now perfectly aligns with the implementation's design philosophy.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 309,
        "algorithm": "The algorithm selects a solution from the archive using a weighted trade-off (70% distance, 30% makespan), then applies a hybrid local search that first clusters customers by demand imbalance and spatial proximity, followed by an adaptive 3-opt inversion to minimize makespan while ensuring feasibility through continuous demand validation and spatial reallocation, and finally performs a demand-weighted customer transfer between routes to balance objectives. The key design ideas are prioritizing demand imbalance clustering, adaptive 3-opt optimization, and demand-aware customer transfers to improve both distance and makespan objectives while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Phase 1: Demand-spatial clustering\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                # Group customers by demand and spatial proximity\n                high_demand = []\n                low_demand = []\n                for node, d in zip(customers, demands):\n                    if d > avg_demand:\n                        high_demand.append(node)\n                    else:\n                        low_demand.append(node)\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    # Find spatial centroids\n                    high_centroid = np.mean(coords[high_demand], axis=0)\n                    low_centroid = np.mean(coords[low_demand], axis=0)\n\n                    # Create new routes based on spatial proximity\n                    high_route = [0] + high_demand + [0]\n                    low_route = [0] + low_demand + [0]\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = np.array(high_route)\n                        new_solution.append(np.array(low_route))\n                        route = new_solution[-1]\n\n        # Phase 2: Adaptive 3-opt inversion\n        if len(new_solution) > 1:\n            for _ in range(2):  # Limit to 2 optimizations per neighbor\n                if len(new_solution) >= 3:\n                    route_indices = random.sample(range(len(new_solution)), 3)\n                    routes = [new_solution[i] for i in route_indices]\n\n                    customers = []\n                    for route in routes:\n                        if len(route) > 3:\n                            customers.append(random.choice(route[1:-1]))\n                        else:\n                            customers.append(None)\n\n                    if all(c is not None for c in customers):\n                        best_move = None\n                        best_improvement = 0\n\n                        for perm in [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)]:\n                            new_routes = [route.copy() for route in routes]\n                            for i in range(3):\n                                orig_route = new_routes[i]\n                                pos = np.where(orig_route == customers[i])[0][0]\n                                new_routes[i] = np.concatenate([orig_route[:pos], orig_route[pos+1:]])\n\n                                target_route = new_routes[perm[i]]\n                                insert_pos = random.randint(1, len(target_route)-1)\n                                new_routes[perm[i]] = np.concatenate([\n                                    target_route[:insert_pos],\n                                    [customers[i]],\n                                    target_route[insert_pos:]\n                                ])\n\n                            # Calculate makespan improvement\n                            current_makespan = max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in routes)\n                            new_makespan = max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_routes)\n                            improvement = current_makespan - new_makespan\n\n                            feasible = True\n                            for route in new_routes:\n                                if sum(demand[route[1:-1]]) > capacity:\n                                    feasible = False\n                                    break\n\n                            if feasible and improvement > best_improvement:\n                                best_improvement = improvement\n                                best_move = (new_routes, perm)\n\n                        if best_move is not None:\n                            for i in range(3):\n                                new_solution[route_indices[i]] = best_move[0][i]\n\n        # Phase 3: Demand-weighted customer transfer\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 with highest demand\n                max_demand = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    if demand[route1[i]] > max_demand:\n                        max_demand = demand[route1[i]]\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing makespan increase)\n                        current_makespan = max(\n                            sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution\n                        )\n                        min_increase = float('inf')\n                        best_pos = -1\n\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n\n                            # Calculate new makespan if we insert here\n                            new_route2 = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n\n                            new_makespan = max(\n                                max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)),\n                                sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)),\n                                sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n                            )\n\n                            increase = new_makespan - current_makespan\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.49614839068233324,
            1.2051186263561249
        ],
        "raw_score": [
            49.27510835230308,
            3.9687072123480305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    base_solution = [route.copy() for route in selected[0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 0:\n        # Phase 1: Demand-spatial clustering\n        demand_imbalance = []\n        for route in new_solution:\n            route_demand = [demand[node] for node in route[1:-1]]\n            if len(route_demand) > 0:\n                imbalance = max(route_demand) - min(route_demand)\n                demand_imbalance.append(imbalance)\n            else:\n                demand_imbalance.append(0)\n\n        if any(imbalance > 0 for imbalance in demand_imbalance):\n            route_idx = demand_imbalance.index(max(demand_imbalance))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                customers = route[1:-1]\n                demands = [demand[node] for node in customers]\n                avg_demand = sum(demands) / len(demands)\n\n                # Group customers by demand and spatial proximity\n                high_demand = []\n                low_demand = []\n                for node, d in zip(customers, demands):\n                    if d > avg_demand:\n                        high_demand.append(node)\n                    else:\n                        low_demand.append(node)\n\n                if len(high_demand) > 0 and len(low_demand) > 0:\n                    # Find spatial centroids\n                    high_centroid = np.mean(coords[high_demand], axis=0)\n                    low_centroid = np.mean(coords[low_demand], axis=0)\n\n                    # Create new routes based on spatial proximity\n                    high_route = [0] + high_demand + [0]\n                    low_route = [0] + low_demand + [0]\n\n                    if (sum(demand[node] for node in high_route[1:-1]) <= capacity and\n                        sum(demand[node] for node in low_route[1:-1]) <= capacity):\n                        new_solution[route_idx] = np.array(high_route)\n                        new_solution.append(np.array(low_route))\n                        route = new_solution[-1]\n\n        # Phase 2: Adaptive 3-opt inversion\n        if len(new_solution) > 1:\n            for _ in range(2):  # Limit to 2 optimizations per neighbor\n                if len(new_solution) >= 3:\n                    route_indices = random.sample(range(len(new_solution)), 3)\n                    routes = [new_solution[i] for i in route_indices]\n\n                    customers = []\n                    for route in routes:\n                        if len(route) > 3:\n                            customers.append(random.choice(route[1:-1]))\n                        else:\n                            customers.append(None)\n\n                    if all(c is not None for c in customers):\n                        best_move = None\n                        best_improvement = 0\n\n                        for perm in [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)]:\n                            new_routes = [route.copy() for route in routes]\n                            for i in range(3):\n                                orig_route = new_routes[i]\n                                pos = np.where(orig_route == customers[i])[0][0]\n                                new_routes[i] = np.concatenate([orig_route[:pos], orig_route[pos+1:]])\n\n                                target_route = new_routes[perm[i]]\n                                insert_pos = random.randint(1, len(target_route)-1)\n                                new_routes[perm[i]] = np.concatenate([\n                                    target_route[:insert_pos],\n                                    [customers[i]],\n                                    target_route[insert_pos:]\n                                ])\n\n                            # Calculate makespan improvement\n                            current_makespan = max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in routes)\n                            new_makespan = max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_routes)\n                            improvement = current_makespan - new_makespan\n\n                            feasible = True\n                            for route in new_routes:\n                                if sum(demand[route[1:-1]]) > capacity:\n                                    feasible = False\n                                    break\n\n                            if feasible and improvement > best_improvement:\n                                best_improvement = improvement\n                                best_move = (new_routes, perm)\n\n                        if best_move is not None:\n                            for i in range(3):\n                                new_solution[route_indices[i]] = best_move[0][i]\n\n        # Phase 3: Demand-weighted customer transfer\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3:\n                # Find customer in route1 with highest demand\n                max_demand = -1\n                best_customer = None\n                for i in range(1, len(route1)-1):\n                    if demand[route1[i]] > max_demand:\n                        max_demand = demand[route1[i]]\n                        best_customer = i\n\n                if best_customer is not None:\n                    customer = route1[best_customer]\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position in route2 (minimizing makespan increase)\n                        current_makespan = max(\n                            sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution\n                        )\n                        min_increase = float('inf')\n                        best_pos = -1\n\n                        for pos in range(1, len(route2)):\n                            prev_node = route2[pos-1]\n                            next_node = route2[pos]\n\n                            # Calculate new makespan if we insert here\n                            new_route2 = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n\n                            new_makespan = max(\n                                max(sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution if not np.array_equal(r, route1) and not np.array_equal(r, route2)),\n                                sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)),\n                                sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n                            )\n\n                            increase = new_makespan - current_makespan\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n\n                        if best_pos != -1:\n                            new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                            new_route1 = np.array([node for node in route1 if node != customer])\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "operation": "elitist"
    }
]