[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-stage hybrid local search that prioritizes balanced solutions (70% distance, 30% makespan) and applies demand-aware route fragmentation, route reversal, customer reallocation with demand pattern matching, and route merging operations iteratively to improve solutions while maintaining feasibility. It intelligently targets customers with similar demand patterns and routes with complementary load characteristics to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.7 + weights[:, 1] * 0.3\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(6):  # Perform 6 iterations of the hybrid operator\n        # Stage 1: Demand-aware route fragmentation\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find split point that balances demand\n                total_demand = np.sum(demand[route[1:-1]])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Route reversal with capacity check\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Customer reallocation with demand pattern matching\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customers with similar demand patterns\n                route_demand = demand[route[1:-1]]\n                median_demand = np.median(route_demand)\n                similar_customers = [i for i, d in enumerate(route_demand)\n                                   if abs(d - median_demand) <= median_demand * 0.3]\n\n                if similar_customers:\n                    customer_pos = random.choice(similar_customers) + 1\n                    customer = route[customer_pos]\n\n                    # Find best route to insert based on demand compatibility\n                    best_route_idx = -1\n                    best_pos = -1\n                    min_demand_diff = float('inf')\n\n                    for other_idx, other_route in enumerate(new_solution):\n                        if other_idx == route_idx:\n                            continue\n\n                        other_demand = np.sum(demand[other_route[1:-1]])\n                        if other_demand + demand[customer] > capacity:\n                            continue\n\n                        for pos in range(1, len(other_route)):\n                            new_demand = other_demand + demand[customer]\n                            demand_diff = abs(new_demand - capacity/2)\n\n                            if demand_diff < min_demand_diff:\n                                min_demand_diff = demand_diff\n                                best_route_idx = other_idx\n                                best_pos = pos\n\n                    if best_route_idx != -1:\n                        other_route = new_solution[best_route_idx]\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            [customer],\n                            other_route[best_pos:]\n                        ])\n                        new_solution[best_route_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n        # Stage 4: Route merging with load balancing\n        if len(new_solution) > 1:\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 25):\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8703280146268155,
            1.1190491020679474
        ]
    },
    {
        "algorithm": "This algorithm implements a multi-stage hybrid local search for the Bi-CVRP, prioritizing balanced solutions (60% distance, 40% makespan) and applying adaptive route segmentation, demand-aware customer insertion, route reversal with capacity optimization, and intelligent route merging with load balancing. It uses dynamic programming for optimal split points and reversal segments, while maintaining feasibility through capacity checks and demand pattern analysis. The algorithm iteratively refines solutions through 8 stages of transformations, focusing on both distance minimization and makespan reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search with 8 iterations\n    for _ in range(8):\n        # Stage 1: Adaptive route segmentation with demand optimization\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal split point using dynamic programming\n                demands = demand[route[1:-1]]\n                n = len(demands)\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                split_pos = 1\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demands[j-1]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[split_pos]:\n                        split_pos = i\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Demand-aware customer insertion\n        if len(new_solution) > 0:\n            # Select customer from route with highest demand variance\n            route_idx = np.argmax([np.std(demand[route[1:-1]]) for route in new_solution])\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with demand closest to average\n                route_demand = demand[route[1:-1]]\n                avg_demand = np.mean(route_demand)\n                closest_customer = np.argmin(np.abs(route_demand - avg_demand)) + 1\n                customer = route[closest_customer]\n\n                # Find best insertion point in another route\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion score based on distance and demand balance\n                        insert_dist = (distance_matrix[other_route[pos-1]][customer] +\n                                      distance_matrix[customer][other_route[pos]] -\n                                      distance_matrix[other_route[pos-1]][other_route[pos]])\n                        new_demand = other_demand + demand[customer]\n                        demand_score = abs(new_demand - capacity/2)\n\n                        total_score = insert_dist * 0.7 + demand_score * 0.3\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:closest_customer], route[closest_customer+1:]])\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Route reversal with capacity optimization\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal reversal segment using dynamic programming\n                n = len(route) - 2\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                best_i, best_j = 1, 2\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demand[route[j]]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[best_i]:\n                        best_i, best_j = i, j\n\n                reversed_segment = route[best_i:best_j+1][::-1]\n                new_route = np.concatenate([route[:best_i], reversed_segment, route[best_j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 4: Intelligent route merging with load balancing\n        if len(new_solution) > 1:\n            # Find pair of routes with most complementary demand patterns\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    demand_i = np.sum(demand[new_solution[i][1:-1]])\n                    demand_j = np.sum(demand[new_solution[j][1:-1]])\n                    if demand_i + demand_j <= capacity:\n                        score = abs(demand_i + demand_j - capacity/2)\n                        if score < best_score:\n                            best_score = score\n                            best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Try both possible merge directions\n                merged1 = np.concatenate([route1[:-1], route2[1:]])\n                merged2 = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merge direction that better balances demands\n                demand1 = np.sum(demand[merged1[1:-1]])\n                demand2 = np.sum(demand[merged2[1:-1]])\n                score1 = abs(demand1 - capacity/2)\n                score2 = abs(demand2 - capacity/2)\n\n                if score1 <= score2 and len(merged1) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged1)\n                elif len(merged2) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged2)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.915810040703673,
            8.590130120515823
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection (prioritizing lower makespan and total distance), then applies a hybrid local search combining route splitting (to reduce makespan) and node reinsertion (to improve total distance), ensuring feasibility by checking vehicle capacity constraints at each step. The method intelligently balances both objectives by iteratively refining the solution through these targeted operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = []\n    for sol, obj in archive:\n        # Higher weight for solutions with lower makespan or total distance\n        weight = 1 / (obj[1] + obj[0] + 1e-6)  # Avoid division by zero\n        weights.append(weight)\n\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + node reinsertion\n    # Step 1: Try to split a route into two if it's too long (makespan reduction)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find a split point that minimizes the increase in total distance\n        best_split = None\n        min_increase = float('inf')\n        for j in range(1, len(route)-1):\n            # Split after node j\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[first_part[1:-1]]) > capacity) or (np.sum(demand[second_part[1:-1]]) > capacity):\n                continue\n\n            # Calculate increase in total distance\n            increase = (distance_matrix[route[j], 0] + distance_matrix[0, route[j+1]]) - distance_matrix[route[j], route[j+1]]\n            if increase < min_increase:\n                min_increase = increase\n                best_split = j\n\n        if best_split is not None:\n            j = best_split\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n            new_solution[i] = first_part\n            new_solution.append(second_part)\n            break  # Only split one route per iteration\n\n    # Step 2: Try to reinsert a node from a route to another to improve total distance\n    for _ in range(2):  # Try a few reinsertions\n        if len(new_solution) < 2:\n            break\n\n        # Select a random route to take a node from\n        from_route_idx = random.randint(0, len(new_solution)-1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) <= 3:  # Skip trivial routes\n            continue\n\n        # Select a random node to move (not depot)\n        node_pos = random.randint(1, len(from_route)-2)\n        node = from_route[node_pos]\n\n        # Try to insert into another route\n        best_insertion = None\n        min_increase = float('inf')\n        for to_route_idx in range(len(new_solution)):\n            if to_route_idx == from_route_idx:\n                continue\n\n            to_route = new_solution[to_route_idx]\n            # Check capacity constraint\n            if np.sum(demand[to_route[1:-1]]) + demand[node] > capacity:\n                continue\n\n            # Try inserting after each node in the to_route\n            for pos in range(len(to_route)-1):\n                # Insert after to_route[pos]\n                # Calculate increase in distance\n                increase = (distance_matrix[to_route[pos], node] +\n                           distance_matrix[node, to_route[pos+1]] -\n                           distance_matrix[to_route[pos], to_route[pos+1]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_insertion = (to_route_idx, pos, node)\n\n        if best_insertion is not None:\n            to_route_idx, pos, node = best_insertion\n            # Remove from original route\n            new_solution[from_route_idx] = np.delete(new_solution[from_route_idx], node_pos)\n            # Insert into new route\n            new_solution[to_route_idx] = np.insert(new_solution[to_route_idx], pos+1, node)\n\n            # If route becomes empty, remove it\n            if len(new_solution[from_route_idx]) == 2:  # Only depot-depot\n                new_solution.pop(from_route_idx)\n            break  # Only one reinsertion per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.74727416385559,
            0.26535162329673767
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized distance and makespan (60% distance, 40% makespan), then applies a hybrid local search combining route fragmentation, customer reallocation, and route merging. It iteratively fragments long routes, reallocates customers between routes with capacity checks, and merges small routes while limiting route length to 20 nodes. The solution is refined through 5 iterations and finally normalized to remove empty routes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + customer reallocation + route merging\n    for _ in range(5):  # Perform 5 iterations\n        # Randomly select a route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Fragment route at random point\n        split_pos = random.randint(2, len(route) - 2)\n        fragment = route[split_pos:]\n        remaining = route[:split_pos]\n\n        # Check capacity feasibility for fragments\n        if np.sum(demand[fragment[1:-1]]) <= capacity and np.sum(demand[remaining[1:-1]]) <= capacity:\n            new_solution[route_idx] = remaining\n            new_solution.append(fragment)\n\n        # Customer reallocation: move customers between routes\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select customers to move (up to 2)\n            customers_to_move = random.sample(range(1, len(route) - 1), min(2, len(route) - 2))\n\n            for customer_pos in sorted(customers_to_move, reverse=True):\n                customer = route[customer_pos]\n\n                # Find best insertion position in other route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                   distance_matrix[customer, other_route[pos]] -\n                                   distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Check capacity feasibility\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into other route\n                    new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from original route\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n                    route = new_route\n\n        # Route merging: try to merge small routes\n        if len(new_solution) > 1:\n            # Select two routes to potentially merge\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            # Check if merging is feasible\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 20):  # Limit route length\n\n                # Create merged route (route1 + route2 without depot)\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Update solution\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7532898215774322,
            0.30173933506011963
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing lower makespan) and applies a hybrid local search combining route merging with probabilistic acceptance to balance distance and makespan objectives while ensuring feasibility through capacity checks. It intelligently merges routes by minimizing distance increases and occasionally accepts worse moves to escape local optima, dynamically updating the solution's objectives. The method focuses on improving both objectives through careful route combination and probabilistic exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + probabilistic acceptance\n    for _ in range(3):  # Perform 3 iterations\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes to potentially merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand > capacity:\n            continue\n\n        # Find best merge point (minimizing distance increase)\n        best_merge = None\n        min_increase = float('inf')\n\n        # Try merging route2 into route1 at different positions\n        for pos in range(1, len(route1)):\n            # Calculate distance increase\n            increase = (distance_matrix[route1[pos-1], route2[1]] +\n                       distance_matrix[route2[-2], route1[pos]] -\n                       distance_matrix[route1[pos-1], route1[pos]])\n\n            if increase < min_increase:\n                min_increase = increase\n                best_merge = (pos, increase)\n\n        if best_merge is not None:\n            pos, increase = best_merge\n\n            # Calculate new objectives\n            old_distance = archive_sorted[selected_idx][1][0]\n            old_makespan = archive_sorted[selected_idx][1][1]\n\n            new_distance = old_distance + increase\n            new_makespan = max(old_makespan - distance_matrix[route1[-2], 0],\n                              distance_matrix[route1[pos-1], route2[1]] +\n                              np.sum(distance_matrix[route2[1:-1], route2[2:]]) +\n                              distance_matrix[route2[-2], route1[pos]])\n\n            # Probabilistic acceptance\n            if (new_distance < old_distance and new_makespan <= old_makespan) or \\\n               random.random() < 0.2:  # 20% chance to accept worse move\n                # Perform the merge\n                merged_route = np.concatenate([route1[:pos], route2[1:-1], route1[pos:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n                # Update current objectives\n                old_distance = new_distance\n                old_makespan = new_makespan\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8087135813524513,
            0.8420414328575134
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage local search\n    for _ in range(4):  # Perform 4 iterations of the multi-stage operator\n        # Stage 1: Route splitting with demand-aware fragmentation\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:  # Only split if route is long enough\n                # Find split point that balances demand\n                total_demand = np.sum(demand[route[1:-1]])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Customer reallocation with demand pattern matching\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customers with similar demand patterns\n                route_demand = demand[route[1:-1]]\n                median_demand = np.median(route_demand)\n                similar_customers = [i for i, d in enumerate(route_demand)\n                                   if abs(d - median_demand) <= median_demand * 0.3]\n\n                if similar_customers:\n                    customer_pos = random.choice(similar_customers) + 1  # +1 for route index\n                    customer = route[customer_pos]\n\n                    # Find best route to insert based on demand compatibility\n                    best_route_idx = -1\n                    best_pos = -1\n                    min_demand_diff = float('inf')\n\n                    for other_idx, other_route in enumerate(new_solution):\n                        if other_idx == route_idx:\n                            continue\n\n                        other_demand = np.sum(demand[other_route[1:-1]])\n                        if other_demand + demand[customer] > capacity:\n                            continue\n\n                        for pos in range(1, len(other_route)):\n                            # Prefer positions that maintain demand balance\n                            new_demand = other_demand + demand[customer]\n                            demand_diff = abs(new_demand - capacity/2)\n\n                            if demand_diff < min_demand_diff:\n                                min_demand_diff = demand_diff\n                                best_route_idx = other_idx\n                                best_pos = pos\n\n                    if best_route_idx != -1:\n                        # Move customer to best position\n                        other_route = new_solution[best_route_idx]\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            [customer],\n                            other_route[best_pos:]\n                        ])\n                        new_solution[best_route_idx] = new_other_route\n\n                        # Remove from original route\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n        # Stage 3: Route merging with load balancing\n        if len(new_solution) > 1:\n            # Select two routes to potentially merge\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            # Check if merging is feasible and maintains balanced load\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity and len(route1) + len(route2) - 2 <= 25:  # Slightly larger route limit\n                # Create merged route\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Update solution\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.7972594454255604,
            0.6602787673473358
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-stage adaptive local search that combines route fragmentation, demand-aware reallocation, and dynamic merging, prioritizing both distance and makespan objectives through weighted selection and spatial/demand-aware operations while maintaining feasibility through capacity checks. It selects promising solutions from the archive, applies probabilistic transformations (with higher probability for fragmentation and reallocation), and includes a final diversity-maintaining perturbation. The code emphasizes balanced route utilization (preferring 60% load) and spatial proximity in customer reallocation, with conservative route splitting and merging to preserve solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + 0.3 * abs(x[1][0] - x[1][1])))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage adaptive local search\n    for _ in range(3):  # Reduced iterations for diversity\n        # Stage 1: Adaptive route fragmentation with distance-aware splitting\n        if len(new_solution) > 1 and random.random() < 0.7:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 5:  # More conservative splitting\n                # Find split point that balances distance and demand\n                total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                half_distance = total_distance / 2\n                current_distance = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_distance += distance_matrix[route[i-1], route[i]]\n                    if current_distance >= half_distance:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Demand-aware customer reallocation with spatial clustering\n        if len(new_solution) > 1 and random.random() < 0.6:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Cluster customers by spatial proximity and demand similarity\n                customers = route[1:-1]\n                if len(customers) > 0:\n                    # Select a customer from the most central cluster\n                    cluster_center = np.mean(coords[customers], axis=0)\n                    distances = np.linalg.norm(coords[customers] - cluster_center, axis=1)\n                    demand_similarity = np.abs(demand[customers] - np.mean(demand[customers]))\n\n                    # Weighted selection combining spatial and demand criteria\n                    weights = 0.7 * distances + 0.3 * demand_similarity\n                    selected_customer_idx = np.argmin(weights)\n                    customer = customers[selected_customer_idx]\n                    customer_pos = np.where(route == customer)[0][0]\n\n                    # Find best route to insert based on spatial proximity and demand fit\n                    best_route_idx = -1\n                    best_pos = -1\n                    best_score = float('inf')\n\n                    for other_idx, other_route in enumerate(new_solution):\n                        if other_idx == route_idx:\n                            continue\n\n                        other_demand = np.sum(demand[other_route[1:-1]])\n                        if other_demand + demand[customer] > capacity:\n                            continue\n\n                        # Calculate spatial proximity to last customer in other route\n                        last_customer = other_route[-2]\n                        spatial_dist = distance_matrix[last_customer, customer]\n\n                        # Calculate demand balance score\n                        new_demand = other_demand + demand[customer]\n                        demand_score = abs(new_demand - capacity * 0.6)  # Prefer 60% load\n\n                        total_score = spatial_dist * 0.5 + demand_score * 0.5\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_route_idx = other_idx\n                            best_pos = len(other_route) - 1  # Append to end\n\n                    if best_route_idx != -1:\n                        other_route = new_solution[best_route_idx]\n                        new_other_route = np.concatenate([other_route[:-1], [customer], [0]])\n                        new_solution[best_route_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n        # Stage 3: Dynamic route merging with capacity-aware movement\n        if len(new_solution) > 1 and random.random() < 0.5:\n            # Select routes based on capacity utilization and spatial proximity\n            route_utilizations = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n            sorted_indices = np.argsort(route_utilizations)\n\n            # Prefer merging underutilized routes with others\n            candidate_pairs = []\n            for i in range(len(sorted_indices)):\n                for j in range(i+1, len(sorted_indices)):\n                    if route_utilizations[sorted_indices[i]] < 0.4 and route_utilizations[sorted_indices[j]] < 0.7:\n                        candidate_pairs.append((sorted_indices[i], sorted_indices[j]))\n\n            if candidate_pairs:\n                pair = random.choice(candidate_pairs)\n                route1 = new_solution[pair[0]]\n                route2 = new_solution[pair[1]]\n\n                # Check if merging is feasible and maintains balanced load\n                total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                if total_demand <= capacity and len(route1) + len(route2) - 2 <= 20:  # More conservative\n                    # Create merged route with capacity-aware movement\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                    # Update solution\n                    new_solution = [route for i, route in enumerate(new_solution)\n                                   if i not in pair]\n                    new_solution.append(merged_route)\n\n    # Final cleanup and diversity maintenance\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Add small random perturbation to maintain diversity\n    if random.random() < 0.2 and len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            # Randomly swap two non-depot customers\n            swap_pos1, swap_pos2 = random.sample(range(1, len(route)-1), 2)\n            route[swap_pos1], route[swap_pos2] = route[swap_pos2], route[swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.7807992063115644,
            0.3419203758239746
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-stage hybrid local search that first selects a solution with high crowding distance (indicating potential for improvement), then applies demand-aware route fragmentation, load-balanced merging, and hybrid customer reallocation to improve both distance and makespan objectives while maintaining feasibility. It prioritizes routes with high demand variance or imbalance and focuses on demand compatibility during customer reallocation, balancing the trade-off between the two objectives. The algorithm emphasizes route-level operations that respect vehicle capacity constraints while seeking to reduce both total travel distance and the longest route length.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(4):  # Perform 4 iterations\n        # Stage 1: Demand-aware route fragmentation\n        if len(new_solution) > 1:\n            # Select route with highest demand variance\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            route_idx = np.argmax(demands)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find split point that balances demand\n                total_demand = np.sum(demand[route[1:-1]])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Load-balanced route merging\n        if len(new_solution) > 1:\n            # Find two routes with complementary demands\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            avg_demand = np.mean(demands)\n            candidates = []\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    if demands[i] + demands[j] <= capacity:\n                        candidates.append((i, j))\n\n            if candidates:\n                # Select pair with most balanced demands\n                best_pair = min(candidates, key=lambda p: abs(demands[p[0]] + demands[p[1]] - avg_demand))\n                route1, route2 = new_solution[best_pair[0]], new_solution[best_pair[1]]\n\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in best_pair]\n                new_solution.append(merged_route)\n\n        # Stage 3: Hybrid customer reallocation\n        if len(new_solution) > 1:\n            # Select route with highest demand\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            route_idx = np.argmax(demands)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customer with demand closest to route's average\n                route_demand = demand[route[1:-1]]\n                avg_route_demand = np.mean(route_demand)\n                customer_pos = np.argmin(np.abs(route_demand - avg_route_demand)) + 1\n                customer = route[customer_pos]\n\n                # Find best route to insert based on demand compatibility\n                best_route_idx = -1\n                best_pos = -1\n                min_demand_diff = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        new_demand = other_demand + demand[customer]\n                        demand_diff = abs(new_demand - capacity/2)\n\n                        if demand_diff < min_demand_diff:\n                            min_demand_diff = demand_diff\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.830150191120199,
            1.302865594625473
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random selection that prioritizes solutions with lower total distance (70% weight) and makespan (30% weight), then applies a hybrid local search combining route merging (to reduce makespan) and node swapping (to optimize total distance while respecting capacity constraints). The merge step checks feasibility and proximity between routes, while the swap step evaluates random node exchanges between routes to improve distance without violating capacity limits.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = []\n    for sol, obj in archive:\n        # Normalize objectives\n        total_dist = obj[0]\n        makespan = obj[1]\n        max_dist = max(o[0] for _, o in archive) + 1e-6\n        max_span = max(o[1] for _, o in archive) + 1e-6\n        # Weight based on normalized objectives (lower is better)\n        weight = 0.7 * (1 - total_dist / max_dist) + 0.3 * (1 - makespan / max_span)\n        weights.append(weight)\n\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + node swapping\n    # Step 1: Try to merge two routes if they are close in space (reduces makespan)\n    if len(new_solution) > 1:\n        # Find the two closest routes in terms of depot distance\n        min_dist = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                dist = distance_matrix[new_solution[i][-2], new_solution[j][1]]  # distance between last node of i and first node of j\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair is not None:\n            i, j = best_pair\n            # Check if merging is feasible\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Merge the routes\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Step 2: Try to swap nodes between routes to improve total distance\n    for _ in range(3):  # Try multiple swaps\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1_idx, route2_idx = route_indices\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 3 or len(route2) <= 3:  # Skip trivial routes\n            continue\n\n        # Select random nodes from each route (not depot)\n        node1_pos = random.randint(1, len(route1)-2)\n        node2_pos = random.randint(1, len(route2)-2)\n        node1 = route1[node1_pos]\n        node2 = route2[node2_pos]\n\n        # Check capacity constraints after swap\n        new_route1 = route1.copy()\n        new_route1[node1_pos] = node2\n        new_route2 = route2.copy()\n        new_route2[node2_pos] = node1\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Calculate distance change\n            old_dist = (distance_matrix[route1[node1_pos-1], node1] +\n                        distance_matrix[node1, route1[node1_pos+1]] +\n                        distance_matrix[route2[node2_pos-1], node2] +\n                        distance_matrix[node2, route2[node2_pos+1]])\n\n            new_dist = (distance_matrix[route1[node1_pos-1], node2] +\n                        distance_matrix[node2, route1[node1_pos+1]] +\n                        distance_matrix[route2[node2_pos-1], node1] +\n                        distance_matrix[node1, route2[node2_pos+1]])\n\n            if new_dist < old_dist:  # Only accept if distance improves\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.46272196370130647,
            0.4604072868824005
        ]
    }
]