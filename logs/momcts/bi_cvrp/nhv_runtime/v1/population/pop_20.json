[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-stage hybrid local search that prioritizes balanced solutions (70% distance, 30% makespan) and applies demand-aware route fragmentation, route reversal, customer reallocation with demand pattern matching, and route merging operations iteratively to improve solutions while maintaining feasibility. It intelligently targets customers with similar demand patterns and routes with complementary load characteristics to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.7 + weights[:, 1] * 0.3\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(6):  # Perform 6 iterations of the hybrid operator\n        # Stage 1: Demand-aware route fragmentation\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find split point that balances demand\n                total_demand = np.sum(demand[route[1:-1]])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Route reversal with capacity check\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Customer reallocation with demand pattern matching\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customers with similar demand patterns\n                route_demand = demand[route[1:-1]]\n                median_demand = np.median(route_demand)\n                similar_customers = [i for i, d in enumerate(route_demand)\n                                   if abs(d - median_demand) <= median_demand * 0.3]\n\n                if similar_customers:\n                    customer_pos = random.choice(similar_customers) + 1\n                    customer = route[customer_pos]\n\n                    # Find best route to insert based on demand compatibility\n                    best_route_idx = -1\n                    best_pos = -1\n                    min_demand_diff = float('inf')\n\n                    for other_idx, other_route in enumerate(new_solution):\n                        if other_idx == route_idx:\n                            continue\n\n                        other_demand = np.sum(demand[other_route[1:-1]])\n                        if other_demand + demand[customer] > capacity:\n                            continue\n\n                        for pos in range(1, len(other_route)):\n                            new_demand = other_demand + demand[customer]\n                            demand_diff = abs(new_demand - capacity/2)\n\n                            if demand_diff < min_demand_diff:\n                                min_demand_diff = demand_diff\n                                best_route_idx = other_idx\n                                best_pos = pos\n\n                    if best_route_idx != -1:\n                        other_route = new_solution[best_route_idx]\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            [customer],\n                            other_route[best_pos:]\n                        ])\n                        new_solution[best_route_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n        # Stage 4: Route merging with load balancing\n        if len(new_solution) > 1:\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 25):\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8703280146268155,
            1.1190491020679474
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects solutions from the archive using non-linear weighted objectives, applying a hybrid local search that combines adaptive route fragmentation (balancing demand and distance), demand-sensitive customer reallocation, probabilistic route merging (with capacity-aware criteria), and an adaptive customer exchange operator (prioritizing distance and demand balance). It emphasizes extreme solutions through exponential weighting and adjusts operator probabilities based on solution characteristics.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    # Normalize with non-linear scaling\n    norm_dist = (distances - min_dist) / (max_dist - min_dist + 1e-6)\n    norm_makespan = (makespans - min_makespan) / (max_makespan - min_makespan + 1e-6)\n\n    # Exponential weighting to emphasize extreme solutions\n    weight_dist = np.exp(-norm_dist * 0.5)\n    weight_makespan = np.exp(-norm_makespan * 0.5)\n\n    # Combine with adaptive focus\n    scores = weight_dist * norm_dist + weight_makespan * norm_makespan\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with adaptive operators\n    for _ in range(4):  # Increased iterations for better exploration\n        # Adaptive route fragmentation based on demand and distance\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:  # Only split if route is long enough\n                total_demand = np.sum(demand[route[1:-1]])\n                route_distance = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n\n                # Find split position that balances both demand and distance\n                best_split = 1\n                best_balance = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_demand = np.sum(demand[route[1:i+1]])\n                    current_dist = sum(distance_matrix[route[j-1], route[j]] for j in range(1, i+1))\n\n                    # Balance score combines demand and distance balance\n                    balance_score = abs((current_demand / total_demand) - 0.5) + \\\n                                  abs((current_dist / route_distance) - 0.5)\n\n                    if balance_score < best_balance:\n                        best_balance = balance_score\n                        best_split = i\n\n                fragment = route[best_split:]\n                remaining = route[:best_split+1]\n\n                if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                    np.sum(demand[remaining[1:-1]]) <= capacity):\n                    new_solution[route_idx] = remaining\n                    new_solution.append(fragment)\n\n        # Demand-sensitive customer reallocation\n        if len(new_solution) > 1:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customers based on demand and distance to depot\n                customers = sorted(range(1, len(source_route)-1),\n                                key=lambda x: demand[source_route[x]] * distance_matrix[0, source_route[x]],\n                                reverse=True)\n\n                num_to_move = min(3, len(customers))  # Move up to 3 customers\n\n                for customer_pos in customers[:num_to_move]:\n                    customer = source_route[customer_pos]\n\n                    # Find best insertion considering both distance and demand impact\n                    best_pos = 1\n                    best_score = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        dist_increase = (distance_matrix[target_route[pos-1], customer] +\n                                       distance_matrix[customer, target_route[pos]] -\n                                       distance_matrix[target_route[pos-1], target_route[pos]])\n\n                        # Demand impact score considers both current and potential demand\n                        current_demand = np.sum(demand[target_route[1:-1]])\n                        new_demand = current_demand + demand[customer]\n\n                        demand_score = abs(new_demand - capacity/2)  # Prefer medium demand routes\n\n                        # Distance to depot factor\n                        depot_dist_factor = distance_matrix[0, customer] / np.max(distance_matrix[0, :])\n\n                        total_score = dist_increase + 0.4 * demand_score + 0.3 * depot_dist_factor\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_pos = pos\n\n                    if (np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                        len(target_route) + 1 <= 25):  # Increased route length limit\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:customer_pos],\n                                                         source_route[customer_pos+1:]])\n                        new_solution[source_idx] = new_source_route\n\n        # Capacity-aware route merging\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            length1 = len(route1)\n            length2 = len(route2)\n\n            # More aggressive merging probability based on capacity utilization\n            merge_prob = min(0.9, 0.3 + 0.6 * (1 - abs(demand1 - demand2) / (total_demand + 1e-6)) +\n                           0.4 * (25 - (length1 + length2 - 2)) / 25)\n\n            if random.random() < merge_prob and total_demand <= capacity:\n                # Consider both direct and reverse merging\n                direct_merged = np.concatenate([route1[:-1], route2[1:]])\n                reverse_merged = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merging option with better distance\n                direct_dist = sum(distance_matrix[direct_merged[i-1], direct_merged[i]] for i in range(1, len(direct_merged)))\n                reverse_dist = sum(distance_matrix[reverse_merged[i-1], reverse_merged[i]] for i in range(1, len(reverse_merged)))\n\n                merged_route = direct_merged if direct_dist <= reverse_dist else reverse_merged\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    # Adaptive customer exchange operator\n    if len(new_solution) > 1 and random.random() < 0.4:  # Increased probability\n        swap_routes = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[swap_routes[0]], new_solution[swap_routes[1]]\n\n        # Consider multiple swap positions\n        best_swaps = []\n        best_score = float('inf')\n\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Calculate potential demand changes\n                new_demand1 = (np.sum(demand[route1[1:i]]) + demand[route2[j]] +\n                              np.sum(demand[route1[i+1:-1]]))\n                new_demand2 = (np.sum(demand[route2[1:j]]) + demand[route1[i]] +\n                              np.sum(demand[route2[j+1:-1]]))\n\n                if new_demand1 > capacity or new_demand2 > capacity:\n                    continue\n\n                # Calculate distance change\n                dist_change = (\n                    distance_matrix[route1[i-1], route2[j]] +\n                    distance_matrix[route2[j], route1[i+1]] -\n                    distance_matrix[route1[i-1], route1[i]] -\n                    distance_matrix[route1[i], route1[i+1]] +\n                    distance_matrix[route2[j-1], route1[i]] +\n                    distance_matrix[route1[i], route2[j+1]] -\n                    distance_matrix[route2[j-1], route2[j]] -\n                    distance_matrix[route2[j], route2[j+1]]\n                )\n\n                # Consider both demand balance and distance to depot\n                demand_balance = abs(new_demand1 - new_demand2)\n                depot_dist_factor = (distance_matrix[0, route1[i]] + distance_matrix[0, route2[j]]) / 2\n\n                total_score = dist_change + 0.4 * demand_balance + 0.2 * depot_dist_factor\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_swaps = [(i, j)]\n                elif total_score == best_score:\n                    best_swaps.append((i, j))\n\n        if best_swaps:\n            i, j = random.choice(best_swaps)\n            # Perform the swap\n            route1[i], route2[j] = route2[j], route1[i]\n            new_solution[swap_routes[0]] = route1\n            new_solution[swap_routes[1]] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.9282340368599087,
            1.7632462084293365
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from an archive using a hybrid of fitness sharing and dominance ranking, then applies a demand-aware route balancing operator that prioritizes spatial clustering (60%) over demand complementarity (40%) while ensuring capacity feasibility. It alternates between spatial imbalance reduction via route splitting and demand-based merging with spatial constraints, iteratively improving both distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) < 2:\n        base_solution = archive[0][0].copy()\n    else:\n        # Hybrid selection using fitness sharing and dominance ranking\n        archive_sorted_dist = sorted(archive, key=lambda x: x[1][0])\n        archive_sorted_make = sorted(archive, key=lambda x: x[1][1])\n\n        # Calculate dominance ranks\n        dominance = {}\n        for i, (sol, obj) in enumerate(archive):\n            rank = sum(1 for j in range(len(archive)) if archive_sorted_dist[j][1][0] < obj[0] and archive_sorted_make[j][1][1] < obj[1])\n            dominance[i] = rank\n\n        # Calculate shared fitness\n        shared_fitness = {}\n        for i, (sol, obj) in enumerate(archive):\n            distance = 0\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i == j:\n                    continue\n                euclidean_dist = np.sqrt((obj[0] - obj_j[0])**2 + (obj[1] - obj_j[1])**2)\n                if euclidean_dist < 1.0:  # Sharing radius\n                    distance += 1 - euclidean_dist\n            shared_fitness[i] = 1 / (1 + distance)\n\n        # Select based on combined score\n        selection_scores = {}\n        for i in range(len(archive)):\n            selection_scores[i] = shared_fitness[i] / (1 + dominance[i])\n\n        selected_idx = max(selection_scores.keys(), key=lambda k: selection_scores[k])\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Spatial clustering balancing\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find route with most spatial imbalance\n        route_centers = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else np.zeros(2) for route in new_solution]\n        overall_center = np.mean(np.concatenate([coords[route[1:-1]] for route in new_solution]), axis=0) if any(len(route) > 2 for route in new_solution) else np.zeros(2)\n        imbalance_scores = [np.linalg.norm(center - overall_center) for center in route_centers]\n        most_imbalanced_idx = max(range(len(new_solution)), key=lambda i: imbalance_scores[i])\n\n        # Find split point that balances spatial distribution\n        route = new_solution[most_imbalanced_idx]\n        if len(route) <= 3:\n            continue\n\n        # Calculate spatial balance score for each possible split\n        best_split = None\n        best_score = float('inf')\n\n        for split_pos in range(1, len(route)-1):\n            left_route = route[:split_pos+1]\n            right_route = np.concatenate([[0], route[split_pos:], [0]])\n\n            left_center = np.mean(coords[left_route[1:-1]], axis=0) if len(left_route) > 2 else np.zeros(2)\n            right_center = np.mean(coords[right_route[1:-1]], axis=0) if len(right_route) > 2 else np.zeros(2)\n\n            left_score = np.linalg.norm(left_center - overall_center)\n            right_score = np.linalg.norm(right_center - overall_center)\n            score = abs(left_score - right_score)\n\n            if score < best_score and np.sum(demand[left_route[1:-1]]) <= capacity and np.sum(demand[right_route[1:-1]]) <= capacity:\n                best_score = score\n                best_split = split_pos\n\n        if best_split is not None:\n            left_route = route[:best_split+1]\n            right_route = np.concatenate([[0], route[best_split:], [0]])\n            new_solution[most_imbalanced_idx] = left_route\n            new_solution.append(right_route)\n\n    # Demand-aware merging with spatial constraints\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        route_centers = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else np.zeros(2) for route in new_solution]\n\n        best_merge = None\n        best_score = -float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                combined_demand = route_demands[i] + route_demands[j]\n                if combined_demand > capacity:\n                    continue\n\n                # Calculate weighted score: spatial proximity + demand complementarity\n                spatial_score = 1 / (1 + np.linalg.norm(route_centers[i] - route_centers[j]))\n                demand_score = (capacity - abs(capacity - combined_demand)) / capacity\n                score = 0.6 * spatial_score + 0.4 * demand_score\n\n                if score > best_score:\n                    best_score = score\n                    best_merge = (i, j)\n\n        if best_merge is not None:\n            i, j = best_merge\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution.append(merged_route)\n                del new_solution[max(i, j)]\n                del new_solution[min(i, j)]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8810906431484877,
            1.3028977513313293
        ]
    },
    {
        "algorithm": "The algorithm combines crowding-distance-based solution selection with a multi-stage hybrid local search that prioritizes demand-complementary route splitting, capacity-aware route consolidation, and probabilistic demand-balanced customer reallocation. It explicitly balances trade-offs between total distance and makespan optimization by selecting solutions with high crowding distances and applying demand-aware transformations to improve solution quality while maintaining feasibility. The approach emphasizes capacity utilization and demand balance through probabilistic operators and complementary demand-based route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    # Normalize objectives\n    norm_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances))\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans))\n\n    # Calculate crowding distances\n    sorted_idx = np.argsort(norm_dist)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_makespan[sorted_idx[i+1]] - norm_makespan[sorted_idx[i-1]]\n\n    sorted_idx = np.argsort(norm_makespan)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_dist[sorted_idx[i+1]] - norm_dist[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(3):\n        # Stage 1: Demand-complementary route splitting\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                # Find customer with demand most complementary to route's average demand\n                route_demand = np.sum(demand[route[1:-1]])\n                avg_demand = route_demand / (len(route) - 2)\n                best_split = None\n                best_diff = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_diff = abs(demand[route[i]] - avg_demand)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_split = i\n\n                if best_split:\n                    split_pos = best_split\n                    fragment = route[split_pos:]\n                    remaining = route[:split_pos+1]\n\n                    if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                        np.sum(demand[remaining[1:-1]]) <= capacity):\n                        new_solution[route_idx] = remaining\n                        new_solution.append(fragment)\n\n        # Stage 2: Capacity-aware route consolidation\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            remaining_cap1 = capacity - demand1\n            remaining_cap2 = capacity - demand2\n\n            # Probability of merging based on capacity complementarity\n            merge_prob = 0.5 * (1 - abs(remaining_cap1 - remaining_cap2) / capacity) + 0.5\n\n            if random.random() < merge_prob and (demand1 + demand2) <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n        # Stage 3: Probabilistic demand-balanced customer reallocation\n        if len(new_solution) > 1 and random.random() < 0.4:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer whose demand is closest to target route's remaining capacity\n                target_demand = np.sum(demand[target_route[1:-1]])\n                remaining_cap = capacity - target_demand\n                best_customer = None\n                best_diff = float('inf')\n\n                for i in range(1, len(source_route)-1):\n                    current_diff = abs(demand[source_route[i]] - remaining_cap)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_customer = i\n\n                if best_customer:\n                    customer = source_route[best_customer]\n\n                    # Find best insertion position considering demand balance\n                    best_pos = 1\n                    best_balance = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_demand = target_demand + demand[customer]\n                        new_balance = abs(new_demand - capacity/2)  # Prefer balanced demand\n\n                        if new_balance < best_balance:\n                            best_balance = new_balance\n                            best_pos = pos\n\n                    if new_demand <= capacity:\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:best_customer],\n                                                         source_route[best_customer+1:]])\n                        new_solution[source_idx] = new_source_route\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7965868091436135,
            0.1786138117313385
        ]
    },
    {
        "algorithm": "This algorithm implements a multi-stage hybrid local search for the Bi-CVRP, prioritizing balanced solutions (60% distance, 40% makespan) and applying adaptive route segmentation, demand-aware customer insertion, route reversal with capacity optimization, and intelligent route merging with load balancing. It uses dynamic programming for optimal split points and reversal segments, while maintaining feasibility through capacity checks and demand pattern analysis. The algorithm iteratively refines solutions through 8 stages of transformations, focusing on both distance minimization and makespan reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search with 8 iterations\n    for _ in range(8):\n        # Stage 1: Adaptive route segmentation with demand optimization\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal split point using dynamic programming\n                demands = demand[route[1:-1]]\n                n = len(demands)\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                split_pos = 1\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demands[j-1]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[split_pos]:\n                        split_pos = i\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Demand-aware customer insertion\n        if len(new_solution) > 0:\n            # Select customer from route with highest demand variance\n            route_idx = np.argmax([np.std(demand[route[1:-1]]) for route in new_solution])\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with demand closest to average\n                route_demand = demand[route[1:-1]]\n                avg_demand = np.mean(route_demand)\n                closest_customer = np.argmin(np.abs(route_demand - avg_demand)) + 1\n                customer = route[closest_customer]\n\n                # Find best insertion point in another route\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion score based on distance and demand balance\n                        insert_dist = (distance_matrix[other_route[pos-1]][customer] +\n                                      distance_matrix[customer][other_route[pos]] -\n                                      distance_matrix[other_route[pos-1]][other_route[pos]])\n                        new_demand = other_demand + demand[customer]\n                        demand_score = abs(new_demand - capacity/2)\n\n                        total_score = insert_dist * 0.7 + demand_score * 0.3\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:closest_customer], route[closest_customer+1:]])\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Route reversal with capacity optimization\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal reversal segment using dynamic programming\n                n = len(route) - 2\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                best_i, best_j = 1, 2\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demand[route[j]]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[best_i]:\n                        best_i, best_j = i, j\n\n                reversed_segment = route[best_i:best_j+1][::-1]\n                new_route = np.concatenate([route[:best_i], reversed_segment, route[best_j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 4: Intelligent route merging with load balancing\n        if len(new_solution) > 1:\n            # Find pair of routes with most complementary demand patterns\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    demand_i = np.sum(demand[new_solution[i][1:-1]])\n                    demand_j = np.sum(demand[new_solution[j][1:-1]])\n                    if demand_i + demand_j <= capacity:\n                        score = abs(demand_i + demand_j - capacity/2)\n                        if score < best_score:\n                            best_score = score\n                            best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Try both possible merge directions\n                merged1 = np.concatenate([route1[:-1], route2[1:]])\n                merged2 = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merge direction that better balances demands\n                demand1 = np.sum(demand[merged1[1:-1]])\n                demand2 = np.sum(demand[merged2[1:-1]])\n                score1 = abs(demand1 - capacity/2)\n                score2 = abs(demand2 - capacity/2)\n\n                if score1 <= score2 and len(merged1) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged1)\n                elif len(merged2) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged2)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.915810040703673,
            8.590130120515823
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid crowding and dominance score, then applies a series of demand-pattern-aware spatial fragmentation, load-balanced merging, and demand-aware reallocation operators to iteratively improve the solution while maintaining feasibility. It prioritizes spatial proximity and demand balance, dynamically adjusting route splits and merges based on demand distribution and spatial coherence, with higher emphasis on demand compatibility during reallocation. The algorithm balances exploration through probabilistic operations and exploitation through demand-based heuristics, ensuring capacity constraints are respected throughout the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    # Calculate dominance score\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        better_than = 0\n        for j in range(len(archive)):\n            if (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) or \\\n               (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]):\n                better_than += 1\n        dominance[i] = better_than\n\n    # Combine crowding and dominance\n    crowding = np.zeros(len(archive))\n    sorted_idx = np.argsort(normalized[:, 0])\n    crowding[sorted_idx[0]] = float('inf')\n    crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[sorted_idx[i]] = (normalized[sorted_idx[i+1], 0] - normalized[sorted_idx[i-1], 0])\n\n    combined_score = 0.6 * crowding + 0.4 * dominance\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Iterative improvement with hybrid operators\n    for _ in range(8):\n        # Demand-pattern-aware spatial fragmentation\n        if len(new_solution) > 1 and random.random() < 0.7:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                route_demand = demand[route[1:-1]]\n                demand_std = np.std(route_demand)\n\n                if demand_std > 0:  # Only proceed if demand pattern is diverse\n                    # Find split point that balances demand and spatial proximity\n                    total_demand = np.sum(route_demand)\n                    target_demand = total_demand * 0.5  # Split at 50% of total demand\n                    current_demand = 0\n                    best_split = 1\n\n                    for i in range(1, len(route)-1):\n                        current_demand += demand[route[i]]\n                        if current_demand >= target_demand:\n                            # Consider spatial proximity to current position\n                            spatial_score = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]]\n                            if i == 1 or spatial_score < distance_matrix[route[best_split-1], route[best_split]] + distance_matrix[route[best_split], route[best_split+1]]:\n                                best_split = i\n\n                    fragment1 = route[:best_split+1]\n                    fragment2 = np.concatenate([[0], route[best_split+1:]])\n\n                    if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                        np.sum(demand[fragment2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = fragment1\n                        new_solution.append(fragment2)\n\n        # Load-balanced spatial merging\n        if len(new_solution) > 2 and random.random() < 0.6:\n            # Find routes with similar demand patterns and spatial proximity\n            route_centroids = []\n            route_demand_avgs = []\n            for route in new_solution:\n                if len(route) > 2:\n                    route_coords = coords[route[1:-1]]\n                    centroid = np.mean(route_coords, axis=0)\n                    route_centroids.append(centroid)\n                    route_demand = demand[route[1:-1]]\n                    route_demand_avgs.append(np.mean(route_demand) if len(route_demand) > 0 else 0)\n                else:\n                    route_centroids.append(np.zeros(2))\n                    route_demand_avgs.append(0)\n\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demand_avgs[i] - route_demand_avgs[j])\n                    combined_score = spatial_dist + 0.5 * demand_diff  # Weight demand difference more\n\n                    if combined_score < best_score:\n                        best_score = combined_score\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                    len(route1) + len(route2) - 2 <= 15):  # Increased route length limit\n\n                    # Check if merging would create a more balanced route\n                    total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                    if abs(total_demand - capacity/2) < capacity/3:  # Accept if within 1/3 of half capacity\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]]\n                        new_solution.append(merged_route)\n\n        # Demand-aware spatial reallocation\n        if len(new_solution) > 1 and random.random() < 0.8:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with most extreme demand relative to route average\n                route_demand = demand[route[1:-1]]\n                route_avg = np.mean(route_demand)\n                customer_pos = np.argmax(np.abs(route_demand - route_avg)) + 1\n                customer = route[customer_pos]\n\n                # Find best route to insert based on spatial and demand compatibility\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = demand[other_route[1:-1]]\n                    if len(other_demand) == 0 or np.sum(other_demand) + demand[customer] > capacity:\n                        continue\n\n                    other_avg = np.mean(other_demand) if len(other_demand) > 0 else 0\n                    demand_diff = abs(route_avg - other_avg)\n\n                    # Find insertion position that minimizes spatial disruption\n                    min_insertion_cost = float('inf')\n                    best_insert_pos = -1\n\n                    for pos in range(1, len(other_route)):\n                        insertion_cost = (distance_matrix[other_route[pos-1], customer] +\n                                        distance_matrix[customer, other_route[pos]] -\n                                        distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if insertion_cost < min_insertion_cost:\n                            min_insertion_cost = insertion_cost\n                            best_insert_pos = pos\n\n                    total_score = min_insertion_cost + 0.4 * demand_diff  # Weight demand difference more\n\n                    if total_score < best_score:\n                        best_score = total_score\n                        best_route_idx = other_idx\n                        best_pos = best_insert_pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8956807917622304,
            3.4301752150058746
        ]
    },
    {
        "algorithm": "The algorithm first selects a promising solution from the archive using crowding distance to identify solutions in less explored regions of the Pareto front. It then applies a multi-stage hybrid local search: Stage 1 fragments high-demand routes, Stage 2 merges capacity-complementary routes, and Stage 3 reallocates customers using a weighted greedy approach that prioritizes distance (60%) and demand balance (40%). The method dynamically balances route operations while ensuring capacity feasibility, exploring trade-offs between total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(5):\n        # Stage 1: Demand-aware route fragmentation\n        if len(new_solution) > 1:\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            route_idx = np.argmax(demands)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                total_demand = np.sum(demand[route[1:-1]])\n                avg_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= avg_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Capacity-complementary merging\n        if len(new_solution) > 1:\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            candidates = []\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    if demands[i] + demands[j] <= capacity:\n                        candidates.append((i, j))\n\n            if candidates:\n                best_pair = min(candidates, key=lambda p: abs(demands[p[0]] + demands[p[1]] - capacity))\n                route1, route2 = new_solution[best_pair[0]], new_solution[best_pair[1]]\n\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in best_pair]\n                new_solution.append(merged_route)\n\n        # Stage 3: Weighted greedy reallocation\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        distance_cost = (distance_matrix[other_route[pos-1], customer] +\n                                       distance_matrix[customer, other_route[pos]] -\n                                       distance_matrix[other_route[pos-1], other_route[pos]])\n                        demand_cost = abs(other_demand + demand[customer] - capacity/2)\n\n                        score = 0.6 * distance_cost + 0.4 * demand_cost\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8779211226769548,
            1.6488251984119415
        ]
    },
    {
        "algorithm": "The algorithm combines three key phases: demand-aware route splitting, capacity-constrained demand pattern matching, and spatial clustering optimization. It prioritizes demand balance and spatial proximity (70%/30% weighting in Phase 2) while minimizing makespan by targeting shortest routes in Phase 3, all while ensuring feasibility through capacity checks. The selection of routes for modification is guided by crowding distance in the objective space to focus on diverse solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        distances[sorted_idx[0]] = np.inf\n        distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_idx[j+1], i] != objectives[sorted_idx[j-1], i]:\n                distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-aware route splitting with capacity balancing\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Find route with highest demand variance\n        route_demands = [demand[route[1:-1]] for route in new_solution]\n        demand_vars = [np.var(d) if len(d) > 0 else 0 for d in route_demands]\n        split_route_idx = np.argmax(demand_vars)\n        split_route = new_solution[split_route_idx]\n\n        if len(split_route) > 4:\n            # Find split point that balances demand and spatial proximity\n            total_demand = np.sum(demand[split_route[1:-1]])\n            half_demand = total_demand / 2\n            current_demand = 0\n            best_split = 1\n            min_spatial_diff = float('inf')\n\n            for i in range(1, len(split_route)-1):\n                current_demand += demand[split_route[i]]\n                if abs(current_demand - half_demand) < abs(np.sum(demand[split_route[1:i+1]]) - half_demand):\n                    # Calculate spatial difference between split parts\n                    part1 = split_route[1:i+1]\n                    part2 = split_route[i+1:-1]\n                    if len(part1) > 0 and len(part2) > 0:\n                        center1 = np.mean(coords[part1], axis=0)\n                        center2 = np.mean(coords[part2], axis=0)\n                        spatial_diff = np.linalg.norm(center1 - center2)\n\n                        if spatial_diff < min_spatial_diff:\n                            min_spatial_diff = spatial_diff\n                            best_split = i\n\n            fragment1 = split_route[:best_split+1]\n            fragment2 = np.concatenate([[0], split_route[best_split+1:]])\n\n            if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                np.sum(demand[fragment2[1:-1]]) <= capacity):\n                new_solution[split_route_idx] = fragment1\n                new_solution.append(fragment2)\n\n    # Phase 2: Capacity-constrained demand pattern matching reallocation\n    for _ in range(4):\n        if len(new_solution) < 2:\n            break\n\n        # Find route with most demand imbalance\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        imbalance_scores = [abs(d - capacity/2) for d in route_demands]\n        source_idx = np.argmax(imbalance_scores)\n        source_route = new_solution[source_idx]\n\n        if len(source_route) > 3:\n            # Find customers with demand closest to route's average demand\n            route_avg = np.mean(demand[source_route[1:-1]]) if len(source_route) > 2 else 0\n            demand_diffs = [abs(d - route_avg) for d in demand[source_route[1:-1]]]\n            candidate_pos = np.argmin(demand_diffs) + 1\n            customer = source_route[candidate_pos]\n\n            # Find best target route based on demand compatibility and spatial proximity\n            best_target = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for target_idx, target_route in enumerate(new_solution):\n                if target_idx == source_idx:\n                    continue\n\n                target_demand = np.sum(demand[target_route[1:-1]])\n                if target_demand + demand[customer] > capacity:\n                    continue\n\n                # Calculate spatial proximity score\n                source_center = np.mean(coords[source_route[1:-1]], axis=0) if len(source_route) > 2 else np.zeros(2)\n                target_center = np.mean(coords[target_route[1:-1]], axis=0) if len(target_route) > 2 else np.zeros(2)\n                spatial_score = np.linalg.norm(source_center - target_center)\n\n                # Calculate demand balance score\n                new_demand = target_demand + demand[customer]\n                demand_score = abs(new_demand - capacity/2)\n\n                # Combined score (weighted by 70% spatial, 30% demand)\n                total_score = 0.7 * spatial_score + 0.3 * demand_score\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_target = target_idx\n                    # Find best insertion position\n                    min_insert_cost = float('inf')\n                    best_insert_pos = 1\n                    for pos in range(1, len(target_route)):\n                        insert_cost = (distance_matrix[target_route[pos-1], customer] +\n                                     distance_matrix[customer, target_route[pos]] -\n                                     distance_matrix[target_route[pos-1], target_route[pos]])\n                        if insert_cost < min_insert_cost:\n                            min_insert_cost = insert_cost\n                            best_insert_pos = pos\n                    best_pos = best_insert_pos\n\n            if best_target != -1:\n                target_route = new_solution[best_target]\n                new_target_route = np.concatenate([\n                    target_route[:best_pos],\n                    [customer],\n                    target_route[best_pos:]\n                ])\n                new_solution[best_target] = new_target_route\n\n                new_source_route = np.concatenate([source_route[:candidate_pos], source_route[candidate_pos+1:]])\n                new_solution[source_idx] = new_source_route\n\n    # Phase 3: Spatial clustering optimization with weighted greedy insertion\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find shortest route\n        route_lengths = [np.sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        shortest_idx = np.argmin(route_lengths)\n        shortest_route = new_solution[shortest_idx]\n\n        if len(shortest_route) > 3:\n            # Find customer with best spatial clustering potential\n            best_customer = -1\n            best_target = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for customer_pos in range(1, len(shortest_route)-1):\n                customer = shortest_route[customer_pos]\n\n                for target_idx, target_route in enumerate(new_solution):\n                    if target_idx == shortest_idx:\n                        continue\n\n                    target_demand = np.sum(demand[target_route[1:-1]])\n                    if target_demand + demand[customer] > capacity:\n                        continue\n\n                    # Calculate spatial clustering score\n                    target_center = np.mean(coords[target_route[1:-1]], axis=0) if len(target_route) > 2 else np.zeros(2)\n                    customer_pos = coords[customer]\n                    spatial_score = np.linalg.norm(target_center - customer_pos)\n\n                    # Calculate distance reduction score\n                    prev_node = target_route[-2]\n                    next_node = shortest_route[customer_pos-1]\n                    insertion_cost = (distance_matrix[prev_node, customer] +\n                                    distance_matrix[customer, next_node] -\n                                    distance_matrix[prev_node, next_node])\n\n                    # Combined score (weighted by 60% spatial, 40% distance)\n                    total_score = 0.6 * spatial_score + 0.4 * insertion_cost\n\n                    if total_score < best_score:\n                        best_score = total_score\n                        best_customer = customer_pos\n                        best_target = target_idx\n                        best_pos = len(target_route)-1\n\n            if best_customer != -1 and best_target != -1:\n                customer = shortest_route[best_customer]\n                target_route = new_solution[best_target]\n\n                new_target_route = np.concatenate([\n                    target_route[:best_pos],\n                    [customer],\n                    target_route[best_pos:]\n                ])\n                new_solution[best_target] = new_target_route\n\n                new_shortest_route = np.concatenate([shortest_route[:best_customer], shortest_route[best_customer+1:]])\n                new_solution[shortest_idx] = new_shortest_route\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8324089511328039,
            1.530431181192398
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding distance to explore diverse trade-offs, then applies a demand-aware fragmentation operator to split imbalanced routes and a load-balanced merging operator to combine complementary routes, prioritizing demand complementarity (70%) over spatial proximity (30%) while maintaining feasibility through capacity checks. The approach balances exploration of the objective space with targeted local improvements to reduce both total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) < 2:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances\n        archive_sorted_dist = sorted(archive, key=lambda x: x[1][0])\n        archive_sorted_make = sorted(archive, key=lambda x: x[1][1])\n\n        crowding_dist = {}\n        for i, (sol, obj) in enumerate(archive):\n            if i == 0 or i == len(archive)-1:\n                crowding_dist[i] = float('inf')\n            else:\n                dist_diff = (archive_sorted_dist[i+1][1][0] - archive_sorted_dist[i-1][1][0]) / (archive_sorted_dist[-1][1][0] - archive_sorted_dist[0][1][0])\n                make_diff = (archive_sorted_make[i+1][1][1] - archive_sorted_make[i-1][1][1]) / (archive_sorted_make[-1][1][1] - archive_sorted_make[0][1][1])\n                crowding_dist[i] = dist_diff + make_diff\n\n        selected_idx = max(crowding_dist.keys(), key=lambda k: crowding_dist[k])\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Demand-aware fragmentation\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find route with most demand imbalance\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        most_imbalanced_idx = max(range(len(new_solution)), key=lambda i: abs(route_demands[i] - capacity/2))\n\n        # Find split point that balances demand\n        route = new_solution[most_imbalanced_idx]\n        if len(route) <= 3:\n            continue\n\n        cumulative_demand = np.cumsum(demand[route[1:-1]])\n        split_pos = np.argmin(np.abs(cumulative_demand - capacity/2)) + 1\n\n        # Create new route from split point\n        new_route = np.concatenate([[0], route[split_pos:], [0]])\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n            new_solution[most_imbalanced_idx] = np.concatenate([[0], route[1:split_pos+1], [0]])\n\n    # Load-balanced merging\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find routes with complementary demands\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        route_centers = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else np.zeros(2) for route in new_solution]\n\n        best_merge = None\n        best_score = -float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                combined_demand = route_demands[i] + route_demands[j]\n                if combined_demand > capacity:\n                    continue\n\n                # Calculate weighted score: demand complementarity + spatial proximity\n                demand_score = (capacity - abs(capacity - combined_demand)) / capacity\n                spatial_score = 1 / (1 + np.linalg.norm(route_centers[i] - route_centers[j]))\n                score = 0.7 * demand_score + 0.3 * spatial_score\n\n                if score > best_score:\n                    best_score = score\n                    best_merge = (i, j)\n\n        if best_merge is not None:\n            i, j = best_merge\n            # Merge routes\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution.append(merged_route)\n                del new_solution[max(i, j)]\n                del new_solution[min(i, j)]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8278933615924351,
            0.5591227412223816
        ]
    }
]