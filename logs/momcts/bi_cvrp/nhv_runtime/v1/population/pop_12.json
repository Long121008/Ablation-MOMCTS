[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection (prioritizing lower makespan and total distance), then applies a hybrid local search combining route splitting (to reduce makespan) and node reinsertion (to improve total distance), ensuring feasibility by checking vehicle capacity constraints at each step. The method intelligently balances both objectives by iteratively refining the solution through these targeted operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = []\n    for sol, obj in archive:\n        # Higher weight for solutions with lower makespan or total distance\n        weight = 1 / (obj[1] + obj[0] + 1e-6)  # Avoid division by zero\n        weights.append(weight)\n\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + node reinsertion\n    # Step 1: Try to split a route into two if it's too long (makespan reduction)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find a split point that minimizes the increase in total distance\n        best_split = None\n        min_increase = float('inf')\n        for j in range(1, len(route)-1):\n            # Split after node j\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[first_part[1:-1]]) > capacity) or (np.sum(demand[second_part[1:-1]]) > capacity):\n                continue\n\n            # Calculate increase in total distance\n            increase = (distance_matrix[route[j], 0] + distance_matrix[0, route[j+1]]) - distance_matrix[route[j], route[j+1]]\n            if increase < min_increase:\n                min_increase = increase\n                best_split = j\n\n        if best_split is not None:\n            j = best_split\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n            new_solution[i] = first_part\n            new_solution.append(second_part)\n            break  # Only split one route per iteration\n\n    # Step 2: Try to reinsert a node from a route to another to improve total distance\n    for _ in range(2):  # Try a few reinsertions\n        if len(new_solution) < 2:\n            break\n\n        # Select a random route to take a node from\n        from_route_idx = random.randint(0, len(new_solution)-1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) <= 3:  # Skip trivial routes\n            continue\n\n        # Select a random node to move (not depot)\n        node_pos = random.randint(1, len(from_route)-2)\n        node = from_route[node_pos]\n\n        # Try to insert into another route\n        best_insertion = None\n        min_increase = float('inf')\n        for to_route_idx in range(len(new_solution)):\n            if to_route_idx == from_route_idx:\n                continue\n\n            to_route = new_solution[to_route_idx]\n            # Check capacity constraint\n            if np.sum(demand[to_route[1:-1]]) + demand[node] > capacity:\n                continue\n\n            # Try inserting after each node in the to_route\n            for pos in range(len(to_route)-1):\n                # Insert after to_route[pos]\n                # Calculate increase in distance\n                increase = (distance_matrix[to_route[pos], node] +\n                           distance_matrix[node, to_route[pos+1]] -\n                           distance_matrix[to_route[pos], to_route[pos+1]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_insertion = (to_route_idx, pos, node)\n\n        if best_insertion is not None:\n            to_route_idx, pos, node = best_insertion\n            # Remove from original route\n            new_solution[from_route_idx] = np.delete(new_solution[from_route_idx], node_pos)\n            # Insert into new route\n            new_solution[to_route_idx] = np.insert(new_solution[to_route_idx], pos+1, node)\n\n            # If route becomes empty, remove it\n            if len(new_solution[from_route_idx]) == 2:  # Only depot-depot\n                new_solution.pop(from_route_idx)\n            break  # Only one reinsertion per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.74727416385559,
            0.26535162329673767
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized distance and makespan (60% distance, 40% makespan), then applies a hybrid local search combining route fragmentation, customer reallocation, and route merging. It iteratively fragments long routes, reallocates customers between routes with capacity checks, and merges small routes while limiting route length to 20 nodes. The solution is refined through 5 iterations and finally normalized to remove empty routes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + customer reallocation + route merging\n    for _ in range(5):  # Perform 5 iterations\n        # Randomly select a route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Fragment route at random point\n        split_pos = random.randint(2, len(route) - 2)\n        fragment = route[split_pos:]\n        remaining = route[:split_pos]\n\n        # Check capacity feasibility for fragments\n        if np.sum(demand[fragment[1:-1]]) <= capacity and np.sum(demand[remaining[1:-1]]) <= capacity:\n            new_solution[route_idx] = remaining\n            new_solution.append(fragment)\n\n        # Customer reallocation: move customers between routes\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select customers to move (up to 2)\n            customers_to_move = random.sample(range(1, len(route) - 1), min(2, len(route) - 2))\n\n            for customer_pos in sorted(customers_to_move, reverse=True):\n                customer = route[customer_pos]\n\n                # Find best insertion position in other route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                   distance_matrix[customer, other_route[pos]] -\n                                   distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Check capacity feasibility\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into other route\n                    new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from original route\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n                    route = new_route\n\n        # Route merging: try to merge small routes\n        if len(new_solution) > 1:\n            # Select two routes to potentially merge\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            # Check if merging is feasible\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 20):  # Limit route length\n\n                # Create merged route (route1 + route2 without depot)\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Update solution\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7532898215774322,
            0.30173933506011963
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing lower makespan) and applies a hybrid local search combining route merging with probabilistic acceptance to balance distance and makespan objectives while ensuring feasibility through capacity checks. It intelligently merges routes by minimizing distance increases and occasionally accepts worse moves to escape local optima, dynamically updating the solution's objectives. The method focuses on improving both objectives through careful route combination and probabilistic exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + probabilistic acceptance\n    for _ in range(3):  # Perform 3 iterations\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes to potentially merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand > capacity:\n            continue\n\n        # Find best merge point (minimizing distance increase)\n        best_merge = None\n        min_increase = float('inf')\n\n        # Try merging route2 into route1 at different positions\n        for pos in range(1, len(route1)):\n            # Calculate distance increase\n            increase = (distance_matrix[route1[pos-1], route2[1]] +\n                       distance_matrix[route2[-2], route1[pos]] -\n                       distance_matrix[route1[pos-1], route1[pos]])\n\n            if increase < min_increase:\n                min_increase = increase\n                best_merge = (pos, increase)\n\n        if best_merge is not None:\n            pos, increase = best_merge\n\n            # Calculate new objectives\n            old_distance = archive_sorted[selected_idx][1][0]\n            old_makespan = archive_sorted[selected_idx][1][1]\n\n            new_distance = old_distance + increase\n            new_makespan = max(old_makespan - distance_matrix[route1[-2], 0],\n                              distance_matrix[route1[pos-1], route2[1]] +\n                              np.sum(distance_matrix[route2[1:-1], route2[2:]]) +\n                              distance_matrix[route2[-2], route1[pos]])\n\n            # Probabilistic acceptance\n            if (new_distance < old_distance and new_makespan <= old_makespan) or \\\n               random.random() < 0.2:  # 20% chance to accept worse move\n                # Perform the merge\n                merged_route = np.concatenate([route1[:pos], route2[1:-1], route1[pos:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n                # Update current objectives\n                old_distance = new_distance\n                old_makespan = new_makespan\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8087135813524513,
            0.8420414328575134
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage local search\n    for _ in range(4):  # Perform 4 iterations of the multi-stage operator\n        # Stage 1: Route splitting with demand-aware fragmentation\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:  # Only split if route is long enough\n                # Find split point that balances demand\n                total_demand = np.sum(demand[route[1:-1]])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Customer reallocation with demand pattern matching\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customers with similar demand patterns\n                route_demand = demand[route[1:-1]]\n                median_demand = np.median(route_demand)\n                similar_customers = [i for i, d in enumerate(route_demand)\n                                   if abs(d - median_demand) <= median_demand * 0.3]\n\n                if similar_customers:\n                    customer_pos = random.choice(similar_customers) + 1  # +1 for route index\n                    customer = route[customer_pos]\n\n                    # Find best route to insert based on demand compatibility\n                    best_route_idx = -1\n                    best_pos = -1\n                    min_demand_diff = float('inf')\n\n                    for other_idx, other_route in enumerate(new_solution):\n                        if other_idx == route_idx:\n                            continue\n\n                        other_demand = np.sum(demand[other_route[1:-1]])\n                        if other_demand + demand[customer] > capacity:\n                            continue\n\n                        for pos in range(1, len(other_route)):\n                            # Prefer positions that maintain demand balance\n                            new_demand = other_demand + demand[customer]\n                            demand_diff = abs(new_demand - capacity/2)\n\n                            if demand_diff < min_demand_diff:\n                                min_demand_diff = demand_diff\n                                best_route_idx = other_idx\n                                best_pos = pos\n\n                    if best_route_idx != -1:\n                        # Move customer to best position\n                        other_route = new_solution[best_route_idx]\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            [customer],\n                            other_route[best_pos:]\n                        ])\n                        new_solution[best_route_idx] = new_other_route\n\n                        # Remove from original route\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n        # Stage 3: Route merging with load balancing\n        if len(new_solution) > 1:\n            # Select two routes to potentially merge\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            # Check if merging is feasible and maintains balanced load\n            total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if total_demand <= capacity and len(route1) + len(route2) - 2 <= 25:  # Slightly larger route limit\n                # Create merged route\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Update solution\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.7972594454255604,
            0.6602787673473358
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing balanced objective solutions) and applies a hybrid local search that intelligently merges nearby routes when feasible (based on capacity and spatial proximity) and splits long routes into balanced parts to improve both total distance and makespan, while maintaining feasibility through demand checks. The method dynamically updates route centroids to guide spatial clustering, with a focus on reducing route imbalance and optimizing multi-objective trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate centroids for each route\n    route_centroids = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_centroids.append(np.zeros(2))\n            continue\n        customer_coords = coords[route[1:-1]]\n        centroid = np.mean(customer_coords, axis=0)\n        route_centroids.append(centroid)\n\n    # Route fusion: try to merge nearby routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find closest pair of routes\n        min_dist = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair is None:\n            break\n\n        i, j = best_pair\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging would exceed capacity\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand > capacity:\n            continue\n\n        # Merge the two routes\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        new_solution[i] = merged_route\n        new_solution.pop(j)\n        route_centroids.pop(j)\n\n        # Recalculate centroid for merged route\n        if len(merged_route) > 2:\n            customer_coords = coords[merged_route[1:-1]]\n            route_centroids[i] = np.mean(customer_coords, axis=0)\n        else:\n            route_centroids[i] = np.zeros(2)\n\n    # Route fragmentation: split long routes into balanced parts\n    for _ in range(2):\n        if len(new_solution) >= len(base_solution) + 2:\n            break\n\n        # Find the longest route\n        longest_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        route = new_solution[longest_idx]\n\n        if len(route) <= 4:  # Skip if route is too short\n            continue\n\n        # Find a balanced split point\n        best_split = None\n        min_diff = float('inf')\n        total_demand = np.sum(demand[route[1:-1]])\n\n        for j in range(2, len(route)-2):\n            left_demand = np.sum(demand[route[1:j+1]])\n            right_demand = total_demand - left_demand\n\n            # Check if both parts would fit within capacity\n            if left_demand <= capacity and right_demand <= capacity:\n                diff = abs(left_demand - right_demand)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_split = j\n\n        if best_split is not None:\n            j = best_split\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n\n            new_solution[longest_idx] = first_part\n            new_solution.append(second_part)\n\n            # Update centroids\n            if len(first_part) > 2:\n                customer_coords = coords[first_part[1:-1]]\n                route_centroids[longest_idx] = np.mean(customer_coords, axis=0)\n            else:\n                route_centroids[longest_idx] = np.zeros(2)\n\n            if len(second_part) > 2:\n                customer_coords = coords[second_part[1:-1]]\n                route_centroids.append(np.mean(customer_coords, axis=0))\n            else:\n                route_centroids.append(np.zeros(2))\n\n    return new_solution\n\n",
        "score": [
            -0.7462077011654622,
            0.5622931718826294
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random selection that prioritizes solutions with lower total distance (70% weight) and makespan (30% weight), then applies a hybrid local search combining route merging (to reduce makespan) and node swapping (to optimize total distance while respecting capacity constraints). The merge step checks feasibility and proximity between routes, while the swap step evaluates random node exchanges between routes to improve distance without violating capacity limits.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = []\n    for sol, obj in archive:\n        # Normalize objectives\n        total_dist = obj[0]\n        makespan = obj[1]\n        max_dist = max(o[0] for _, o in archive) + 1e-6\n        max_span = max(o[1] for _, o in archive) + 1e-6\n        # Weight based on normalized objectives (lower is better)\n        weight = 0.7 * (1 - total_dist / max_dist) + 0.3 * (1 - makespan / max_span)\n        weights.append(weight)\n\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + node swapping\n    # Step 1: Try to merge two routes if they are close in space (reduces makespan)\n    if len(new_solution) > 1:\n        # Find the two closest routes in terms of depot distance\n        min_dist = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                dist = distance_matrix[new_solution[i][-2], new_solution[j][1]]  # distance between last node of i and first node of j\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair is not None:\n            i, j = best_pair\n            # Check if merging is feasible\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Merge the routes\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Step 2: Try to swap nodes between routes to improve total distance\n    for _ in range(3):  # Try multiple swaps\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1_idx, route2_idx = route_indices\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 3 or len(route2) <= 3:  # Skip trivial routes\n            continue\n\n        # Select random nodes from each route (not depot)\n        node1_pos = random.randint(1, len(route1)-2)\n        node2_pos = random.randint(1, len(route2)-2)\n        node1 = route1[node1_pos]\n        node2 = route2[node2_pos]\n\n        # Check capacity constraints after swap\n        new_route1 = route1.copy()\n        new_route1[node1_pos] = node2\n        new_route2 = route2.copy()\n        new_route2[node2_pos] = node1\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Calculate distance change\n            old_dist = (distance_matrix[route1[node1_pos-1], node1] +\n                        distance_matrix[node1, route1[node1_pos+1]] +\n                        distance_matrix[route2[node2_pos-1], node2] +\n                        distance_matrix[node2, route2[node2_pos+1]])\n\n            new_dist = (distance_matrix[route1[node1_pos-1], node2] +\n                        distance_matrix[node2, route1[node1_pos+1]] +\n                        distance_matrix[route2[node2_pos-1], node1] +\n                        distance_matrix[node1, route2[node2_pos+1]])\n\n            if new_dist < old_dist:  # Only accept if distance improves\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.46272196370130647,
            0.4604072868824005
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of distance (40%) and makespan (60%), then applies a hybrid local search combining route splitting, regret-based customer reinsertion, and route consolidation, iterating 7 times while ensuring feasibility and limiting route lengths to 15 nodes. It prioritizes reducing makespan (60%) over minimizing distance (40%) and uses regret-based insertion to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.4 + weights[:, 1] * 0.6  # Adjusted weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(7):  # Increased iterations\n        # Route splitting\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                fragment = route[split_pos:]\n                remaining = route[:split_pos]\n\n                if np.sum(demand[fragment[1:-1]]) <= capacity and np.sum(demand[remaining[1:-1]]) <= capacity:\n                    new_solution[route_idx] = remaining\n                    new_solution.append(fragment)\n\n        # Customer reinsertion with regret\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Calculate regret for each possible insertion\n                insertion_costs = []\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_route_idx]\n                    costs = []\n                    for pos in range(1, len(other_route)):\n                        cost = (distance_matrix[other_route[pos-1], customer] +\n                               distance_matrix[customer, other_route[pos]] -\n                               distance_matrix[other_route[pos-1], other_route[pos]])\n                        costs.append(cost)\n                    insertion_costs.append(costs)\n\n                # Select route with highest regret (minimum second-best option)\n                regrets = []\n                for i, costs in enumerate(insertion_costs):\n                    if not costs:\n                        regrets.append(float('inf'))\n                        continue\n                    sorted_costs = sorted(costs)\n                    regret = sorted_costs[0] - sorted_costs[1] if len(sorted_costs) > 1 else sorted_costs[0]\n                    regrets.append(regret)\n\n                best_route_idx = np.argmin(regrets)\n                if regrets[best_route_idx] != float('inf'):\n                    best_route = new_solution[best_route_idx]\n                    best_pos = np.argmin(insertion_costs[best_route_idx])\n\n                    if np.sum(demand[best_route[1:-1]]) + demand[customer] <= capacity:\n                        new_route = np.concatenate([best_route[:best_pos+1], [customer], best_route[best_pos+1:]])\n                        new_solution[best_route_idx] = new_route\n                        new_solution[route_idx] = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n\n        # Route consolidation\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n            merged = False\n\n            for i in range(len(routes_to_merge)):\n                for j in range(i+1, len(routes_to_merge)):\n                    route1 = new_solution[routes_to_merge[i]]\n                    route2 = new_solution[routes_to_merge[j]]\n\n                    if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                        len(route1) + len(route2) - 2 <= 15):  # Reduced route length limit\n\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution = [route for idx, route in enumerate(new_solution)\n                                       if idx not in [routes_to_merge[i], routes_to_merge[j]]]\n                        new_solution.append(merged_route)\n                        merged = True\n                        break\n                if merged:\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8010353765686999,
            1.060107707977295
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest makespan from the archive and applies a hybrid local search that first redistributes customers between routes to balance demands and spatial proximity, then adjusts route lengths by moving customers from long to short routes, all while ensuring feasibility through capacity checks. It prioritizes demand balance and spatial locality in customer redistribution, followed by route length optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    selected_idx = 0\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route demands and spatial centers\n    route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n    route_centers = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else np.zeros(2) for route in new_solution]\n\n    # Customer redistribution: move customers between routes\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Find the most imbalanced route\n        most_imbalanced_idx = max(range(len(new_solution)), key=lambda i: abs(route_demands[i] - capacity/2))\n\n        # Find the closest route that can accommodate the customer\n        best_candidate = None\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == most_imbalanced_idx:\n                continue\n\n            # Check if we can move a customer from most_imbalanced to i\n            for j in range(1, len(new_solution[most_imbalanced_idx])-1):\n                customer = new_solution[most_imbalanced_idx][j]\n                new_demand = route_demands[i] + demand[customer]\n\n                if new_demand <= capacity:\n                    # Calculate cost of moving customer to route i\n                    prev_node = new_solution[i][-2]\n                    next_node = new_solution[most_imbalanced_idx][j-1]\n                    insertion_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                    if insertion_cost < min_cost:\n                        min_cost = insertion_cost\n                        best_candidate = (i, j)\n\n        if best_candidate is not None:\n            i, j = best_candidate\n            customer = new_solution[most_imbalanced_idx][j]\n\n            # Insert customer into route i\n            insertion_pos = len(new_solution[i])-1\n            new_solution[i] = np.insert(new_solution[i], insertion_pos, customer)\n\n            # Remove customer from original route\n            new_solution[most_imbalanced_idx] = np.delete(new_solution[most_imbalanced_idx], j)\n\n            # Update demands and centers\n            route_demands[i] += demand[customer]\n            route_demands[most_imbalanced_idx] -= demand[customer]\n\n            if len(new_solution[i]) > 2:\n                route_centers[i] = np.mean(coords[new_solution[i][1:-1]], axis=0)\n            if len(new_solution[most_imbalanced_idx]) > 2:\n                route_centers[most_imbalanced_idx] = np.mean(coords[new_solution[most_imbalanced_idx][1:-1]], axis=0)\n\n    # Route balancing: adjust route lengths by moving customers\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find the longest and shortest routes\n        longest_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        shortest_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        # Try to balance by moving customers\n        for j in range(1, len(new_solution[longest_idx])-1):\n            customer = new_solution[longest_idx][j]\n            new_demand = route_demands[shortest_idx] + demand[customer]\n\n            if new_demand <= capacity:\n                # Calculate cost of moving customer to shortest route\n                prev_node = new_solution[shortest_idx][-2]\n                next_node = new_solution[longest_idx][j-1]\n                insertion_cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n\n                # Calculate potential improvement\n                current_length = distance_matrix[new_solution[longest_idx][j-1], customer] + distance_matrix[customer, new_solution[longest_idx][j+1]]\n                new_length = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n                if new_length < current_length:\n                    # Perform the move\n                    new_solution[shortest_idx] = np.insert(new_solution[shortest_idx], len(new_solution[shortest_idx])-1, customer)\n                    new_solution[longest_idx] = np.delete(new_solution[longest_idx], j)\n\n                    # Update demands and centers\n                    route_demands[shortest_idx] += demand[customer]\n                    route_demands[longest_idx] -= demand[customer]\n\n                    if len(new_solution[shortest_idx]) > 2:\n                        route_centers[shortest_idx] = np.mean(coords[new_solution[shortest_idx][1:-1]], axis=0)\n                    if len(new_solution[longest_idx]) > 2:\n                        route_centers[longest_idx] = np.mean(coords[new_solution[longest_idx][1:-1]], axis=0)\n\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7797572033141008,
            0.6627451479434967
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive with a good balance between total distance and makespan, then applies a hybrid local search combining route merging, split-and-reinsertion, and demand-aware swaps to improve both objectives while maintaining feasibility through capacity checks. The selection prioritizes solutions with lower average objective values, while the hybrid search focuses on reducing route length imbalances and improving overall efficiency through strategic route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between distance and makespan\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route merging (if routes are short)\n        merged = False\n        for i in range(len(solution)):\n            if merged:\n                break\n            for j in range(i + 1, len(solution)):\n                route1 = solution[i]\n                route2 = solution[j]\n                combined_route = np.concatenate([route1[:-1], route2[1:]])\n                total_demand = sum(demand[node] for node in combined_route if node != 0)\n\n                if total_demand <= capacity:\n                    # Check if merging reduces makespan\n                    dist1 = sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1))\n                    dist2 = sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1))\n                    new_dist = sum(distance_matrix[combined_route[k]][combined_route[k+1]] for k in range(len(combined_route)-1))\n\n                    if new_dist <= max(dist1, dist2):\n                        solution[i] = combined_route\n                        del solution[j]\n                        merged = True\n                        break\n\n        # Step 2: Split-and-reinsert (if routes are long)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 4:  # Only consider long routes\n                for split_pos in range(2, len(route)-2):\n                    part1 = route[:split_pos+1]\n                    part2 = route[split_pos:]\n                    part1_demand = sum(demand[node] for node in part1 if node != 0)\n                    part2_demand = sum(demand[node] for node in part2 if node != 0)\n\n                    if part1_demand <= capacity and part2_demand <= capacity:\n                        # Try to reinsert part2 into another route\n                        for j in range(len(solution)):\n                            if i == j:\n                                continue\n                            combined = np.concatenate([solution[j][:-1], part2[1:]])\n                            combined_demand = sum(demand[node] for node in combined if node != 0)\n\n                            if combined_demand <= capacity:\n                                solution[i] = part1\n                                solution[j] = combined\n                                break\n\n        # Step 3: Demand-aware swaps (within routes)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 3:\n                for a in range(1, len(route)-2):\n                    for b in range(a+1, len(route)-1):\n                        # Check if swapping nodes a and b improves balance\n                        new_route = route.copy()\n                        new_route[a], new_route[b] = new_route[b], new_route[a]\n\n                        # Check capacity constraints\n                        part1 = new_route[:a+1]\n                        part2 = new_route[a:b+1]\n                        part3 = new_route[b:]\n\n                        if (sum(demand[node] for node in part1 if node != 0) <= capacity and\n                            sum(demand[node] for node in part2 if node != 0) <= capacity and\n                            sum(demand[node] for node in part3 if node != 0) <= capacity):\n\n                            # Check if swap improves balance\n                            dist_original = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n                            dist_new = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n\n                            if dist_new <= dist_original:\n                                solution[i] = new_route\n                                break\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure solution is feasible\n    for route in new_solution:\n        total_demand = sum(demand[node] for node in route if node != 0)\n        if total_demand > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.7331149904954284,
            10.16728326678276
        ]
    }
]