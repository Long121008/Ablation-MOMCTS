[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection (prioritizing lower makespan and total distance), then applies a hybrid local search combining route splitting (to reduce makespan) and node reinsertion (to improve total distance), ensuring feasibility by checking vehicle capacity constraints at each step. The method intelligently balances both objectives by iteratively refining the solution through these targeted operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = []\n    for sol, obj in archive:\n        # Higher weight for solutions with lower makespan or total distance\n        weight = 1 / (obj[1] + obj[0] + 1e-6)  # Avoid division by zero\n        weights.append(weight)\n\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + node reinsertion\n    # Step 1: Try to split a route into two if it's too long (makespan reduction)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find a split point that minimizes the increase in total distance\n        best_split = None\n        min_increase = float('inf')\n        for j in range(1, len(route)-1):\n            # Split after node j\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[first_part[1:-1]]) > capacity) or (np.sum(demand[second_part[1:-1]]) > capacity):\n                continue\n\n            # Calculate increase in total distance\n            increase = (distance_matrix[route[j], 0] + distance_matrix[0, route[j+1]]) - distance_matrix[route[j], route[j+1]]\n            if increase < min_increase:\n                min_increase = increase\n                best_split = j\n\n        if best_split is not None:\n            j = best_split\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n            new_solution[i] = first_part\n            new_solution.append(second_part)\n            break  # Only split one route per iteration\n\n    # Step 2: Try to reinsert a node from a route to another to improve total distance\n    for _ in range(2):  # Try a few reinsertions\n        if len(new_solution) < 2:\n            break\n\n        # Select a random route to take a node from\n        from_route_idx = random.randint(0, len(new_solution)-1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) <= 3:  # Skip trivial routes\n            continue\n\n        # Select a random node to move (not depot)\n        node_pos = random.randint(1, len(from_route)-2)\n        node = from_route[node_pos]\n\n        # Try to insert into another route\n        best_insertion = None\n        min_increase = float('inf')\n        for to_route_idx in range(len(new_solution)):\n            if to_route_idx == from_route_idx:\n                continue\n\n            to_route = new_solution[to_route_idx]\n            # Check capacity constraint\n            if np.sum(demand[to_route[1:-1]]) + demand[node] > capacity:\n                continue\n\n            # Try inserting after each node in the to_route\n            for pos in range(len(to_route)-1):\n                # Insert after to_route[pos]\n                # Calculate increase in distance\n                increase = (distance_matrix[to_route[pos], node] +\n                           distance_matrix[node, to_route[pos+1]] -\n                           distance_matrix[to_route[pos], to_route[pos+1]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_insertion = (to_route_idx, pos, node)\n\n        if best_insertion is not None:\n            to_route_idx, pos, node = best_insertion\n            # Remove from original route\n            new_solution[from_route_idx] = np.delete(new_solution[from_route_idx], node_pos)\n            # Insert into new route\n            new_solution[to_route_idx] = np.insert(new_solution[to_route_idx], pos+1, node)\n\n            # If route becomes empty, remove it\n            if len(new_solution[from_route_idx]) == 2:  # Only depot-depot\n                new_solution.pop(from_route_idx)\n            break  # Only one reinsertion per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.74727416385559,
            0.26535162329673767
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized distance and makespan (60% distance, 40% makespan), then applies a hybrid local search combining route fragmentation, customer reallocation, and route merging. It iteratively fragments long routes, reallocates customers between routes with capacity checks, and merges small routes while limiting route length to 20 nodes. The solution is refined through 5 iterations and finally normalized to remove empty routes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + customer reallocation + route merging\n    for _ in range(5):  # Perform 5 iterations\n        # Randomly select a route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Fragment route at random point\n        split_pos = random.randint(2, len(route) - 2)\n        fragment = route[split_pos:]\n        remaining = route[:split_pos]\n\n        # Check capacity feasibility for fragments\n        if np.sum(demand[fragment[1:-1]]) <= capacity and np.sum(demand[remaining[1:-1]]) <= capacity:\n            new_solution[route_idx] = remaining\n            new_solution.append(fragment)\n\n        # Customer reallocation: move customers between routes\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select customers to move (up to 2)\n            customers_to_move = random.sample(range(1, len(route) - 1), min(2, len(route) - 2))\n\n            for customer_pos in sorted(customers_to_move, reverse=True):\n                customer = route[customer_pos]\n\n                # Find best insertion position in other route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                   distance_matrix[customer, other_route[pos]] -\n                                   distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Check capacity feasibility\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into other route\n                    new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from original route\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n                    route = new_route\n\n        # Route merging: try to merge small routes\n        if len(new_solution) > 1:\n            # Select two routes to potentially merge\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            # Check if merging is feasible\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 20):  # Limit route length\n\n                # Create merged route (route1 + route2 without depot)\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Update solution\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7532898215774322,
            0.30173933506011963
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing lower makespan) and applies a hybrid local search combining route merging with probabilistic acceptance to balance distance and makespan objectives while ensuring feasibility through capacity checks. It intelligently merges routes by minimizing distance increases and occasionally accepts worse moves to escape local optima, dynamically updating the solution's objectives. The method focuses on improving both objectives through careful route combination and probabilistic exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + probabilistic acceptance\n    for _ in range(3):  # Perform 3 iterations\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes to potentially merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand > capacity:\n            continue\n\n        # Find best merge point (minimizing distance increase)\n        best_merge = None\n        min_increase = float('inf')\n\n        # Try merging route2 into route1 at different positions\n        for pos in range(1, len(route1)):\n            # Calculate distance increase\n            increase = (distance_matrix[route1[pos-1], route2[1]] +\n                       distance_matrix[route2[-2], route1[pos]] -\n                       distance_matrix[route1[pos-1], route1[pos]])\n\n            if increase < min_increase:\n                min_increase = increase\n                best_merge = (pos, increase)\n\n        if best_merge is not None:\n            pos, increase = best_merge\n\n            # Calculate new objectives\n            old_distance = archive_sorted[selected_idx][1][0]\n            old_makespan = archive_sorted[selected_idx][1][1]\n\n            new_distance = old_distance + increase\n            new_makespan = max(old_makespan - distance_matrix[route1[-2], 0],\n                              distance_matrix[route1[pos-1], route2[1]] +\n                              np.sum(distance_matrix[route2[1:-1], route2[2:]]) +\n                              distance_matrix[route2[-2], route1[pos]])\n\n            # Probabilistic acceptance\n            if (new_distance < old_distance and new_makespan <= old_makespan) or \\\n               random.random() < 0.2:  # 20% chance to accept worse move\n                # Perform the merge\n                merged_route = np.concatenate([route1[:pos], route2[1:-1], route1[pos:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n                # Update current objectives\n                old_distance = new_distance\n                old_makespan = new_makespan\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8087135813524513,
            0.8420414328575134
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing balanced objective solutions) and applies a hybrid local search that intelligently merges nearby routes when feasible (based on capacity and spatial proximity) and splits long routes into balanced parts to improve both total distance and makespan, while maintaining feasibility through demand checks. The method dynamically updates route centroids to guide spatial clustering, with a focus on reducing route imbalance and optimizing multi-objective trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate centroids for each route\n    route_centroids = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_centroids.append(np.zeros(2))\n            continue\n        customer_coords = coords[route[1:-1]]\n        centroid = np.mean(customer_coords, axis=0)\n        route_centroids.append(centroid)\n\n    # Route fusion: try to merge nearby routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find closest pair of routes\n        min_dist = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair is None:\n            break\n\n        i, j = best_pair\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging would exceed capacity\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand > capacity:\n            continue\n\n        # Merge the two routes\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        new_solution[i] = merged_route\n        new_solution.pop(j)\n        route_centroids.pop(j)\n\n        # Recalculate centroid for merged route\n        if len(merged_route) > 2:\n            customer_coords = coords[merged_route[1:-1]]\n            route_centroids[i] = np.mean(customer_coords, axis=0)\n        else:\n            route_centroids[i] = np.zeros(2)\n\n    # Route fragmentation: split long routes into balanced parts\n    for _ in range(2):\n        if len(new_solution) >= len(base_solution) + 2:\n            break\n\n        # Find the longest route\n        longest_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        route = new_solution[longest_idx]\n\n        if len(route) <= 4:  # Skip if route is too short\n            continue\n\n        # Find a balanced split point\n        best_split = None\n        min_diff = float('inf')\n        total_demand = np.sum(demand[route[1:-1]])\n\n        for j in range(2, len(route)-2):\n            left_demand = np.sum(demand[route[1:j+1]])\n            right_demand = total_demand - left_demand\n\n            # Check if both parts would fit within capacity\n            if left_demand <= capacity and right_demand <= capacity:\n                diff = abs(left_demand - right_demand)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_split = j\n\n        if best_split is not None:\n            j = best_split\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n\n            new_solution[longest_idx] = first_part\n            new_solution.append(second_part)\n\n            # Update centroids\n            if len(first_part) > 2:\n                customer_coords = coords[first_part[1:-1]]\n                route_centroids[longest_idx] = np.mean(customer_coords, axis=0)\n            else:\n                route_centroids[longest_idx] = np.zeros(2)\n\n            if len(second_part) > 2:\n                customer_coords = coords[second_part[1:-1]]\n                route_centroids.append(np.mean(customer_coords, axis=0))\n            else:\n                route_centroids.append(np.zeros(2))\n\n    return new_solution\n\n",
        "score": [
            -0.7462077011654622,
            0.5622931718826294
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random selection that prioritizes solutions with lower total distance (70% weight) and makespan (30% weight), then applies a hybrid local search combining route merging (to reduce makespan) and node swapping (to optimize total distance while respecting capacity constraints). The merge step checks feasibility and proximity between routes, while the swap step evaluates random node exchanges between routes to improve distance without violating capacity limits.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = []\n    for sol, obj in archive:\n        # Normalize objectives\n        total_dist = obj[0]\n        makespan = obj[1]\n        max_dist = max(o[0] for _, o in archive) + 1e-6\n        max_span = max(o[1] for _, o in archive) + 1e-6\n        # Weight based on normalized objectives (lower is better)\n        weight = 0.7 * (1 - total_dist / max_dist) + 0.3 * (1 - makespan / max_span)\n        weights.append(weight)\n\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + node swapping\n    # Step 1: Try to merge two routes if they are close in space (reduces makespan)\n    if len(new_solution) > 1:\n        # Find the two closest routes in terms of depot distance\n        min_dist = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                dist = distance_matrix[new_solution[i][-2], new_solution[j][1]]  # distance between last node of i and first node of j\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair is not None:\n            i, j = best_pair\n            # Check if merging is feasible\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # Merge the routes\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Step 2: Try to swap nodes between routes to improve total distance\n    for _ in range(3):  # Try multiple swaps\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1_idx, route2_idx = route_indices\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 3 or len(route2) <= 3:  # Skip trivial routes\n            continue\n\n        # Select random nodes from each route (not depot)\n        node1_pos = random.randint(1, len(route1)-2)\n        node2_pos = random.randint(1, len(route2)-2)\n        node1 = route1[node1_pos]\n        node2 = route2[node2_pos]\n\n        # Check capacity constraints after swap\n        new_route1 = route1.copy()\n        new_route1[node1_pos] = node2\n        new_route2 = route2.copy()\n        new_route2[node2_pos] = node1\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n\n            # Calculate distance change\n            old_dist = (distance_matrix[route1[node1_pos-1], node1] +\n                        distance_matrix[node1, route1[node1_pos+1]] +\n                        distance_matrix[route2[node2_pos-1], node2] +\n                        distance_matrix[node2, route2[node2_pos+1]])\n\n            new_dist = (distance_matrix[route1[node1_pos-1], node2] +\n                        distance_matrix[node2, route1[node1_pos+1]] +\n                        distance_matrix[route2[node2_pos-1], node1] +\n                        distance_matrix[node1, route2[node2_pos+1]])\n\n            if new_dist < old_dist:  # Only accept if distance improves\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.46272196370130647,
            0.4604072868824005
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive with a good balance between total distance and makespan, then applies a hybrid local search combining route merging, split-and-reinsertion, and demand-aware swaps to improve both objectives while maintaining feasibility through capacity checks. The selection prioritizes solutions with lower average objective values, while the hybrid search focuses on reducing route length imbalances and improving overall efficiency through strategic route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between distance and makespan\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route merging (if routes are short)\n        merged = False\n        for i in range(len(solution)):\n            if merged:\n                break\n            for j in range(i + 1, len(solution)):\n                route1 = solution[i]\n                route2 = solution[j]\n                combined_route = np.concatenate([route1[:-1], route2[1:]])\n                total_demand = sum(demand[node] for node in combined_route if node != 0)\n\n                if total_demand <= capacity:\n                    # Check if merging reduces makespan\n                    dist1 = sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1))\n                    dist2 = sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1))\n                    new_dist = sum(distance_matrix[combined_route[k]][combined_route[k+1]] for k in range(len(combined_route)-1))\n\n                    if new_dist <= max(dist1, dist2):\n                        solution[i] = combined_route\n                        del solution[j]\n                        merged = True\n                        break\n\n        # Step 2: Split-and-reinsert (if routes are long)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 4:  # Only consider long routes\n                for split_pos in range(2, len(route)-2):\n                    part1 = route[:split_pos+1]\n                    part2 = route[split_pos:]\n                    part1_demand = sum(demand[node] for node in part1 if node != 0)\n                    part2_demand = sum(demand[node] for node in part2 if node != 0)\n\n                    if part1_demand <= capacity and part2_demand <= capacity:\n                        # Try to reinsert part2 into another route\n                        for j in range(len(solution)):\n                            if i == j:\n                                continue\n                            combined = np.concatenate([solution[j][:-1], part2[1:]])\n                            combined_demand = sum(demand[node] for node in combined if node != 0)\n\n                            if combined_demand <= capacity:\n                                solution[i] = part1\n                                solution[j] = combined\n                                break\n\n        # Step 3: Demand-aware swaps (within routes)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 3:\n                for a in range(1, len(route)-2):\n                    for b in range(a+1, len(route)-1):\n                        # Check if swapping nodes a and b improves balance\n                        new_route = route.copy()\n                        new_route[a], new_route[b] = new_route[b], new_route[a]\n\n                        # Check capacity constraints\n                        part1 = new_route[:a+1]\n                        part2 = new_route[a:b+1]\n                        part3 = new_route[b:]\n\n                        if (sum(demand[node] for node in part1 if node != 0) <= capacity and\n                            sum(demand[node] for node in part2 if node != 0) <= capacity and\n                            sum(demand[node] for node in part3 if node != 0) <= capacity):\n\n                            # Check if swap improves balance\n                            dist_original = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n                            dist_new = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n\n                            if dist_new <= dist_original:\n                                solution[i] = new_route\n                                break\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure solution is feasible\n    for route in new_solution:\n        total_demand = sum(demand[node] for node in route if node != 0)\n        if total_demand > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.7331149904954284,
            10.16728326678276
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with better makespan first, then applies a hybrid local search combining route splitting and customer swapping with temporary capacity relaxation, followed by feasibility restoration, and uses tournament selection to retain the most improved solution after operations. It intelligently selects promising solutions from the archive, applies aggressive exploration, and ensures feasibility through demand redistribution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    # Select top 5 solutions, then randomly pick one\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer swapping\n    for _ in range(5):  # More iterations for more exploration\n        # Randomly select two different routes\n        if len(new_solution) < 2:\n            break\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1_idx, route2_idx = route_indices\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to split a route into two\n        if len(route1) > 4:  # Ensure route is long enough to split\n            split_pos = random.randint(2, len(route1) - 3)\n            new_route1 = route1[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route1[split_pos + 1:]])\n\n            # Check capacity feasibility (allow temporary violations)\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Try to swap customers between routes\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customers from each route\n            cust1_pos = random.randint(1, len(route1) - 2)\n            cust2_pos = random.randint(1, len(route2) - 2)\n            cust1 = route1[cust1_pos]\n            cust2 = route2[cust2_pos]\n\n            # Calculate new demands\n            new_demand1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n            new_demand2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n            # Allow temporary violations, but check later\n            if new_demand1 <= capacity * 1.2 and new_demand2 <= capacity * 1.2:\n                # Perform swap\n                route1[cust1_pos] = cust2\n                route2[cust2_pos] = cust1\n\n    # Restore feasibility by redistributing customers\n    for route in new_solution:\n        while np.sum(demand[route[1:-1]]) > capacity:\n            # Find the customer with largest demand\n            customers = route[1:-1]\n            if len(customers) == 0:\n                break\n            largest_cust = customers[np.argmax(demand[customers])]\n            # Move to a new route\n            new_route = np.array([0, largest_cust, 0])\n            new_solution.append(new_route)\n            # Remove from current route\n            route[route == largest_cust] = 0\n            route = np.array([x for x in route if x != 0])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Tournament selection: keep the best solution after operations\n    candidates = [base_solution, new_solution]\n    best_candidate = min(candidates, key=lambda x: (sum(len(route) - 1 for route in x), max(len(route) - 1 for route in x)))\n\n    return best_candidate\n\n",
        "score": [
            -0.5956286579761156,
            2.6354566514492035
        ]
    },
    {
        "algorithm": "The algorithm combines spatial clustering with adaptive route balancing to generate high-quality solutions for the Bi-CVRP. It first selects a promising solution from the archive, then applies a modified k-means clustering (prioritizing demand-weighted positions) to reorganize customers into capacity-feasible routes. A second phase adaptively merges nearby routes when feasible, balancing total distance and makespan while maintaining vehicle capacity constraints. The method dynamically adjusts its operations based on spatial proximity and demand patterns, with a focus on reducing the longest route while minimizing total travel distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Initialize new solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Spatial clustering with demand awareness\n    all_customers = []\n    route_indices = []\n    for route_idx, route in enumerate(new_solution):\n        customers = route[1:-1]\n        if len(customers) > 0:\n            all_customers.extend(customers)\n            route_indices.extend([route_idx] * len(customers))\n\n    if len(all_customers) == 0:\n        return new_solution\n\n    # Determine number of clusters (between 1 and len(new_solution))\n    k = max(1, min(len(new_solution), len(all_customers) // 2))\n\n    # Modified k-means clustering considering demand and distance\n    customer_coords = coords[all_customers]\n    customer_demands = demand[all_customers]\n\n    # Initialize centroids\n    centroids = customer_coords[np.random.choice(len(all_customers), k, replace=False)]\n\n    for _ in range(5):  # k-means iterations\n        # Assign customers to nearest centroid\n        distances = np.linalg.norm(customer_coords[:, np.newaxis] - centroids, axis=2)\n        clusters = np.argmin(distances, axis=1)\n\n        # Update centroids with demand-weighted positions\n        new_centroids = np.zeros((k, 2))\n        total_demands = np.zeros(k)\n        for i in range(k):\n            cluster_mask = (clusters == i)\n            if np.any(cluster_mask):\n                cluster_coords = customer_coords[cluster_mask]\n                cluster_demands = customer_demands[cluster_mask]\n                new_centroids[i] = np.average(cluster_coords, axis=0, weights=cluster_demands)\n                total_demands[i] = np.sum(cluster_demands)\n\n        # Check for convergence\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n\n    # Create new routes from clusters\n    new_routes = []\n    for i in range(k):\n        cluster_mask = (clusters == i)\n        if not np.any(cluster_mask):\n            continue\n\n        cluster_customers = np.array(all_customers)[cluster_mask]\n        cluster_demand = total_demands[i]\n\n        # If cluster exceeds capacity, split it\n        if cluster_demand > capacity:\n            # Sort customers by distance to centroid\n            centroid = centroids[i]\n            dist_to_centroid = np.linalg.norm(coords[cluster_customers] - centroid, axis=1)\n            sorted_indices = np.argsort(dist_to_centroid)\n            sorted_customers = cluster_customers[sorted_indices]\n\n            # Greedy splitting\n            current_route = [0]\n            current_demand = 0.0\n            for customer in sorted_customers:\n                if current_demand + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_demand += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_routes.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_demand = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n        else:\n            # Create a single route for the cluster\n            route = [0] + list(cluster_customers) + [0]\n            new_routes.append(np.array(route))\n\n    # Phase 2: Adaptive route refinement\n    if len(new_routes) > 0:\n        # Try to merge small routes\n        for _ in range(2):\n            if len(new_routes) < 2:\n                break\n\n            # Find closest pair of routes\n            min_dist = float('inf')\n            best_pair = None\n            for i in range(len(new_routes)):\n                for j in range(i+1, len(new_routes)):\n                    route_i = new_routes[i]\n                    route_j = new_routes[j]\n\n                    if len(route_i) <= 2 or len(route_j) <= 2:\n                        continue\n\n                    # Calculate centroids\n                    centroid_i = np.mean(coords[route_i[1:-1]], axis=0)\n                    centroid_j = np.mean(coords[route_j[1:-1]], axis=0)\n                    dist = np.linalg.norm(centroid_i - centroid_j)\n\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pair = (i, j)\n\n            if best_pair is None:\n                break\n\n            i, j = best_pair\n            route_i = new_routes[i]\n            route_j = new_routes[j]\n\n            # Check capacity\n            total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n            if total_demand > capacity:\n                continue\n\n            # Merge routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_routes[i] = merged_route\n            new_routes.pop(j)\n\n    # Ensure we have at least one route\n    if len(new_routes) == 0:\n        # Fallback: create a single route with all customers\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n        if len(all_customers) > 0:\n            new_routes = [np.array([0] + all_customers + [0])]\n\n    return new_routes\n\n",
        "score": [
            -0.6063896771806969,
            7.871662378311157
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted selection strategy that prioritizes solutions with lower total distance and balanced makespan. It then applies a hybrid local search combining route merging (to reduce makespan) and node swapping (to improve total distance), ensuring feasibility by strict capacity checks at each step. The selection weights balance total distance and makespan, while the local search intelligently merges routes when beneficial and performs targeted node swaps to optimize distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = []\n    for sol, obj in archive:\n        # Higher weight for solutions with lower total distance and more balanced makespan\n        total_dist, makespan = obj\n        balance_factor = 1 / (1 + abs(total_dist - makespan))  # Encourages balanced solutions\n        weight = (1 / (total_dist + 1e-6)) * balance_factor\n        weights.append(weight)\n\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + node swapping\n    # Step 1: Try to merge two routes if it reduces makespan\n    if len(new_solution) > 1:\n        best_merge = None\n        min_makespan_diff = float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Check capacity constraint\n                if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) > capacity:\n                    continue\n\n                # Calculate potential merged route\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Calculate makespan difference\n                original_makespan = max(\n                    distance_matrix[route1[:-1], np.roll(route1[1:], -1)].sum(),\n                    distance_matrix[route2[:-1], np.roll(route2[1:], -1)].sum()\n                )\n                new_makespan = distance_matrix[merged_route[:-1], np.roll(merged_route[1:], -1)].sum()\n                makespan_diff = new_makespan - original_makespan\n\n                if makespan_diff < min_makespan_diff:\n                    min_makespan_diff = makespan_diff\n                    best_merge = (i, j, merged_route)\n\n        if best_merge is not None and min_makespan_diff < 0:\n            i, j, merged_route = best_merge\n            # Remove the two routes and add the merged one\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(merged_route)\n\n    # Step 2: Try to swap nodes between routes to improve total distance\n    for _ in range(3):  # Try multiple swaps\n        if len(new_solution) < 2:\n            break\n\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) <= 2 or len(route2) <= 2:  # Skip trivial routes\n            continue\n\n        # Select random nodes to swap (not depot)\n        node1_pos = random.randint(1, len(route1)-2)\n        node2_pos = random.randint(1, len(route2)-2)\n        node1 = route1[node1_pos]\n        node2 = route2[node2_pos]\n\n        # Check capacity constraints after swap\n        if (np.sum(demand[route1[1:-1]]) - demand[node1] + demand[node2] > capacity or\n            np.sum(demand[route2[1:-1]]) - demand[node2] + demand[node1] > capacity):\n            continue\n\n        # Calculate distance change\n        # Original distances\n        orig_dist1 = (distance_matrix[route1[node1_pos-1], node1] +\n                      distance_matrix[node1, route1[node1_pos+1]])\n        orig_dist2 = (distance_matrix[route2[node2_pos-1], node2] +\n                      distance_matrix[node2, route2[node2_pos+1]])\n\n        # New distances after swap\n        new_dist1 = (distance_matrix[route1[node1_pos-1], node2] +\n                     distance_matrix[node2, route1[node1_pos+1]])\n        new_dist2 = (distance_matrix[route2[node2_pos-1], node1] +\n                     distance_matrix[node1, route2[node2_pos+1]])\n\n        # Calculate total distance change\n        delta = (new_dist1 + new_dist2) - (orig_dist1 + orig_dist2)\n\n        if delta < 0:  # Only accept if improvement\n            # Perform the swap\n            route1[node1_pos] = node2\n            route2[node2_pos] = node1\n\n    return new_solution\n\n",
        "score": [
            -0.508749651812878,
            0.5716311037540436
        ]
    }
]