[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection (prioritizing lower makespan and total distance), then applies a hybrid local search combining route splitting (to reduce makespan) and node reinsertion (to improve total distance), ensuring feasibility by checking vehicle capacity constraints at each step. The method intelligently balances both objectives by iteratively refining the solution through these targeted operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = []\n    for sol, obj in archive:\n        # Higher weight for solutions with lower makespan or total distance\n        weight = 1 / (obj[1] + obj[0] + 1e-6)  # Avoid division by zero\n        weights.append(weight)\n\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting + node reinsertion\n    # Step 1: Try to split a route into two if it's too long (makespan reduction)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find a split point that minimizes the increase in total distance\n        best_split = None\n        min_increase = float('inf')\n        for j in range(1, len(route)-1):\n            # Split after node j\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n\n            # Check capacity constraints\n            if (np.sum(demand[first_part[1:-1]]) > capacity) or (np.sum(demand[second_part[1:-1]]) > capacity):\n                continue\n\n            # Calculate increase in total distance\n            increase = (distance_matrix[route[j], 0] + distance_matrix[0, route[j+1]]) - distance_matrix[route[j], route[j+1]]\n            if increase < min_increase:\n                min_increase = increase\n                best_split = j\n\n        if best_split is not None:\n            j = best_split\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n            new_solution[i] = first_part\n            new_solution.append(second_part)\n            break  # Only split one route per iteration\n\n    # Step 2: Try to reinsert a node from a route to another to improve total distance\n    for _ in range(2):  # Try a few reinsertions\n        if len(new_solution) < 2:\n            break\n\n        # Select a random route to take a node from\n        from_route_idx = random.randint(0, len(new_solution)-1)\n        from_route = new_solution[from_route_idx]\n        if len(from_route) <= 3:  # Skip trivial routes\n            continue\n\n        # Select a random node to move (not depot)\n        node_pos = random.randint(1, len(from_route)-2)\n        node = from_route[node_pos]\n\n        # Try to insert into another route\n        best_insertion = None\n        min_increase = float('inf')\n        for to_route_idx in range(len(new_solution)):\n            if to_route_idx == from_route_idx:\n                continue\n\n            to_route = new_solution[to_route_idx]\n            # Check capacity constraint\n            if np.sum(demand[to_route[1:-1]]) + demand[node] > capacity:\n                continue\n\n            # Try inserting after each node in the to_route\n            for pos in range(len(to_route)-1):\n                # Insert after to_route[pos]\n                # Calculate increase in distance\n                increase = (distance_matrix[to_route[pos], node] +\n                           distance_matrix[node, to_route[pos+1]] -\n                           distance_matrix[to_route[pos], to_route[pos+1]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_insertion = (to_route_idx, pos, node)\n\n        if best_insertion is not None:\n            to_route_idx, pos, node = best_insertion\n            # Remove from original route\n            new_solution[from_route_idx] = np.delete(new_solution[from_route_idx], node_pos)\n            # Insert into new route\n            new_solution[to_route_idx] = np.insert(new_solution[to_route_idx], pos+1, node)\n\n            # If route becomes empty, remove it\n            if len(new_solution[from_route_idx]) == 2:  # Only depot-depot\n                new_solution.pop(from_route_idx)\n            break  # Only one reinsertion per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.74727416385559,
            0.26535162329673767
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized distance and makespan (60% distance, 40% makespan), then applies a hybrid local search combining route fragmentation, customer reallocation, and route merging. It iteratively fragments long routes, reallocates customers between routes with capacity checks, and merges small routes while limiting route length to 20 nodes. The solution is refined through 5 iterations and finally normalized to remove empty routes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route fragmentation + customer reallocation + route merging\n    for _ in range(5):  # Perform 5 iterations\n        # Randomly select a route to fragment\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Fragment route at random point\n        split_pos = random.randint(2, len(route) - 2)\n        fragment = route[split_pos:]\n        remaining = route[:split_pos]\n\n        # Check capacity feasibility for fragments\n        if np.sum(demand[fragment[1:-1]]) <= capacity and np.sum(demand[remaining[1:-1]]) <= capacity:\n            new_solution[route_idx] = remaining\n            new_solution.append(fragment)\n\n        # Customer reallocation: move customers between routes\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select customers to move (up to 2)\n            customers_to_move = random.sample(range(1, len(route) - 1), min(2, len(route) - 2))\n\n            for customer_pos in sorted(customers_to_move, reverse=True):\n                customer = route[customer_pos]\n\n                # Find best insertion position in other route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                   distance_matrix[customer, other_route[pos]] -\n                                   distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Check capacity feasibility\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into other route\n                    new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from original route\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n                    route = new_route\n\n        # Route merging: try to merge small routes\n        if len(new_solution) > 1:\n            # Select two routes to potentially merge\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            # Check if merging is feasible\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 20):  # Limit route length\n\n                # Create merged route (route1 + route2 without depot)\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                # Update solution\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7532898215774322,
            0.30173933506011963
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing balanced objective solutions) and applies a hybrid local search that intelligently merges nearby routes when feasible (based on capacity and spatial proximity) and splits long routes into balanced parts to improve both total distance and makespan, while maintaining feasibility through demand checks. The method dynamically updates route centroids to guide spatial clustering, with a focus on reducing route imbalance and optimizing multi-objective trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate centroids for each route\n    route_centroids = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_centroids.append(np.zeros(2))\n            continue\n        customer_coords = coords[route[1:-1]]\n        centroid = np.mean(customer_coords, axis=0)\n        route_centroids.append(centroid)\n\n    # Route fusion: try to merge nearby routes\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find closest pair of routes\n        min_dist = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair is None:\n            break\n\n        i, j = best_pair\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging would exceed capacity\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand > capacity:\n            continue\n\n        # Merge the two routes\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        new_solution[i] = merged_route\n        new_solution.pop(j)\n        route_centroids.pop(j)\n\n        # Recalculate centroid for merged route\n        if len(merged_route) > 2:\n            customer_coords = coords[merged_route[1:-1]]\n            route_centroids[i] = np.mean(customer_coords, axis=0)\n        else:\n            route_centroids[i] = np.zeros(2)\n\n    # Route fragmentation: split long routes into balanced parts\n    for _ in range(2):\n        if len(new_solution) >= len(base_solution) + 2:\n            break\n\n        # Find the longest route\n        longest_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        route = new_solution[longest_idx]\n\n        if len(route) <= 4:  # Skip if route is too short\n            continue\n\n        # Find a balanced split point\n        best_split = None\n        min_diff = float('inf')\n        total_demand = np.sum(demand[route[1:-1]])\n\n        for j in range(2, len(route)-2):\n            left_demand = np.sum(demand[route[1:j+1]])\n            right_demand = total_demand - left_demand\n\n            # Check if both parts would fit within capacity\n            if left_demand <= capacity and right_demand <= capacity:\n                diff = abs(left_demand - right_demand)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_split = j\n\n        if best_split is not None:\n            j = best_split\n            first_part = route[:j+1] + [0]\n            second_part = [0] + route[j+1:]\n\n            new_solution[longest_idx] = first_part\n            new_solution.append(second_part)\n\n            # Update centroids\n            if len(first_part) > 2:\n                customer_coords = coords[first_part[1:-1]]\n                route_centroids[longest_idx] = np.mean(customer_coords, axis=0)\n            else:\n                route_centroids[longest_idx] = np.zeros(2)\n\n            if len(second_part) > 2:\n                customer_coords = coords[second_part[1:-1]]\n                route_centroids.append(np.mean(customer_coords, axis=0))\n            else:\n                route_centroids.append(np.zeros(2))\n\n    return new_solution\n\n",
        "score": [
            -0.7462077011654622,
            0.5622931718826294
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive with a good balance between total distance and makespan, then applies a hybrid local search combining route merging, split-and-reinsertion, and demand-aware swaps to improve both objectives while maintaining feasibility through capacity checks. The selection prioritizes solutions with lower average objective values, while the hybrid search focuses on reducing route length imbalances and improving overall efficiency through strategic route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between distance and makespan\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route merging (if routes are short)\n        merged = False\n        for i in range(len(solution)):\n            if merged:\n                break\n            for j in range(i + 1, len(solution)):\n                route1 = solution[i]\n                route2 = solution[j]\n                combined_route = np.concatenate([route1[:-1], route2[1:]])\n                total_demand = sum(demand[node] for node in combined_route if node != 0)\n\n                if total_demand <= capacity:\n                    # Check if merging reduces makespan\n                    dist1 = sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1))\n                    dist2 = sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1))\n                    new_dist = sum(distance_matrix[combined_route[k]][combined_route[k+1]] for k in range(len(combined_route)-1))\n\n                    if new_dist <= max(dist1, dist2):\n                        solution[i] = combined_route\n                        del solution[j]\n                        merged = True\n                        break\n\n        # Step 2: Split-and-reinsert (if routes are long)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 4:  # Only consider long routes\n                for split_pos in range(2, len(route)-2):\n                    part1 = route[:split_pos+1]\n                    part2 = route[split_pos:]\n                    part1_demand = sum(demand[node] for node in part1 if node != 0)\n                    part2_demand = sum(demand[node] for node in part2 if node != 0)\n\n                    if part1_demand <= capacity and part2_demand <= capacity:\n                        # Try to reinsert part2 into another route\n                        for j in range(len(solution)):\n                            if i == j:\n                                continue\n                            combined = np.concatenate([solution[j][:-1], part2[1:]])\n                            combined_demand = sum(demand[node] for node in combined if node != 0)\n\n                            if combined_demand <= capacity:\n                                solution[i] = part1\n                                solution[j] = combined\n                                break\n\n        # Step 3: Demand-aware swaps (within routes)\n        for i in range(len(solution)):\n            route = solution[i]\n            if len(route) > 3:\n                for a in range(1, len(route)-2):\n                    for b in range(a+1, len(route)-1):\n                        # Check if swapping nodes a and b improves balance\n                        new_route = route.copy()\n                        new_route[a], new_route[b] = new_route[b], new_route[a]\n\n                        # Check capacity constraints\n                        part1 = new_route[:a+1]\n                        part2 = new_route[a:b+1]\n                        part3 = new_route[b:]\n\n                        if (sum(demand[node] for node in part1 if node != 0) <= capacity and\n                            sum(demand[node] for node in part2 if node != 0) <= capacity and\n                            sum(demand[node] for node in part3 if node != 0) <= capacity):\n\n                            # Check if swap improves balance\n                            dist_original = sum(distance_matrix[route[k]][route[k+1]] for k in range(len(route)-1))\n                            dist_new = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n\n                            if dist_new <= dist_original:\n                                solution[i] = new_route\n                                break\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure solution is feasible\n    for route in new_solution:\n        total_demand = sum(demand[node] for node in route if node != 0)\n        if total_demand > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.7331149904954284,
            10.16728326678276
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with better makespan first, then applies a hybrid local search combining route splitting and customer swapping with temporary capacity relaxation, followed by feasibility restoration, and uses tournament selection to retain the most improved solution after operations. It intelligently selects promising solutions from the archive, applies aggressive exploration, and ensures feasibility through demand redistribution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    # Select top 5 solutions, then randomly pick one\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer swapping\n    for _ in range(5):  # More iterations for more exploration\n        # Randomly select two different routes\n        if len(new_solution) < 2:\n            break\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1_idx, route2_idx = route_indices\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to split a route into two\n        if len(route1) > 4:  # Ensure route is long enough to split\n            split_pos = random.randint(2, len(route1) - 3)\n            new_route1 = route1[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route1[split_pos + 1:]])\n\n            # Check capacity feasibility (allow temporary violations)\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[route1_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Try to swap customers between routes\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customers from each route\n            cust1_pos = random.randint(1, len(route1) - 2)\n            cust2_pos = random.randint(1, len(route2) - 2)\n            cust1 = route1[cust1_pos]\n            cust2 = route2[cust2_pos]\n\n            # Calculate new demands\n            new_demand1 = np.sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n            new_demand2 = np.sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n            # Allow temporary violations, but check later\n            if new_demand1 <= capacity * 1.2 and new_demand2 <= capacity * 1.2:\n                # Perform swap\n                route1[cust1_pos] = cust2\n                route2[cust2_pos] = cust1\n\n    # Restore feasibility by redistributing customers\n    for route in new_solution:\n        while np.sum(demand[route[1:-1]]) > capacity:\n            # Find the customer with largest demand\n            customers = route[1:-1]\n            if len(customers) == 0:\n                break\n            largest_cust = customers[np.argmax(demand[customers])]\n            # Move to a new route\n            new_route = np.array([0, largest_cust, 0])\n            new_solution.append(new_route)\n            # Remove from current route\n            route[route == largest_cust] = 0\n            route = np.array([x for x in route if x != 0])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Tournament selection: keep the best solution after operations\n    candidates = [base_solution, new_solution]\n    best_candidate = min(candidates, key=lambda x: (sum(len(route) - 1 for route in x), max(len(route) - 1 for route in x)))\n\n    return best_candidate\n\n",
        "score": [
            -0.5956286579761156,
            2.6354566514492035
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a high-potential solution from the archive (prioritizing those with high makespan or total distance) and applies a hybrid local search combining route merging, demand-aware customer reinsertion, and route balancing to reduce the longest route while minimizing total distance, ensuring feasibility through capacity checks. The method avoids standard 2-opt by incorporating novel route transformations and demand-aware placement, focusing on balancing objectives through strategic customer reallocation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route merging, customer reinsertion, and route balancing\n    new_solution = selected.copy()\n\n    # Step 1: Route Merging - try to merge two routes if possible\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[i][1:-1]  # exclude depots\n        route2 = new_solution[j][1:-1]\n        merged_route = np.concatenate([[0], route1, route2, [0]])\n        total_demand = np.sum(demand[merged_route])\n\n        if total_demand <= capacity:\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in [i, j]]\n            new_solution.append(merged_route)\n            # Re-optimize the merged route (simple 2-opt for demonstration)\n            for _ in range(2):  # limit iterations\n                improved = False\n                for k in range(1, len(merged_route)-2):\n                    for l in range(k+1, len(merged_route)-1):\n                        new_route = merged_route.copy()\n                        new_route[k:l+1] = new_route[k:l+1][::-1]\n                        if np.sum(demand[new_route]) <= capacity:\n                            merged_route = new_route\n                            improved = True\n                            break\n                    if improved:\n                        break\n            new_solution[-1] = merged_route\n\n    # Step 2: Customer Reinsertion with Demand-Aware Placement\n    if len(new_solution) > 0:\n        # Select a random route and remove a customer\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx]\n        if len(route) > 3:  # at least one customer\n            cust_idx = np.random.randint(1, len(route)-1)\n            removed_customer = route[cust_idx]\n            route = np.delete(route, cust_idx)\n            new_solution[route_idx] = route\n\n            # Find best insertion position in the same route\n            best_pos = -1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                new_route = np.insert(route, pos, removed_customer)\n                if np.sum(demand[new_route]) <= capacity:\n                    cost = distance_matrix[new_route[pos-1]][new_route[pos]] + distance_matrix[new_route[pos]][new_route[pos+1]] - distance_matrix[new_route[pos-1]][new_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            if best_pos != -1:\n                new_route = np.insert(route, best_pos, removed_customer)\n                new_solution[route_idx] = new_route\n\n    # Step 3: Route Balancing - try to reduce the longest route\n    if len(new_solution) > 1:\n        longest_route_idx = np.argmax([np.sum(distance_matrix[r[:-1], r[1:]]) for r in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Try to move a customer to another route\n        for cust_idx in range(1, len(longest_route)-1):\n            customer = longest_route[cust_idx]\n            temp_route = np.delete(longest_route, cust_idx)\n\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == longest_route_idx:\n                    continue\n                other_route = new_solution[other_route_idx]\n\n                # Find best insertion position in other route\n                best_pos = -1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    new_other_route = np.insert(other_route, pos, customer)\n                    if np.sum(demand[new_other_route]) <= capacity:\n                        cost = distance_matrix[new_other_route[pos-1]][new_other_route[pos]] + distance_matrix[new_other_route[pos]][new_other_route[pos+1]] - distance_matrix[new_other_route[pos-1]][new_other_route[pos+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                if best_pos != -1:\n                    new_other_route = np.insert(other_route, best_pos, customer)\n                    if np.sum(demand[temp_route]) <= capacity:\n                        new_solution[longest_route_idx] = temp_route\n                        new_solution[other_route_idx] = new_other_route\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7007415985502181,
            10.47944888472557
        ]
    },
    {
        "algorithm": "The algorithm selects a high-quality solution from the archive using weighted random selection, then applies a hybrid local search combining customer reallocation, capacity-aware edge swaps, and route merging to generate a feasible neighbor solution, prioritizing solutions with lower combined objective values while ensuring all customers are served and vehicle capacity constraints are respected. The method intelligently combines multiple operators to explore the solution space while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    # Hybrid local search: combine multiple operators\n    new_solution = []\n    for route in base_solution:\n        new_route = route.copy()\n        # Operator 1: Random customer reallocation (with capacity check)\n        if len(new_route) > 3:\n            i = random.randint(1, len(new_route)-2)\n            customer = new_route[i]\n            # Try to move to another route\n            for other_route in base_solution:\n                if other_route is not new_route:\n                    # Check capacity\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert at best position\n                        min_cost = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[pos-1], customer] +\n                                    distance_matrix[customer, other_route[pos]] -\n                                    distance_matrix[other_route[pos-1], other_route[pos]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = pos\n                        other_route = np.insert(other_route, best_pos, customer)\n                        new_route = np.delete(new_route, i)\n                        break\n        # Operator 2: Capacity-aware edge swap\n        if len(new_route) > 4:\n            i = random.randint(1, len(new_route)-3)\n            j = random.randint(i+1, len(new_route)-2)\n            # Check if swap maintains capacity\n            if (np.sum(demand[new_route[1:i]]) + demand[new_route[j]] <= capacity and\n                np.sum(demand[new_route[1:j]]) + demand[new_route[i]] <= capacity):\n                new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_solution.append(new_route)\n\n    # Operator 3: Route merging (if two routes can be merged)\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[i], new_solution[j]\n        # Check if merging is possible\n        if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n            distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], route1[1]] <\n            distance_matrix[route1[-2], 0] + distance_matrix[route2[-2], 0]):\n            # Merge routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        # If not all customers are served, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5230175581420444,
            3.4554883539676666
        ]
    },
    {
        "algorithm": "The algorithm combines three key operations: route segment relocation with demand-based insertion, adaptive customer reinsertion based on spatial proximity, and capacity-aware route splitting, while intelligently selecting high-quality solutions from the archive and ensuring feasibility by dynamically adjusting routes and validating customer coverage. It prioritizes demand constraints and spatial proximity during reinsertion while probabilistically balancing exploration of different transformation strategies to effectively trade off distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=scores, k=1)[0]\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    new_solution = []\n    for route in base_solution:\n        new_route = route.copy()\n        # Route segment relocation with demand-based insertion\n        if len(new_route) > 4:\n            # Select a random segment\n            start = random.randint(1, len(new_route)-3)\n            end = random.randint(start+1, len(new_route)-2)\n            segment = new_route[start:end+1]\n\n            # Try to insert segment into another route\n            for other_route in base_solution:\n                if other_route is not new_route:\n                    # Check capacity\n                    if np.sum(demand[segment[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                        # Find best insertion position\n                        min_cost = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[pos-1], segment[0]] +\n                                   distance_matrix[segment[-1], other_route[pos]] -\n                                   distance_matrix[other_route[pos-1], other_route[pos]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = pos\n                        # Insert segment\n                        other_route = np.concatenate([other_route[:best_pos], segment, other_route[best_pos:]])\n                        new_route = np.concatenate([new_route[:start], new_route[end+1:]])\n                        break\n\n        # Adaptive customer reinsertion based on spatial proximity\n        if len(new_route) > 3:\n            # Select a random customer\n            customer_pos = random.randint(1, len(new_route)-2)\n            customer = new_route[customer_pos]\n\n            # Find routes where customer might fit better based on distance\n            candidate_routes = []\n            for other_route in base_solution:\n                if other_route is not new_route:\n                    # Check capacity and distance to nearest node\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Find closest position\n                        min_dist = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(other_route)):\n                            dist = distance_matrix[other_route[pos-1], customer] + distance_matrix[customer, other_route[pos]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = pos\n                        candidate_routes.append((other_route, best_pos, min_dist))\n\n            # Insert into route with lowest distance increase\n            if candidate_routes:\n                best_route, best_pos, _ = min(candidate_routes, key=lambda x: x[2])\n                best_route = np.insert(best_route, best_pos, customer)\n                new_route = np.delete(new_route, customer_pos)\n\n        new_solution.append(new_route)\n\n    # Capacity-aware route splitting\n    for route in new_solution[:]:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find split point that minimizes capacity violation\n            best_split = 1\n            min_violation = float('inf')\n            for i in range(1, len(route)-1):\n                left_demand = np.sum(demand[route[1:i+1]])\n                right_demand = np.sum(demand[route[i+1:-1]])\n                violation = max(0, left_demand - capacity) + max(0, right_demand - capacity)\n                if violation < min_violation:\n                    min_violation = violation\n                    best_split = i\n\n            # Split the route\n            new_route1 = np.concatenate([route[:best_split+1], [0]])\n            new_route2 = np.concatenate([[0], route[best_split+1:]])\n            new_solution.remove(route)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [route for route in new_solution if len(route) > 2]\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    if served_customers != all_customers:\n        # If not all customers served, revert to original solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.540416581454072,
            4.210382759571075
        ]
    }
]