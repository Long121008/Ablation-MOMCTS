[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-stage hybrid local search that prioritizes balanced solutions (70% distance, 30% makespan) and applies demand-aware route fragmentation, route reversal, customer reallocation with demand pattern matching, and route merging operations iteratively to improve solutions while maintaining feasibility. It intelligently targets customers with similar demand patterns and routes with complementary load characteristics to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.7 + weights[:, 1] * 0.3\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(6):  # Perform 6 iterations of the hybrid operator\n        # Stage 1: Demand-aware route fragmentation\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find split point that balances demand\n                total_demand = np.sum(demand[route[1:-1]])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Route reversal with capacity check\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Customer reallocation with demand pattern matching\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customers with similar demand patterns\n                route_demand = demand[route[1:-1]]\n                median_demand = np.median(route_demand)\n                similar_customers = [i for i, d in enumerate(route_demand)\n                                   if abs(d - median_demand) <= median_demand * 0.3]\n\n                if similar_customers:\n                    customer_pos = random.choice(similar_customers) + 1\n                    customer = route[customer_pos]\n\n                    # Find best route to insert based on demand compatibility\n                    best_route_idx = -1\n                    best_pos = -1\n                    min_demand_diff = float('inf')\n\n                    for other_idx, other_route in enumerate(new_solution):\n                        if other_idx == route_idx:\n                            continue\n\n                        other_demand = np.sum(demand[other_route[1:-1]])\n                        if other_demand + demand[customer] > capacity:\n                            continue\n\n                        for pos in range(1, len(other_route)):\n                            new_demand = other_demand + demand[customer]\n                            demand_diff = abs(new_demand - capacity/2)\n\n                            if demand_diff < min_demand_diff:\n                                min_demand_diff = demand_diff\n                                best_route_idx = other_idx\n                                best_pos = pos\n\n                    if best_route_idx != -1:\n                        other_route = new_solution[best_route_idx]\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            [customer],\n                            other_route[best_pos:]\n                        ])\n                        new_solution[best_route_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n        # Stage 4: Route merging with load balancing\n        if len(new_solution) > 1:\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 25):\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8703280146268155,
            1.1190491020679474
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects solutions from the archive using non-linear weighted objectives, applying a hybrid local search that combines adaptive route fragmentation (balancing demand and distance), demand-sensitive customer reallocation, probabilistic route merging (with capacity-aware criteria), and an adaptive customer exchange operator (prioritizing distance and demand balance). It emphasizes extreme solutions through exponential weighting and adjusts operator probabilities based on solution characteristics.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    # Normalize with non-linear scaling\n    norm_dist = (distances - min_dist) / (max_dist - min_dist + 1e-6)\n    norm_makespan = (makespans - min_makespan) / (max_makespan - min_makespan + 1e-6)\n\n    # Exponential weighting to emphasize extreme solutions\n    weight_dist = np.exp(-norm_dist * 0.5)\n    weight_makespan = np.exp(-norm_makespan * 0.5)\n\n    # Combine with adaptive focus\n    scores = weight_dist * norm_dist + weight_makespan * norm_makespan\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with adaptive operators\n    for _ in range(4):  # Increased iterations for better exploration\n        # Adaptive route fragmentation based on demand and distance\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:  # Only split if route is long enough\n                total_demand = np.sum(demand[route[1:-1]])\n                route_distance = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n\n                # Find split position that balances both demand and distance\n                best_split = 1\n                best_balance = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_demand = np.sum(demand[route[1:i+1]])\n                    current_dist = sum(distance_matrix[route[j-1], route[j]] for j in range(1, i+1))\n\n                    # Balance score combines demand and distance balance\n                    balance_score = abs((current_demand / total_demand) - 0.5) + \\\n                                  abs((current_dist / route_distance) - 0.5)\n\n                    if balance_score < best_balance:\n                        best_balance = balance_score\n                        best_split = i\n\n                fragment = route[best_split:]\n                remaining = route[:best_split+1]\n\n                if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                    np.sum(demand[remaining[1:-1]]) <= capacity):\n                    new_solution[route_idx] = remaining\n                    new_solution.append(fragment)\n\n        # Demand-sensitive customer reallocation\n        if len(new_solution) > 1:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customers based on demand and distance to depot\n                customers = sorted(range(1, len(source_route)-1),\n                                key=lambda x: demand[source_route[x]] * distance_matrix[0, source_route[x]],\n                                reverse=True)\n\n                num_to_move = min(3, len(customers))  # Move up to 3 customers\n\n                for customer_pos in customers[:num_to_move]:\n                    customer = source_route[customer_pos]\n\n                    # Find best insertion considering both distance and demand impact\n                    best_pos = 1\n                    best_score = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        dist_increase = (distance_matrix[target_route[pos-1], customer] +\n                                       distance_matrix[customer, target_route[pos]] -\n                                       distance_matrix[target_route[pos-1], target_route[pos]])\n\n                        # Demand impact score considers both current and potential demand\n                        current_demand = np.sum(demand[target_route[1:-1]])\n                        new_demand = current_demand + demand[customer]\n\n                        demand_score = abs(new_demand - capacity/2)  # Prefer medium demand routes\n\n                        # Distance to depot factor\n                        depot_dist_factor = distance_matrix[0, customer] / np.max(distance_matrix[0, :])\n\n                        total_score = dist_increase + 0.4 * demand_score + 0.3 * depot_dist_factor\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_pos = pos\n\n                    if (np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                        len(target_route) + 1 <= 25):  # Increased route length limit\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:customer_pos],\n                                                         source_route[customer_pos+1:]])\n                        new_solution[source_idx] = new_source_route\n\n        # Capacity-aware route merging\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            length1 = len(route1)\n            length2 = len(route2)\n\n            # More aggressive merging probability based on capacity utilization\n            merge_prob = min(0.9, 0.3 + 0.6 * (1 - abs(demand1 - demand2) / (total_demand + 1e-6)) +\n                           0.4 * (25 - (length1 + length2 - 2)) / 25)\n\n            if random.random() < merge_prob and total_demand <= capacity:\n                # Consider both direct and reverse merging\n                direct_merged = np.concatenate([route1[:-1], route2[1:]])\n                reverse_merged = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merging option with better distance\n                direct_dist = sum(distance_matrix[direct_merged[i-1], direct_merged[i]] for i in range(1, len(direct_merged)))\n                reverse_dist = sum(distance_matrix[reverse_merged[i-1], reverse_merged[i]] for i in range(1, len(reverse_merged)))\n\n                merged_route = direct_merged if direct_dist <= reverse_dist else reverse_merged\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    # Adaptive customer exchange operator\n    if len(new_solution) > 1 and random.random() < 0.4:  # Increased probability\n        swap_routes = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[swap_routes[0]], new_solution[swap_routes[1]]\n\n        # Consider multiple swap positions\n        best_swaps = []\n        best_score = float('inf')\n\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Calculate potential demand changes\n                new_demand1 = (np.sum(demand[route1[1:i]]) + demand[route2[j]] +\n                              np.sum(demand[route1[i+1:-1]]))\n                new_demand2 = (np.sum(demand[route2[1:j]]) + demand[route1[i]] +\n                              np.sum(demand[route2[j+1:-1]]))\n\n                if new_demand1 > capacity or new_demand2 > capacity:\n                    continue\n\n                # Calculate distance change\n                dist_change = (\n                    distance_matrix[route1[i-1], route2[j]] +\n                    distance_matrix[route2[j], route1[i+1]] -\n                    distance_matrix[route1[i-1], route1[i]] -\n                    distance_matrix[route1[i], route1[i+1]] +\n                    distance_matrix[route2[j-1], route1[i]] +\n                    distance_matrix[route1[i], route2[j+1]] -\n                    distance_matrix[route2[j-1], route2[j]] -\n                    distance_matrix[route2[j], route2[j+1]]\n                )\n\n                # Consider both demand balance and distance to depot\n                demand_balance = abs(new_demand1 - new_demand2)\n                depot_dist_factor = (distance_matrix[0, route1[i]] + distance_matrix[0, route2[j]]) / 2\n\n                total_score = dist_change + 0.4 * demand_balance + 0.2 * depot_dist_factor\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_swaps = [(i, j)]\n                elif total_score == best_score:\n                    best_swaps.append((i, j))\n\n        if best_swaps:\n            i, j = random.choice(best_swaps)\n            # Perform the swap\n            route1[i], route2[j] = route2[j], route1[i]\n            new_solution[swap_routes[0]] = route1\n            new_solution[swap_routes[1]] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.9282340368599087,
            1.7632462084293365
        ]
    },
    {
        "algorithm": "The algorithm first selects a promising solution from the archive using crowding distance to identify solutions in less explored regions of the Pareto front. It then applies a multi-stage hybrid local search: Stage 1 fragments high-demand routes, Stage 2 merges capacity-complementary routes, and Stage 3 reallocates customers using a weighted greedy approach that prioritizes distance (60%) and demand balance (40%). The method dynamically balances route operations while ensuring capacity feasibility, exploring trade-offs between total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(5):\n        # Stage 1: Demand-aware route fragmentation\n        if len(new_solution) > 1:\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            route_idx = np.argmax(demands)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                total_demand = np.sum(demand[route[1:-1]])\n                avg_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= avg_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Capacity-complementary merging\n        if len(new_solution) > 1:\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            candidates = []\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    if demands[i] + demands[j] <= capacity:\n                        candidates.append((i, j))\n\n            if candidates:\n                best_pair = min(candidates, key=lambda p: abs(demands[p[0]] + demands[p[1]] - capacity))\n                route1, route2 = new_solution[best_pair[0]], new_solution[best_pair[1]]\n\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in best_pair]\n                new_solution.append(merged_route)\n\n        # Stage 3: Weighted greedy reallocation\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        distance_cost = (distance_matrix[other_route[pos-1], customer] +\n                                       distance_matrix[customer, other_route[pos]] -\n                                       distance_matrix[other_route[pos-1], other_route[pos]])\n                        demand_cost = abs(other_demand + demand[customer] - capacity/2)\n\n                        score = 0.6 * distance_cost + 0.4 * demand_cost\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8779211226769548,
            1.6488251984119415
        ]
    },
    {
        "algorithm": "The algorithm combines crowding-distance-based solution selection with a multi-stage hybrid local search that prioritizes demand-complementary route splitting, capacity-aware route consolidation, and probabilistic demand-balanced customer reallocation. It explicitly balances trade-offs between total distance and makespan optimization by selecting solutions with high crowding distances and applying demand-aware transformations to improve solution quality while maintaining feasibility. The approach emphasizes capacity utilization and demand balance through probabilistic operators and complementary demand-based route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    # Normalize objectives\n    norm_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances))\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans))\n\n    # Calculate crowding distances\n    sorted_idx = np.argsort(norm_dist)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_makespan[sorted_idx[i+1]] - norm_makespan[sorted_idx[i-1]]\n\n    sorted_idx = np.argsort(norm_makespan)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_dist[sorted_idx[i+1]] - norm_dist[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(3):\n        # Stage 1: Demand-complementary route splitting\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                # Find customer with demand most complementary to route's average demand\n                route_demand = np.sum(demand[route[1:-1]])\n                avg_demand = route_demand / (len(route) - 2)\n                best_split = None\n                best_diff = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_diff = abs(demand[route[i]] - avg_demand)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_split = i\n\n                if best_split:\n                    split_pos = best_split\n                    fragment = route[split_pos:]\n                    remaining = route[:split_pos+1]\n\n                    if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                        np.sum(demand[remaining[1:-1]]) <= capacity):\n                        new_solution[route_idx] = remaining\n                        new_solution.append(fragment)\n\n        # Stage 2: Capacity-aware route consolidation\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            remaining_cap1 = capacity - demand1\n            remaining_cap2 = capacity - demand2\n\n            # Probability of merging based on capacity complementarity\n            merge_prob = 0.5 * (1 - abs(remaining_cap1 - remaining_cap2) / capacity) + 0.5\n\n            if random.random() < merge_prob and (demand1 + demand2) <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n        # Stage 3: Probabilistic demand-balanced customer reallocation\n        if len(new_solution) > 1 and random.random() < 0.4:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer whose demand is closest to target route's remaining capacity\n                target_demand = np.sum(demand[target_route[1:-1]])\n                remaining_cap = capacity - target_demand\n                best_customer = None\n                best_diff = float('inf')\n\n                for i in range(1, len(source_route)-1):\n                    current_diff = abs(demand[source_route[i]] - remaining_cap)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_customer = i\n\n                if best_customer:\n                    customer = source_route[best_customer]\n\n                    # Find best insertion position considering demand balance\n                    best_pos = 1\n                    best_balance = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_demand = target_demand + demand[customer]\n                        new_balance = abs(new_demand - capacity/2)  # Prefer balanced demand\n\n                        if new_balance < best_balance:\n                            best_balance = new_balance\n                            best_pos = pos\n\n                    if new_demand <= capacity:\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:best_customer],\n                                                         source_route[best_customer+1:]])\n                        new_solution[source_idx] = new_source_route\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7965868091436135,
            0.1786138117313385
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing lower makespan) and applies a hybrid local search combining route merging with probabilistic acceptance to balance distance and makespan objectives while ensuring feasibility through capacity checks. It intelligently merges routes by minimizing distance increases and occasionally accepts worse moves to escape local optima, dynamically updating the solution's objectives. The method focuses on improving both objectives through careful route combination and probabilistic exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging + probabilistic acceptance\n    for _ in range(3):  # Perform 3 iterations\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes to potentially merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand > capacity:\n            continue\n\n        # Find best merge point (minimizing distance increase)\n        best_merge = None\n        min_increase = float('inf')\n\n        # Try merging route2 into route1 at different positions\n        for pos in range(1, len(route1)):\n            # Calculate distance increase\n            increase = (distance_matrix[route1[pos-1], route2[1]] +\n                       distance_matrix[route2[-2], route1[pos]] -\n                       distance_matrix[route1[pos-1], route1[pos]])\n\n            if increase < min_increase:\n                min_increase = increase\n                best_merge = (pos, increase)\n\n        if best_merge is not None:\n            pos, increase = best_merge\n\n            # Calculate new objectives\n            old_distance = archive_sorted[selected_idx][1][0]\n            old_makespan = archive_sorted[selected_idx][1][1]\n\n            new_distance = old_distance + increase\n            new_makespan = max(old_makespan - distance_matrix[route1[-2], 0],\n                              distance_matrix[route1[pos-1], route2[1]] +\n                              np.sum(distance_matrix[route2[1:-1], route2[2:]]) +\n                              distance_matrix[route2[-2], route1[pos]])\n\n            # Probabilistic acceptance\n            if (new_distance < old_distance and new_makespan <= old_makespan) or \\\n               random.random() < 0.2:  # 20% chance to accept worse move\n                # Perform the merge\n                merged_route = np.concatenate([route1[:pos], route2[1:-1], route1[pos:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n                # Update current objectives\n                old_distance = new_distance\n                old_makespan = new_makespan\n\n    # Remove empty routes (if any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8087135813524513,
            0.8420414328575134
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-stage hybrid local search that first selects a solution with high crowding distance (indicating potential for improvement), then applies demand-aware route fragmentation, load-balanced merging, and hybrid customer reallocation to improve both distance and makespan objectives while maintaining feasibility. It prioritizes routes with high demand variance or imbalance and focuses on demand compatibility during customer reallocation, balancing the trade-off between the two objectives. The algorithm emphasizes route-level operations that respect vehicle capacity constraints while seeking to reduce both total travel distance and the longest route length.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(4):  # Perform 4 iterations\n        # Stage 1: Demand-aware route fragmentation\n        if len(new_solution) > 1:\n            # Select route with highest demand variance\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            route_idx = np.argmax(demands)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find split point that balances demand\n                total_demand = np.sum(demand[route[1:-1]])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Load-balanced route merging\n        if len(new_solution) > 1:\n            # Find two routes with complementary demands\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            avg_demand = np.mean(demands)\n            candidates = []\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    if demands[i] + demands[j] <= capacity:\n                        candidates.append((i, j))\n\n            if candidates:\n                # Select pair with most balanced demands\n                best_pair = min(candidates, key=lambda p: abs(demands[p[0]] + demands[p[1]] - avg_demand))\n                route1, route2 = new_solution[best_pair[0]], new_solution[best_pair[1]]\n\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in best_pair]\n                new_solution.append(merged_route)\n\n        # Stage 3: Hybrid customer reallocation\n        if len(new_solution) > 1:\n            # Select route with highest demand\n            demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            route_idx = np.argmax(demands)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customer with demand closest to route's average\n                route_demand = demand[route[1:-1]]\n                avg_route_demand = np.mean(route_demand)\n                customer_pos = np.argmin(np.abs(route_demand - avg_route_demand)) + 1\n                customer = route[customer_pos]\n\n                # Find best route to insert based on demand compatibility\n                best_route_idx = -1\n                best_pos = -1\n                min_demand_diff = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        new_demand = other_demand + demand[customer]\n                        demand_diff = abs(new_demand - capacity/2)\n\n                        if demand_diff < min_demand_diff:\n                            min_demand_diff = demand_diff\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.830150191120199,
            1.302865594625473
        ]
    },
    {
        "algorithm": "This algorithm implements a multi-stage hybrid local search for the Bi-CVRP, prioritizing balanced solutions (60% distance, 40% makespan) and applying adaptive route segmentation, demand-aware customer insertion, route reversal with capacity optimization, and intelligent route merging with load balancing. It uses dynamic programming for optimal split points and reversal segments, while maintaining feasibility through capacity checks and demand pattern analysis. The algorithm iteratively refines solutions through 8 stages of transformations, focusing on both distance minimization and makespan reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search with 8 iterations\n    for _ in range(8):\n        # Stage 1: Adaptive route segmentation with demand optimization\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal split point using dynamic programming\n                demands = demand[route[1:-1]]\n                n = len(demands)\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                split_pos = 1\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demands[j-1]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[split_pos]:\n                        split_pos = i\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Demand-aware customer insertion\n        if len(new_solution) > 0:\n            # Select customer from route with highest demand variance\n            route_idx = np.argmax([np.std(demand[route[1:-1]]) for route in new_solution])\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with demand closest to average\n                route_demand = demand[route[1:-1]]\n                avg_demand = np.mean(route_demand)\n                closest_customer = np.argmin(np.abs(route_demand - avg_demand)) + 1\n                customer = route[closest_customer]\n\n                # Find best insertion point in another route\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion score based on distance and demand balance\n                        insert_dist = (distance_matrix[other_route[pos-1]][customer] +\n                                      distance_matrix[customer][other_route[pos]] -\n                                      distance_matrix[other_route[pos-1]][other_route[pos]])\n                        new_demand = other_demand + demand[customer]\n                        demand_score = abs(new_demand - capacity/2)\n\n                        total_score = insert_dist * 0.7 + demand_score * 0.3\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:closest_customer], route[closest_customer+1:]])\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Route reversal with capacity optimization\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal reversal segment using dynamic programming\n                n = len(route) - 2\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                best_i, best_j = 1, 2\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demand[route[j]]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[best_i]:\n                        best_i, best_j = i, j\n\n                reversed_segment = route[best_i:best_j+1][::-1]\n                new_route = np.concatenate([route[:best_i], reversed_segment, route[best_j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 4: Intelligent route merging with load balancing\n        if len(new_solution) > 1:\n            # Find pair of routes with most complementary demand patterns\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    demand_i = np.sum(demand[new_solution[i][1:-1]])\n                    demand_j = np.sum(demand[new_solution[j][1:-1]])\n                    if demand_i + demand_j <= capacity:\n                        score = abs(demand_i + demand_j - capacity/2)\n                        if score < best_score:\n                            best_score = score\n                            best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Try both possible merge directions\n                merged1 = np.concatenate([route1[:-1], route2[1:]])\n                merged2 = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merge direction that better balances demands\n                demand1 = np.sum(demand[merged1[1:-1]])\n                demand2 = np.sum(demand[merged2[1:-1]])\n                score1 = abs(demand1 - capacity/2)\n                score2 = abs(demand2 - capacity/2)\n\n                if score1 <= score2 and len(merged1) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged1)\n                elif len(merged2) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged2)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.915810040703673,
            8.590130120515823
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid crowding and dominance score, then applies a series of demand-pattern-aware spatial fragmentation, load-balanced merging, and demand-aware reallocation operators to iteratively improve the solution while maintaining feasibility. It prioritizes spatial proximity and demand balance, dynamically adjusting route splits and merges based on demand distribution and spatial coherence, with higher emphasis on demand compatibility during reallocation. The algorithm balances exploration through probabilistic operations and exploitation through demand-based heuristics, ensuring capacity constraints are respected throughout the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    # Calculate dominance score\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        better_than = 0\n        for j in range(len(archive)):\n            if (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) or \\\n               (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]):\n                better_than += 1\n        dominance[i] = better_than\n\n    # Combine crowding and dominance\n    crowding = np.zeros(len(archive))\n    sorted_idx = np.argsort(normalized[:, 0])\n    crowding[sorted_idx[0]] = float('inf')\n    crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[sorted_idx[i]] = (normalized[sorted_idx[i+1], 0] - normalized[sorted_idx[i-1], 0])\n\n    combined_score = 0.6 * crowding + 0.4 * dominance\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Iterative improvement with hybrid operators\n    for _ in range(8):\n        # Demand-pattern-aware spatial fragmentation\n        if len(new_solution) > 1 and random.random() < 0.7:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                route_demand = demand[route[1:-1]]\n                demand_std = np.std(route_demand)\n\n                if demand_std > 0:  # Only proceed if demand pattern is diverse\n                    # Find split point that balances demand and spatial proximity\n                    total_demand = np.sum(route_demand)\n                    target_demand = total_demand * 0.5  # Split at 50% of total demand\n                    current_demand = 0\n                    best_split = 1\n\n                    for i in range(1, len(route)-1):\n                        current_demand += demand[route[i]]\n                        if current_demand >= target_demand:\n                            # Consider spatial proximity to current position\n                            spatial_score = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]]\n                            if i == 1 or spatial_score < distance_matrix[route[best_split-1], route[best_split]] + distance_matrix[route[best_split], route[best_split+1]]:\n                                best_split = i\n\n                    fragment1 = route[:best_split+1]\n                    fragment2 = np.concatenate([[0], route[best_split+1:]])\n\n                    if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                        np.sum(demand[fragment2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = fragment1\n                        new_solution.append(fragment2)\n\n        # Load-balanced spatial merging\n        if len(new_solution) > 2 and random.random() < 0.6:\n            # Find routes with similar demand patterns and spatial proximity\n            route_centroids = []\n            route_demand_avgs = []\n            for route in new_solution:\n                if len(route) > 2:\n                    route_coords = coords[route[1:-1]]\n                    centroid = np.mean(route_coords, axis=0)\n                    route_centroids.append(centroid)\n                    route_demand = demand[route[1:-1]]\n                    route_demand_avgs.append(np.mean(route_demand) if len(route_demand) > 0 else 0)\n                else:\n                    route_centroids.append(np.zeros(2))\n                    route_demand_avgs.append(0)\n\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demand_avgs[i] - route_demand_avgs[j])\n                    combined_score = spatial_dist + 0.5 * demand_diff  # Weight demand difference more\n\n                    if combined_score < best_score:\n                        best_score = combined_score\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                    len(route1) + len(route2) - 2 <= 15):  # Increased route length limit\n\n                    # Check if merging would create a more balanced route\n                    total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                    if abs(total_demand - capacity/2) < capacity/3:  # Accept if within 1/3 of half capacity\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]]\n                        new_solution.append(merged_route)\n\n        # Demand-aware spatial reallocation\n        if len(new_solution) > 1 and random.random() < 0.8:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with most extreme demand relative to route average\n                route_demand = demand[route[1:-1]]\n                route_avg = np.mean(route_demand)\n                customer_pos = np.argmax(np.abs(route_demand - route_avg)) + 1\n                customer = route[customer_pos]\n\n                # Find best route to insert based on spatial and demand compatibility\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = demand[other_route[1:-1]]\n                    if len(other_demand) == 0 or np.sum(other_demand) + demand[customer] > capacity:\n                        continue\n\n                    other_avg = np.mean(other_demand) if len(other_demand) > 0 else 0\n                    demand_diff = abs(route_avg - other_avg)\n\n                    # Find insertion position that minimizes spatial disruption\n                    min_insertion_cost = float('inf')\n                    best_insert_pos = -1\n\n                    for pos in range(1, len(other_route)):\n                        insertion_cost = (distance_matrix[other_route[pos-1], customer] +\n                                        distance_matrix[customer, other_route[pos]] -\n                                        distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if insertion_cost < min_insertion_cost:\n                            min_insertion_cost = insertion_cost\n                            best_insert_pos = pos\n\n                    total_score = min_insertion_cost + 0.4 * demand_diff  # Weight demand difference more\n\n                    if total_score < best_score:\n                        best_score = total_score\n                        best_route_idx = other_idx\n                        best_pos = best_insert_pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8956807917622304,
            3.4301752150058746
        ]
    },
    {
        "algorithm": "The algorithm combines demand-aware route fragmentation, spatial clustering, and load-balanced merging to explore the solution space, prioritizing solutions with high crowding distance in the objective space. It dynamically splits routes at demand-complementary points while merging routes with similar spatial proximity and complementary load characteristics, ensuring feasibility through capacity checks and route length limits. The algorithm balances exploration through iterative demand-pattern-aware reallocation and spatial-aware consolidation, with key variables like demand patterns and spatial centroids driving the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    sorted_idx = np.argsort(normalized[:, 0])\n    crowding = np.zeros(len(archive))\n    crowding[sorted_idx[0]] = float('inf')\n    crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[sorted_idx[i]] = (normalized[sorted_idx[i+1], 0] - normalized[sorted_idx[i-1], 0])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(5):\n        # Stage 1: Demand-complementary fragmentation with spatial awareness\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find split point that balances demand and spatial proximity\n                total_demand = np.sum(demand[route[1:-1]])\n                target_demand = total_demand * 0.45  # Split at 45% of total demand\n                current_demand = 0\n                best_split = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= target_demand:\n                        # Prefer splits where next customer is close to current position\n                        spatial_score = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]]\n                        if i == 1 or spatial_score < distance_matrix[route[best_split-1], route[best_split]] + distance_matrix[route[best_split], route[best_split+1]]:\n                            best_split = i\n\n                fragment1 = route[:best_split+1]\n                fragment2 = np.concatenate([[0], route[best_split+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Spatial-aware route merging\n        if len(new_solution) > 1:\n            # Find routes with similar spatial clusters\n            route_centroids = []\n            for route in new_solution:\n                if len(route) > 2:\n                    route_coords = coords[route[1:-1]]\n                    centroid = np.mean(route_coords, axis=0)\n                    route_centroids.append(centroid)\n                else:\n                    route_centroids.append(np.zeros(2))\n\n            # Find most similar route pairs based on centroid distance\n            best_pair = None\n            min_distance = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    if dist < min_distance:\n                        min_distance = dist\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                    len(route1) + len(route2) - 2 <= 20):  # Increased route length limit\n\n                    # Check if merging would create a more balanced route\n                    total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                    if abs(total_demand - capacity/2) < capacity/3:  # Accept if within 1/3 of half capacity\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]]\n                        new_solution.append(merged_route)\n\n        # Stage 3: Demand-pattern-aware reallocation\n        if len(new_solution) > 1:\n            # Select a route with diverse demand patterns\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                route_demand = demand[route[1:-1]]\n                demand_std = np.std(route_demand)\n\n                if demand_std > 0:  # Only proceed if demand pattern is diverse\n                    # Find customer with demand most different from route average\n                    route_avg = np.mean(route_demand)\n                    customer_pos = np.argmax(np.abs(route_demand - route_avg)) + 1\n                    customer = route[customer_pos]\n\n                    # Find best route to insert based on demand pattern similarity\n                    best_route_idx = -1\n                    best_pos = -1\n                    min_pattern_diff = float('inf')\n\n                    for other_idx, other_route in enumerate(new_solution):\n                        if other_idx == route_idx:\n                            continue\n\n                        other_demand = demand[other_route[1:-1]]\n                        if len(other_demand) == 0 or np.sum(other_demand) + demand[customer] > capacity:\n                            continue\n\n                        other_avg = np.mean(other_demand) if len(other_demand) > 0 else 0\n                        pattern_diff = abs(route_avg - other_avg)\n\n                        if pattern_diff < min_pattern_diff:\n                            min_pattern_diff = pattern_diff\n                            best_route_idx = other_idx\n                            best_pos = random.randint(1, len(other_route) - 1)  # Random position for diversity\n\n                    if best_route_idx != -1:\n                        other_route = new_solution[best_route_idx]\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            [customer],\n                            other_route[best_pos:]\n                        ])\n                        new_solution[best_route_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.848377349080088,
            2.526892274618149
        ]
    }
]