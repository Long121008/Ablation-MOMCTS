[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive, then applies a dynamic hybrid local search combining demand-aware spatial clustering, load-balanced route fragmentation, and multi-objective hybrid reinsertion, adaptively adjusting operator probabilities based on operator success rates while maintaining feasibility through continuous capacity checks. It prioritizes operators that show recent success (e.g., increasing weights for merge/split if successful) and focuses on spatial proximity and demand compatibility for route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route statistics and centroids\n    route_stats = []\n    route_centroids = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_stats.append((0, 0, 0, 0))\n            route_centroids.append(np.zeros(2))\n            continue\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        centroid = np.mean(coords[customers], axis=0)\n        route_stats.append((total_demand, total_distance, centroid, len(customers)))\n        route_centroids.append(centroid)\n\n    # Dynamic hybrid local search\n    operators = ['merge', 'split', 'reverse', 'insert']\n    operator_weights = [0.3, 0.3, 0.2, 0.2]  # Initial weights\n\n    for _ in range(5):  # Perform 5 iterations\n        # Select operator based on current weights\n        operator = random.choices(operators, weights=operator_weights, k=1)[0]\n\n        if operator == 'merge' and len(new_solution) >= 2:\n            # Find closest pair of routes\n            min_dist = float('inf')\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n                total_demand = route_stats[i][0] + route_stats[j][0]\n                if total_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    route_stats.pop(j)\n                    route_centroids.pop(j)\n                    if len(merged_route) > 2:\n                        customers = merged_route[1:-1]\n                        route_stats[i] = (np.sum(demand[customers]),\n                                         sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)),\n                                         np.mean(coords[customers], axis=0),\n                                         len(customers))\n                        route_centroids[i] = route_stats[i][2]\n                    else:\n                        route_stats[i] = (0, 0, np.zeros(2), 0)\n                        route_centroids[i] = np.zeros(2)\n                    # Update weights to favor merge more if successful\n                    operator_weights = [w * 1.1 if op == 'merge' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'split' and len(new_solution) > 1:\n            # Find longest route with high demand\n            longest_idx = max(range(len(new_solution)), key=lambda i: route_stats[i][0])\n            route = new_solution[longest_idx]\n            if len(route) > 4:\n                customers = route[1:-1]\n                total_demand = route_stats[longest_idx][0]\n                best_split = None\n                min_diff = float('inf')\n\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n                    if left_demand <= capacity and right_demand <= capacity:\n                        diff = abs(left_demand - right_demand)\n                        if diff < min_diff:\n                            min_diff = diff\n                            best_split = j\n\n                if best_split:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[longest_idx] = first_part\n                    new_solution.append(second_part)\n\n                    # Update stats for both parts\n                    for k, part in enumerate([first_part, second_part]):\n                        if len(part) > 2:\n                            customers = part[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[part[i], part[i+1]] for i in range(len(part)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[longest_idx] = stats\n                                route_centroids[longest_idx] = stats[2]\n                            else:\n                                route_stats.append(stats)\n                                route_centroids.append(stats[2])\n                        else:\n                            if k == 0:\n                                route_stats[longest_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[longest_idx] = np.zeros(2)\n                            else:\n                                route_stats.append((0, 0, np.zeros(2), 0))\n                                route_centroids.append(np.zeros(2))\n                    # Update weights to favor split more if successful\n                    operator_weights = [w * 1.1 if op == 'split' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'reverse' and len(new_solution) > 0:\n            # Select a route to reverse\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n                    customers = new_route[1:-1]\n                    route_stats[route_idx] = (np.sum(demand[customers]),\n                                             sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1)),\n                                             np.mean(coords[customers], axis=0),\n                                             len(customers))\n                    route_centroids[route_idx] = route_stats[route_idx][2]\n                    # Update weights to favor reverse more if successful\n                    operator_weights = [w * 1.1 if op == 'reverse' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'insert' and len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 2:\n                # Select a customer to move\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                # Find best insertion position in route2\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    dist_increase = (distance_matrix[route2[pos-1], customer] +\n                                   distance_matrix[customer, route2[pos]] -\n                                   distance_matrix[route2[pos-1], route2[pos]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Check capacity feasibility\n                if route_stats[route2_idx][0] + demand[customer] <= capacity:\n                    # Insert customer into route2\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    # Remove customer from route1\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    # Update stats for both routes\n                    for k, route in enumerate([new_route1, new_route2]):\n                        if len(route) > 2:\n                            customers = route[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[route1_idx] = stats\n                                route_centroids[route1_idx] = stats[2]\n                            else:\n                                route_stats[route2_idx] = stats\n                                route_centroids[route2_idx] = stats[2]\n                        else:\n                            if k == 0:\n                                route_stats[route1_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[route1_idx] = np.zeros(2)\n                            else:\n                                route_stats[route2_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[route2_idx] = np.zeros(2)\n                    # Update weights to favor insert more if successful\n                    operator_weights = [w * 1.1 if op == 'insert' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9445891665421444,
            0.6630864441394806
        ]
    },
    {
        "algorithm": "The algorithm combines crowding-distance-based solution selection with a multi-stage hybrid local search that prioritizes demand-complementary route splitting, capacity-aware route consolidation, and probabilistic demand-balanced customer reallocation. It explicitly balances trade-offs between total distance and makespan optimization by selecting solutions with high crowding distances and applying demand-aware transformations to improve solution quality while maintaining feasibility. The approach emphasizes capacity utilization and demand balance through probabilistic operators and complementary demand-based route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    # Normalize objectives\n    norm_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances))\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans))\n\n    # Calculate crowding distances\n    sorted_idx = np.argsort(norm_dist)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_makespan[sorted_idx[i+1]] - norm_makespan[sorted_idx[i-1]]\n\n    sorted_idx = np.argsort(norm_makespan)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_dist[sorted_idx[i+1]] - norm_dist[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(3):\n        # Stage 1: Demand-complementary route splitting\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                # Find customer with demand most complementary to route's average demand\n                route_demand = np.sum(demand[route[1:-1]])\n                avg_demand = route_demand / (len(route) - 2)\n                best_split = None\n                best_diff = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_diff = abs(demand[route[i]] - avg_demand)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_split = i\n\n                if best_split:\n                    split_pos = best_split\n                    fragment = route[split_pos:]\n                    remaining = route[:split_pos+1]\n\n                    if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                        np.sum(demand[remaining[1:-1]]) <= capacity):\n                        new_solution[route_idx] = remaining\n                        new_solution.append(fragment)\n\n        # Stage 2: Capacity-aware route consolidation\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            remaining_cap1 = capacity - demand1\n            remaining_cap2 = capacity - demand2\n\n            # Probability of merging based on capacity complementarity\n            merge_prob = 0.5 * (1 - abs(remaining_cap1 - remaining_cap2) / capacity) + 0.5\n\n            if random.random() < merge_prob and (demand1 + demand2) <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n        # Stage 3: Probabilistic demand-balanced customer reallocation\n        if len(new_solution) > 1 and random.random() < 0.4:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer whose demand is closest to target route's remaining capacity\n                target_demand = np.sum(demand[target_route[1:-1]])\n                remaining_cap = capacity - target_demand\n                best_customer = None\n                best_diff = float('inf')\n\n                for i in range(1, len(source_route)-1):\n                    current_diff = abs(demand[source_route[i]] - remaining_cap)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_customer = i\n\n                if best_customer:\n                    customer = source_route[best_customer]\n\n                    # Find best insertion position considering demand balance\n                    best_pos = 1\n                    best_balance = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_demand = target_demand + demand[customer]\n                        new_balance = abs(new_demand - capacity/2)  # Prefer balanced demand\n\n                        if new_balance < best_balance:\n                            best_balance = new_balance\n                            best_pos = pos\n\n                    if new_demand <= capacity:\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:best_customer],\n                                                         source_route[best_customer+1:]])\n                        new_solution[source_idx] = new_source_route\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7965868091436135,
            0.1786138117313385
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding distance to explore diverse trade-offs, then applies a demand-aware fragmentation operator to split imbalanced routes and a load-balanced merging operator to combine complementary routes, prioritizing demand complementarity (70%) over spatial proximity (30%) while maintaining feasibility through capacity checks. The approach balances exploration of the objective space with targeted local improvements to reduce both total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) < 2:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances\n        archive_sorted_dist = sorted(archive, key=lambda x: x[1][0])\n        archive_sorted_make = sorted(archive, key=lambda x: x[1][1])\n\n        crowding_dist = {}\n        for i, (sol, obj) in enumerate(archive):\n            if i == 0 or i == len(archive)-1:\n                crowding_dist[i] = float('inf')\n            else:\n                dist_diff = (archive_sorted_dist[i+1][1][0] - archive_sorted_dist[i-1][1][0]) / (archive_sorted_dist[-1][1][0] - archive_sorted_dist[0][1][0])\n                make_diff = (archive_sorted_make[i+1][1][1] - archive_sorted_make[i-1][1][1]) / (archive_sorted_make[-1][1][1] - archive_sorted_make[0][1][1])\n                crowding_dist[i] = dist_diff + make_diff\n\n        selected_idx = max(crowding_dist.keys(), key=lambda k: crowding_dist[k])\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Demand-aware fragmentation\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find route with most demand imbalance\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        most_imbalanced_idx = max(range(len(new_solution)), key=lambda i: abs(route_demands[i] - capacity/2))\n\n        # Find split point that balances demand\n        route = new_solution[most_imbalanced_idx]\n        if len(route) <= 3:\n            continue\n\n        cumulative_demand = np.cumsum(demand[route[1:-1]])\n        split_pos = np.argmin(np.abs(cumulative_demand - capacity/2)) + 1\n\n        # Create new route from split point\n        new_route = np.concatenate([[0], route[split_pos:], [0]])\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n            new_solution[most_imbalanced_idx] = np.concatenate([[0], route[1:split_pos+1], [0]])\n\n    # Load-balanced merging\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find routes with complementary demands\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        route_centers = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else np.zeros(2) for route in new_solution]\n\n        best_merge = None\n        best_score = -float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                combined_demand = route_demands[i] + route_demands[j]\n                if combined_demand > capacity:\n                    continue\n\n                # Calculate weighted score: demand complementarity + spatial proximity\n                demand_score = (capacity - abs(capacity - combined_demand)) / capacity\n                spatial_score = 1 / (1 + np.linalg.norm(route_centers[i] - route_centers[j]))\n                score = 0.7 * demand_score + 0.3 * spatial_score\n\n                if score > best_score:\n                    best_score = score\n                    best_merge = (i, j)\n\n        if best_merge is not None:\n            i, j = best_merge\n            # Merge routes\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution.append(merged_route)\n                del new_solution[max(i, j)]\n                del new_solution[min(i, j)]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8278933615924351,
            0.5591227412223816
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects solutions from the archive using non-linear weighted objectives, applying a hybrid local search that combines adaptive route fragmentation (balancing demand and distance), demand-sensitive customer reallocation, probabilistic route merging (with capacity-aware criteria), and an adaptive customer exchange operator (prioritizing distance and demand balance). It emphasizes extreme solutions through exponential weighting and adjusts operator probabilities based on solution characteristics.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    # Normalize with non-linear scaling\n    norm_dist = (distances - min_dist) / (max_dist - min_dist + 1e-6)\n    norm_makespan = (makespans - min_makespan) / (max_makespan - min_makespan + 1e-6)\n\n    # Exponential weighting to emphasize extreme solutions\n    weight_dist = np.exp(-norm_dist * 0.5)\n    weight_makespan = np.exp(-norm_makespan * 0.5)\n\n    # Combine with adaptive focus\n    scores = weight_dist * norm_dist + weight_makespan * norm_makespan\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with adaptive operators\n    for _ in range(4):  # Increased iterations for better exploration\n        # Adaptive route fragmentation based on demand and distance\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:  # Only split if route is long enough\n                total_demand = np.sum(demand[route[1:-1]])\n                route_distance = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n\n                # Find split position that balances both demand and distance\n                best_split = 1\n                best_balance = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_demand = np.sum(demand[route[1:i+1]])\n                    current_dist = sum(distance_matrix[route[j-1], route[j]] for j in range(1, i+1))\n\n                    # Balance score combines demand and distance balance\n                    balance_score = abs((current_demand / total_demand) - 0.5) + \\\n                                  abs((current_dist / route_distance) - 0.5)\n\n                    if balance_score < best_balance:\n                        best_balance = balance_score\n                        best_split = i\n\n                fragment = route[best_split:]\n                remaining = route[:best_split+1]\n\n                if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                    np.sum(demand[remaining[1:-1]]) <= capacity):\n                    new_solution[route_idx] = remaining\n                    new_solution.append(fragment)\n\n        # Demand-sensitive customer reallocation\n        if len(new_solution) > 1:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customers based on demand and distance to depot\n                customers = sorted(range(1, len(source_route)-1),\n                                key=lambda x: demand[source_route[x]] * distance_matrix[0, source_route[x]],\n                                reverse=True)\n\n                num_to_move = min(3, len(customers))  # Move up to 3 customers\n\n                for customer_pos in customers[:num_to_move]:\n                    customer = source_route[customer_pos]\n\n                    # Find best insertion considering both distance and demand impact\n                    best_pos = 1\n                    best_score = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        dist_increase = (distance_matrix[target_route[pos-1], customer] +\n                                       distance_matrix[customer, target_route[pos]] -\n                                       distance_matrix[target_route[pos-1], target_route[pos]])\n\n                        # Demand impact score considers both current and potential demand\n                        current_demand = np.sum(demand[target_route[1:-1]])\n                        new_demand = current_demand + demand[customer]\n\n                        demand_score = abs(new_demand - capacity/2)  # Prefer medium demand routes\n\n                        # Distance to depot factor\n                        depot_dist_factor = distance_matrix[0, customer] / np.max(distance_matrix[0, :])\n\n                        total_score = dist_increase + 0.4 * demand_score + 0.3 * depot_dist_factor\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_pos = pos\n\n                    if (np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                        len(target_route) + 1 <= 25):  # Increased route length limit\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:customer_pos],\n                                                         source_route[customer_pos+1:]])\n                        new_solution[source_idx] = new_source_route\n\n        # Capacity-aware route merging\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            length1 = len(route1)\n            length2 = len(route2)\n\n            # More aggressive merging probability based on capacity utilization\n            merge_prob = min(0.9, 0.3 + 0.6 * (1 - abs(demand1 - demand2) / (total_demand + 1e-6)) +\n                           0.4 * (25 - (length1 + length2 - 2)) / 25)\n\n            if random.random() < merge_prob and total_demand <= capacity:\n                # Consider both direct and reverse merging\n                direct_merged = np.concatenate([route1[:-1], route2[1:]])\n                reverse_merged = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merging option with better distance\n                direct_dist = sum(distance_matrix[direct_merged[i-1], direct_merged[i]] for i in range(1, len(direct_merged)))\n                reverse_dist = sum(distance_matrix[reverse_merged[i-1], reverse_merged[i]] for i in range(1, len(reverse_merged)))\n\n                merged_route = direct_merged if direct_dist <= reverse_dist else reverse_merged\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    # Adaptive customer exchange operator\n    if len(new_solution) > 1 and random.random() < 0.4:  # Increased probability\n        swap_routes = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[swap_routes[0]], new_solution[swap_routes[1]]\n\n        # Consider multiple swap positions\n        best_swaps = []\n        best_score = float('inf')\n\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Calculate potential demand changes\n                new_demand1 = (np.sum(demand[route1[1:i]]) + demand[route2[j]] +\n                              np.sum(demand[route1[i+1:-1]]))\n                new_demand2 = (np.sum(demand[route2[1:j]]) + demand[route1[i]] +\n                              np.sum(demand[route2[j+1:-1]]))\n\n                if new_demand1 > capacity or new_demand2 > capacity:\n                    continue\n\n                # Calculate distance change\n                dist_change = (\n                    distance_matrix[route1[i-1], route2[j]] +\n                    distance_matrix[route2[j], route1[i+1]] -\n                    distance_matrix[route1[i-1], route1[i]] -\n                    distance_matrix[route1[i], route1[i+1]] +\n                    distance_matrix[route2[j-1], route1[i]] +\n                    distance_matrix[route1[i], route2[j+1]] -\n                    distance_matrix[route2[j-1], route2[j]] -\n                    distance_matrix[route2[j], route2[j+1]]\n                )\n\n                # Consider both demand balance and distance to depot\n                demand_balance = abs(new_demand1 - new_demand2)\n                depot_dist_factor = (distance_matrix[0, route1[i]] + distance_matrix[0, route2[j]]) / 2\n\n                total_score = dist_change + 0.4 * demand_balance + 0.2 * depot_dist_factor\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_swaps = [(i, j)]\n                elif total_score == best_score:\n                    best_swaps.append((i, j))\n\n        if best_swaps:\n            i, j = random.choice(best_swaps)\n            # Perform the swap\n            route1[i], route2[j] = route2[j], route1[i]\n            new_solution[swap_routes[0]] = route1\n            new_solution[swap_routes[1]] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.9282340368599087,
            1.7632462084293365
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of total distance and makespan, then applies a hybrid local search combining route merging (prioritizing routes with similar demand), splitting (for high-length-to-demand routes), and customer relocation (with proximity constraints to centroids). It emphasizes balancing demand and spatial proximity while prioritizing makespan reduction through intelligent route adjustments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]) / (max(x[1][0], x[1][1]) + 1))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route properties\n    route_properties = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_properties.append((np.zeros(2), 0, 0))\n            continue\n        customer_coords = coords[route[1:-1]]\n        centroid = np.mean(customer_coords, axis=0)\n        total_demand = np.sum(demand[route[1:-1]])\n        route_length = np.sum([distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)])\n        route_properties.append((centroid, total_demand, route_length))\n\n    # Hybrid local search\n    for _ in range(4):\n        # Try to merge routes with similar demand\n        if len(new_solution) > 1:\n            min_diff = float('inf')\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    demand_diff = abs(route_properties[i][1] - route_properties[j][1])\n                    if demand_diff < min_diff:\n                        min_diff = demand_diff\n                        best_pair = (i, j)\n\n            if best_pair is not None and min_diff < 0.3 * capacity:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n\n                total_demand = route_properties[i][1] + route_properties[j][1]\n                if total_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n\n                    # Update properties\n                    if len(merged_route) > 2:\n                        customer_coords = coords[merged_route[1:-1]]\n                        centroid = np.mean(customer_coords, axis=0)\n                        route_length = np.sum([distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)])\n                        route_properties[i] = (centroid, total_demand, route_length)\n                    else:\n                        route_properties[i] = (np.zeros(2), 0, 0)\n                    route_properties.pop(j)\n\n        # Try to split routes with high length-to-demand ratio\n        if len(new_solution) < len(base_solution) + 3:\n            max_ratio = -1\n            best_route = None\n            for i in range(len(new_solution)):\n                if len(new_solution[i]) > 4 and route_properties[i][1] > 0:\n                    ratio = route_properties[i][2] / route_properties[i][1]\n                    if ratio > max_ratio:\n                        max_ratio = ratio\n                        best_route = i\n\n            if best_route is not None and max_ratio > 1.2:\n                route = new_solution[best_route]\n                total_demand = route_properties[best_route][1]\n\n                best_split = None\n                min_ratio_diff = float('inf')\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n\n                    if left_demand <= capacity and right_demand <= capacity:\n                        left_length = np.sum([distance_matrix[route[k], route[k+1]] for k in range(j)])\n                        right_length = np.sum([distance_matrix[route[j+k], route[j+k+1]] for k in range(len(route)-j)])\n\n                        ratio_diff = abs((left_length / left_demand) - (right_length / right_demand))\n                        if ratio_diff < min_ratio_diff:\n                            min_ratio_diff = ratio_diff\n                            best_split = j\n\n                if best_split is not None:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[best_route] = first_part\n                    new_solution.append(second_part)\n\n                    # Update properties\n                    for part, idx in [(first_part, best_route), (second_part, len(new_solution)-1)]:\n                        if len(part) > 2:\n                            customer_coords = coords[part[1:-1]]\n                            centroid = np.mean(customer_coords, axis=0)\n                            part_demand = np.sum(demand[part[1:-1]])\n                            part_length = np.sum([distance_matrix[part[k], part[k+1]] for k in range(len(part)-1)])\n                            route_properties[idx] = (centroid, part_demand, part_length)\n                        else:\n                            route_properties[idx] = (np.zeros(2), 0, 0)\n\n        # Try customer relocation with proximity constraint\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Find target route with similar centroid\n                target_idx = None\n                min_centroid_dist = float('inf')\n                for i in range(len(new_solution)):\n                    if i != route_idx:\n                        dist = np.linalg.norm(route_properties[i][0] - coords[customer])\n                        if dist < min_centroid_dist:\n                            min_centroid_dist = dist\n                            target_idx = i\n\n                if target_idx is not None:\n                    other_route = new_solution[target_idx]\n\n                    # Find best insertion position with proximity constraint\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                       distance_matrix[customer, other_route[pos]] -\n                                       distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if dist_increase < min_increase and distance_matrix[customer, other_route[pos]] < 1.5 * np.mean(distance_matrix[other_route[pos-1], other_route[pos]]):\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                        new_solution[target_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n                        # Update properties\n                        for idx in [route_idx, target_idx]:\n                            route = new_solution[idx]\n                            if len(route) > 2:\n                                customer_coords = coords[route[1:-1]]\n                                centroid = np.mean(customer_coords, axis=0)\n                                part_demand = np.sum(demand[route[1:-1]])\n                                part_length = np.sum([distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)])\n                                route_properties[idx] = (centroid, part_demand, part_length)\n                            else:\n                                route_properties[idx] = (np.zeros(2), 0, 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9252961419680493,
            0.7954302430152893
        ]
    },
    {
        "algorithm": "The algorithm first clusters solutions based on route structure diversity, selecting from the least explored cluster to promote exploration of underrepresented regions. It then applies a novel \"route fragmentation and reassembly\" operator that intelligently splits routes into demand-balanced segments and reconstructs them while prioritizing capacity constraints, ensuring high-quality neighbors through structural diversification and non-standard segmentation logic. The method prioritizes demand-weighted segmentation (70% capacity threshold) and random shuffling of segments for robust reassembly.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Cluster solutions by route structure diversity\n    route_lengths = []\n    for sol, _ in archive:\n        lengths = [len(route) - 2 for route in sol]  # exclude depot nodes\n        route_lengths.append(tuple(sorted(lengths)))\n\n    # Find least explored cluster\n    from collections import Counter\n    cluster_counts = Counter(route_lengths)\n    least_explored = min(cluster_counts, key=cluster_counts.get)\n    candidates = [sol for (sol, _), lengths in zip(archive, route_lengths) if lengths == least_explored]\n    base_solution = random.choice(candidates).copy()\n\n    # Route fragmentation and reassembly\n    new_solution = []\n    segments = []\n\n    # Fragment all routes into segments\n    for route in base_solution:\n        if len(route) <= 3:  # too short to fragment\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into segments based on demand balance\n        current_segment = [route[0]]\n        current_demand = 0\n        for node in route[1:-1]:\n            if current_demand + demand[node] > capacity * 0.7:  # 70% capacity threshold\n                segments.append(current_segment + [0])\n                current_segment = [0]\n                current_demand = 0\n            current_segment.append(node)\n            current_demand += demand[node]\n        if len(current_segment) > 1:\n            segments.append(current_segment + [0])\n\n    # Reassemble segments into new routes\n    random.shuffle(segments)\n    current_route = [0]\n    current_demand = 0\n\n    for segment in segments:\n        segment_demand = sum(demand[node] for node in segment[1:-1])\n        if current_demand + segment_demand <= capacity:\n            current_route.extend(segment[1:-1])\n            current_demand += segment_demand\n        else:\n            if len(current_route) > 1:\n                new_solution.append(np.array(current_route + [0]))\n            current_route = [0] + segment[1:-1]\n            current_demand = segment_demand\n\n    if len(current_route) > 1:\n        new_solution.append(np.array(current_route + [0]))\n\n    # Verify all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        # Fallback to original solution if reassembly failed\n        return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6204871571716079,
            0.4501461386680603
        ]
    },
    {
        "algorithm": "The algorithm combines demand-sensitive spatial clustering with adaptive multi-objective rebalancing, where it selectively fragments high-demand routes into balanced parts and rebalances imbalanced route pairs by transferring customers based on spatial proximity and demand balance, prioritizing makespan reduction (60%) over total distance (40%) in selection and using dynamic operator fusion to maintain feasibility through iterative demand validation. The algorithm focuses on high-distance/high-demand routes and favors rebalancing operations that improve both objectives by considering both spatial and demand-based metrics in its scoring system.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route characteristics\n    route_info = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_info.append((0, 0, 0, 0))  # demand, distance, centroid, num_customers\n            continue\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        centroid = np.mean(coords[customers], axis=0)\n        route_info.append((total_demand, total_distance, centroid, len(customers)))\n\n    # Dynamic operator fusion\n    for _ in range(3):\n        # Fragmentation operator\n        if len(new_solution) < len(base_solution) + 2 and random.random() < 0.6:\n            max_ratio = -1\n            best_route = None\n            for i in range(len(new_solution)):\n                if len(new_solution[i]) > 4 and route_info[i][0] > 0.5 * capacity:\n                    ratio = route_info[i][1] / route_info[i][0]\n                    if ratio > max_ratio:\n                        max_ratio = ratio\n                        best_route = i\n\n            if best_route is not None and max_ratio > 1.1:\n                route = new_solution[best_route]\n                customers = route[1:-1]\n                total_demand = route_info[best_route][0]\n\n                # Find optimal split point\n                best_split = None\n                min_variance = float('inf')\n                for j in range(2, len(customers)-1):\n                    left_demand = np.sum(demand[customers[:j]])\n                    right_demand = total_demand - left_demand\n\n                    if left_demand <= capacity and right_demand <= capacity:\n                        left_dist = sum(distance_matrix[route[k], route[k+1]] for k in range(j+1))\n                        right_dist = sum(distance_matrix[route[j+k], route[j+k+1]] for k in range(len(customers)-j+1))\n\n                        demand_var = abs(left_demand - right_demand)\n                        dist_var = abs(left_dist - right_dist)\n                        total_var = 0.7 * demand_var + 0.3 * dist_var\n\n                        if total_var < min_variance:\n                            min_variance = total_var\n                            best_split = j\n\n                if best_split is not None:\n                    j = best_split\n                    first_part = np.concatenate([route[:j+2], [0]])\n                    second_part = np.concatenate([[0], route[j+2:-1], [0]])\n\n                    new_solution[best_route] = first_part\n                    new_solution.append(second_part)\n\n                    # Update route info\n                    for part, idx in [(first_part, best_route), (second_part, len(new_solution)-1)]:\n                        if len(part) > 2:\n                            customers = part[1:-1]\n                            total_demand = np.sum(demand[customers])\n                            total_distance = sum(distance_matrix[part[k], part[k+1]] for k in range(len(part)-1))\n                            centroid = np.mean(coords[customers], axis=0)\n                            route_info[idx] = (total_demand, total_distance, centroid, len(customers))\n                        else:\n                            route_info[idx] = (0, 0, 0, 0)\n\n        # Rebalancing operator\n        if len(new_solution) > 1 and random.random() < 0.7:\n            # Find most imbalanced pair\n            max_imbalance = -1\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    demand_diff = abs(route_info[i][0] - route_info[j][0])\n                    dist_diff = abs(route_info[i][1] - route_info[j][1])\n                    imbalance = 0.6 * demand_diff + 0.4 * dist_diff\n                    if imbalance > max_imbalance:\n                        max_imbalance = imbalance\n                        best_pair = (i, j)\n\n            if best_pair is not None:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n                customers1, customers2 = route1[1:-1], route2[1:-1]\n\n                # Find best candidate transfer\n                best_transfer = None\n                min_score = float('inf')\n\n                for k in range(len(customers1)):\n                    new_demand2 = route_info[j][0] + demand[customers1[k]]\n                    if new_demand2 > capacity:\n                        continue\n\n                    # Calculate spatial proximity score\n                    dist_to_centroid = np.linalg.norm(coords[customers1[k]] - route_info[j][2])\n                    dist_score = dist_to_centroid / (route_info[j][1] + 1e-6)\n\n                    # Calculate demand balance score\n                    demand_score = abs((new_demand2 - route_info[i][0] + demand[customers1[k]]) - capacity/2)\n\n                    total_score = 0.5 * dist_score + 0.5 * demand_score\n                    if total_score < min_score:\n                        min_score = total_score\n                        best_transfer = (i, j, k, 'to_j')\n\n                for k in range(len(customers2)):\n                    new_demand1 = route_info[i][0] + demand[customers2[k]]\n                    if new_demand1 > capacity:\n                        continue\n\n                    dist_to_centroid = np.linalg.norm(coords[customers2[k]] - route_info[i][2])\n                    dist_score = dist_to_centroid / (route_info[i][1] + 1e-6)\n\n                    demand_score = abs((new_demand1 - route_info[j][0] + demand[customers2[k]]) - capacity/2)\n\n                    total_score = 0.5 * dist_score + 0.5 * demand_score\n                    if total_score < min_score:\n                        min_score = total_score\n                        best_transfer = (i, j, k, 'to_i')\n\n                # Perform transfer if beneficial\n                if best_transfer and min_score < 1.0:\n                    i, j, k, direction = best_transfer\n                    if direction == 'to_j':\n                        customer = new_solution[i][1:-1][k]\n                        new_solution[i] = np.concatenate([new_solution[i][:k+1], new_solution[i][k+2:]])\n                        new_solution[j] = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                    else:\n                        customer = new_solution[j][1:-1][k]\n                        new_solution[j] = np.concatenate([new_solution[j][:k+1], new_solution[j][k+2:]])\n                        new_solution[i] = np.concatenate([new_solution[i][:-1], [customer], [0]])\n\n                    # Update route info\n                    for idx in [i, j]:\n                        route = new_solution[idx]\n                        if len(route) > 2:\n                            customers = route[1:-1]\n                            total_demand = np.sum(demand[customers])\n                            total_distance = sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                            centroid = np.mean(coords[customers], axis=0)\n                            route_info[idx] = (total_demand, total_distance, centroid, len(customers))\n                        else:\n                            route_info[idx] = (0, 0, 0, 0)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7864768755471796,
            0.6936072111129761
        ]
    },
    {
        "algorithm": "This algorithm implements a multi-stage hybrid local search for the Bi-CVRP, prioritizing balanced solutions (60% distance, 40% makespan) and applying adaptive route segmentation, demand-aware customer insertion, route reversal with capacity optimization, and intelligent route merging with load balancing. It uses dynamic programming for optimal split points and reversal segments, while maintaining feasibility through capacity checks and demand pattern analysis. The algorithm iteratively refines solutions through 8 stages of transformations, focusing on both distance minimization and makespan reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search with 8 iterations\n    for _ in range(8):\n        # Stage 1: Adaptive route segmentation with demand optimization\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal split point using dynamic programming\n                demands = demand[route[1:-1]]\n                n = len(demands)\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                split_pos = 1\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demands[j-1]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[split_pos]:\n                        split_pos = i\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Demand-aware customer insertion\n        if len(new_solution) > 0:\n            # Select customer from route with highest demand variance\n            route_idx = np.argmax([np.std(demand[route[1:-1]]) for route in new_solution])\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with demand closest to average\n                route_demand = demand[route[1:-1]]\n                avg_demand = np.mean(route_demand)\n                closest_customer = np.argmin(np.abs(route_demand - avg_demand)) + 1\n                customer = route[closest_customer]\n\n                # Find best insertion point in another route\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion score based on distance and demand balance\n                        insert_dist = (distance_matrix[other_route[pos-1]][customer] +\n                                      distance_matrix[customer][other_route[pos]] -\n                                      distance_matrix[other_route[pos-1]][other_route[pos]])\n                        new_demand = other_demand + demand[customer]\n                        demand_score = abs(new_demand - capacity/2)\n\n                        total_score = insert_dist * 0.7 + demand_score * 0.3\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:closest_customer], route[closest_customer+1:]])\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Route reversal with capacity optimization\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal reversal segment using dynamic programming\n                n = len(route) - 2\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                best_i, best_j = 1, 2\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demand[route[j]]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[best_i]:\n                        best_i, best_j = i, j\n\n                reversed_segment = route[best_i:best_j+1][::-1]\n                new_route = np.concatenate([route[:best_i], reversed_segment, route[best_j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 4: Intelligent route merging with load balancing\n        if len(new_solution) > 1:\n            # Find pair of routes with most complementary demand patterns\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    demand_i = np.sum(demand[new_solution[i][1:-1]])\n                    demand_j = np.sum(demand[new_solution[j][1:-1]])\n                    if demand_i + demand_j <= capacity:\n                        score = abs(demand_i + demand_j - capacity/2)\n                        if score < best_score:\n                            best_score = score\n                            best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Try both possible merge directions\n                merged1 = np.concatenate([route1[:-1], route2[1:]])\n                merged2 = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merge direction that better balances demands\n                demand1 = np.sum(demand[merged1[1:-1]])\n                demand2 = np.sum(demand[merged2[1:-1]])\n                score1 = abs(demand1 - capacity/2)\n                score2 = abs(demand2 - capacity/2)\n\n                if score1 <= score2 and len(merged1) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged1)\n                elif len(merged2) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged2)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.915810040703673,
            8.590130120515823
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid crowding and dominance score, then applies a series of demand-pattern-aware spatial fragmentation, load-balanced merging, and demand-aware reallocation operators to iteratively improve the solution while maintaining feasibility. It prioritizes spatial proximity and demand balance, dynamically adjusting route splits and merges based on demand distribution and spatial coherence, with higher emphasis on demand compatibility during reallocation. The algorithm balances exploration through probabilistic operations and exploitation through demand-based heuristics, ensuring capacity constraints are respected throughout the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    # Calculate dominance score\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        better_than = 0\n        for j in range(len(archive)):\n            if (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) or \\\n               (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]):\n                better_than += 1\n        dominance[i] = better_than\n\n    # Combine crowding and dominance\n    crowding = np.zeros(len(archive))\n    sorted_idx = np.argsort(normalized[:, 0])\n    crowding[sorted_idx[0]] = float('inf')\n    crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[sorted_idx[i]] = (normalized[sorted_idx[i+1], 0] - normalized[sorted_idx[i-1], 0])\n\n    combined_score = 0.6 * crowding + 0.4 * dominance\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Iterative improvement with hybrid operators\n    for _ in range(8):\n        # Demand-pattern-aware spatial fragmentation\n        if len(new_solution) > 1 and random.random() < 0.7:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                route_demand = demand[route[1:-1]]\n                demand_std = np.std(route_demand)\n\n                if demand_std > 0:  # Only proceed if demand pattern is diverse\n                    # Find split point that balances demand and spatial proximity\n                    total_demand = np.sum(route_demand)\n                    target_demand = total_demand * 0.5  # Split at 50% of total demand\n                    current_demand = 0\n                    best_split = 1\n\n                    for i in range(1, len(route)-1):\n                        current_demand += demand[route[i]]\n                        if current_demand >= target_demand:\n                            # Consider spatial proximity to current position\n                            spatial_score = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]]\n                            if i == 1 or spatial_score < distance_matrix[route[best_split-1], route[best_split]] + distance_matrix[route[best_split], route[best_split+1]]:\n                                best_split = i\n\n                    fragment1 = route[:best_split+1]\n                    fragment2 = np.concatenate([[0], route[best_split+1:]])\n\n                    if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                        np.sum(demand[fragment2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = fragment1\n                        new_solution.append(fragment2)\n\n        # Load-balanced spatial merging\n        if len(new_solution) > 2 and random.random() < 0.6:\n            # Find routes with similar demand patterns and spatial proximity\n            route_centroids = []\n            route_demand_avgs = []\n            for route in new_solution:\n                if len(route) > 2:\n                    route_coords = coords[route[1:-1]]\n                    centroid = np.mean(route_coords, axis=0)\n                    route_centroids.append(centroid)\n                    route_demand = demand[route[1:-1]]\n                    route_demand_avgs.append(np.mean(route_demand) if len(route_demand) > 0 else 0)\n                else:\n                    route_centroids.append(np.zeros(2))\n                    route_demand_avgs.append(0)\n\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demand_avgs[i] - route_demand_avgs[j])\n                    combined_score = spatial_dist + 0.5 * demand_diff  # Weight demand difference more\n\n                    if combined_score < best_score:\n                        best_score = combined_score\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                    len(route1) + len(route2) - 2 <= 15):  # Increased route length limit\n\n                    # Check if merging would create a more balanced route\n                    total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                    if abs(total_demand - capacity/2) < capacity/3:  # Accept if within 1/3 of half capacity\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]]\n                        new_solution.append(merged_route)\n\n        # Demand-aware spatial reallocation\n        if len(new_solution) > 1 and random.random() < 0.8:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with most extreme demand relative to route average\n                route_demand = demand[route[1:-1]]\n                route_avg = np.mean(route_demand)\n                customer_pos = np.argmax(np.abs(route_demand - route_avg)) + 1\n                customer = route[customer_pos]\n\n                # Find best route to insert based on spatial and demand compatibility\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = demand[other_route[1:-1]]\n                    if len(other_demand) == 0 or np.sum(other_demand) + demand[customer] > capacity:\n                        continue\n\n                    other_avg = np.mean(other_demand) if len(other_demand) > 0 else 0\n                    demand_diff = abs(route_avg - other_avg)\n\n                    # Find insertion position that minimizes spatial disruption\n                    min_insertion_cost = float('inf')\n                    best_insert_pos = -1\n\n                    for pos in range(1, len(other_route)):\n                        insertion_cost = (distance_matrix[other_route[pos-1], customer] +\n                                        distance_matrix[customer, other_route[pos]] -\n                                        distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if insertion_cost < min_insertion_cost:\n                            min_insertion_cost = insertion_cost\n                            best_insert_pos = pos\n\n                    total_score = min_insertion_cost + 0.4 * demand_diff  # Weight demand difference more\n\n                    if total_score < best_score:\n                        best_score = total_score\n                        best_route_idx = other_idx\n                        best_pos = best_insert_pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8956807917622304,
            3.4301752150058746
        ]
    }
]