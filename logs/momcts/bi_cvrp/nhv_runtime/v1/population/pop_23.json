[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects solutions from the archive using non-linear weighted objectives, applying a hybrid local search that combines adaptive route fragmentation (balancing demand and distance), demand-sensitive customer reallocation, probabilistic route merging (with capacity-aware criteria), and an adaptive customer exchange operator (prioritizing distance and demand balance). It emphasizes extreme solutions through exponential weighting and adjusts operator probabilities based on solution characteristics.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    # Normalize with non-linear scaling\n    norm_dist = (distances - min_dist) / (max_dist - min_dist + 1e-6)\n    norm_makespan = (makespans - min_makespan) / (max_makespan - min_makespan + 1e-6)\n\n    # Exponential weighting to emphasize extreme solutions\n    weight_dist = np.exp(-norm_dist * 0.5)\n    weight_makespan = np.exp(-norm_makespan * 0.5)\n\n    # Combine with adaptive focus\n    scores = weight_dist * norm_dist + weight_makespan * norm_makespan\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with adaptive operators\n    for _ in range(4):  # Increased iterations for better exploration\n        # Adaptive route fragmentation based on demand and distance\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:  # Only split if route is long enough\n                total_demand = np.sum(demand[route[1:-1]])\n                route_distance = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n\n                # Find split position that balances both demand and distance\n                best_split = 1\n                best_balance = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_demand = np.sum(demand[route[1:i+1]])\n                    current_dist = sum(distance_matrix[route[j-1], route[j]] for j in range(1, i+1))\n\n                    # Balance score combines demand and distance balance\n                    balance_score = abs((current_demand / total_demand) - 0.5) + \\\n                                  abs((current_dist / route_distance) - 0.5)\n\n                    if balance_score < best_balance:\n                        best_balance = balance_score\n                        best_split = i\n\n                fragment = route[best_split:]\n                remaining = route[:best_split+1]\n\n                if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                    np.sum(demand[remaining[1:-1]]) <= capacity):\n                    new_solution[route_idx] = remaining\n                    new_solution.append(fragment)\n\n        # Demand-sensitive customer reallocation\n        if len(new_solution) > 1:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customers based on demand and distance to depot\n                customers = sorted(range(1, len(source_route)-1),\n                                key=lambda x: demand[source_route[x]] * distance_matrix[0, source_route[x]],\n                                reverse=True)\n\n                num_to_move = min(3, len(customers))  # Move up to 3 customers\n\n                for customer_pos in customers[:num_to_move]:\n                    customer = source_route[customer_pos]\n\n                    # Find best insertion considering both distance and demand impact\n                    best_pos = 1\n                    best_score = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        dist_increase = (distance_matrix[target_route[pos-1], customer] +\n                                       distance_matrix[customer, target_route[pos]] -\n                                       distance_matrix[target_route[pos-1], target_route[pos]])\n\n                        # Demand impact score considers both current and potential demand\n                        current_demand = np.sum(demand[target_route[1:-1]])\n                        new_demand = current_demand + demand[customer]\n\n                        demand_score = abs(new_demand - capacity/2)  # Prefer medium demand routes\n\n                        # Distance to depot factor\n                        depot_dist_factor = distance_matrix[0, customer] / np.max(distance_matrix[0, :])\n\n                        total_score = dist_increase + 0.4 * demand_score + 0.3 * depot_dist_factor\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_pos = pos\n\n                    if (np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                        len(target_route) + 1 <= 25):  # Increased route length limit\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:customer_pos],\n                                                         source_route[customer_pos+1:]])\n                        new_solution[source_idx] = new_source_route\n\n        # Capacity-aware route merging\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            length1 = len(route1)\n            length2 = len(route2)\n\n            # More aggressive merging probability based on capacity utilization\n            merge_prob = min(0.9, 0.3 + 0.6 * (1 - abs(demand1 - demand2) / (total_demand + 1e-6)) +\n                           0.4 * (25 - (length1 + length2 - 2)) / 25)\n\n            if random.random() < merge_prob and total_demand <= capacity:\n                # Consider both direct and reverse merging\n                direct_merged = np.concatenate([route1[:-1], route2[1:]])\n                reverse_merged = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merging option with better distance\n                direct_dist = sum(distance_matrix[direct_merged[i-1], direct_merged[i]] for i in range(1, len(direct_merged)))\n                reverse_dist = sum(distance_matrix[reverse_merged[i-1], reverse_merged[i]] for i in range(1, len(reverse_merged)))\n\n                merged_route = direct_merged if direct_dist <= reverse_dist else reverse_merged\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    # Adaptive customer exchange operator\n    if len(new_solution) > 1 and random.random() < 0.4:  # Increased probability\n        swap_routes = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[swap_routes[0]], new_solution[swap_routes[1]]\n\n        # Consider multiple swap positions\n        best_swaps = []\n        best_score = float('inf')\n\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Calculate potential demand changes\n                new_demand1 = (np.sum(demand[route1[1:i]]) + demand[route2[j]] +\n                              np.sum(demand[route1[i+1:-1]]))\n                new_demand2 = (np.sum(demand[route2[1:j]]) + demand[route1[i]] +\n                              np.sum(demand[route2[j+1:-1]]))\n\n                if new_demand1 > capacity or new_demand2 > capacity:\n                    continue\n\n                # Calculate distance change\n                dist_change = (\n                    distance_matrix[route1[i-1], route2[j]] +\n                    distance_matrix[route2[j], route1[i+1]] -\n                    distance_matrix[route1[i-1], route1[i]] -\n                    distance_matrix[route1[i], route1[i+1]] +\n                    distance_matrix[route2[j-1], route1[i]] +\n                    distance_matrix[route1[i], route2[j+1]] -\n                    distance_matrix[route2[j-1], route2[j]] -\n                    distance_matrix[route2[j], route2[j+1]]\n                )\n\n                # Consider both demand balance and distance to depot\n                demand_balance = abs(new_demand1 - new_demand2)\n                depot_dist_factor = (distance_matrix[0, route1[i]] + distance_matrix[0, route2[j]]) / 2\n\n                total_score = dist_change + 0.4 * demand_balance + 0.2 * depot_dist_factor\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_swaps = [(i, j)]\n                elif total_score == best_score:\n                    best_swaps.append((i, j))\n\n        if best_swaps:\n            i, j = random.choice(best_swaps)\n            # Perform the swap\n            route1[i], route2[j] = route2[j], route1[i]\n            new_solution[swap_routes[0]] = route1\n            new_solution[swap_routes[1]] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.9282340368599087,
            1.7632462084293365
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of total distance and makespan, then applies a hybrid local search combining route merging (prioritizing routes with similar demand), splitting (for high-length-to-demand routes), and customer relocation (with proximity constraints to centroids). It emphasizes balancing demand and spatial proximity while prioritizing makespan reduction through intelligent route adjustments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]) / (max(x[1][0], x[1][1]) + 1))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route properties\n    route_properties = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_properties.append((np.zeros(2), 0, 0))\n            continue\n        customer_coords = coords[route[1:-1]]\n        centroid = np.mean(customer_coords, axis=0)\n        total_demand = np.sum(demand[route[1:-1]])\n        route_length = np.sum([distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)])\n        route_properties.append((centroid, total_demand, route_length))\n\n    # Hybrid local search\n    for _ in range(4):\n        # Try to merge routes with similar demand\n        if len(new_solution) > 1:\n            min_diff = float('inf')\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    demand_diff = abs(route_properties[i][1] - route_properties[j][1])\n                    if demand_diff < min_diff:\n                        min_diff = demand_diff\n                        best_pair = (i, j)\n\n            if best_pair is not None and min_diff < 0.3 * capacity:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n\n                total_demand = route_properties[i][1] + route_properties[j][1]\n                if total_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n\n                    # Update properties\n                    if len(merged_route) > 2:\n                        customer_coords = coords[merged_route[1:-1]]\n                        centroid = np.mean(customer_coords, axis=0)\n                        route_length = np.sum([distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)])\n                        route_properties[i] = (centroid, total_demand, route_length)\n                    else:\n                        route_properties[i] = (np.zeros(2), 0, 0)\n                    route_properties.pop(j)\n\n        # Try to split routes with high length-to-demand ratio\n        if len(new_solution) < len(base_solution) + 3:\n            max_ratio = -1\n            best_route = None\n            for i in range(len(new_solution)):\n                if len(new_solution[i]) > 4 and route_properties[i][1] > 0:\n                    ratio = route_properties[i][2] / route_properties[i][1]\n                    if ratio > max_ratio:\n                        max_ratio = ratio\n                        best_route = i\n\n            if best_route is not None and max_ratio > 1.2:\n                route = new_solution[best_route]\n                total_demand = route_properties[best_route][1]\n\n                best_split = None\n                min_ratio_diff = float('inf')\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n\n                    if left_demand <= capacity and right_demand <= capacity:\n                        left_length = np.sum([distance_matrix[route[k], route[k+1]] for k in range(j)])\n                        right_length = np.sum([distance_matrix[route[j+k], route[j+k+1]] for k in range(len(route)-j)])\n\n                        ratio_diff = abs((left_length / left_demand) - (right_length / right_demand))\n                        if ratio_diff < min_ratio_diff:\n                            min_ratio_diff = ratio_diff\n                            best_split = j\n\n                if best_split is not None:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[best_route] = first_part\n                    new_solution.append(second_part)\n\n                    # Update properties\n                    for part, idx in [(first_part, best_route), (second_part, len(new_solution)-1)]:\n                        if len(part) > 2:\n                            customer_coords = coords[part[1:-1]]\n                            centroid = np.mean(customer_coords, axis=0)\n                            part_demand = np.sum(demand[part[1:-1]])\n                            part_length = np.sum([distance_matrix[part[k], part[k+1]] for k in range(len(part)-1)])\n                            route_properties[idx] = (centroid, part_demand, part_length)\n                        else:\n                            route_properties[idx] = (np.zeros(2), 0, 0)\n\n        # Try customer relocation with proximity constraint\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Find target route with similar centroid\n                target_idx = None\n                min_centroid_dist = float('inf')\n                for i in range(len(new_solution)):\n                    if i != route_idx:\n                        dist = np.linalg.norm(route_properties[i][0] - coords[customer])\n                        if dist < min_centroid_dist:\n                            min_centroid_dist = dist\n                            target_idx = i\n\n                if target_idx is not None:\n                    other_route = new_solution[target_idx]\n\n                    # Find best insertion position with proximity constraint\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                       distance_matrix[customer, other_route[pos]] -\n                                       distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if dist_increase < min_increase and distance_matrix[customer, other_route[pos]] < 1.5 * np.mean(distance_matrix[other_route[pos-1], other_route[pos]]):\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                        new_solution[target_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n                        # Update properties\n                        for idx in [route_idx, target_idx]:\n                            route = new_solution[idx]\n                            if len(route) > 2:\n                                customer_coords = coords[route[1:-1]]\n                                centroid = np.mean(customer_coords, axis=0)\n                                part_demand = np.sum(demand[route[1:-1]])\n                                part_length = np.sum([distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)])\n                                route_properties[idx] = (centroid, part_demand, part_length)\n                            else:\n                                route_properties[idx] = (np.zeros(2), 0, 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9252961419680493,
            0.7954302430152893
        ]
    },
    {
        "algorithm": "The algorithm combines crowding-distance-based solution selection with a multi-stage hybrid local search that prioritizes demand-complementary route splitting, capacity-aware route consolidation, and probabilistic demand-balanced customer reallocation. It explicitly balances trade-offs between total distance and makespan optimization by selecting solutions with high crowding distances and applying demand-aware transformations to improve solution quality while maintaining feasibility. The approach emphasizes capacity utilization and demand balance through probabilistic operators and complementary demand-based route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    # Normalize objectives\n    norm_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances))\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans))\n\n    # Calculate crowding distances\n    sorted_idx = np.argsort(norm_dist)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_makespan[sorted_idx[i+1]] - norm_makespan[sorted_idx[i-1]]\n\n    sorted_idx = np.argsort(norm_makespan)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_dist[sorted_idx[i+1]] - norm_dist[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(3):\n        # Stage 1: Demand-complementary route splitting\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                # Find customer with demand most complementary to route's average demand\n                route_demand = np.sum(demand[route[1:-1]])\n                avg_demand = route_demand / (len(route) - 2)\n                best_split = None\n                best_diff = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_diff = abs(demand[route[i]] - avg_demand)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_split = i\n\n                if best_split:\n                    split_pos = best_split\n                    fragment = route[split_pos:]\n                    remaining = route[:split_pos+1]\n\n                    if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                        np.sum(demand[remaining[1:-1]]) <= capacity):\n                        new_solution[route_idx] = remaining\n                        new_solution.append(fragment)\n\n        # Stage 2: Capacity-aware route consolidation\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            remaining_cap1 = capacity - demand1\n            remaining_cap2 = capacity - demand2\n\n            # Probability of merging based on capacity complementarity\n            merge_prob = 0.5 * (1 - abs(remaining_cap1 - remaining_cap2) / capacity) + 0.5\n\n            if random.random() < merge_prob and (demand1 + demand2) <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n        # Stage 3: Probabilistic demand-balanced customer reallocation\n        if len(new_solution) > 1 and random.random() < 0.4:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer whose demand is closest to target route's remaining capacity\n                target_demand = np.sum(demand[target_route[1:-1]])\n                remaining_cap = capacity - target_demand\n                best_customer = None\n                best_diff = float('inf')\n\n                for i in range(1, len(source_route)-1):\n                    current_diff = abs(demand[source_route[i]] - remaining_cap)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_customer = i\n\n                if best_customer:\n                    customer = source_route[best_customer]\n\n                    # Find best insertion position considering demand balance\n                    best_pos = 1\n                    best_balance = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_demand = target_demand + demand[customer]\n                        new_balance = abs(new_demand - capacity/2)  # Prefer balanced demand\n\n                        if new_balance < best_balance:\n                            best_balance = new_balance\n                            best_pos = pos\n\n                    if new_demand <= capacity:\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:best_customer],\n                                                         source_route[best_customer+1:]])\n                        new_solution[source_idx] = new_source_route\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7965868091436135,
            0.1786138117313385
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding distance to explore diverse trade-offs, then applies a demand-aware fragmentation operator to split imbalanced routes and a load-balanced merging operator to combine complementary routes, prioritizing demand complementarity (70%) over spatial proximity (30%) while maintaining feasibility through capacity checks. The approach balances exploration of the objective space with targeted local improvements to reduce both total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) < 2:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances\n        archive_sorted_dist = sorted(archive, key=lambda x: x[1][0])\n        archive_sorted_make = sorted(archive, key=lambda x: x[1][1])\n\n        crowding_dist = {}\n        for i, (sol, obj) in enumerate(archive):\n            if i == 0 or i == len(archive)-1:\n                crowding_dist[i] = float('inf')\n            else:\n                dist_diff = (archive_sorted_dist[i+1][1][0] - archive_sorted_dist[i-1][1][0]) / (archive_sorted_dist[-1][1][0] - archive_sorted_dist[0][1][0])\n                make_diff = (archive_sorted_make[i+1][1][1] - archive_sorted_make[i-1][1][1]) / (archive_sorted_make[-1][1][1] - archive_sorted_make[0][1][1])\n                crowding_dist[i] = dist_diff + make_diff\n\n        selected_idx = max(crowding_dist.keys(), key=lambda k: crowding_dist[k])\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Demand-aware fragmentation\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find route with most demand imbalance\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        most_imbalanced_idx = max(range(len(new_solution)), key=lambda i: abs(route_demands[i] - capacity/2))\n\n        # Find split point that balances demand\n        route = new_solution[most_imbalanced_idx]\n        if len(route) <= 3:\n            continue\n\n        cumulative_demand = np.cumsum(demand[route[1:-1]])\n        split_pos = np.argmin(np.abs(cumulative_demand - capacity/2)) + 1\n\n        # Create new route from split point\n        new_route = np.concatenate([[0], route[split_pos:], [0]])\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution.append(new_route)\n            new_solution[most_imbalanced_idx] = np.concatenate([[0], route[1:split_pos+1], [0]])\n\n    # Load-balanced merging\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find routes with complementary demands\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        route_centers = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else np.zeros(2) for route in new_solution]\n\n        best_merge = None\n        best_score = -float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                combined_demand = route_demands[i] + route_demands[j]\n                if combined_demand > capacity:\n                    continue\n\n                # Calculate weighted score: demand complementarity + spatial proximity\n                demand_score = (capacity - abs(capacity - combined_demand)) / capacity\n                spatial_score = 1 / (1 + np.linalg.norm(route_centers[i] - route_centers[j]))\n                score = 0.7 * demand_score + 0.3 * spatial_score\n\n                if score > best_score:\n                    best_score = score\n                    best_merge = (i, j)\n\n        if best_merge is not None:\n            i, j = best_merge\n            # Merge routes\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution.append(merged_route)\n                del new_solution[max(i, j)]\n                del new_solution[min(i, j)]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8278933615924351,
            0.5591227412223816
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-stage hybrid local search that prioritizes balanced solutions (70% distance, 30% makespan) and applies demand-aware route fragmentation, route reversal, customer reallocation with demand pattern matching, and route merging operations iteratively to improve solutions while maintaining feasibility. It intelligently targets customers with similar demand patterns and routes with complementary load characteristics to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.7 + weights[:, 1] * 0.3\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(6):  # Perform 6 iterations of the hybrid operator\n        # Stage 1: Demand-aware route fragmentation\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find split point that balances demand\n                total_demand = np.sum(demand[route[1:-1]])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Route reversal with capacity check\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Customer reallocation with demand pattern matching\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customers with similar demand patterns\n                route_demand = demand[route[1:-1]]\n                median_demand = np.median(route_demand)\n                similar_customers = [i for i, d in enumerate(route_demand)\n                                   if abs(d - median_demand) <= median_demand * 0.3]\n\n                if similar_customers:\n                    customer_pos = random.choice(similar_customers) + 1\n                    customer = route[customer_pos]\n\n                    # Find best route to insert based on demand compatibility\n                    best_route_idx = -1\n                    best_pos = -1\n                    min_demand_diff = float('inf')\n\n                    for other_idx, other_route in enumerate(new_solution):\n                        if other_idx == route_idx:\n                            continue\n\n                        other_demand = np.sum(demand[other_route[1:-1]])\n                        if other_demand + demand[customer] > capacity:\n                            continue\n\n                        for pos in range(1, len(other_route)):\n                            new_demand = other_demand + demand[customer]\n                            demand_diff = abs(new_demand - capacity/2)\n\n                            if demand_diff < min_demand_diff:\n                                min_demand_diff = demand_diff\n                                best_route_idx = other_idx\n                                best_pos = pos\n\n                    if best_route_idx != -1:\n                        other_route = new_solution[best_route_idx]\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            [customer],\n                            other_route[best_pos:]\n                        ])\n                        new_solution[best_route_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n        # Stage 4: Route merging with load balancing\n        if len(new_solution) > 1:\n            routes_to_merge = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n\n            route1 = new_solution[routes_to_merge[0]]\n            route2 = new_solution[routes_to_merge[1]]\n\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                len(route1) + len(route2) - 2 <= 25):\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                               if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8703280146268155,
            1.1190491020679474
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from an archive using a hybrid of fitness sharing and dominance ranking, then applies a demand-aware route balancing operator that prioritizes spatial clustering (60%) over demand complementarity (40%) while ensuring capacity feasibility. It alternates between spatial imbalance reduction via route splitting and demand-based merging with spatial constraints, iteratively improving both distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) < 2:\n        base_solution = archive[0][0].copy()\n    else:\n        # Hybrid selection using fitness sharing and dominance ranking\n        archive_sorted_dist = sorted(archive, key=lambda x: x[1][0])\n        archive_sorted_make = sorted(archive, key=lambda x: x[1][1])\n\n        # Calculate dominance ranks\n        dominance = {}\n        for i, (sol, obj) in enumerate(archive):\n            rank = sum(1 for j in range(len(archive)) if archive_sorted_dist[j][1][0] < obj[0] and archive_sorted_make[j][1][1] < obj[1])\n            dominance[i] = rank\n\n        # Calculate shared fitness\n        shared_fitness = {}\n        for i, (sol, obj) in enumerate(archive):\n            distance = 0\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i == j:\n                    continue\n                euclidean_dist = np.sqrt((obj[0] - obj_j[0])**2 + (obj[1] - obj_j[1])**2)\n                if euclidean_dist < 1.0:  # Sharing radius\n                    distance += 1 - euclidean_dist\n            shared_fitness[i] = 1 / (1 + distance)\n\n        # Select based on combined score\n        selection_scores = {}\n        for i in range(len(archive)):\n            selection_scores[i] = shared_fitness[i] / (1 + dominance[i])\n\n        selected_idx = max(selection_scores.keys(), key=lambda k: selection_scores[k])\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Spatial clustering balancing\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Find route with most spatial imbalance\n        route_centers = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else np.zeros(2) for route in new_solution]\n        overall_center = np.mean(np.concatenate([coords[route[1:-1]] for route in new_solution]), axis=0) if any(len(route) > 2 for route in new_solution) else np.zeros(2)\n        imbalance_scores = [np.linalg.norm(center - overall_center) for center in route_centers]\n        most_imbalanced_idx = max(range(len(new_solution)), key=lambda i: imbalance_scores[i])\n\n        # Find split point that balances spatial distribution\n        route = new_solution[most_imbalanced_idx]\n        if len(route) <= 3:\n            continue\n\n        # Calculate spatial balance score for each possible split\n        best_split = None\n        best_score = float('inf')\n\n        for split_pos in range(1, len(route)-1):\n            left_route = route[:split_pos+1]\n            right_route = np.concatenate([[0], route[split_pos:], [0]])\n\n            left_center = np.mean(coords[left_route[1:-1]], axis=0) if len(left_route) > 2 else np.zeros(2)\n            right_center = np.mean(coords[right_route[1:-1]], axis=0) if len(right_route) > 2 else np.zeros(2)\n\n            left_score = np.linalg.norm(left_center - overall_center)\n            right_score = np.linalg.norm(right_center - overall_center)\n            score = abs(left_score - right_score)\n\n            if score < best_score and np.sum(demand[left_route[1:-1]]) <= capacity and np.sum(demand[right_route[1:-1]]) <= capacity:\n                best_score = score\n                best_split = split_pos\n\n        if best_split is not None:\n            left_route = route[:best_split+1]\n            right_route = np.concatenate([[0], route[best_split:], [0]])\n            new_solution[most_imbalanced_idx] = left_route\n            new_solution.append(right_route)\n\n    # Demand-aware merging with spatial constraints\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        route_centers = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else np.zeros(2) for route in new_solution]\n\n        best_merge = None\n        best_score = -float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                combined_demand = route_demands[i] + route_demands[j]\n                if combined_demand > capacity:\n                    continue\n\n                # Calculate weighted score: spatial proximity + demand complementarity\n                spatial_score = 1 / (1 + np.linalg.norm(route_centers[i] - route_centers[j]))\n                demand_score = (capacity - abs(capacity - combined_demand)) / capacity\n                score = 0.6 * spatial_score + 0.4 * demand_score\n\n                if score > best_score:\n                    best_score = score\n                    best_merge = (i, j)\n\n        if best_merge is not None:\n            i, j = best_merge\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution.append(merged_route)\n                del new_solution[max(i, j)]\n                del new_solution[min(i, j)]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8810906431484877,
            1.3028977513313293
        ]
    },
    {
        "algorithm": "This algorithm implements a multi-stage hybrid local search for the Bi-CVRP, prioritizing balanced solutions (60% distance, 40% makespan) and applying adaptive route segmentation, demand-aware customer insertion, route reversal with capacity optimization, and intelligent route merging with load balancing. It uses dynamic programming for optimal split points and reversal segments, while maintaining feasibility through capacity checks and demand pattern analysis. The algorithm iteratively refines solutions through 8 stages of transformations, focusing on both distance minimization and makespan reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] / max(1, obj[0]), obj[1] / max(1, obj[1])) for _, obj in archive])\n    scores = weights[:, 0] * 0.6 + weights[:, 1] * 0.4\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search with 8 iterations\n    for _ in range(8):\n        # Stage 1: Adaptive route segmentation with demand optimization\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal split point using dynamic programming\n                demands = demand[route[1:-1]]\n                n = len(demands)\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                split_pos = 1\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demands[j-1]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[split_pos]:\n                        split_pos = i\n\n                fragment1 = route[:split_pos+1]\n                fragment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                    np.sum(demand[fragment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = fragment1\n                    new_solution.append(fragment2)\n\n        # Stage 2: Demand-aware customer insertion\n        if len(new_solution) > 0:\n            # Select customer from route with highest demand variance\n            route_idx = np.argmax([np.std(demand[route[1:-1]]) for route in new_solution])\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with demand closest to average\n                route_demand = demand[route[1:-1]]\n                avg_demand = np.mean(route_demand)\n                closest_customer = np.argmin(np.abs(route_demand - avg_demand)) + 1\n                customer = route[closest_customer]\n\n                # Find best insertion point in another route\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        # Calculate insertion score based on distance and demand balance\n                        insert_dist = (distance_matrix[other_route[pos-1]][customer] +\n                                      distance_matrix[customer][other_route[pos]] -\n                                      distance_matrix[other_route[pos-1]][other_route[pos]])\n                        new_demand = other_demand + demand[customer]\n                        demand_score = abs(new_demand - capacity/2)\n\n                        total_score = insert_dist * 0.7 + demand_score * 0.3\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_route_idx = other_idx\n                            best_pos = pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:closest_customer], route[closest_customer+1:]])\n                    new_solution[route_idx] = new_route\n\n        # Stage 3: Route reversal with capacity optimization\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find optimal reversal segment using dynamic programming\n                n = len(route) - 2\n                dp = [float('inf')] * (n + 1)\n                dp[0] = 0\n                best_i, best_j = 1, 2\n\n                for i in range(1, n + 1):\n                    current_demand = 0\n                    for j in range(i, n + 1):\n                        current_demand += demand[route[j]]\n                        if current_demand <= capacity:\n                            dp[j] = min(dp[j], dp[i-1] + abs(current_demand - capacity/2))\n                        else:\n                            break\n                    if i > 1 and dp[i] < dp[best_i]:\n                        best_i, best_j = i, j\n\n                reversed_segment = route[best_i:best_j+1][::-1]\n                new_route = np.concatenate([route[:best_i], reversed_segment, route[best_j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Stage 4: Intelligent route merging with load balancing\n        if len(new_solution) > 1:\n            # Find pair of routes with most complementary demand patterns\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    demand_i = np.sum(demand[new_solution[i][1:-1]])\n                    demand_j = np.sum(demand[new_solution[j][1:-1]])\n                    if demand_i + demand_j <= capacity:\n                        score = abs(demand_i + demand_j - capacity/2)\n                        if score < best_score:\n                            best_score = score\n                            best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Try both possible merge directions\n                merged1 = np.concatenate([route1[:-1], route2[1:]])\n                merged2 = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merge direction that better balances demands\n                demand1 = np.sum(demand[merged1[1:-1]])\n                demand2 = np.sum(demand[merged2[1:-1]])\n                score1 = abs(demand1 - capacity/2)\n                score2 = abs(demand2 - capacity/2)\n\n                if score1 <= score2 and len(merged1) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged1)\n                elif len(merged2) <= 25:\n                    new_solution = [route for k, route in enumerate(new_solution) if k not in best_pair]\n                    new_solution.append(merged2)\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.915810040703673,
            8.590130120515823
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid crowding and dominance score, then applies a series of demand-pattern-aware spatial fragmentation, load-balanced merging, and demand-aware reallocation operators to iteratively improve the solution while maintaining feasibility. It prioritizes spatial proximity and demand balance, dynamically adjusting route splits and merges based on demand distribution and spatial coherence, with higher emphasis on demand compatibility during reallocation. The algorithm balances exploration through probabilistic operations and exploitation through demand-based heuristics, ensuring capacity constraints are respected throughout the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    # Calculate dominance score\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        better_than = 0\n        for j in range(len(archive)):\n            if (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) or \\\n               (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]):\n                better_than += 1\n        dominance[i] = better_than\n\n    # Combine crowding and dominance\n    crowding = np.zeros(len(archive))\n    sorted_idx = np.argsort(normalized[:, 0])\n    crowding[sorted_idx[0]] = float('inf')\n    crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[sorted_idx[i]] = (normalized[sorted_idx[i+1], 0] - normalized[sorted_idx[i-1], 0])\n\n    combined_score = 0.6 * crowding + 0.4 * dominance\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Iterative improvement with hybrid operators\n    for _ in range(8):\n        # Demand-pattern-aware spatial fragmentation\n        if len(new_solution) > 1 and random.random() < 0.7:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                route_demand = demand[route[1:-1]]\n                demand_std = np.std(route_demand)\n\n                if demand_std > 0:  # Only proceed if demand pattern is diverse\n                    # Find split point that balances demand and spatial proximity\n                    total_demand = np.sum(route_demand)\n                    target_demand = total_demand * 0.5  # Split at 50% of total demand\n                    current_demand = 0\n                    best_split = 1\n\n                    for i in range(1, len(route)-1):\n                        current_demand += demand[route[i]]\n                        if current_demand >= target_demand:\n                            # Consider spatial proximity to current position\n                            spatial_score = distance_matrix[route[i-1], route[i]] + distance_matrix[route[i], route[i+1]]\n                            if i == 1 or spatial_score < distance_matrix[route[best_split-1], route[best_split]] + distance_matrix[route[best_split], route[best_split+1]]:\n                                best_split = i\n\n                    fragment1 = route[:best_split+1]\n                    fragment2 = np.concatenate([[0], route[best_split+1:]])\n\n                    if (np.sum(demand[fragment1[1:-1]]) <= capacity and\n                        np.sum(demand[fragment2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = fragment1\n                        new_solution.append(fragment2)\n\n        # Load-balanced spatial merging\n        if len(new_solution) > 2 and random.random() < 0.6:\n            # Find routes with similar demand patterns and spatial proximity\n            route_centroids = []\n            route_demand_avgs = []\n            for route in new_solution:\n                if len(route) > 2:\n                    route_coords = coords[route[1:-1]]\n                    centroid = np.mean(route_coords, axis=0)\n                    route_centroids.append(centroid)\n                    route_demand = demand[route[1:-1]]\n                    route_demand_avgs.append(np.mean(route_demand) if len(route_demand) > 0 else 0)\n                else:\n                    route_centroids.append(np.zeros(2))\n                    route_demand_avgs.append(0)\n\n            best_pair = None\n            best_score = float('inf')\n\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demand_avgs[i] - route_demand_avgs[j])\n                    combined_score = spatial_dist + 0.5 * demand_diff  # Weight demand difference more\n\n                    if combined_score < best_score:\n                        best_score = combined_score\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity and\n                    len(route1) + len(route2) - 2 <= 15):  # Increased route length limit\n\n                    # Check if merging would create a more balanced route\n                    total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                    if abs(total_demand - capacity/2) < capacity/3:  # Accept if within 1/3 of half capacity\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]]\n                        new_solution.append(merged_route)\n\n        # Demand-aware spatial reallocation\n        if len(new_solution) > 1 and random.random() < 0.8:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find customer with most extreme demand relative to route average\n                route_demand = demand[route[1:-1]]\n                route_avg = np.mean(route_demand)\n                customer_pos = np.argmax(np.abs(route_demand - route_avg)) + 1\n                customer = route[customer_pos]\n\n                # Find best route to insert based on spatial and demand compatibility\n                best_route_idx = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for other_idx, other_route in enumerate(new_solution):\n                    if other_idx == route_idx:\n                        continue\n\n                    other_demand = demand[other_route[1:-1]]\n                    if len(other_demand) == 0 or np.sum(other_demand) + demand[customer] > capacity:\n                        continue\n\n                    other_avg = np.mean(other_demand) if len(other_demand) > 0 else 0\n                    demand_diff = abs(route_avg - other_avg)\n\n                    # Find insertion position that minimizes spatial disruption\n                    min_insertion_cost = float('inf')\n                    best_insert_pos = -1\n\n                    for pos in range(1, len(other_route)):\n                        insertion_cost = (distance_matrix[other_route[pos-1], customer] +\n                                        distance_matrix[customer, other_route[pos]] -\n                                        distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if insertion_cost < min_insertion_cost:\n                            min_insertion_cost = insertion_cost\n                            best_insert_pos = pos\n\n                    total_score = min_insertion_cost + 0.4 * demand_diff  # Weight demand difference more\n\n                    if total_score < best_score:\n                        best_score = total_score\n                        best_route_idx = other_idx\n                        best_pos = best_insert_pos\n\n                if best_route_idx != -1:\n                    other_route = new_solution[best_route_idx]\n                    new_other_route = np.concatenate([\n                        other_route[:best_pos],\n                        [customer],\n                        other_route[best_pos:]\n                    ])\n                    new_solution[best_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n    # Final cleanup\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8956807917622304,
            3.4301752150058746
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of objectives (60% distance, 40% makespan) and applies a hybrid local search combining spatial clustering-based merging, demand-aware splitting, and customer relocation with spatial consideration to improve both objectives while maintaining feasibility. It prioritizes routes with high demand or spatial imbalance, balancing improvements in distance and makespan through iterative refinement of route structures.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_metrics.append((0, 0, 0))  # (demand, length, centroid)\n            continue\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        route_length = np.sum(distance_matrix[route[:-1], route[1:]])\n        centroid = np.mean(coords[customers], axis=0)\n        route_metrics.append((total_demand, route_length, centroid))\n\n    # Hybrid local search with spatial clustering\n    for _ in range(4):\n        # Spatial clustering-based merging\n        if len(new_solution) > 1:\n            # Cluster routes based on spatial proximity\n            centroids = [metric[2] for metric in route_metrics]\n            clusters = []\n            visited = [False] * len(new_solution)\n\n            for i in range(len(new_solution)):\n                if not visited[i]:\n                    cluster = [i]\n                    visited[i] = True\n                    for j in range(i+1, len(new_solution)):\n                        if not visited[j] and np.linalg.norm(centroids[i] - centroids[j]) < 1.5 * np.mean(distance_matrix[0]):\n                            cluster.append(j)\n                            visited[j] = True\n                    clusters.append(cluster)\n\n            # Try merging within clusters\n            for cluster in clusters:\n                if len(cluster) > 1:\n                    # Sort routes in cluster by demand\n                    cluster_sorted = sorted(cluster, key=lambda x: route_metrics[x][0])\n                    i, j = cluster_sorted[0], cluster_sorted[-1]\n\n                    route1, route2 = new_solution[i], new_solution[j]\n                    total_demand = route_metrics[i][0] + route_metrics[j][0]\n\n                    if total_demand <= capacity:\n                        # Merge routes with demand balancing\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        route_metrics.pop(j)\n\n                        # Update metrics\n                        customers = merged_route[1:-1]\n                        route_metrics[i] = (\n                            np.sum(demand[customers]),\n                            np.sum(distance_matrix[merged_route[:-1], merged_route[1:]]),\n                            np.mean(coords[customers], axis=0) if len(customers) > 0 else np.zeros(2)\n                        )\n\n        # Demand-aware splitting\n        if len(new_solution) < len(base_solution) + 3:\n            # Find route with highest demand\n            max_demand_idx = max(range(len(new_solution)), key=lambda x: route_metrics[x][0])\n            route = new_solution[max_demand_idx]\n\n            if len(route) > 4 and route_metrics[max_demand_idx][0] > 0.7 * capacity:\n                # Find balanced split point\n                customers = route[1:-1]\n                total_demand = route_metrics[max_demand_idx][0]\n                best_split = None\n                min_diff = float('inf')\n\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n\n                    if left_demand <= capacity and right_demand <= capacity:\n                        diff = abs(left_demand - right_demand)\n                        if diff < min_diff:\n                            min_diff = diff\n                            best_split = j\n\n                if best_split is not None:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[max_demand_idx] = first_part\n                    new_solution.append(second_part)\n\n                    # Update metrics\n                    for part, idx in [(first_part, max_demand_idx), (second_part, -1)]:\n                        customers = part[1:-1]\n                        if idx == -1:\n                            route_metrics.append((\n                                np.sum(demand[customers]),\n                                np.sum(distance_matrix[part[:-1], part[1:]]),\n                                np.mean(coords[customers], axis=0) if len(customers) > 0 else np.zeros(2)\n                            ))\n                        else:\n                            route_metrics[idx] = (\n                                np.sum(demand[customers]),\n                                np.sum(distance_matrix[part[:-1], part[1:]]),\n                                np.mean(coords[customers], axis=0) if len(customers) > 0 else np.zeros(2)\n                            )\n\n        # Customer relocation with spatial consideration\n        if len(new_solution) > 1:\n            # Select route with highest length-to-demand ratio\n            route_idx = max(range(len(new_solution)), key=lambda x: route_metrics[x][1] / (route_metrics[x][0] + 1e-6))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Select customer closest to route centroid\n                customers = route[1:-1]\n                centroid = route_metrics[route_idx][2]\n                customer_pos = np.argmin([np.linalg.norm(coords[c] - centroid) for c in customers]) + 1\n                customer = route[customer_pos]\n\n                # Select target route based on spatial proximity and demand fit\n                other_route_idx = min(\n                    [i for i in range(len(new_solution)) if i != route_idx],\n                    key=lambda i: (\n                        np.linalg.norm(route_metrics[i][2] - centroid),\n                        abs(route_metrics[i][0] + demand[customer] - 0.5 * capacity)\n                    )\n                )\n                other_route = new_solution[other_route_idx]\n\n                # Find best insertion position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(other_route)):\n                    dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                   distance_matrix[customer, other_route[pos]] -\n                                   distance_matrix[other_route[pos-1], other_route[pos]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Check capacity\n                if route_metrics[other_route_idx][0] + demand[customer] <= capacity:\n                    # Perform relocation\n                    new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                    new_solution[other_route_idx] = new_other_route\n\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_solution[route_idx] = new_route\n\n                    # Update metrics\n                    for part, idx in [(new_other_route, other_route_idx), (new_route, route_idx)]:\n                        customers = part[1:-1]\n                        route_metrics[idx] = (\n                            np.sum(demand[customers]),\n                            np.sum(distance_matrix[part[:-1], part[1:]]),\n                            np.mean(coords[customers], axis=0) if len(customers) > 0 else np.zeros(2)\n                        )\n\n    # Remove empty routes and update metrics\n    new_solution = [route for route in new_solution if len(route) > 2]\n    route_metrics = [metric for route, metric in zip(new_solution, route_metrics) if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.632854039965471,
            1.3363809883594513
        ]
    }
]