[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route reversal and customer insertion to generate a neighbor solution while ensuring feasibility. It intelligently balances exploration and exploitation by iteratively modifying routes and customers, checking capacity constraints, and removing empty routes. The key design choices include prioritizing solutions with better objectives, combining 2-opt-like operations with customer relocations, and ensuring feasibility at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route reversal and customer insertion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Apply route reversal (2-opt-like operation)\n        i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n        reversed_segment = route[i:j+1][::-1]\n        new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[route_idx] = new_route\n            route = new_route\n\n        # Apply customer insertion (move a customer to another route)\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Select a random customer to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find insertion position in other route\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(other_route)):\n                # Calculate distance increase\n                dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                distance_matrix[customer, other_route[pos]] -\n                                distance_matrix[other_route[pos-1], other_route[pos]])\n\n                if dist_increase < min_increase:\n                    min_increase = dist_increase\n                    best_pos = pos\n\n            # Check capacity feasibility\n            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into other route\n                new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                new_solution[other_route_idx] = new_other_route\n\n                # Remove customer from original route\n                new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8618261031397456,
            0.17265713214874268
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive, then applies a dynamic hybrid local search combining demand-aware spatial clustering, load-balanced route fragmentation, and multi-objective hybrid reinsertion, adaptively adjusting operator probabilities based on operator success rates while maintaining feasibility through continuous capacity checks. It prioritizes operators that show recent success (e.g., increasing weights for merge/split if successful) and focuses on spatial proximity and demand compatibility for route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route statistics and centroids\n    route_stats = []\n    route_centroids = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_stats.append((0, 0, 0, 0))\n            route_centroids.append(np.zeros(2))\n            continue\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        centroid = np.mean(coords[customers], axis=0)\n        route_stats.append((total_demand, total_distance, centroid, len(customers)))\n        route_centroids.append(centroid)\n\n    # Dynamic hybrid local search\n    operators = ['merge', 'split', 'reverse', 'insert']\n    operator_weights = [0.3, 0.3, 0.2, 0.2]  # Initial weights\n\n    for _ in range(5):  # Perform 5 iterations\n        # Select operator based on current weights\n        operator = random.choices(operators, weights=operator_weights, k=1)[0]\n\n        if operator == 'merge' and len(new_solution) >= 2:\n            # Find closest pair of routes\n            min_dist = float('inf')\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n                total_demand = route_stats[i][0] + route_stats[j][0]\n                if total_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    route_stats.pop(j)\n                    route_centroids.pop(j)\n                    if len(merged_route) > 2:\n                        customers = merged_route[1:-1]\n                        route_stats[i] = (np.sum(demand[customers]),\n                                         sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)),\n                                         np.mean(coords[customers], axis=0),\n                                         len(customers))\n                        route_centroids[i] = route_stats[i][2]\n                    else:\n                        route_stats[i] = (0, 0, np.zeros(2), 0)\n                        route_centroids[i] = np.zeros(2)\n                    # Update weights to favor merge more if successful\n                    operator_weights = [w * 1.1 if op == 'merge' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'split' and len(new_solution) > 1:\n            # Find longest route with high demand\n            longest_idx = max(range(len(new_solution)), key=lambda i: route_stats[i][0])\n            route = new_solution[longest_idx]\n            if len(route) > 4:\n                customers = route[1:-1]\n                total_demand = route_stats[longest_idx][0]\n                best_split = None\n                min_diff = float('inf')\n\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n                    if left_demand <= capacity and right_demand <= capacity:\n                        diff = abs(left_demand - right_demand)\n                        if diff < min_diff:\n                            min_diff = diff\n                            best_split = j\n\n                if best_split:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[longest_idx] = first_part\n                    new_solution.append(second_part)\n\n                    # Update stats for both parts\n                    for k, part in enumerate([first_part, second_part]):\n                        if len(part) > 2:\n                            customers = part[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[part[i], part[i+1]] for i in range(len(part)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[longest_idx] = stats\n                                route_centroids[longest_idx] = stats[2]\n                            else:\n                                route_stats.append(stats)\n                                route_centroids.append(stats[2])\n                        else:\n                            if k == 0:\n                                route_stats[longest_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[longest_idx] = np.zeros(2)\n                            else:\n                                route_stats.append((0, 0, np.zeros(2), 0))\n                                route_centroids.append(np.zeros(2))\n                    # Update weights to favor split more if successful\n                    operator_weights = [w * 1.1 if op == 'split' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'reverse' and len(new_solution) > 0:\n            # Select a route to reverse\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n                    customers = new_route[1:-1]\n                    route_stats[route_idx] = (np.sum(demand[customers]),\n                                             sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1)),\n                                             np.mean(coords[customers], axis=0),\n                                             len(customers))\n                    route_centroids[route_idx] = route_stats[route_idx][2]\n                    # Update weights to favor reverse more if successful\n                    operator_weights = [w * 1.1 if op == 'reverse' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'insert' and len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 2:\n                # Select a customer to move\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                # Find best insertion position in route2\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    dist_increase = (distance_matrix[route2[pos-1], customer] +\n                                   distance_matrix[customer, route2[pos]] -\n                                   distance_matrix[route2[pos-1], route2[pos]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                # Check capacity feasibility\n                if route_stats[route2_idx][0] + demand[customer] <= capacity:\n                    # Insert customer into route2\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    # Remove customer from route1\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    # Update stats for both routes\n                    for k, route in enumerate([new_route1, new_route2]):\n                        if len(route) > 2:\n                            customers = route[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[route1_idx] = stats\n                                route_centroids[route1_idx] = stats[2]\n                            else:\n                                route_stats[route2_idx] = stats\n                                route_centroids[route2_idx] = stats[2]\n                        else:\n                            if k == 0:\n                                route_stats[route1_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[route1_idx] = np.zeros(2)\n                            else:\n                                route_stats[route2_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[route2_idx] = np.zeros(2)\n                    # Update weights to favor insert more if successful\n                    operator_weights = [w * 1.1 if op == 'insert' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9445891665421444,
            0.6630864441394806
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using adaptive extreme-solution targeting, then applies a multi-stage hybrid local search combining demand-aware spatial clustering, dynamic operator fusion, and weighted multi-objective reinsertion to generate a neighbor solution while maintaining feasibility. It prioritizes operators that improve both objectives (distance and makespan) through weighted scoring, with higher weights for successful operators, and balances improvements between routes based on demand clusters. The algorithm dynamically adjusts operator weights and focuses on demand-aware transformations to balance the bi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]), reverse=True)\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route statistics and demand clusters\n    route_stats = []\n    demand_clusters = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_stats.append((0, 0, 0, 0))\n            demand_clusters.append(0)\n            continue\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        demand_cluster = np.mean(demand[customers])\n        route_stats.append((total_demand, total_distance, demand_cluster, len(customers)))\n        demand_clusters.append(demand_cluster)\n\n    # Dynamic operator fusion\n    operators = ['cluster_merge', 'demand_split', 'reverse', 'weighted_insert']\n    operator_weights = [0.3, 0.3, 0.2, 0.2]\n\n    for _ in range(5):\n        operator = random.choices(operators, weights=operator_weights, k=1)[0]\n\n        if operator == 'cluster_merge' and len(new_solution) >= 2:\n            # Merge routes from the same demand cluster\n            cluster_routes = {}\n            for i, route in enumerate(new_solution):\n                if len(route) > 2:\n                    cluster = route_stats[i][2]\n                    if cluster not in cluster_routes:\n                        cluster_routes[cluster] = []\n                    cluster_routes[cluster].append(i)\n\n            for cluster, routes in cluster_routes.items():\n                if len(routes) >= 2:\n                    i, j = sorted(routes[:2])\n                    route1, route2 = new_solution[i], new_solution[j]\n                    total_demand = route_stats[i][0] + route_stats[j][0]\n                    if total_demand <= capacity:\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        route_stats.pop(j)\n                        demand_clusters.pop(j)\n                        if len(merged_route) > 2:\n                            customers = merged_route[1:-1]\n                            route_stats[i] = (np.sum(demand[customers]),\n                                            sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)),\n                                            np.mean(demand[customers]),\n                                            len(customers))\n                            demand_clusters[i] = route_stats[i][2]\n                        else:\n                            route_stats[i] = (0, 0, 0, 0)\n                            demand_clusters[i] = 0\n                        operator_weights = [w * 1.1 if op == 'cluster_merge' else w * 0.9 for w, op in zip(operator_weights, operators)]\n                        break\n\n        elif operator == 'demand_split' and len(new_solution) > 1:\n            # Split routes based on demand balance\n            longest_idx = max(range(len(new_solution)), key=lambda i: route_stats[i][0])\n            route = new_solution[longest_idx]\n            if len(route) > 4:\n                customers = route[1:-1]\n                total_demand = route_stats[longest_idx][0]\n                best_split = None\n                min_diff = float('inf')\n\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n                    if left_demand <= capacity and right_demand <= capacity:\n                        diff = abs(left_demand - right_demand)\n                        if diff < min_diff:\n                            min_diff = diff\n                            best_split = j\n\n                if best_split:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[longest_idx] = first_part\n                    new_solution.append(second_part)\n\n                    for k, part in enumerate([first_part, second_part]):\n                        if len(part) > 2:\n                            customers = part[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[part[i], part[i+1]] for i in range(len(part)-1)),\n                                   np.mean(demand[customers]),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[longest_idx] = stats\n                                demand_clusters[longest_idx] = stats[2]\n                            else:\n                                route_stats.append(stats)\n                                demand_clusters.append(stats[2])\n                        else:\n                            if k == 0:\n                                route_stats[longest_idx] = (0, 0, 0, 0)\n                                demand_clusters[longest_idx] = 0\n                            else:\n                                route_stats.append((0, 0, 0, 0))\n                                demand_clusters.append(0)\n                    operator_weights = [w * 1.1 if op == 'demand_split' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'reverse' and len(new_solution) > 0:\n            # Reverse route segment with demand-aware selection\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n                    customers = new_route[1:-1]\n                    route_stats[route_idx] = (np.sum(demand[customers]),\n                                           sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1)),\n                                           np.mean(demand[customers]),\n                                           len(customers))\n                    demand_clusters[route_idx] = route_stats[route_idx][2]\n                    operator_weights = [w * 1.1 if op == 'reverse' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'weighted_insert' and len(new_solution) > 1:\n            # Weighted multi-objective reinsertion\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 2:\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                best_pos = 1\n                min_score = float('inf')\n                for pos in range(1, len(route2)):\n                    dist_increase = distance_matrix[route2[pos-1], customer] + distance_matrix[customer, route2[pos]] - distance_matrix[route2[pos-1], route2[pos]]\n                    makespan_increase = max(0, dist_increase - (route_stats[route2_idx][1] - distance_matrix[route2[pos-1], route2[pos]]))\n                    weighted_score = 0.7 * dist_increase + 0.3 * makespan_increase\n\n                    if weighted_score < min_score:\n                        min_score = weighted_score\n                        best_pos = pos\n\n                if route_stats[route2_idx][0] + demand[customer] <= capacity:\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    for k, route in enumerate([new_route1, new_route2]):\n                        if len(route) > 2:\n                            customers = route[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)),\n                                   np.mean(demand[customers]),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[route1_idx] = stats\n                                demand_clusters[route1_idx] = stats[2]\n                            else:\n                                route_stats[route2_idx] = stats\n                                demand_clusters[route2_idx] = stats[2]\n                        else:\n                            if k == 0:\n                                route_stats[route1_idx] = (0, 0, 0, 0)\n                                demand_clusters[route1_idx] = 0\n                            else:\n                                route_stats[route2_idx] = (0, 0, 0, 0)\n                                demand_clusters[route2_idx] = 0\n                    operator_weights = [w * 1.1 if op == 'weighted_insert' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.907264251842089,
            0.35981351137161255
        ]
    },
    {
        "algorithm": "The algorithm combines crowding-distance-based solution selection with a multi-stage hybrid local search that prioritizes demand-complementary route splitting, capacity-aware route consolidation, and probabilistic demand-balanced customer reallocation. It explicitly balances trade-offs between total distance and makespan optimization by selecting solutions with high crowding distances and applying demand-aware transformations to improve solution quality while maintaining feasibility. The approach emphasizes capacity utilization and demand balance through probabilistic operators and complementary demand-based route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    # Normalize objectives\n    norm_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances))\n    norm_makespan = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans))\n\n    # Calculate crowding distances\n    sorted_idx = np.argsort(norm_dist)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_makespan[sorted_idx[i+1]] - norm_makespan[sorted_idx[i-1]]\n\n    sorted_idx = np.argsort(norm_makespan)\n    crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n    for i in range(1, len(sorted_idx)-1):\n        crowding[sorted_idx[i]] += norm_dist[sorted_idx[i+1]] - norm_dist[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-stage hybrid local search\n    for _ in range(3):\n        # Stage 1: Demand-complementary route splitting\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                # Find customer with demand most complementary to route's average demand\n                route_demand = np.sum(demand[route[1:-1]])\n                avg_demand = route_demand / (len(route) - 2)\n                best_split = None\n                best_diff = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_diff = abs(demand[route[i]] - avg_demand)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_split = i\n\n                if best_split:\n                    split_pos = best_split\n                    fragment = route[split_pos:]\n                    remaining = route[:split_pos+1]\n\n                    if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                        np.sum(demand[remaining[1:-1]]) <= capacity):\n                        new_solution[route_idx] = remaining\n                        new_solution.append(fragment)\n\n        # Stage 2: Capacity-aware route consolidation\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            remaining_cap1 = capacity - demand1\n            remaining_cap2 = capacity - demand2\n\n            # Probability of merging based on capacity complementarity\n            merge_prob = 0.5 * (1 - abs(remaining_cap1 - remaining_cap2) / capacity) + 0.5\n\n            if random.random() < merge_prob and (demand1 + demand2) <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n        # Stage 3: Probabilistic demand-balanced customer reallocation\n        if len(new_solution) > 1 and random.random() < 0.4:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer whose demand is closest to target route's remaining capacity\n                target_demand = np.sum(demand[target_route[1:-1]])\n                remaining_cap = capacity - target_demand\n                best_customer = None\n                best_diff = float('inf')\n\n                for i in range(1, len(source_route)-1):\n                    current_diff = abs(demand[source_route[i]] - remaining_cap)\n                    if current_diff < best_diff:\n                        best_diff = current_diff\n                        best_customer = i\n\n                if best_customer:\n                    customer = source_route[best_customer]\n\n                    # Find best insertion position considering demand balance\n                    best_pos = 1\n                    best_balance = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_demand = target_demand + demand[customer]\n                        new_balance = abs(new_demand - capacity/2)  # Prefer balanced demand\n\n                        if new_balance < best_balance:\n                            best_balance = new_balance\n                            best_pos = pos\n\n                    if new_demand <= capacity:\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:best_customer],\n                                                         source_route[best_customer+1:]])\n                        new_solution[source_idx] = new_source_route\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    return new_solution\n\n",
        "score": [
            -0.7965868091436135,
            0.1786138117313385
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of total distance and makespan, then applies a hybrid local search combining route merging (prioritizing routes with similar demand), splitting (for high-length-to-demand routes), and customer relocation (with proximity constraints to centroids). It emphasizes balancing demand and spatial proximity while prioritizing makespan reduction through intelligent route adjustments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]) / (max(x[1][0], x[1][1]) + 1))\n    selected_idx = min(2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route properties\n    route_properties = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_properties.append((np.zeros(2), 0, 0))\n            continue\n        customer_coords = coords[route[1:-1]]\n        centroid = np.mean(customer_coords, axis=0)\n        total_demand = np.sum(demand[route[1:-1]])\n        route_length = np.sum([distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)])\n        route_properties.append((centroid, total_demand, route_length))\n\n    # Hybrid local search\n    for _ in range(4):\n        # Try to merge routes with similar demand\n        if len(new_solution) > 1:\n            min_diff = float('inf')\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    demand_diff = abs(route_properties[i][1] - route_properties[j][1])\n                    if demand_diff < min_diff:\n                        min_diff = demand_diff\n                        best_pair = (i, j)\n\n            if best_pair is not None and min_diff < 0.3 * capacity:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n\n                total_demand = route_properties[i][1] + route_properties[j][1]\n                if total_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n\n                    # Update properties\n                    if len(merged_route) > 2:\n                        customer_coords = coords[merged_route[1:-1]]\n                        centroid = np.mean(customer_coords, axis=0)\n                        route_length = np.sum([distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)])\n                        route_properties[i] = (centroid, total_demand, route_length)\n                    else:\n                        route_properties[i] = (np.zeros(2), 0, 0)\n                    route_properties.pop(j)\n\n        # Try to split routes with high length-to-demand ratio\n        if len(new_solution) < len(base_solution) + 3:\n            max_ratio = -1\n            best_route = None\n            for i in range(len(new_solution)):\n                if len(new_solution[i]) > 4 and route_properties[i][1] > 0:\n                    ratio = route_properties[i][2] / route_properties[i][1]\n                    if ratio > max_ratio:\n                        max_ratio = ratio\n                        best_route = i\n\n            if best_route is not None and max_ratio > 1.2:\n                route = new_solution[best_route]\n                total_demand = route_properties[best_route][1]\n\n                best_split = None\n                min_ratio_diff = float('inf')\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n\n                    if left_demand <= capacity and right_demand <= capacity:\n                        left_length = np.sum([distance_matrix[route[k], route[k+1]] for k in range(j)])\n                        right_length = np.sum([distance_matrix[route[j+k], route[j+k+1]] for k in range(len(route)-j)])\n\n                        ratio_diff = abs((left_length / left_demand) - (right_length / right_demand))\n                        if ratio_diff < min_ratio_diff:\n                            min_ratio_diff = ratio_diff\n                            best_split = j\n\n                if best_split is not None:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[best_route] = first_part\n                    new_solution.append(second_part)\n\n                    # Update properties\n                    for part, idx in [(first_part, best_route), (second_part, len(new_solution)-1)]:\n                        if len(part) > 2:\n                            customer_coords = coords[part[1:-1]]\n                            centroid = np.mean(customer_coords, axis=0)\n                            part_demand = np.sum(demand[part[1:-1]])\n                            part_length = np.sum([distance_matrix[part[k], part[k+1]] for k in range(len(part)-1)])\n                            route_properties[idx] = (centroid, part_demand, part_length)\n                        else:\n                            route_properties[idx] = (np.zeros(2), 0, 0)\n\n        # Try customer relocation with proximity constraint\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Find target route with similar centroid\n                target_idx = None\n                min_centroid_dist = float('inf')\n                for i in range(len(new_solution)):\n                    if i != route_idx:\n                        dist = np.linalg.norm(route_properties[i][0] - coords[customer])\n                        if dist < min_centroid_dist:\n                            min_centroid_dist = dist\n                            target_idx = i\n\n                if target_idx is not None:\n                    other_route = new_solution[target_idx]\n\n                    # Find best insertion position with proximity constraint\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(other_route)):\n                        dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                       distance_matrix[customer, other_route[pos]] -\n                                       distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if dist_increase < min_increase and distance_matrix[customer, other_route[pos]] < 1.5 * np.mean(distance_matrix[other_route[pos-1], other_route[pos]]):\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n                        new_solution[target_idx] = new_other_route\n\n                        new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                        new_solution[route_idx] = new_route\n\n                        # Update properties\n                        for idx in [route_idx, target_idx]:\n                            route = new_solution[idx]\n                            if len(route) > 2:\n                                customer_coords = coords[route[1:-1]]\n                                centroid = np.mean(customer_coords, axis=0)\n                                part_demand = np.sum(demand[route[1:-1]])\n                                part_length = np.sum([distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)])\n                                route_properties[idx] = (centroid, part_demand, part_length)\n                            else:\n                                route_properties[idx] = (np.zeros(2), 0, 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9252961419680493,
            0.7954302430152893
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (prioritizing solutions where total distance and makespan are close) and applies a hybrid local search combining spatial-aware route merging, demand-balanced route splitting, intelligent customer transfer, and route segment reversal, with adaptive operator selection based on success rates and feasibility checks. It dynamically adjusts operator probabilities, prioritizes spatially and demand-compatible operations, and maintains capacity constraints throughout the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route statistics and centroids\n    route_stats = []\n    route_centroids = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_stats.append((0, 0, 0, 0))\n            route_centroids.append(np.zeros(2))\n            continue\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        centroid = np.mean(coords[customers], axis=0)\n        route_stats.append((total_demand, total_distance, centroid, len(customers)))\n        route_centroids.append(centroid)\n\n    # Hybrid local search with adaptive operator selection\n    operators = ['merge', 'split', 'transfer', 'reverse']\n    operator_weights = [0.3, 0.3, 0.2, 0.2]  # Initial weights\n    operator_success = [0, 0, 0, 0]\n\n    for _ in range(5):\n        # Select operator based on current weights\n        operator = random.choices(operators, weights=operator_weights, k=1)[0]\n\n        if operator == 'merge' and len(new_solution) >= 2:\n            # Find closest pair of routes with compatible demand\n            min_score = float('inf')\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_stats[i][0] - route_stats[j][0])\n                    score = dist + 0.5 * demand_diff\n                    if score < min_score:\n                        min_score = score\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n                total_demand = route_stats[i][0] + route_stats[j][0]\n                if total_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    route_stats.pop(j)\n                    route_centroids.pop(j)\n                    if len(merged_route) > 2:\n                        customers = merged_route[1:-1]\n                        route_stats[i] = (np.sum(demand[customers]),\n                                         sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)),\n                                         np.mean(coords[customers], axis=0),\n                                         len(customers))\n                        route_centroids[i] = route_stats[i][2]\n                    else:\n                        route_stats[i] = (0, 0, np.zeros(2), 0)\n                        route_centroids[i] = np.zeros(2)\n                    operator_success[0] += 1\n\n        elif operator == 'split' and len(new_solution) > 1:\n            # Find longest route with high demand\n            longest_idx = max(range(len(new_solution)), key=lambda i: route_stats[i][0])\n            route = new_solution[longest_idx]\n            if len(route) > 4:\n                customers = route[1:-1]\n                total_demand = route_stats[longest_idx][0]\n                best_split = None\n                min_diff = float('inf')\n\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n                    if left_demand <= capacity and right_demand <= capacity:\n                        diff = abs(left_demand - right_demand)\n                        if diff < min_diff:\n                            min_diff = diff\n                            best_split = j\n\n                if best_split:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[longest_idx] = first_part\n                    new_solution.append(second_part)\n\n                    # Update stats for both parts\n                    for k, part in enumerate([first_part, second_part]):\n                        if len(part) > 2:\n                            customers = part[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[part[i], part[i+1]] for i in range(len(part)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[longest_idx] = stats\n                                route_centroids[longest_idx] = stats[2]\n                            else:\n                                route_stats.append(stats)\n                                route_centroids.append(stats[2])\n                        else:\n                            if k == 0:\n                                route_stats[longest_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[longest_idx] = np.zeros(2)\n                            else:\n                                route_stats.append((0, 0, np.zeros(2), 0))\n                                route_centroids.append(np.zeros(2))\n                    operator_success[1] += 1\n\n        elif operator == 'transfer' and len(new_solution) > 1:\n            # Find most imbalanced route pair\n            max_imbalance = -1\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    demand_diff = abs(route_stats[i][0] - route_stats[j][0])\n                    distance_diff = abs(route_stats[i][1] - route_stats[j][1])\n                    imbalance = demand_diff + 0.5 * distance_diff\n                    if imbalance > max_imbalance:\n                        max_imbalance = imbalance\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n                customers1, customers2 = route1[1:-1], route2[1:-1]\n\n                # Find best candidate customer to transfer\n                best_transfer = None\n                min_cost_diff = float('inf')\n\n                for k in range(len(customers1)):\n                    new_demand2 = route_stats[j][0] + demand[customers1[k]]\n                    if new_demand2 > capacity:\n                        continue\n\n                    old_cost = (distance_matrix[route1[k], route1[k+1]] + distance_matrix[route1[k], route1[k-1]])\n                    new_cost = (distance_matrix[route1[k-1], route1[k+1]] +\n                               distance_matrix[route2[-2], customers1[k]] +\n                               distance_matrix[customers1[k], 0])\n\n                    cost_diff = new_cost - old_cost\n                    if cost_diff < min_cost_diff:\n                        min_cost_diff = cost_diff\n                        best_transfer = (i, j, k, 'to_j')\n\n                for k in range(len(customers2)):\n                    new_demand1 = route_stats[i][0] + demand[customers2[k]]\n                    if new_demand1 > capacity:\n                        continue\n\n                    old_cost = (distance_matrix[route2[k], route2[k+1]] + distance_matrix[route2[k], route2[k-1]])\n                    new_cost = (distance_matrix[route2[k-1], route2[k+1]] +\n                               distance_matrix[route1[-2], customers2[k]] +\n                               distance_matrix[customers2[k], 0])\n\n                    cost_diff = new_cost - old_cost\n                    if cost_diff < min_cost_diff:\n                        min_cost_diff = cost_diff\n                        best_transfer = (i, j, k, 'to_i')\n\n                if best_transfer and min_cost_diff < 0:\n                    i, j, k, direction = best_transfer\n                    if direction == 'to_j':\n                        customer = new_solution[i][1:-1][k]\n                        new_solution[i] = np.concatenate([new_solution[i][:k+1], new_solution[i][k+2:]])\n                        new_solution[j] = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                    else:\n                        customer = new_solution[j][1:-1][k]\n                        new_solution[j] = np.concatenate([new_solution[j][:k+1], new_solution[j][k+2:]])\n                        new_solution[i] = np.concatenate([new_solution[i][:-1], [customer], [0]])\n\n                    # Update route statistics\n                    route_stats = []\n                    route_centroids = []\n                    for route in new_solution:\n                        if len(route) <= 2:\n                            route_stats.append((0, 0, 0, 0))\n                            route_centroids.append(np.zeros(2))\n                            continue\n                        customers = route[1:-1]\n                        total_demand = np.sum(demand[customers])\n                        total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                        centroid = np.mean(coords[customers], axis=0)\n                        route_stats.append((total_demand, total_distance, centroid, len(customers)))\n                        route_centroids.append(centroid)\n                    operator_success[2] += 1\n\n        elif operator == 'reverse' and len(new_solution) > 0:\n            # Select a route to reverse\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n                    customers = new_route[1:-1]\n                    route_stats[route_idx] = (np.sum(demand[customers]),\n                                             sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1)),\n                                             np.mean(coords[customers], axis=0),\n                                             len(customers))\n                    route_centroids[route_idx] = route_stats[route_idx][2]\n                    operator_success[3] += 1\n\n        # Update operator weights based on success rates\n        total_success = sum(operator_success)\n        if total_success > 0:\n            operator_weights = [max(0.1, 0.3 + 0.2 * (success / total_success)) for success in operator_success]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9422559015370556,
            0.8705934584140778
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-stage hybrid local search that first analyzes route characteristics (demand, distance, centroid) and then adaptively applies demand-sensitive operators (reverse, insert, swap) with dynamic weights, prioritizing promising solutions from the archive while maintaining feasibility through continuous capacity checks. It balances exploration and exploitation by adjusting operator weights based on success rates and spatial-demand relationships, with a focus on reducing both total distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    selected_idx = min(1, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    route_info = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_info.append((0, 0, 0, 0))\n            continue\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        centroid = np.mean(coords[customers], axis=0)\n        route_info.append((total_demand, total_distance, centroid, len(customers)))\n\n    operators = ['reverse', 'insert', 'swap']\n    operator_weights = [0.4, 0.4, 0.2]\n\n    for _ in range(4):\n        operator = random.choices(operators, weights=operator_weights, k=1)[0]\n\n        if operator == 'reverse' and len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n                    customers = new_route[1:-1]\n                    route_info[route_idx] = (np.sum(demand[customers]),\n                                           sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1)),\n                                           np.mean(coords[customers], axis=0),\n                                           len(customers))\n                    operator_weights = [w * 1.1 if op == 'reverse' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'insert' and len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 2:\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    dist_increase = (distance_matrix[route2[pos-1], customer] +\n                                   distance_matrix[customer, route2[pos]] -\n                                   distance_matrix[route2[pos-1], route2[pos]])\n\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = pos\n\n                if route_info[route2_idx][0] + demand[customer] <= capacity:\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    for k, route in enumerate([new_route1, new_route2]):\n                        if len(route) > 2:\n                            customers = route[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_info[route1_idx] = stats\n                            else:\n                                route_info[route2_idx] = stats\n                        else:\n                            if k == 0:\n                                route_info[route1_idx] = (0, 0, 0, 0)\n                            else:\n                                route_info[route2_idx] = (0, 0, 0, 0)\n                    operator_weights = [w * 1.1 if op == 'insert' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'swap' and len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                customer1_pos = random.randint(1, len(route1) - 2)\n                customer2_pos = random.randint(1, len(route2) - 2)\n                customer1, customer2 = route1[customer1_pos], route2[customer2_pos]\n\n                if (route_info[route1_idx][0] - demand[customer1] + demand[customer2] <= capacity and\n                    route_info[route2_idx][0] - demand[customer2] + demand[customer1] <= capacity):\n\n                    new_route1 = route1.copy()\n                    new_route1[customer1_pos] = customer2\n\n                    new_route2 = route2.copy()\n                    new_route2[customer2_pos] = customer1\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n                    for k, route in enumerate([new_route1, new_route2]):\n                        if len(route) > 2:\n                            customers = route[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_info[route1_idx] = stats\n                            else:\n                                route_info[route2_idx] = stats\n                        else:\n                            if k == 0:\n                                route_info[route1_idx] = (0, 0, 0, 0)\n                            else:\n                                route_info[route2_idx] = (0, 0, 0, 0)\n                    operator_weights = [w * 1.1 if op == 'swap' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9051147418875374,
            0.4199872612953186
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects solutions from the archive using non-linear weighted objectives, applying a hybrid local search that combines adaptive route fragmentation (balancing demand and distance), demand-sensitive customer reallocation, probabilistic route merging (with capacity-aware criteria), and an adaptive customer exchange operator (prioritizing distance and demand balance). It emphasizes extreme solutions through exponential weighting and adjusts operator probabilities based on solution characteristics.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_makespan, max_makespan = np.min(makespans), np.max(makespans)\n\n    # Normalize with non-linear scaling\n    norm_dist = (distances - min_dist) / (max_dist - min_dist + 1e-6)\n    norm_makespan = (makespans - min_makespan) / (max_makespan - min_makespan + 1e-6)\n\n    # Exponential weighting to emphasize extreme solutions\n    weight_dist = np.exp(-norm_dist * 0.5)\n    weight_makespan = np.exp(-norm_makespan * 0.5)\n\n    # Combine with adaptive focus\n    scores = weight_dist * norm_dist + weight_makespan * norm_makespan\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with adaptive operators\n    for _ in range(4):  # Increased iterations for better exploration\n        # Adaptive route fragmentation based on demand and distance\n        if len(new_solution) > 1:\n            route_idx = random.choice(range(len(new_solution)))\n            route = new_solution[route_idx]\n\n            if len(route) > 4:  # Only split if route is long enough\n                total_demand = np.sum(demand[route[1:-1]])\n                route_distance = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n\n                # Find split position that balances both demand and distance\n                best_split = 1\n                best_balance = float('inf')\n\n                for i in range(1, len(route)-1):\n                    current_demand = np.sum(demand[route[1:i+1]])\n                    current_dist = sum(distance_matrix[route[j-1], route[j]] for j in range(1, i+1))\n\n                    # Balance score combines demand and distance balance\n                    balance_score = abs((current_demand / total_demand) - 0.5) + \\\n                                  abs((current_dist / route_distance) - 0.5)\n\n                    if balance_score < best_balance:\n                        best_balance = balance_score\n                        best_split = i\n\n                fragment = route[best_split:]\n                remaining = route[:best_split+1]\n\n                if (np.sum(demand[fragment[1:-1]]) <= capacity and\n                    np.sum(demand[remaining[1:-1]]) <= capacity):\n                    new_solution[route_idx] = remaining\n                    new_solution.append(fragment)\n\n        # Demand-sensitive customer reallocation\n        if len(new_solution) > 1:\n            source_idx = random.choice(range(len(new_solution)))\n            target_idx = random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customers based on demand and distance to depot\n                customers = sorted(range(1, len(source_route)-1),\n                                key=lambda x: demand[source_route[x]] * distance_matrix[0, source_route[x]],\n                                reverse=True)\n\n                num_to_move = min(3, len(customers))  # Move up to 3 customers\n\n                for customer_pos in customers[:num_to_move]:\n                    customer = source_route[customer_pos]\n\n                    # Find best insertion considering both distance and demand impact\n                    best_pos = 1\n                    best_score = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        dist_increase = (distance_matrix[target_route[pos-1], customer] +\n                                       distance_matrix[customer, target_route[pos]] -\n                                       distance_matrix[target_route[pos-1], target_route[pos]])\n\n                        # Demand impact score considers both current and potential demand\n                        current_demand = np.sum(demand[target_route[1:-1]])\n                        new_demand = current_demand + demand[customer]\n\n                        demand_score = abs(new_demand - capacity/2)  # Prefer medium demand routes\n\n                        # Distance to depot factor\n                        depot_dist_factor = distance_matrix[0, customer] / np.max(distance_matrix[0, :])\n\n                        total_score = dist_increase + 0.4 * demand_score + 0.3 * depot_dist_factor\n\n                        if total_score < best_score:\n                            best_score = total_score\n                            best_pos = pos\n\n                    if (np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity and\n                        len(target_route) + 1 <= 25):  # Increased route length limit\n                        new_target_route = np.concatenate([target_route[:best_pos],\n                                                         [customer], target_route[best_pos:]])\n                        new_solution[target_idx] = new_target_route\n\n                        new_source_route = np.concatenate([source_route[:customer_pos],\n                                                         source_route[customer_pos+1:]])\n                        new_solution[source_idx] = new_source_route\n\n        # Capacity-aware route merging\n        if len(new_solution) > 2:\n            routes_to_merge = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[routes_to_merge[0]], new_solution[routes_to_merge[1]]\n\n            demand1 = np.sum(demand[route1[1:-1]])\n            demand2 = np.sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            length1 = len(route1)\n            length2 = len(route2)\n\n            # More aggressive merging probability based on capacity utilization\n            merge_prob = min(0.9, 0.3 + 0.6 * (1 - abs(demand1 - demand2) / (total_demand + 1e-6)) +\n                           0.4 * (25 - (length1 + length2 - 2)) / 25)\n\n            if random.random() < merge_prob and total_demand <= capacity:\n                # Consider both direct and reverse merging\n                direct_merged = np.concatenate([route1[:-1], route2[1:]])\n                reverse_merged = np.concatenate([route2[:-1], route1[1:]])\n\n                # Select the merging option with better distance\n                direct_dist = sum(distance_matrix[direct_merged[i-1], direct_merged[i]] for i in range(1, len(direct_merged)))\n                reverse_dist = sum(distance_matrix[reverse_merged[i-1], reverse_merged[i]] for i in range(1, len(reverse_merged)))\n\n                merged_route = direct_merged if direct_dist <= reverse_dist else reverse_merged\n\n                new_solution = [route for i, route in enumerate(new_solution)\n                              if i not in routes_to_merge]\n                new_solution.append(merged_route)\n\n    # Remove empty routes and normalize\n    new_solution = [route for route in new_solution if len(route) > 2]\n    new_solution = [np.array(route) for route in new_solution]\n\n    # Adaptive customer exchange operator\n    if len(new_solution) > 1 and random.random() < 0.4:  # Increased probability\n        swap_routes = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[swap_routes[0]], new_solution[swap_routes[1]]\n\n        # Consider multiple swap positions\n        best_swaps = []\n        best_score = float('inf')\n\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                # Calculate potential demand changes\n                new_demand1 = (np.sum(demand[route1[1:i]]) + demand[route2[j]] +\n                              np.sum(demand[route1[i+1:-1]]))\n                new_demand2 = (np.sum(demand[route2[1:j]]) + demand[route1[i]] +\n                              np.sum(demand[route2[j+1:-1]]))\n\n                if new_demand1 > capacity or new_demand2 > capacity:\n                    continue\n\n                # Calculate distance change\n                dist_change = (\n                    distance_matrix[route1[i-1], route2[j]] +\n                    distance_matrix[route2[j], route1[i+1]] -\n                    distance_matrix[route1[i-1], route1[i]] -\n                    distance_matrix[route1[i], route1[i+1]] +\n                    distance_matrix[route2[j-1], route1[i]] +\n                    distance_matrix[route1[i], route2[j+1]] -\n                    distance_matrix[route2[j-1], route2[j]] -\n                    distance_matrix[route2[j], route2[j+1]]\n                )\n\n                # Consider both demand balance and distance to depot\n                demand_balance = abs(new_demand1 - new_demand2)\n                depot_dist_factor = (distance_matrix[0, route1[i]] + distance_matrix[0, route2[j]]) / 2\n\n                total_score = dist_change + 0.4 * demand_balance + 0.2 * depot_dist_factor\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_swaps = [(i, j)]\n                elif total_score == best_score:\n                    best_swaps.append((i, j))\n\n        if best_swaps:\n            i, j = random.choice(best_swaps)\n            # Perform the swap\n            route1[i], route2[j] = route2[j], route1[i]\n            new_solution[swap_routes[0]] = route1\n            new_solution[swap_routes[1]] = route2\n\n    return new_solution\n\n",
        "score": [
            -0.9282340368599087,
            1.7632462084293365
        ]
    },
    {
        "algorithm": "The algorithm first clusters solutions based on route structure diversity, selecting from the least explored cluster to promote exploration of underrepresented regions. It then applies a novel \"route fragmentation and reassembly\" operator that intelligently splits routes into demand-balanced segments and reconstructs them while prioritizing capacity constraints, ensuring high-quality neighbors through structural diversification and non-standard segmentation logic. The method prioritizes demand-weighted segmentation (70% capacity threshold) and random shuffling of segments for robust reassembly.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Cluster solutions by route structure diversity\n    route_lengths = []\n    for sol, _ in archive:\n        lengths = [len(route) - 2 for route in sol]  # exclude depot nodes\n        route_lengths.append(tuple(sorted(lengths)))\n\n    # Find least explored cluster\n    from collections import Counter\n    cluster_counts = Counter(route_lengths)\n    least_explored = min(cluster_counts, key=cluster_counts.get)\n    candidates = [sol for (sol, _), lengths in zip(archive, route_lengths) if lengths == least_explored]\n    base_solution = random.choice(candidates).copy()\n\n    # Route fragmentation and reassembly\n    new_solution = []\n    segments = []\n\n    # Fragment all routes into segments\n    for route in base_solution:\n        if len(route) <= 3:  # too short to fragment\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into segments based on demand balance\n        current_segment = [route[0]]\n        current_demand = 0\n        for node in route[1:-1]:\n            if current_demand + demand[node] > capacity * 0.7:  # 70% capacity threshold\n                segments.append(current_segment + [0])\n                current_segment = [0]\n                current_demand = 0\n            current_segment.append(node)\n            current_demand += demand[node]\n        if len(current_segment) > 1:\n            segments.append(current_segment + [0])\n\n    # Reassemble segments into new routes\n    random.shuffle(segments)\n    current_route = [0]\n    current_demand = 0\n\n    for segment in segments:\n        segment_demand = sum(demand[node] for node in segment[1:-1])\n        if current_demand + segment_demand <= capacity:\n            current_route.extend(segment[1:-1])\n            current_demand += segment_demand\n        else:\n            if len(current_route) > 1:\n                new_solution.append(np.array(current_route + [0]))\n            current_route = [0] + segment[1:-1]\n            current_demand = segment_demand\n\n    if len(current_route) > 1:\n        new_solution.append(np.array(current_route + [0]))\n\n    # Verify all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    if served_customers != all_customers:\n        # Fallback to original solution if reassembly failed\n        return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6204871571716079,
            0.4501461386680603
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (prioritizing solutions where total distance and makespan are similar) and applies a dynamic hybrid local search combining spatial clustering (merge/split), demand-aware route modifications (insert/swap), and adaptive operator selection (weights adjusted based on success). It emphasizes spatial proximity and demand compatibility while maintaining feasibility through continuous capacity checks, with operators like merge and swap given higher weights when successful.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    route_stats = []\n    route_centroids = []\n    for route in new_solution:\n        if len(route) <= 2:\n            route_stats.append((0, 0, 0, 0))\n            route_centroids.append(np.zeros(2))\n            continue\n        customers = route[1:-1]\n        total_demand = np.sum(demand[customers])\n        total_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        centroid = np.mean(coords[customers], axis=0)\n        route_stats.append((total_demand, total_distance, centroid, len(customers)))\n        route_centroids.append(centroid)\n\n    operators = ['merge', 'split', 'reverse', 'insert', 'swap']\n    operator_weights = [0.25, 0.25, 0.2, 0.2, 0.1]\n\n    for _ in range(8):\n        operator = random.choices(operators, weights=operator_weights, k=1)[0]\n\n        if operator == 'merge' and len(new_solution) >= 2:\n            min_dist = float('inf')\n            best_pair = None\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_ratio = abs(route_stats[i][0] - route_stats[j][0]) / capacity\n                    combined_score = dist * (1 + demand_ratio)\n                    if combined_score < min_dist:\n                        min_dist = combined_score\n                        best_pair = (i, j)\n\n            if best_pair:\n                i, j = best_pair\n                route1, route2 = new_solution[i], new_solution[j]\n                total_demand = route_stats[i][0] + route_stats[j][0]\n                if total_demand <= capacity * 1.1:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    route_stats.pop(j)\n                    route_centroids.pop(j)\n                    if len(merged_route) > 2:\n                        customers = merged_route[1:-1]\n                        route_stats[i] = (np.sum(demand[customers]),\n                                         sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1)),\n                                         np.mean(coords[customers], axis=0),\n                                         len(customers))\n                        route_centroids[i] = route_stats[i][2]\n                    else:\n                        route_stats[i] = (0, 0, np.zeros(2), 0)\n                        route_centroids[i] = np.zeros(2)\n                    operator_weights = [w * 1.2 if op == 'merge' else w * 0.8 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'split' and len(new_solution) > 1:\n            longest_idx = max(range(len(new_solution)), key=lambda i: route_stats[i][1])\n            route = new_solution[longest_idx]\n            if len(route) > 5:\n                customers = route[1:-1]\n                total_demand = route_stats[longest_idx][0]\n                best_split = None\n                min_variance = float('inf')\n\n                for j in range(2, len(route)-2):\n                    left_demand = np.sum(demand[route[1:j+1]])\n                    right_demand = total_demand - left_demand\n                    variance = (left_demand - right_demand)**2\n                    if left_demand <= capacity and right_demand <= capacity and variance < min_variance:\n                        min_variance = variance\n                        best_split = j\n\n                if best_split:\n                    j = best_split\n                    first_part = route[:j+1] + [0]\n                    second_part = [0] + route[j+1:]\n\n                    new_solution[longest_idx] = first_part\n                    new_solution.append(second_part)\n\n                    for k, part in enumerate([first_part, second_part]):\n                        if len(part) > 2:\n                            customers = part[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[part[i], part[i+1]] for i in range(len(part)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[longest_idx] = stats\n                                route_centroids[longest_idx] = stats[2]\n                            else:\n                                route_stats.append(stats)\n                                route_centroids.append(stats[2])\n                        else:\n                            if k == 0:\n                                route_stats[longest_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[longest_idx] = np.zeros(2)\n                            else:\n                                route_stats.append((0, 0, np.zeros(2), 0))\n                                route_centroids.append(np.zeros(2))\n                    operator_weights = [w * 1.2 if op == 'split' else w * 0.8 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'reverse' and len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                reversed_segment = route[i:j+1][::-1]\n                new_route = np.concatenate([route[:i], reversed_segment, route[j+1:]])\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity * 1.05:\n                    new_solution[route_idx] = new_route\n                    customers = new_route[1:-1]\n                    route_stats[route_idx] = (np.sum(demand[customers]),\n                                             sum(distance_matrix[new_route[k], new_route[k+1]] for k in range(len(new_route)-1)),\n                                             np.mean(coords[customers], axis=0),\n                                             len(customers))\n                    route_centroids[route_idx] = route_stats[route_idx][2]\n                    operator_weights = [w * 1.1 if op == 'reverse' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'insert' and len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 2:\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route2)):\n                    dist_increase = (distance_matrix[route2[pos-1], customer] +\n                                   distance_matrix[customer, route2[pos]] -\n                                   distance_matrix[route2[pos-1], route2[pos]])\n\n                    demand_ratio = (route_stats[route2_idx][0] + demand[customer]) / capacity\n                    weighted_increase = dist_increase * (1 + demand_ratio)\n\n                    if weighted_increase < min_increase:\n                        min_increase = weighted_increase\n                        best_pos = pos\n\n                if route_stats[route2_idx][0] + demand[customer] <= capacity * 1.05:\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    new_route1 = np.concatenate([route1[:customer_pos], route1[customer_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n                    for k, route in enumerate([new_route1, new_route2]):\n                        if len(route) > 2:\n                            customers = route[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[route1_idx] = stats\n                                route_centroids[route1_idx] = stats[2]\n                            else:\n                                route_stats[route2_idx] = stats\n                                route_centroids[route2_idx] = stats[2]\n                        else:\n                            if k == 0:\n                                route_stats[route1_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[route1_idx] = np.zeros(2)\n                            else:\n                                route_stats[route2_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[route2_idx] = np.zeros(2)\n                    operator_weights = [w * 1.1 if op == 'insert' else w * 0.9 for w, op in zip(operator_weights, operators)]\n\n        elif operator == 'swap' and len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                customer1_pos = random.randint(1, len(route1) - 2)\n                customer2_pos = random.randint(1, len(route2) - 2)\n                customer1, customer2 = route1[customer1_pos], route2[customer2_pos]\n\n                if (route_stats[route1_idx][0] - demand[customer1] + demand[customer2] <= capacity * 1.05 and\n                    route_stats[route2_idx][0] - demand[customer2] + demand[customer1] <= capacity * 1.05):\n\n                    new_route1 = route1.copy()\n                    new_route1[customer1_pos] = customer2\n                    new_route2 = route2.copy()\n                    new_route2[customer2_pos] = customer1\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n                    for k, route in enumerate([new_route1, new_route2]):\n                        if len(route) > 2:\n                            customers = route[1:-1]\n                            stats = (np.sum(demand[customers]),\n                                   sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)),\n                                   np.mean(coords[customers], axis=0),\n                                   len(customers))\n                            if k == 0:\n                                route_stats[route1_idx] = stats\n                                route_centroids[route1_idx] = stats[2]\n                            else:\n                                route_stats[route2_idx] = stats\n                                route_centroids[route2_idx] = stats[2]\n                        else:\n                            if k == 0:\n                                route_stats[route1_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[route1_idx] = np.zeros(2)\n                            else:\n                                route_stats[route2_idx] = (0, 0, np.zeros(2), 0)\n                                route_centroids[route2_idx] = np.zeros(2)\n                    operator_weights = [w * 1.2 if op == 'swap' else w * 0.8 for w, op in zip(operator_weights, operators)]\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8851156697030861,
            0.9271502792835236
        ]
    }
]