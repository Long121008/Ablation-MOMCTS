[
    {
        "algorithm": "The algorithm selects promising solutions from the archive based on a weighted score combining normalized distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and a novel route merging operator to balance objectives while maintaining feasibility. The selection prioritizes distance reduction (weighted 70%) and randomly explores top 30% solutions, while the operators intelligently modify routes to reduce makespan without violating capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def score_solution(solution, objectives):\n        total_dist, makespan = objectives\n        # Normalize objectives (assuming archive is non-empty)\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        # Weighted score (can be adjusted)\n        weight = 0.7  # More weight on distance reduction\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(score_solution(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    # Select top 30% solutions and pick one randomly\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Operator 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Split only if route has more than 2 customers\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only one split per iteration\n\n    # Operator 2: Customer reinsertion with capacity check\n    for _ in range(2):  # Try multiple times\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue  # Skip if route has only depot and one customer\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        # Remove customer temporarily\n        temp_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n        if not is_feasible(temp_route):\n            continue\n\n        # Try to insert in another route\n        for other_idx in range(len(new_solution)):\n            if other_idx == route_idx:\n                continue\n            other_route = new_solution[other_idx]\n            for insert_pos in range(1, len(other_route)):\n                new_other_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n                if is_feasible(new_other_route):\n                    new_solution[route_idx] = temp_route\n                    new_solution[other_idx] = new_other_route\n                    break\n            else:\n                continue\n            break\n\n    # Operator 3: Novel route merging (if two routes can be merged without exceeding capacity)\n    if len(new_solution) > 1:\n        for _ in range(2):  # Try multiple times\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if is_feasible(merged_route):\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    # Ensure all customers are served (sanity check)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    assert served_customers == all_customers, \"Not all customers are served\"\n\n    return new_solution\n\n",
        "score": [
            -0.5590214532653537,
            0.2597949504852295
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated or slightly dominated solutions) and applies a hybrid local search combining route swapping, demand-aware 2-opt with customer relocations, and adaptive route merging/splitting, while ensuring feasibility through capacity checks. It balances distance and makespan objectives by probabilistically applying these operations and reverting infeasible changes. The approach emphasizes demand-aware transformations and adaptive route adjustments to improve solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance and select one\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        # Select a solution that is not too dominated in either objective\n        candidate_indices = [i for i in range(len(sorted_solutions))\n                           if i < len(sorted_solutions)//2 or random.random() < 0.3]\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:  # Route swapping with demand-aware check\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Check if swapping customers between routes is feasible\n            if (np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= 2 * capacity):\n                # Try to swap a segment between routes\n                if len(route_i) > 3 and len(route_j) > 3:\n                    # Select a random segment from each route\n                    seg_i_start = random.randint(1, len(route_i)-3)\n                    seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n                    seg_j_start = random.randint(1, len(route_j)-3)\n                    seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n                    # Check capacity constraints\n                    if (np.sum(demand[route_i[seg_i_start:seg_i_end]]) + np.sum(demand[route_j[1:-1]]) <= capacity and\n                        np.sum(demand[route_j[seg_j_start:seg_j_end]]) + np.sum(demand[route_i[1:-1]]) <= capacity):\n                        # Perform the swap\n                        new_route_i = np.concatenate([\n                            route_i[:seg_i_start],\n                            route_j[seg_j_start:seg_j_end],\n                            route_i[seg_i_end:]\n                        ])\n                        new_route_j = np.concatenate([\n                            route_j[:seg_j_start],\n                            route_i[seg_i_start:seg_i_end],\n                            route_j[seg_j_end:]\n                        ])\n\n                        # Update solution\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n    else:  # Intra-route 2-opt with demand-aware relocations\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx].copy()\n\n            if len(route) > 4:\n                # Select two random edges to reverse\n                a = random.randint(1, len(route)-3)\n                b = random.randint(a+1, len(route)-2)\n\n                # Check if reversing this segment is feasible\n                if np.sum(demand[route[a:b]]) == np.sum(demand[route[a:b][::-1]]):\n                    # Perform 2-opt\n                    new_route = np.concatenate([\n                        route[:a],\n                        route[a:b][::-1],\n                        route[b:]\n                    ])\n                    new_solution[route_idx] = new_route\n\n                    # Additional demand-aware relocation\n                    if random.random() < 0.3:\n                        # Try to relocate a customer to a different position\n                        relocate_pos = random.randint(1, len(new_route)-2)\n                        if relocate_pos != a and relocate_pos != b-1:\n                            customer = new_route[relocate_pos]\n                            # Find a better position for this customer\n                            best_pos = relocate_pos\n                            best_dist = float('inf')\n                            for pos in range(1, len(new_route)-1):\n                                if pos != relocate_pos:\n                                    # Check capacity constraint\n                                    if (np.sum(demand[new_route[1:pos]]) + demand[customer] <= capacity and\n                                        np.sum(demand[new_route[pos:-1]]) + demand[customer] <= capacity):\n                                        # Calculate new distance\n                                        prev_node = new_route[pos-1] if pos > 1 else 0\n                                        next_node = new_route[pos] if pos < len(new_route)-1 else 0\n                                        new_dist = (distance_matrix[prev_node][customer] +\n                                                   distance_matrix[customer][next_node] -\n                                                   distance_matrix[prev_node][next_node])\n                                        if new_dist < best_dist:\n                                            best_dist = new_dist\n                                            best_pos = pos\n                            if best_pos != relocate_pos:\n                                # Perform relocation\n                                new_route = np.concatenate([\n                                    new_route[:relocate_pos],\n                                    new_route[relocate_pos+1:]\n                                ])\n                                new_route = np.insert(new_route, best_pos, customer)\n                                new_solution[route_idx] = new_route\n\n    # Adaptive route merging/splitting\n    if len(new_solution) > 1 and random.random() < 0.3:\n        # Try to merge two routes if possible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if (np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity):\n            # Check if merging is beneficial\n            dist_before = distance_matrix[route_i[-2]][0] + distance_matrix[route_j[-2]][0]\n            dist_after = distance_matrix[route_i[-2]][route_j[1]] + distance_matrix[route_j[-2]][0]\n\n            if dist_after < dist_before:\n                # Merge routes\n                merged_route = np.concatenate([\n                    route_i[:-1],\n                    route_j[1:]\n                ])\n                # Update solution\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    if random.random() < 0.2 and len(new_solution) < len(demand)-1:\n        # Try to split a route if beneficial\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 5:\n            # Find a good split point\n            best_split = -1\n            best_diff = float('inf')\n\n            for split in range(2, len(route)-2):\n                # Check capacity constraints for both parts\n                if (np.sum(demand[route[1:split]]) <= capacity and\n                    np.sum(demand[route[split:-1]]) <= capacity):\n                    # Calculate difference in distances\n                    dist_before = (distance_matrix[route[split-1]][route[split]] +\n                                 distance_matrix[route[split]][route[split+1]])\n                    dist_after = (distance_matrix[route[split-1]][0] +\n                                 distance_matrix[0][route[split]] +\n                                 distance_matrix[route[split]][0] +\n                                 distance_matrix[0][route[split+1]])\n                    diff = dist_after - dist_before\n                    if diff < best_diff:\n                        best_diff = diff\n                        best_split = split\n\n            if best_split != -1:\n                # Perform split\n                route1 = np.concatenate([route[:best_split], [0]])\n                route2 = np.concatenate([[0], route[best_split:]])\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx+1, route2)\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            for i in range(len(new_solution)):\n                if np.array_equal(new_solution[i], route):\n                    new_solution[i] = base_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5562969074910635,
            0.22014114260673523
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that combines adaptive route clustering based on spatial and demand proximity, a demand-balanced route reshaping operator, and probabilistic route inversion, while ensuring feasibility through continuous capacity validation and repair. It prioritizes solutions with balanced objective trade-offs by selecting from the top half of the archive, and applies novel transformations to explore alternative configurations while maintaining vehicle capacity constraints. The key design ideas are the spatial-demand-aware route merging, segment-based demand balancing, and probabilistic route inversion, all integrated within a feasibility-preserving framework.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 2:\n        candidates = archive_sorted[:len(archive)//2]\n        base_solution = random.choice(candidates)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route clustering based on spatial and demand proximity\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Group routes by spatial proximity and demand similarity\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = np.sum(demand[route[1:-1]])\n                route_centroids.append((centroid, total_demand))\n\n        # Find closest route pairs\n        closest_pairs = []\n        for i in range(len(route_centroids)):\n            for j in range(i+1, len(route_centroids)):\n                dist = np.linalg.norm(route_centroids[i][0] - route_centroids[j][0])\n                demand_diff = abs(route_centroids[i][1] - route_centroids[j][1])\n                closest_pairs.append((dist + demand_diff, i, j))\n\n        if closest_pairs:\n            closest_pairs.sort()\n            # Select top 3 closest pairs\n            for _, i, j in closest_pairs[:min(3, len(closest_pairs))]:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                # Try to merge if capacity allows\n                if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                    # Find optimal merge point\n                    min_dist = float('inf')\n                    best_i, best_j = 0, 0\n                    for a in range(1, len(route_i)-1):\n                        for b in range(1, len(route_j)-1):\n                            dist = distance_matrix[route_i[a]][route_j[b]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_i, best_j = a, b\n\n                    merged_route = np.concatenate([\n                        route_i[:best_i+1],\n                        route_j[best_j:-1],\n                        route_i[-1:]\n                    ])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    # Demand-balanced route reshaping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Find segments with demand imbalance\n            total_route_demand = np.sum(demand[route[1:-1]])\n            target_demand = total_route_demand / (len(route)-2)\n\n            # Find the most imbalanced segment\n            max_diff = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                segment_demand = np.sum(demand[route[1:i]])\n                diff = abs(segment_demand - target_demand * (i-1))\n                if diff > max_diff:\n                    max_diff = diff\n                    split_pos = i\n\n            if split_pos > 1 and split_pos < len(route)-2:\n                # Try to split and balance\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                # Check capacity constraints\n                if (np.sum(demand[segment1[1:-1]]) <= capacity and\n                    np.sum(demand[segment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Probabilistic route inversion\n    if random.random() < 0.3:\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 5:\n                # Select a random segment to invert\n                start = random.randint(1, len(route)-3)\n                end = random.randint(start+1, len(route)-2)\n\n                # Check capacity constraint\n                if np.sum(demand[route[start:end]]) == np.sum(demand[route[start:end][::-1]]):\n                    new_route = np.concatenate([\n                        route[:start],\n                        route[start:end][::-1],\n                        route[end:]\n                    ])\n                    new_solution[route_idx] = new_route\n\n    # Capacity validation and repair\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If route is over capacity, try to split it\n            cumulative_demand = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > capacity:\n                    split_pos = i\n                    break\n\n            if split_pos > 1:\n                # Perform split\n                route1 = np.concatenate([route[:split_pos], [0]])\n                route2 = np.concatenate([[0], route[split_pos:]])\n                # Replace the over-capacity route\n                for i in range(len(new_solution)):\n                    if np.array_equal(new_solution[i], route):\n                        new_solution[i] = route1\n                        new_solution.insert(i+1, route2)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8304065435505548,
            0.2735443413257599
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using an adaptive weighted scoring that balances distance and makespan, then applies a hybrid local search combining route merging, demand-aware customer reinsertion, and route splitting to generate feasible neighbor solutions, prioritizing distance reduction and makespan optimization with randomized selection and feasibility checks. The method emphasizes intelligent route transformations with adaptive weights and probabilistic operations to explore diverse neighborhoods while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.6 if random.random() < 0.5 else 0.4\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    for _ in range(2):\n        if len(new_solution) > 1 and random.random() < 0.4:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i, route_j = new_solution[i], new_solution[j]\n            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                min_dist = float('inf')\n                best_pair = (0, 0)\n                for a in range(1, len(route_i)):\n                    for b in range(1, len(route_j)):\n                        dist = distance_matrix[route_i[a]][route_j[b]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (a, b)\n                merged_route = np.concatenate([route_i[:best_pair[0]+1], route_j[best_pair[1]:-1], route_i[-1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]] + [merged_route]\n                break\n\n    for _ in range(3):\n        if len(new_solution) > 1 and random.random() < 0.6:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i, route_j = new_solution[i], new_solution[j]\n            if len(route_i) > 3:\n                customer_pos = random.randint(1, len(route_i)-2)\n                customer = route_i[customer_pos]\n                if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    min_cost = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(route_j)):\n                        cost = (distance_matrix[route_j[pos-1]][customer] +\n                               distance_matrix[customer][route_j[pos]] -\n                               distance_matrix[route_j[pos-1]][route_j[pos]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_route_i = np.concatenate([route_i[:customer_pos], route_i[customer_pos+1:]])\n                    new_route_j = np.concatenate([route_j[:best_pos], [customer], route_j[best_pos:]])\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n\n    for _ in range(2):\n        if len(new_solution) > 1 and random.random() < 0.3:\n            i = random.randint(0, len(new_solution)-1)\n            route = new_solution[i]\n            if len(route) > 5:\n                split_pos = random.randint(2, len(route)-3)\n                if sum(demand[route[1:split_pos]]) <= capacity and sum(demand[route[split_pos:-1]]) <= capacity:\n                    new_route1 = np.concatenate([route[:split_pos], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos:]])\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.4700528493331201,
            0.18445441126823425
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects solutions from the archive using a dynamic weighted scoring that balances distance and makespan objectives, then applies a hybrid local search combining spatial-demand-aware clustering, probabilistic route inversion, and demand-balanced route reshaping to generate high-quality neighbor solutions while preserving feasibility. It prioritizes routes with spatial proximity and similar demand levels for clustering, randomly inverts route segments when feasible, and splits routes to balance demand when deviations exceed a target threshold. The method emphasizes feasibility checks and multi-objective trade-offs in its neighborhood generation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.2 * (random.random() - 0.5)\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Spatial-demand-aware clustering\n    if len(new_solution) > 1 and random.random() < 0.4:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = sum(demand[route[1:-1]])\n                route_data.append((centroid, total_demand, route))\n\n        if len(route_data) > 1:\n            clusters = []\n            while len(route_data) > 0:\n                base = route_data.pop(0)\n                cluster = [base]\n                i = 0\n                while i < len(route_data):\n                    centroid, demand_val, _ = route_data[i]\n                    dist = np.linalg.norm(base[0] - centroid)\n                    demand_diff = abs(base[1] - demand_val)\n                    if dist < 1.5 * np.mean(distance_matrix) and demand_diff < 0.3 * capacity:\n                        cluster.append(route_data.pop(i))\n                    else:\n                        i += 1\n                clusters.append(cluster)\n\n            for cluster in clusters:\n                if len(cluster) > 1:\n                    for i in range(len(cluster)-1):\n                        for j in range(i+1, len(cluster)):\n                            route_i = cluster[i][2]\n                            route_j = cluster[j][2]\n                            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                                min_dist = float('inf')\n                                best_i, best_j = 0, 0\n                                for a in range(1, len(route_i)-1):\n                                    for b in range(1, len(route_j)-1):\n                                        dist = distance_matrix[route_i[a]][route_j[b]]\n                                        if dist < min_dist:\n                                            min_dist = dist\n                                            best_i, best_j = a, b\n                                merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                                new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                                new_solution.append(merged_route)\n                                break\n\n    # Probabilistic route inversion with capacity check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.3:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            if is_feasible(np.concatenate([route[:start], route[start:end][::-1], route[end:]])):\n                new_route = np.concatenate([route[:start], route[start:end][::-1], route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Demand-balanced route reshaping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            total_route_demand = sum(demand[route[1:-1]])\n            target_demand = total_route_demand / (len(route)-2)\n            max_diff = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                segment_demand = sum(demand[route[1:i]])\n                diff = abs(segment_demand - target_demand * (i-1))\n                if diff > max_diff:\n                    max_diff = diff\n                    split_pos = i\n            if split_pos > 1 and split_pos < len(route)-2:\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7061916725677131,
            0.26974308490753174
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto scoring with a hybrid local search strategy that prioritizes demand-balanced route merging while probabilistically applying route inversion to improve both distance and makespan objectives, all while maintaining feasibility through capacity-aware operations. It first selects promising solutions based on normalized objective trade-offs, then applies dynamic route reshaping (inversion and merging) to balance objectives, with special attention to spatially close and demand-complementary routes. The algorithm emphasizes capacity constraints through rigorous checks during route modifications and splitting.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_pareto_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_pareto_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Dynamic Pareto-aware route inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.5:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n            if is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Adaptive demand-centric clustering\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                route_centroids.append(centroid)\n\n        if len(route_centroids) > 1:\n            closest_pairs = []\n            for i in range(len(route_centroids)):\n                for j in range(i+1, len(route_centroids)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demands[i] - route_demands[j])\n                    closest_pairs.append((dist + 0.3*demand_diff, i, j))\n\n            if closest_pairs:\n                closest_pairs.sort()\n                for _, i, j in closest_pairs[:min(2, len(closest_pairs))]:\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                        min_dist = float('inf')\n                        best_i, best_j = 0, 0\n                        for a in range(1, len(route_i)-1):\n                            for b in range(1, len(route_j)-1):\n                                dist = distance_matrix[route_i[a]][route_j[b]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_i, best_j = a, b\n                        merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    # Capacity-aware route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and sum(demand[route[1:-1]]) > 0.8 * capacity:\n            split_pos = random.randint(2, len(route)-3)\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n            if is_feasible(segment1) and is_feasible(segment2):\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8680926223332354,
            0.32213422656059265
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects promising solutions from an archive using a dynamic weighted scoring that balances distance and makespan objectives, then applies a hybrid local search combining spatial-demand-aware clustering, probabilistic route inversion with capacity checks, demand-balanced route reshaping, and a novel route segment swapping operator to improve solution quality while maintaining feasibility. The selection prioritizes solutions with better normalized objective values, while the local search operators focus on spatial proximity, demand balance, and segment swaps to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.2 * (random.random() - 0.5)\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Spatial-demand-aware clustering\n    if len(new_solution) > 1 and random.random() < 0.4:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = sum(demand[route[1:-1]])\n                route_data.append((centroid, total_demand, route))\n\n        if len(route_data) > 1:\n            clusters = []\n            while len(route_data) > 0:\n                base = route_data.pop(0)\n                cluster = [base]\n                i = 0\n                while i < len(route_data):\n                    centroid, demand_val, _ = route_data[i]\n                    dist = np.linalg.norm(base[0] - centroid)\n                    demand_diff = abs(base[1] - demand_val)\n                    if dist < 1.5 * np.mean(distance_matrix) and demand_diff < 0.3 * capacity:\n                        cluster.append(route_data.pop(i))\n                    else:\n                        i += 1\n                clusters.append(cluster)\n\n            for cluster in clusters:\n                if len(cluster) > 1:\n                    for i in range(len(cluster)-1):\n                        for j in range(i+1, len(cluster)):\n                            route_i = cluster[i][2]\n                            route_j = cluster[j][2]\n                            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                                min_dist = float('inf')\n                                best_i, best_j = 0, 0\n                                for a in range(1, len(route_i)-1):\n                                    for b in range(1, len(route_j)-1):\n                                        dist = distance_matrix[route_i[a]][route_j[b]]\n                                        if dist < min_dist:\n                                            min_dist = dist\n                                            best_i, best_j = a, b\n                                merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                                new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                                new_solution.append(merged_route)\n                                break\n\n    # Probabilistic route inversion with capacity check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.3:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            if is_feasible(np.concatenate([route[:start], route[start:end][::-1], route[end:]])):\n                new_route = np.concatenate([route[:start], route[start:end][::-1], route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Demand-balanced route reshaping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            total_route_demand = sum(demand[route[1:-1]])\n            target_demand = total_route_demand / (len(route)-2)\n            max_diff = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                segment_demand = sum(demand[route[1:i]])\n                diff = abs(segment_demand - target_demand * (i-1))\n                if diff > max_diff:\n                    max_diff = diff\n                    split_pos = i\n            if split_pos > 1 and split_pos < len(route)-2:\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Novel route segment swapping operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Select random segments from each route\n            seg_i_start = random.randint(1, len(route_i)-3)\n            seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n            seg_j_start = random.randint(1, len(route_j)-3)\n            seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n            # Check capacity constraints\n            if (sum(demand[route_i[seg_i_start:seg_i_end]]) + sum(demand[route_j[1:-1]]) <= capacity and\n                sum(demand[route_j[seg_j_start:seg_j_end]]) + sum(demand[route_i[1:-1]]) <= capacity):\n                # Perform the swap\n                new_route_i = np.concatenate([\n                    route_i[:seg_i_start],\n                    route_j[seg_j_start:seg_j_end],\n                    route_i[seg_i_end:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:seg_j_start],\n                    route_i[seg_i_start:seg_i_end],\n                    route_j[seg_j_end:]\n                ])\n\n                # Update solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.8022699717026534,
            0.2725068926811218
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using adaptive weighted scoring (prioritizing balanced distance and makespan) and applies a hybrid local search combining demand-aware route splitting, spatial-demand-aware customer reinsertion, and adaptive route merging, ensuring feasibility and Pareto-efficient improvements while maintaining capacity constraints. It prioritizes distance reduction (70%) over demand balance (30%) in reinsertion and balances exploration (50% split/50% reinsertion) with exploitation (40% merging). The weighted scoring dynamically adjusts selection pressure based on random weights between 0.5 and 0.9.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.4 * random.random()\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Hybrid local search operators\n    if random.random() < 0.5:\n        # Demand-aware route splitting\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:\n                # Find split point based on demand balance\n                total_demand = sum(demand[route[1:-1]])\n                target_demand = total_demand / 2\n                cumulative_demand = 0\n                split_pos = 1\n                for j in range(1, len(route)-1):\n                    cumulative_demand += demand[route[j]]\n                    if cumulative_demand >= target_demand:\n                        split_pos = j\n                        break\n\n                if split_pos > 1 and split_pos < len(route)-2:\n                    route1 = np.concatenate([route[:split_pos+1], [0]])\n                    route2 = np.concatenate([[0], route[split_pos+1:]])\n                    if is_feasible(route1) and is_feasible(route2):\n                        new_solution[i] = route1\n                        new_solution.insert(i+1, route2)\n                        break\n    else:\n        # Spatial-demand-aware customer reinsertion\n        for _ in range(3):\n            if len(new_solution) > 1:\n                i, j = random.sample(range(len(new_solution)), 2)\n                route_i, route_j = new_solution[i], new_solution[j]\n\n                if len(route_i) > 3:\n                    # Select customer to reinsert\n                    customer_pos = random.randint(1, len(route_i)-2)\n                    customer = route_i[customer_pos]\n                    customer_demand = demand[customer]\n\n                    if sum(demand[route_j[1:-1]]) + customer_demand <= capacity:\n                        # Find best insertion position considering spatial proximity and demand\n                        best_pos = 1\n                        best_score = float('inf')\n                        for pos in range(1, len(route_j)):\n                            prev_node = route_j[pos-1]\n                            next_node = route_j[pos]\n                            dist_change = (distance_matrix[prev_node][customer] +\n                                         distance_matrix[customer][next_node] -\n                                         distance_matrix[prev_node][next_node])\n                            demand_change = abs(sum(demand[route_j[1:pos]]) - sum(demand[route_j[1:pos+1]]))\n                            score = 0.7 * dist_change + 0.3 * demand_change\n                            if score < best_score:\n                                best_score = score\n                                best_pos = pos\n\n                        # Perform reinsertion\n                        new_route_i = np.concatenate([route_i[:customer_pos], route_i[customer_pos+1:]])\n                        new_route_j = np.concatenate([route_j[:best_pos], [customer], route_j[best_pos:]])\n                        if is_feasible(new_route_i) and is_feasible(new_route_j):\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            break\n\n    # Adaptive route merging\n    if len(new_solution) > 1 and random.random() < 0.4:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i, route_j = new_solution[i], new_solution[j]\n\n        if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n            # Find best merge points considering spatial proximity\n            best_pair = (1, 1)\n            best_dist = float('inf')\n            for a in range(1, len(route_i)-1):\n                for b in range(1, len(route_j)-1):\n                    dist = distance_matrix[route_i[a]][route_j[b]]\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_pair = (a, b)\n\n            merged_route = np.concatenate([route_i[:best_pair[0]+1], route_j[best_pair[1]:-1], route_i[-1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n    return new_solution\n\n",
        "score": [
            -0.4889841824950912,
            0.22419819235801697
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects a promising solution from the archive using weighted scoring that balances distance and makespan objectives, then applies a hybrid local search combining demand-balanced route reshaping, probabilistic route inversion with capacity checks, and spatial-demand-aware route merging to generate high-quality neighbor solutions while preserving feasibility. It prioritizes solutions with better normalized objective values (with dynamic weights) and focuses on improving routes by splitting, inverting segments, and merging spatially close routes with similar demands.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.2 * (random.random() - 0.5)  # Dynamic weight between 0.3 and 0.7\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-balanced route reshaping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            total_route_demand = sum(demand[route[1:-1]])\n            target_demand = total_route_demand / (len(route)-2)\n            max_diff = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                segment_demand = sum(demand[route[1:i]])\n                diff = abs(segment_demand - target_demand * (i-1))\n                if diff > max_diff:\n                    max_diff = diff\n                    split_pos = i\n            if split_pos > 1 and split_pos < len(route)-2:\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Probabilistic route inversion with capacity check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.4:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            if is_feasible(np.concatenate([route[:start], route[start:end][::-1], route[end:]])):\n                new_route = np.concatenate([route[:start], route[start:end][::-1], route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Spatial-demand-aware route merging\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = sum(demand[route[1:-1]])\n                route_centroids.append((centroid, total_demand))\n        if len(route_centroids) > 1:\n            closest_pairs = []\n            for i in range(len(route_centroids)):\n                for j in range(i+1, len(route_centroids)):\n                    dist = np.linalg.norm(route_centroids[i][0] - route_centroids[j][0])\n                    demand_diff = abs(route_centroids[i][1] - route_centroids[j][1])\n                    closest_pairs.append((dist + 0.5*demand_diff, i, j))\n            if closest_pairs:\n                closest_pairs.sort()\n                for _, i, j in closest_pairs[:min(2, len(closest_pairs))]:\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                        min_dist = float('inf')\n                        best_i, best_j = 0, 0\n                        for a in range(1, len(route_i)-1):\n                            for b in range(1, len(route_j)-1):\n                                dist = distance_matrix[route_i[a]][route_j[b]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_i, best_j = a, b\n                        merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.831800500269364,
            0.33242061734199524
        ]
    },
    {
        "algorithm": "The algorithm prioritizes reducing makespan by first selecting the solution with the shortest longest route from the archive, then applies a hybrid local search combining route splitting and customer reallocation while ensuring vehicle capacity constraints are maintained. It focuses on balancing distance and makespan by iteratively improving the longest routes through strategic customer moves and splits, with limited attempts to prevent excessive computation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive[0][0].copy()\n\n    # Make a deep copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route-splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Try to split the route into two parts\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Create new routes\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n            break\n\n    # Try to reallocate customers between routes to balance makespan\n    for _ in range(3):  # Limit attempts to avoid excessive computation\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][j]][new_solution[i][j+1]] for j in range(len(new_solution[i])-1)))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) <= 3:\n            break\n\n        # Select a random customer from the longest route\n        customer_pos = random.randint(1, len(longest_route) - 2)\n        customer = longest_route[customer_pos]\n\n        # Try to insert into another route\n        for j in range(len(new_solution)):\n            if j == longest_route_idx:\n                continue\n\n            # Find the best insertion position in the other route\n            min_insert_cost = float('inf')\n            best_pos = -1\n\n            for k in range(len(new_solution[j]) - 1):\n                # Calculate insertion cost\n                cost = (distance_matrix[new_solution[j][k]][customer] +\n                        distance_matrix[customer][new_solution[j][k+1]] -\n                        distance_matrix[new_solution[j][k]][new_solution[j][k+1]])\n\n                if cost < min_insert_cost:\n                    min_insert_cost = cost\n                    best_pos = k + 1\n\n            # Check capacity constraint\n            if best_pos != -1:\n                new_demand = sum(demand[node] for node in new_solution[j][1:-1]) + demand[customer]\n                if new_demand <= capacity:\n                    # Perform the insertion\n                    new_solution[j] = np.insert(new_solution[j], best_pos, customer)\n                    new_solution[longest_route_idx] = np.delete(longest_route, customer_pos)\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7600897930810312,
            0.29289934039115906
        ]
    }
]