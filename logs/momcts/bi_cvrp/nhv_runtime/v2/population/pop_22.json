[
    {
        "algorithm": "The algorithm selects promising solutions from the archive based on a weighted score combining normalized distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and a novel route merging operator to balance objectives while maintaining feasibility. The selection prioritizes distance reduction (weighted 70%) and randomly explores top 30% solutions, while the operators intelligently modify routes to reduce makespan without violating capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def score_solution(solution, objectives):\n        total_dist, makespan = objectives\n        # Normalize objectives (assuming archive is non-empty)\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        # Weighted score (can be adjusted)\n        weight = 0.7  # More weight on distance reduction\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(score_solution(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    # Select top 30% solutions and pick one randomly\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Operator 1: Route splitting (if a route is too long)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Split only if route has more than 2 customers\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate([route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n            if is_feasible(new_route1) and is_feasible(new_route2):\n                new_solution[i] = new_route1\n                new_solution.insert(i + 1, new_route2)\n                break  # Only one split per iteration\n\n    # Operator 2: Customer reinsertion with capacity check\n    for _ in range(2):  # Try multiple times\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue  # Skip if route has only depot and one customer\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        # Remove customer temporarily\n        temp_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n        if not is_feasible(temp_route):\n            continue\n\n        # Try to insert in another route\n        for other_idx in range(len(new_solution)):\n            if other_idx == route_idx:\n                continue\n            other_route = new_solution[other_idx]\n            for insert_pos in range(1, len(other_route)):\n                new_other_route = np.concatenate([other_route[:insert_pos], [customer], other_route[insert_pos:]])\n                if is_feasible(new_other_route):\n                    new_solution[route_idx] = temp_route\n                    new_solution[other_idx] = new_other_route\n                    break\n            else:\n                continue\n            break\n\n    # Operator 3: Novel route merging (if two routes can be merged without exceeding capacity)\n    if len(new_solution) > 1:\n        for _ in range(2):  # Try multiple times\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[i], new_solution[j]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if is_feasible(merged_route):\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n    # Ensure all customers are served (sanity check)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    assert served_customers == all_customers, \"Not all customers are served\"\n\n    return new_solution\n\n",
        "score": [
            -0.5590214532653537,
            0.2597949504852295
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated or slightly dominated solutions) and applies a hybrid local search combining route swapping, demand-aware 2-opt with customer relocations, and adaptive route merging/splitting, while ensuring feasibility through capacity checks. It balances distance and makespan objectives by probabilistically applying these operations and reverting infeasible changes. The approach emphasizes demand-aware transformations and adaptive route adjustments to improve solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance and select one\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        # Select a solution that is not too dominated in either objective\n        candidate_indices = [i for i in range(len(sorted_solutions))\n                           if i < len(sorted_solutions)//2 or random.random() < 0.3]\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:  # Route swapping with demand-aware check\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Check if swapping customers between routes is feasible\n            if (np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= 2 * capacity):\n                # Try to swap a segment between routes\n                if len(route_i) > 3 and len(route_j) > 3:\n                    # Select a random segment from each route\n                    seg_i_start = random.randint(1, len(route_i)-3)\n                    seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n                    seg_j_start = random.randint(1, len(route_j)-3)\n                    seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n                    # Check capacity constraints\n                    if (np.sum(demand[route_i[seg_i_start:seg_i_end]]) + np.sum(demand[route_j[1:-1]]) <= capacity and\n                        np.sum(demand[route_j[seg_j_start:seg_j_end]]) + np.sum(demand[route_i[1:-1]]) <= capacity):\n                        # Perform the swap\n                        new_route_i = np.concatenate([\n                            route_i[:seg_i_start],\n                            route_j[seg_j_start:seg_j_end],\n                            route_i[seg_i_end:]\n                        ])\n                        new_route_j = np.concatenate([\n                            route_j[:seg_j_start],\n                            route_i[seg_i_start:seg_i_end],\n                            route_j[seg_j_end:]\n                        ])\n\n                        # Update solution\n                        new_solution[i] = new_route_i\n                        new_solution[j] = new_route_j\n    else:  # Intra-route 2-opt with demand-aware relocations\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx].copy()\n\n            if len(route) > 4:\n                # Select two random edges to reverse\n                a = random.randint(1, len(route)-3)\n                b = random.randint(a+1, len(route)-2)\n\n                # Check if reversing this segment is feasible\n                if np.sum(demand[route[a:b]]) == np.sum(demand[route[a:b][::-1]]):\n                    # Perform 2-opt\n                    new_route = np.concatenate([\n                        route[:a],\n                        route[a:b][::-1],\n                        route[b:]\n                    ])\n                    new_solution[route_idx] = new_route\n\n                    # Additional demand-aware relocation\n                    if random.random() < 0.3:\n                        # Try to relocate a customer to a different position\n                        relocate_pos = random.randint(1, len(new_route)-2)\n                        if relocate_pos != a and relocate_pos != b-1:\n                            customer = new_route[relocate_pos]\n                            # Find a better position for this customer\n                            best_pos = relocate_pos\n                            best_dist = float('inf')\n                            for pos in range(1, len(new_route)-1):\n                                if pos != relocate_pos:\n                                    # Check capacity constraint\n                                    if (np.sum(demand[new_route[1:pos]]) + demand[customer] <= capacity and\n                                        np.sum(demand[new_route[pos:-1]]) + demand[customer] <= capacity):\n                                        # Calculate new distance\n                                        prev_node = new_route[pos-1] if pos > 1 else 0\n                                        next_node = new_route[pos] if pos < len(new_route)-1 else 0\n                                        new_dist = (distance_matrix[prev_node][customer] +\n                                                   distance_matrix[customer][next_node] -\n                                                   distance_matrix[prev_node][next_node])\n                                        if new_dist < best_dist:\n                                            best_dist = new_dist\n                                            best_pos = pos\n                            if best_pos != relocate_pos:\n                                # Perform relocation\n                                new_route = np.concatenate([\n                                    new_route[:relocate_pos],\n                                    new_route[relocate_pos+1:]\n                                ])\n                                new_route = np.insert(new_route, best_pos, customer)\n                                new_solution[route_idx] = new_route\n\n    # Adaptive route merging/splitting\n    if len(new_solution) > 1 and random.random() < 0.3:\n        # Try to merge two routes if possible\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if (np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity):\n            # Check if merging is beneficial\n            dist_before = distance_matrix[route_i[-2]][0] + distance_matrix[route_j[-2]][0]\n            dist_after = distance_matrix[route_i[-2]][route_j[1]] + distance_matrix[route_j[-2]][0]\n\n            if dist_after < dist_before:\n                # Merge routes\n                merged_route = np.concatenate([\n                    route_i[:-1],\n                    route_j[1:]\n                ])\n                # Update solution\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    if random.random() < 0.2 and len(new_solution) < len(demand)-1:\n        # Try to split a route if beneficial\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 5:\n            # Find a good split point\n            best_split = -1\n            best_diff = float('inf')\n\n            for split in range(2, len(route)-2):\n                # Check capacity constraints for both parts\n                if (np.sum(demand[route[1:split]]) <= capacity and\n                    np.sum(demand[route[split:-1]]) <= capacity):\n                    # Calculate difference in distances\n                    dist_before = (distance_matrix[route[split-1]][route[split]] +\n                                 distance_matrix[route[split]][route[split+1]])\n                    dist_after = (distance_matrix[route[split-1]][0] +\n                                 distance_matrix[0][route[split]] +\n                                 distance_matrix[route[split]][0] +\n                                 distance_matrix[0][route[split+1]])\n                    diff = dist_after - dist_before\n                    if diff < best_diff:\n                        best_diff = diff\n                        best_split = split\n\n            if best_split != -1:\n                # Perform split\n                route1 = np.concatenate([route[:best_split], [0]])\n                route2 = np.concatenate([[0], route[best_split:]])\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx+1, route2)\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            for i in range(len(new_solution)):\n                if np.array_equal(new_solution[i], route):\n                    new_solution[i] = base_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5562969074910635,
            0.22014114260673523
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that combines adaptive route clustering based on spatial and demand proximity, a demand-balanced route reshaping operator, and probabilistic route inversion, while ensuring feasibility through continuous capacity validation and repair. It prioritizes solutions with balanced objective trade-offs by selecting from the top half of the archive, and applies novel transformations to explore alternative configurations while maintaining vehicle capacity constraints. The key design ideas are the spatial-demand-aware route merging, segment-based demand balancing, and probabilistic route inversion, all integrated within a feasibility-preserving framework.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 2:\n        candidates = archive_sorted[:len(archive)//2]\n        base_solution = random.choice(candidates)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route clustering based on spatial and demand proximity\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Group routes by spatial proximity and demand similarity\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = np.sum(demand[route[1:-1]])\n                route_centroids.append((centroid, total_demand))\n\n        # Find closest route pairs\n        closest_pairs = []\n        for i in range(len(route_centroids)):\n            for j in range(i+1, len(route_centroids)):\n                dist = np.linalg.norm(route_centroids[i][0] - route_centroids[j][0])\n                demand_diff = abs(route_centroids[i][1] - route_centroids[j][1])\n                closest_pairs.append((dist + demand_diff, i, j))\n\n        if closest_pairs:\n            closest_pairs.sort()\n            # Select top 3 closest pairs\n            for _, i, j in closest_pairs[:min(3, len(closest_pairs))]:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                # Try to merge if capacity allows\n                if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                    # Find optimal merge point\n                    min_dist = float('inf')\n                    best_i, best_j = 0, 0\n                    for a in range(1, len(route_i)-1):\n                        for b in range(1, len(route_j)-1):\n                            dist = distance_matrix[route_i[a]][route_j[b]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_i, best_j = a, b\n\n                    merged_route = np.concatenate([\n                        route_i[:best_i+1],\n                        route_j[best_j:-1],\n                        route_i[-1:]\n                    ])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    # Demand-balanced route reshaping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Find segments with demand imbalance\n            total_route_demand = np.sum(demand[route[1:-1]])\n            target_demand = total_route_demand / (len(route)-2)\n\n            # Find the most imbalanced segment\n            max_diff = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                segment_demand = np.sum(demand[route[1:i]])\n                diff = abs(segment_demand - target_demand * (i-1))\n                if diff > max_diff:\n                    max_diff = diff\n                    split_pos = i\n\n            if split_pos > 1 and split_pos < len(route)-2:\n                # Try to split and balance\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                # Check capacity constraints\n                if (np.sum(demand[segment1[1:-1]]) <= capacity and\n                    np.sum(demand[segment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Probabilistic route inversion\n    if random.random() < 0.3:\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 5:\n                # Select a random segment to invert\n                start = random.randint(1, len(route)-3)\n                end = random.randint(start+1, len(route)-2)\n\n                # Check capacity constraint\n                if np.sum(demand[route[start:end]]) == np.sum(demand[route[start:end][::-1]]):\n                    new_route = np.concatenate([\n                        route[:start],\n                        route[start:end][::-1],\n                        route[end:]\n                    ])\n                    new_solution[route_idx] = new_route\n\n    # Capacity validation and repair\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If route is over capacity, try to split it\n            cumulative_demand = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > capacity:\n                    split_pos = i\n                    break\n\n            if split_pos > 1:\n                # Perform split\n                route1 = np.concatenate([route[:split_pos], [0]])\n                route2 = np.concatenate([[0], route[split_pos:]])\n                # Replace the over-capacity route\n                for i in range(len(new_solution)):\n                    if np.array_equal(new_solution[i], route):\n                        new_solution[i] = route1\n                        new_solution.insert(i+1, route2)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8304065435505548,
            0.2735443413257599
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using an adaptive weighted scoring that balances distance and makespan, then applies a hybrid local search combining route merging, demand-aware customer reinsertion, and route splitting to generate feasible neighbor solutions, prioritizing distance reduction and makespan optimization with randomized selection and feasibility checks. The method emphasizes intelligent route transformations with adaptive weights and probabilistic operations to explore diverse neighborhoods while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.6 if random.random() < 0.5 else 0.4\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    for _ in range(2):\n        if len(new_solution) > 1 and random.random() < 0.4:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i, route_j = new_solution[i], new_solution[j]\n            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                min_dist = float('inf')\n                best_pair = (0, 0)\n                for a in range(1, len(route_i)):\n                    for b in range(1, len(route_j)):\n                        dist = distance_matrix[route_i[a]][route_j[b]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (a, b)\n                merged_route = np.concatenate([route_i[:best_pair[0]+1], route_j[best_pair[1]:-1], route_i[-1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]] + [merged_route]\n                break\n\n    for _ in range(3):\n        if len(new_solution) > 1 and random.random() < 0.6:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i, route_j = new_solution[i], new_solution[j]\n            if len(route_i) > 3:\n                customer_pos = random.randint(1, len(route_i)-2)\n                customer = route_i[customer_pos]\n                if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    min_cost = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(route_j)):\n                        cost = (distance_matrix[route_j[pos-1]][customer] +\n                               distance_matrix[customer][route_j[pos]] -\n                               distance_matrix[route_j[pos-1]][route_j[pos]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_route_i = np.concatenate([route_i[:customer_pos], route_i[customer_pos+1:]])\n                    new_route_j = np.concatenate([route_j[:best_pos], [customer], route_j[best_pos:]])\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n\n    for _ in range(2):\n        if len(new_solution) > 1 and random.random() < 0.3:\n            i = random.randint(0, len(new_solution)-1)\n            route = new_solution[i]\n            if len(route) > 5:\n                split_pos = random.randint(2, len(route)-3)\n                if sum(demand[route[1:split_pos]]) <= capacity and sum(demand[route[split_pos:-1]]) <= capacity:\n                    new_route1 = np.concatenate([route[:split_pos], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos:]])\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.4700528493331201,
            0.18445441126823425
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive based on makespan and total distance, then applies a hybrid local search combining route merging, customer reinsertion, and capacity-aware 2-opt swaps to generate a neighbor solution. It prioritizes solutions with lower makespan and total distance while ensuring feasibility through capacity checks during each transformation. The hybrid approach iteratively improves the solution by intelligently combining different neighborhood structures.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route merging, reinsertion, and capacity-aware swaps\n    for _ in range(3):  # Number of iterations can be adjusted\n        # Step 1: Try to merge two routes if possible\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible (capacity constraint)\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if total_demand <= capacity:\n                # Merge routes by connecting them via the closest pair of nodes\n                min_dist = float('inf')\n                best_pair = (0, 0)\n                for a in range(1, len(route1)):\n                    for b in range(1, len(route2)):\n                        dist = distance_matrix[route1[a]][route2[b]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (a, b)\n\n                # Create merged route\n                merged_route = np.concatenate([route1[:best_pair[0]+1], route2[best_pair[1]:-1], route1[-1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]] + [merged_route]\n\n        # Step 2: Try to reinsert a customer from one route to another\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) > 3:  # Ensure we can remove a customer\n                # Select a random customer from route1 (not depot)\n                customer_idx = np.random.randint(1, len(route1)-1)\n                customer = route1[customer_idx]\n\n                # Check if inserting into route2 is feasible\n                if sum(demand[node] for node in route2[1:-1]) + demand[customer] <= capacity:\n                    # Find the best insertion position in route2\n                    min_cost = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(route2)):\n                        cost = (distance_matrix[route2[pos-1]][customer] +\n                               distance_matrix[customer][route2[pos]] -\n                               distance_matrix[route2[pos-1]][route2[pos]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n\n                    # Perform the reinsertion\n                    new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n        # Step 3: Try a capacity-aware 2-opt swap within a route\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:  # Need at least 4 nodes to perform 2-opt\n                a, b = sorted(np.random.choice(range(1, len(route)-1), 2, replace=False))\n                # Check if swapping segments is feasible\n                segment1 = route[a:b+1]\n                segment2 = route[b+1:a-1:-1]  # Reverse order\n                new_segment = np.concatenate([segment1, segment2])\n\n                # Check capacity constraint\n                if sum(demand[node] for node in new_segment) <= capacity:\n                    new_route = np.concatenate([route[:a], new_segment, route[b+1:]])\n                    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8246564816575866,
            0.7151578962802887
        ]
    },
    {
        "algorithm": "The algorithm prioritizes reducing makespan by first selecting the solution with the shortest longest route from the archive, then applies a hybrid local search combining route splitting and customer reallocation while ensuring vehicle capacity constraints are maintained. It focuses on balancing distance and makespan by iteratively improving the longest routes through strategic customer moves and splits, with limited attempts to prevent excessive computation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive[0][0].copy()\n\n    # Make a deep copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route-splitting and customer reallocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            continue\n\n        # Try to split the route into two parts\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        demand_part1 = sum(demand[node] for node in part1[1:-1])\n        demand_part2 = sum(demand[node] for node in part2[1:-1])\n\n        if demand_part1 <= capacity and demand_part2 <= capacity:\n            # Create new routes\n            new_solution[i] = part1\n            new_solution.insert(i + 1, part2)\n            break\n\n    # Try to reallocate customers between routes to balance makespan\n    for _ in range(3):  # Limit attempts to avoid excessive computation\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: sum(distance_matrix[new_solution[i][j]][new_solution[i][j+1]] for j in range(len(new_solution[i])-1)))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) <= 3:\n            break\n\n        # Select a random customer from the longest route\n        customer_pos = random.randint(1, len(longest_route) - 2)\n        customer = longest_route[customer_pos]\n\n        # Try to insert into another route\n        for j in range(len(new_solution)):\n            if j == longest_route_idx:\n                continue\n\n            # Find the best insertion position in the other route\n            min_insert_cost = float('inf')\n            best_pos = -1\n\n            for k in range(len(new_solution[j]) - 1):\n                # Calculate insertion cost\n                cost = (distance_matrix[new_solution[j][k]][customer] +\n                        distance_matrix[customer][new_solution[j][k+1]] -\n                        distance_matrix[new_solution[j][k]][new_solution[j][k+1]])\n\n                if cost < min_insert_cost:\n                    min_insert_cost = cost\n                    best_pos = k + 1\n\n            # Check capacity constraint\n            if best_pos != -1:\n                new_demand = sum(demand[node] for node in new_solution[j][1:-1]) + demand[customer]\n                if new_demand <= capacity:\n                    # Perform the insertion\n                    new_solution[j] = np.insert(new_solution[j], best_pos, customer)\n                    new_solution[longest_route_idx] = np.delete(longest_route, customer_pos)\n\n                    # Remove empty routes\n                    new_solution = [route for route in new_solution if len(route) > 2]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7600897930810312,
            0.29289934039115906
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted random selection prioritizing distance (70%) over makespan (30%), then applies a hybrid local search combining route splitting, demand-balanced customer relocation, and adaptive 2-opt swaps, ensuring capacity feasibility at each step. It balances exploration (route splitting) and exploitation (relocation/2-opt) with probabilistic triggers and adaptive segment selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    norm_dist = (objectives[:, 0] - objectives[:, 0].min()) / (objectives[:, 0].max() - objectives[:, 0].min() + 1e-8)\n    norm_makespan = (objectives[:, 1] - objectives[:, 1].min()) / (objectives[:, 1].max() - objectives[:, 1].min() + 1e-8)\n    weights = 0.7 * norm_dist + 0.3 * norm_makespan  # Prioritize distance\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with adaptive components\n    for _ in range(3):\n        # Step 1: Route splitting based on demand balance\n        if len(new_solution) < len(demand) and np.random.rand() < 0.4:\n            route_idx = np.random.choice(len(new_solution))\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = np.random.randint(2, len(route)-2)\n                route1 = np.concatenate([route[:split_pos], [0]])\n                route2 = np.concatenate([[0], route[split_pos:]])\n\n                demand1 = sum(demand[node] for node in route1[1:-1])\n                demand2 = sum(demand[node] for node in route2[1:-1])\n\n                if demand1 <= capacity and demand2 <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx+1, route2)\n\n        # Step 2: Customer relocation with demand balancing\n        if len(new_solution) > 1 and np.random.rand() < 0.6:\n            from_route_idx = np.random.choice(len(new_solution))\n            from_route = new_solution[from_route_idx]\n            if len(from_route) > 3:\n                customer_idx = np.random.randint(1, len(from_route)-1)\n                customer = from_route[customer_idx]\n\n                # Find target route with complementary demand\n                demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n                target_idx = np.argmin(np.abs(np.array(demands) - (capacity - demand[customer])))\n                target_route = new_solution[target_idx]\n\n                if sum(demand[node] for node in target_route[1:-1]) + demand[customer] <= capacity:\n                    # Find best insertion position\n                    min_cost = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(target_route)):\n                        cost = (distance_matrix[target_route[pos-1]][customer] +\n                               distance_matrix[customer][target_route[pos]] -\n                               distance_matrix[target_route[pos-1]][target_route[pos]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n\n                    # Perform relocation\n                    new_from_route = np.concatenate([from_route[:customer_idx], from_route[customer_idx+1:]])\n                    new_target_route = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n                    new_solution[from_route_idx] = new_from_route\n                    new_solution[target_idx] = new_target_route\n\n        # Step 3: Adaptive 2-opt with capacity check\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                # Adaptive segment selection\n                segment_length = min(3, len(route)-2)\n                a = np.random.randint(1, len(route)-segment_length)\n                b = a + segment_length\n\n                # Check feasibility before swap\n                segment1 = route[a:b+1]\n                segment2 = route[b+1:a-1:-1]\n                new_segment = np.concatenate([segment1, segment2])\n\n                if sum(demand[node] for node in new_segment) <= capacity:\n                    new_route = np.concatenate([route[:a], new_segment, route[b+1:]])\n                    new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7586780431530137,
            0.5241886377334595
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing solutions with good distance-makespan trade-offs), then applies a hybrid local search combining route splitting, demand-aware reinsertion, and cross-route swapping to improve both objectives while maintaining feasibility. It prioritizes splitting overloaded routes, optimizes customer positions within routes, and balances demands between routes through strategic swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] - 0.5 * x[1][1])[0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search\n    # Step 1: Route splitting (if any route exceeds capacity by more than 50%)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 2:  # Skip single-customer routes\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand > 1.5 * capacity:\n                # Split the route into two\n                split_point = len(route) // 2\n                new_route1 = np.concatenate(([0], route[1:split_point+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_point+1:-1], [0]))\n\n                # Check capacity constraints\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    # Step 2: Demand-aware customer reinsertion\n    for route in new_solution:\n        if len(route) > 3:  # Routes with at least 2 customers\n            # Remove a random customer (not depot)\n            removed_idx = random.randint(1, len(route)-2)\n            removed_customer = route[removed_idx]\n            removed_demand = demand[removed_customer]\n\n            # Find best position to reinsert\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(1, len(route)-1):\n                if i == removed_idx or i == removed_idx - 1:\n                    continue\n\n                # Calculate insertion cost\n                prev_node = route[i-1]\n                next_node = route[i]\n                cost = (distance_matrix[prev_node][removed_customer] +\n                        distance_matrix[removed_customer][next_node] -\n                        distance_matrix[prev_node][next_node])\n\n                # Check capacity constraint\n                current_demand = sum(demand[node] for node in route[1:-1])\n                if current_demand - demand[route[removed_idx]] + removed_demand <= capacity:\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n            if best_pos != -1:\n                # Perform the insertion\n                route = np.concatenate((route[:best_pos], [removed_customer], route[best_pos:]))\n                # Remove the old position\n                if best_pos < removed_idx:\n                    route = np.delete(route, removed_idx + 1)\n                else:\n                    route = np.delete(route, removed_idx)\n\n    # Step 3: Cross-route swapping (if there are at least two routes)\n    if len(new_solution) >= 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Try to swap two customers between routes\n        if len(route1) > 2 and len(route2) > 2:\n            # Select random customers from each route (excluding depots)\n            cust1_idx = random.randint(1, len(route1)-2)\n            cust2_idx = random.randint(1, len(route2)-2)\n            cust1 = route1[cust1_idx]\n            cust2 = route2[cust2_idx]\n\n            # Check capacity constraints after swap\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if ((demand1 - demand[cust1] + demand[cust2] <= capacity) and\n                (demand2 - demand[cust2] + demand[cust1] <= capacity)):\n\n                # Perform the swap\n                route1[cust1_idx] = cust2\n                route2[cust2_idx] = cust1\n\n    return new_solution\n\n",
        "score": [
            -0.4406720189487392,
            0.6140982210636139
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1] - 0.5*max(x[1][0], x[1][1])))\n    selection_prob = np.exp(-np.arange(len(archive_sorted)) / len(archive_sorted))\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive_sorted), p=selection_prob)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Route clustering based on spatial and demand proximity\n    if len(new_solution) > 2 and random.random() < 0.4:\n        # Group routes by spatial proximity\n        route_centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            route_centroids.append(centroid)\n\n        # Find closest route pairs\n        closest_pairs = []\n        for i in range(len(route_centroids)):\n            for j in range(i+1, len(route_centroids)):\n                dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                closest_pairs.append((dist, i, j))\n        closest_pairs.sort()\n\n        # Try merging the closest compatible routes\n        for dist, i, j in closest_pairs[:2]:\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            total_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n\n            if total_demand <= capacity:\n                # Find best insertion point\n                min_dist = float('inf')\n                best_pos = (0, 0)\n                for a in range(1, len(route_i)):\n                    for b in range(1, len(route_j)):\n                        d = distance_matrix[route_i[a]][route_j[b]]\n                        if d < min_dist:\n                            min_dist = d\n                            best_pos = (a, b)\n\n                # Create merged route\n                merged_route = np.concatenate([\n                    route_i[:best_pos[0]+1],\n                    route_j[best_pos[1]:-1],\n                    route_i[-1:]\n                ])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]] + [merged_route]\n                break\n\n    # Phase 2: Demand-aware segment swaps between routes\n    if len(new_solution) > 1 and random.random() < 0.6:\n        # Select two routes with complementary demands\n        route_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                demand_i = np.sum(demand[new_solution[i][1:-1]])\n                demand_j = np.sum(demand[new_solution[j][1:-1]])\n                if abs(demand_i - demand_j) < capacity * 0.3:  # Similar demands\n                    route_pairs.append((i, j))\n\n        if route_pairs:\n            i, j = random.choice(route_pairs)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Find segments to swap\n            for _ in range(3):  # Try multiple times\n                seg_i_start = random.randint(1, len(route_i)-3)\n                seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n                seg_j_start = random.randint(1, len(route_j)-3)\n                seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n                segment_i = route_i[seg_i_start:seg_i_end]\n                segment_j = route_j[seg_j_start:seg_j_end]\n\n                # Check capacity constraints\n                new_demand_i = (np.sum(demand[route_i[1:-1]]) - np.sum(demand[segment_i]) + np.sum(demand[segment_j]))\n                new_demand_j = (np.sum(demand[route_j[1:-1]]) - np.sum(demand[segment_j]) + np.sum(demand[segment_i]))\n\n                if new_demand_i <= capacity and new_demand_j <= capacity:\n                    # Perform the swap\n                    new_route_i = np.concatenate([\n                        route_i[:seg_i_start],\n                        segment_j,\n                        route_i[seg_i_end:]\n                    ])\n                    new_route_j = np.concatenate([\n                        route_j[:seg_j_start],\n                        segment_i,\n                        route_j[seg_j_end:]\n                    ])\n\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n\n    # Phase 3: Adaptive route balancing\n    if random.random() < 0.5:\n        # Find routes that could benefit from load balancing\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        avg_demand = np.mean(route_demands)\n        candidates = [i for i, d in enumerate(route_demands) if abs(d - avg_demand) > capacity * 0.2]\n\n        if candidates:\n            route_idx = random.choice(candidates)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Try to move a customer to another route\n                customer_idx = random.randint(1, len(route)-2)\n                customer = route[customer_idx]\n\n                for other_idx in range(len(new_solution)):\n                    if other_idx != route_idx:\n                        other_route = new_solution[other_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Find best insertion position\n                            min_cost = float('inf')\n                            best_pos = 1\n                            for pos in range(1, len(other_route)):\n                                cost = (distance_matrix[other_route[pos-1]][customer] +\n                                       distance_matrix[customer][other_route[pos]] -\n                                       distance_matrix[other_route[pos-1]][other_route[pos]])\n                                if cost < min_cost:\n                                    min_cost = cost\n                                    best_pos = pos\n\n                            # Perform the move\n                            new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                            new_other_route = np.concatenate([other_route[:best_pos], [customer], other_route[best_pos:]])\n\n                            new_solution[route_idx] = new_route\n                            new_solution[other_idx] = new_other_route\n                            break\n\n    # Final feasibility check\n    for i in range(len(new_solution)):\n        if np.sum(demand[new_solution[i][1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution[i] = base_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.57967871109932,
            0.7455040812492371
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of normalized makespan (40%) and total distance (60%), then applies a hybrid local search combining route splitting, customer relocation, and capacity-constrained 3-opt swaps, prioritizing solutions with balanced improvement in both objectives while ensuring feasibility through strict capacity checks. The method iteratively refines the solution by splitting long routes, relocating customers between routes, and optimizing sequences within routes, with a focus on minimizing both total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        min_dist = min(x[1][0] for x in archive)\n        max_dist = max(x[1][0] for x in archive)\n        min_makespan = min(x[1][1] for x in archive)\n        max_makespan = max(x[1][1] for x in archive)\n\n        def score(x):\n            norm_dist = (x[1][0] - min_dist) / (max_dist - min_dist + 1e-8)\n            norm_makespan = (x[1][1] - min_makespan) / (max_makespan - min_makespan + 1e-8)\n            return 0.6 * norm_dist + 0.4 * norm_makespan\n\n        archive_sorted = sorted(archive, key=score)\n    else:\n        archive_sorted = archive\n\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer relocation, and 3-opt\n    for _ in range(4):  # Increased iterations\n        # Step 1: Try to split a long route into two\n        if len(new_solution) < len(coords) - 1:  # Prevent too many routes\n            route_idx = np.random.randint(len(new_solution))\n            route = new_solution[route_idx]\n            if len(route) > 5:  # Only split if route is long enough\n                split_pos = np.random.randint(2, len(route)-2)\n                new_route1 = route[:split_pos+1]\n                new_route2 = np.concatenate([[0], route[split_pos:-1]])\n\n                # Check capacity constraints\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution = [r for i, r in enumerate(new_solution) if i != route_idx] + [new_route1, new_route2]\n\n        # Step 2: Try to relocate a customer to a different route\n        if len(new_solution) > 1:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) > 3:  # Ensure we can remove a customer\n                # Select a random customer from route1 (not depot)\n                customer_idx = np.random.randint(1, len(route1)-1)\n                customer = route1[customer_idx]\n\n                # Check if inserting into route2 is feasible\n                if sum(demand[node] for node in route2[1:-1]) + demand[customer] <= capacity:\n                    # Find the best insertion position in route2\n                    min_cost = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(route2)):\n                        cost = (distance_matrix[route2[pos-1]][customer] +\n                               distance_matrix[customer][route2[pos]] -\n                               distance_matrix[route2[pos-1]][route2[pos]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n\n                    # Perform the relocation\n                    new_route1 = np.concatenate([route1[:customer_idx], route1[customer_idx+1:]])\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[i] = new_route1\n                    new_solution[j] = new_route2\n\n        # Step 3: Try a capacity-constrained 3-opt swap within a route\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 5:  # Need at least 6 nodes for 3-opt\n                a, b, c = sorted(np.random.choice(range(1, len(route)-1), 3, replace=False))\n\n                # Generate all possible 3-opt configurations\n                configs = [\n                    np.concatenate([route[:a], route[b+1:c+1], route[a:b+1], route[c+1:]]),\n                    np.concatenate([route[:a], route[c+1:], route[a:b+1], route[b+1:c+1], route[c+1:]]),\n                    np.concatenate([route[:a], route[b+1:c+1], route[a:b+1][::-1], route[c+1:]]),\n                    np.concatenate([route[:a], route[c+1:], route[a:b+1][::-1], route[b+1:c+1], route[c+1:]])\n                ]\n\n                # Find the best configuration that maintains capacity\n                best_config = None\n                min_cost = float('inf')\n                for config in configs:\n                    if sum(demand[node] for node in config[1:-1]) <= capacity:\n                        cost = sum(distance_matrix[config[i]][config[i+1]] for i in range(len(config)-1))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_config = config\n\n                if best_config is not None:\n                    new_solution[route_idx] = best_config\n\n    return new_solution\n\n",
        "score": [
            -0.7056176154314161,
            2.6358802318573
        ]
    }
]