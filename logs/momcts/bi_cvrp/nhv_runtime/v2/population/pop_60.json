[
    {
        "algorithm": "The algorithm combines adaptive Pareto scoring with a hybrid local search strategy that prioritizes demand-balanced route merging while probabilistically applying route inversion to improve both distance and makespan objectives, all while maintaining feasibility through capacity-aware operations. It first selects promising solutions based on normalized objective trade-offs, then applies dynamic route reshaping (inversion and merging) to balance objectives, with special attention to spatially close and demand-complementary routes. The algorithm emphasizes capacity constraints through rigorous checks during route modifications and splitting.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_pareto_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_pareto_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Dynamic Pareto-aware route inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.5:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n            if is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Adaptive demand-centric clustering\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                route_centroids.append(centroid)\n\n        if len(route_centroids) > 1:\n            closest_pairs = []\n            for i in range(len(route_centroids)):\n                for j in range(i+1, len(route_centroids)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demands[i] - route_demands[j])\n                    closest_pairs.append((dist + 0.3*demand_diff, i, j))\n\n            if closest_pairs:\n                closest_pairs.sort()\n                for _, i, j in closest_pairs[:min(2, len(closest_pairs))]:\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                        min_dist = float('inf')\n                        best_i, best_j = 0, 0\n                        for a in range(1, len(route_i)-1):\n                            for b in range(1, len(route_j)-1):\n                                dist = distance_matrix[route_i[a]][route_j[b]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_i, best_j = a, b\n                        merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    # Capacity-aware route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and sum(demand[route[1:-1]]) > 0.8 * capacity:\n            split_pos = random.randint(2, len(route)-3)\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n            if is_feasible(segment1) and is_feasible(segment2):\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8680926223332354,
            0.32213422656059265
        ]
    },
    {
        "algorithm": "The algorithm implements a novel hybrid local search strategy that combines adaptive spatial-demand clustering with probabilistic route inversion and segment swapping, while dynamically balancing distance and makespan objectives through an oscillating weighting scheme and ensuring feasibility through capacity-aware route modifications and splitting. It prioritizes solutions with better normalized objective scores, applies spatial clustering to merge similar routes, probabilistically inverts route segments, swaps segments between routes while maintaining capacity, and splits overloaded routes for better demand balance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def dynamic_weighting(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.3 + 0.3 * (np.sin(len(archive) / 10) + 1)  # Oscillating weight between 0.3 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(dynamic_weighting(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Adaptive spatial-demand clustering\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = sum(demand[route[1:-1]])\n                route_data.append((centroid, total_demand, route))\n\n        if len(route_data) > 1:\n            clusters = []\n            while len(route_data) > 0:\n                base = route_data.pop(0)\n                cluster = [base]\n                i = 0\n                while i < len(route_data):\n                    centroid, demand_val, _ = route_data[i]\n                    dist = np.linalg.norm(base[0] - centroid)\n                    demand_diff = abs(base[1] - demand_val)\n                    if dist < 1.2 * np.mean(distance_matrix) and demand_diff < 0.4 * capacity:\n                        cluster.append(route_data.pop(i))\n                    else:\n                        i += 1\n                clusters.append(cluster)\n\n            for cluster in clusters:\n                if len(cluster) > 1:\n                    for i in range(len(cluster)-1):\n                        for j in range(i+1, len(cluster)):\n                            route_i = cluster[i][2]\n                            route_j = cluster[j][2]\n                            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                                min_dist = float('inf')\n                                best_i, best_j = 0, 0\n                                for a in range(1, len(route_i)-1):\n                                    for b in range(1, len(route_j)-1):\n                                        dist = distance_matrix[route_i[a]][route_j[b]]\n                                        if dist < min_dist:\n                                            min_dist = dist\n                                            best_i, best_j = a, b\n                                merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                                new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                                new_solution.append(merged_route)\n                                break\n\n    # Probabilistic route inversion with capacity check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.4:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n            if is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Segment swapping with demand balance consideration\n    if len(new_solution) > 1 and random.random() < 0.6:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            seg_i_start = random.randint(1, len(route_i)-3)\n            seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n            seg_j_start = random.randint(1, len(route_j)-3)\n            seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n            demand_i = sum(demand[route_i[seg_i_start:seg_i_end]])\n            demand_j = sum(demand[route_j[seg_j_start:seg_j_end]])\n\n            if (sum(demand[route_i[1:-1]]) - demand_i + demand_j <= capacity and\n                sum(demand[route_j[1:-1]]) - demand_j + demand_i <= capacity):\n\n                new_route_i = np.concatenate([\n                    route_i[:seg_i_start],\n                    route_j[seg_j_start:seg_j_end],\n                    route_i[seg_i_end:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:seg_j_start],\n                    route_i[seg_i_start:seg_i_end],\n                    route_j[seg_j_end:]\n                ])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Capacity-aware route splitting with demand balancing\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and sum(demand[route[1:-1]]) > 0.7 * capacity:\n            total_demand = sum(demand[route[1:-1]])\n            best_split = None\n            min_diff = float('inf')\n            for i in range(2, len(route)-2):\n                segment_demand = sum(demand[route[1:i]])\n                remaining_demand = total_demand - segment_demand\n                current_diff = abs(segment_demand - remaining_demand)\n                if current_diff < min_diff:\n                    min_diff = current_diff\n                    best_split = i\n            if best_split and min_diff < capacity * 0.3:\n                segment1 = route[:best_split+1]\n                segment2 = np.concatenate([[0], route[best_split+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8857202748740283,
            0.3450027406215668
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that combines adaptive demand-aware route splitting, spatial-proximity guided demand-balanced reinsertion, and dynamic capacity-balanced route reshaping, prioritizing solutions with balanced distance and makespan objectives while ensuring capacity feasibility. It intelligently selects promising solutions from the archive using an adaptive weighted scoring mechanism, then applies probabilistic route transformations to improve both objectives. The method dynamically balances exploration and exploitation through weighted selection and conditional probabilistic operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(sol, obj):\n        total_dist, makespan = obj\n        max_dist = max(o[0] for _, o in archive)\n        max_makespan = max(o[1] for _, o in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-aware route splitting with probabilistic inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.6:\n            customers = route[1:-1]\n            demands = demand[customers]\n            supply = np.cumsum(demands)\n            target_supply = supply[-1] / 2\n\n            split_pos = np.argmin(np.abs(supply - target_supply)) + 1\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(segment1) and is_feasible(segment2):\n                if random.random() < 0.4:\n                    segment2 = np.concatenate([[0], segment2[-2:0:-1], segment2[-1:]])\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    # Spatial-proximity guided demand-balanced reinsertion\n    if len(new_solution) > 1 and random.random() < 0.7:\n        source_idx = random.randint(0, len(new_solution)-1)\n        target_idx = random.randint(0, len(new_solution)-1)\n        if source_idx != target_idx:\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                customer_pos = random.randint(1, len(source_route)-2)\n                customer = source_route[customer_pos]\n\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    best_pos = 1\n                    min_increase = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_target = np.concatenate([target_route[:pos], [customer], target_route[pos:]])\n                        dist_increase = (distance_matrix[target_route[pos-1]][customer] +\n                                        distance_matrix[customer][target_route[pos]] -\n                                        distance_matrix[target_route[pos-1]][target_route[pos]])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    new_target = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n\n                    if is_feasible(new_source) and is_feasible(new_target):\n                        new_solution[source_idx] = new_source\n                        new_solution[target_idx] = new_target\n\n    # Dynamic capacity-balanced route reshaping\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_stats = []\n        for route in new_solution:\n            if len(route) > 2:\n                total_demand = sum(demand[route[1:-1]])\n                route_stats.append((total_demand, route))\n\n        if len(route_stats) > 1:\n            route_stats.sort(key=lambda x: x[0])\n            for i in range(len(route_stats)-1):\n                j = len(route_stats)-1-i\n                if i >= j:\n                    break\n\n                route_i = route_stats[i][1]\n                route_j = route_stats[j][1]\n\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n\n                    if is_feasible(merged_route):\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8222700764257004,
            0.09269183874130249
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive route segmentation with demand-aware reinsertion, prioritizing spatial proximity and demand balance to generate high-quality neighbor solutions while maintaining capacity constraints. It first selects promising solutions from the archive using an adaptive weighted scoring that balances distance and makespan objectives, then dynamically splits routes based on spatial centroids and demand distribution, followed by capacity-constrained reinsertion of segments into spatially nearby routes to improve both objectives. The method emphasizes spatial-demand-aware splitting and probabilistic reinsertion to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(sol, obj):\n        total_dist, makespan = obj\n        max_dist = max(o[0] for _, o in archive)\n        max_makespan = max(o[1] for _, o in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Spatial-demand-aware route segmentation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3 and random.random() < 0.6:\n            customers = route[1:-1]\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            dists = np.linalg.norm(route_coords - centroid, axis=1)\n            demands = demand[customers]\n\n            # Split based on spatial proximity and demand balance\n            split_pos = np.argmax(dists) + 1 if random.random() < 0.7 else np.argmin(demands) + 1\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(segment1) and is_feasible(segment2):\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    # Capacity-constrained reinsertion with spatial proximity\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Select a random segment to reinsert\n        source_route_idx = random.randint(0, len(new_solution)-1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 3:\n            start = random.randint(1, len(source_route)-3)\n            end = random.randint(start+1, len(source_route)-2)\n            segment = source_route[start:end+1]\n            segment_demand = sum(demand[segment[1:-1]])\n\n            # Find target route with spatial proximity\n            source_centroid = np.mean(coords[source_route[1:-1]], axis=0)\n            closest_route_idx = -1\n            min_dist = float('inf')\n            for i, route in enumerate(new_solution):\n                if i != source_route_idx and len(route) > 1:\n                    route_centroid = np.mean(coords[route[1:-1]], axis=0)\n                    dist = np.linalg.norm(source_centroid - route_centroid)\n                    if dist < min_dist:\n                        min_dist = dist\n                        closest_route_idx = i\n\n            if closest_route_idx != -1 and sum(demand[new_solution[closest_route_idx][1:-1]]) + segment_demand <= capacity:\n                # Find best insertion point\n                best_pos = 1\n                best_cost = float('inf')\n                target_route = new_solution[closest_route_idx]\n                for i in range(1, len(target_route)):\n                    cost = distance_matrix[target_route[i-1]][segment[1]] + distance_matrix[segment[-2]][target_route[i]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n\n                # Perform reinsertion\n                new_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_solution[closest_route_idx] = new_route\n                new_solution[source_route_idx] = np.concatenate([source_route[:start], source_route[end+1:]])\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8542899562589252,
            0.1418667733669281
        ]
    },
    {
        "algorithm": "The algorithm combines centroid-based route clustering with adaptive demand-sensitive operations, prioritizing spatial proximity (40%) and demand balance (60%) for merging, while using demand imbalance (60%) and capacity utilization (40%) to guide splitting and inversion. It dynamically adjusts routes by merging spatially close routes with complementary demands, splitting imbalanced routes, and inverting routes with high demand imbalance, all while maintaining feasibility. The selection process balances normalized distance (50%), makespan (40%), and spatial variance (30%) to identify promising solutions for further optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def multi_objective_selection(solutions, objectives):\n        norm_dist = (objectives[0] - min(obj[0] for _, obj in archive)) / (max(obj[0] for _, obj in archive) - min(obj[0] for _, obj in archive) + 1e-6)\n        norm_makespan = (objectives[1] - min(obj[1] for _, obj in archive)) / (max(obj[1] for _, obj in archive) - min(obj[1] for _, obj in archive) + 1e-6)\n        spatial_variance = np.std([np.mean(coords[route[1:-1]], axis=0) for route in solutions])\n        return 0.5 * norm_dist + 0.4 * norm_makespan + 0.3 * (1 - spatial_variance / np.max(np.std(coords, axis=0)))\n\n    scored_solutions = [(multi_objective_selection(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    selection_pool = scored_solutions[:max(1, int(0.3 * len(scored_solutions)))]\n    selected_solution = random.choice([sol for _, sol in selection_pool])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Spatial-aware route clustering with demand constraints\n    route_centroids = []\n    for route in new_solution:\n        if len(route) > 2:\n            centroid = np.mean(coords[route[1:-1]], axis=0)\n            route_centroids.append((centroid, route))\n\n    for i in range(len(route_centroids)):\n        for j in range(i+1, len(route_centroids)):\n            centroid_i, route_i = route_centroids[i]\n            centroid_j, route_j = route_centroids[j]\n            spatial_dist = np.linalg.norm(centroid_i - centroid_j)\n            demand_i = sum(demand[route_i[1:-1]])\n            demand_j = sum(demand[route_j[1:-1]])\n\n            if demand_i + demand_j <= capacity:\n                merge_prob = 0.4 * (1 - spatial_dist/np.max(distance_matrix)) + 0.6 * (1 - abs(demand_i - demand_j)/max(demand_i, demand_j))\n                if random.random() < merge_prob:\n                    # Find best insertion points\n                    min_dist = float('inf')\n                    best_pair = (0, 0)\n                    for a in range(1, len(route_i)-1):\n                        for b in range(1, len(route_j)-1):\n                            dist = distance_matrix[route_i[a]][route_j[b]] * (1 + 0.2 * abs(demand[route_i[a]] - demand[route_j[b]])/capacity)\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pair = (a, b)\n                    merged_route = np.concatenate([route_i[:best_pair[0]+1], route_j[best_pair[1]:-1], route_i[-1:]])\n                    new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]] + [merged_route]\n                    break\n\n    # Adaptive demand-sensitive splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5:\n            total_demand = sum(demand[route[1:-1]])\n            split_candidates = []\n            for pos in range(2, len(route)-2):\n                left_demand = sum(demand[route[1:pos]])\n                right_demand = total_demand - left_demand\n                demand_balance = 1 - abs(left_demand - right_demand)/total_demand\n                left_centroid = np.mean(coords[route[1:pos]], axis=0)\n                right_centroid = np.mean(coords[route[pos:-1]], axis=0)\n                spatial_separation = np.linalg.norm(left_centroid - right_centroid)\n                split_score = 0.7 * demand_balance + 0.3 * (spatial_separation / np.max(distance_matrix))\n                split_candidates.append((split_score, pos))\n\n            if split_candidates:\n                split_candidates.sort(reverse=True, key=lambda x: x[0])\n                best_pos = split_candidates[0][1]\n                if sum(demand[route[1:best_pos]]) <= capacity and sum(demand[route[best_pos:-1]]) <= capacity:\n                    new_route1 = np.concatenate([route[:best_pos], [0]])\n                    new_route2 = np.concatenate([[0], route[best_pos:]])\n                    new_solution[route_idx] = new_route1\n                    new_solution.insert(route_idx+1, new_route2)\n                    break\n\n    # Demand-balanced route inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            demand_profile = np.cumsum(demand[route[1:-1]])\n            total_demand = demand_profile[-1]\n            imbalance = max(demand_profile) - min(demand_profile)\n            inversion_prob = 0.6 * (imbalance/total_demand) + 0.4 * (1 - sum(demand[route[1:-1]])/capacity)\n            if inversion_prob > 0.8 and random.random() < 0.6:\n                farthest_node = max(route[1:-1], key=lambda x: np.linalg.norm(coords[x] - np.mean(coords[route[1:-1]], axis=0)))\n                pos = np.where(route == farthest_node)[0][0]\n                inverted_route = np.concatenate([route[:pos], route[pos:][::-1]])\n                if sum(demand[inverted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = inverted_route\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8971851196955121,
            3.77056685090065
        ]
    },
    {
        "algorithm": "The algorithm combines demand-aware route partitioning, spatial-demand correlation analysis, adaptive route fusion, and probabilistic route rebalancing to generate high-quality neighbors by prioritizing under-explored regions of the Pareto front, focusing on demand distribution and spatial proximity while maintaining feasibility through dynamic capacity checks. It intelligently selects solutions with lower Pareto front coverage scores and applies probabilistic transformations to balance route lengths and demands, with higher emphasis on demand-aware partitioning and spatial correlation analysis.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def pareto_distance_score(solution, objectives):\n        total_dist, makespan = objectives\n        min_dist = min(obj[0] for _, obj in archive)\n        min_makespan = min(obj[1] for _, obj in archive)\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n\n        norm_dist = (total_dist - min_dist) / (max_dist - min_dist + 1e-6)\n        norm_makespan = (makespan - min_makespan) / (max_makespan - min_makespan + 1e-6)\n\n        crowding_dist = np.sqrt(norm_dist**2 + norm_makespan**2)\n        return crowding_dist\n\n    scored_solutions = [(pareto_distance_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    bottom_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[-bottom_k:]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-aware route partitioning\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5:\n            demands = demand[route[1:-1]]\n            sorted_indices = np.argsort(demands)\n            partition_size = max(1, len(sorted_indices) // 2)\n            for i in range(0, len(sorted_indices), partition_size):\n                partition = sorted_indices[i:i+partition_size]\n                if len(partition) > 1 and random.random() < 0.5:\n                    segment = route[1:-1][partition]\n                    if sum(demands[partition]) <= capacity:\n                        new_route = np.concatenate([[0], segment, [0]])\n                        if is_feasible(new_route):\n                            new_solution[route_idx] = new_route\n                            break\n\n    # Spatial-demand correlation analysis\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_stats = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                demand_density = sum(demand[route[1:-1]]) / len(route_coords)\n                route_stats.append((centroid, demand_density))\n\n        if len(route_stats) > 1:\n            correlation_pairs = []\n            for i in range(len(route_stats)):\n                for j in range(i+1, len(route_stats)):\n                    spatial_dist = np.linalg.norm(route_stats[i][0] - route_stats[j][0])\n                    demand_diff = abs(route_stats[i][1] - route_stats[j][1])\n                    correlation_pairs.append((spatial_dist * (1 + demand_diff), i, j))\n\n            if correlation_pairs:\n                correlation_pairs.sort()\n                for _, i, j in correlation_pairs[:min(3, len(correlation_pairs))]:\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                        if is_feasible(merged_route):\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Adaptive route fusion\n    if len(new_solution) > 1 and random.random() < 0.4:\n        route_lengths = [len(route) for route in new_solution]\n        long_routes = [i for i, l in enumerate(route_lengths) if l > 4]\n        if long_routes:\n            route_idx = random.choice(long_routes)\n            route = new_solution[route_idx]\n            best_split = -1\n            best_improvement = 0\n\n            for split in range(3, len(route)-3):\n                part1 = route[:split+1]\n                part2 = np.concatenate([[0], route[split+1:]])\n                if is_feasible(part1) and is_feasible(part2):\n                    current_length = distance_matrix[route[:-1], route[1:]].sum()\n                    new_length = (distance_matrix[part1[:-1], part1[1:]].sum() +\n                                 distance_matrix[part2[:-1], part2[1:]].sum())\n                    improvement = current_length - new_length\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_split = split\n\n            if best_split != -1:\n                part1 = route[:best_split+1]\n                part2 = np.concatenate([[0], route[best_split+1:]])\n                new_solution[route_idx] = part1\n                new_solution.insert(route_idx+1, part2)\n\n    # Probabilistic route rebalancing\n    if random.random() < 0.5 and len(new_solution) < len(demand)-1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            current_demand = sum(demand[route[1:-1]])\n            target_demand = capacity * 0.7\n            if current_demand > target_demand:\n                excess = current_demand - target_demand\n                candidates = [i for i in range(1, len(route)-1) if demand[route[i]] <= excess]\n\n                if candidates:\n                    node_idx = random.choice(candidates)\n                    new_route = np.concatenate([route[:node_idx+1], [0], route[node_idx+1:]])\n                    if is_feasible(new_route[:-1]) and is_feasible(np.concatenate([[0], new_route[node_idx+1:]])):\n                        new_solution[route_idx] = new_route[:-1]\n                        new_solution.insert(route_idx+1, np.concatenate([[0], new_route[node_idx+1:]]))\n\n    return new_solution\n\n",
        "score": [
            -0.8960085873524968,
            0.37631556391716003
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive route segmentation, spatial-proximity guided reinsertion, and dynamic route inversion to improve bi-objective CVRP solutions, prioritizing demand-balanced route restructuring while maintaining capacity feasibility through probabilistic reshaping and spatial inversions. It dynamically balances distance and makespan objectives through an adaptive weighted scoring mechanism, focusing on high-potential solutions from the archive while ensuring feasibility checks at each transformation step. The hybrid approach alternates between demand-aware segmentation, proximity-guided reinsertion, and capacity-constrained merging to explore diverse neighborhoods while preserving solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(sol, obj):\n        total_dist, makespan = obj\n        max_dist = max(o[0] for _, o in archive)\n        max_makespan = max(o[1] for _, o in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Adaptive demand-aware route segmentation\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.6:\n            customers = route[1:-1]\n            demands = demand[customers]\n            supply = np.cumsum(demands)\n            target_supply = supply[-1] * (0.3 + 0.4 * random.random())\n\n            split_pos = np.argmin(np.abs(supply - target_supply)) + 1\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(segment1) and is_feasible(segment2):\n                if random.random() < 0.5:\n                    segment2 = np.concatenate([[0], segment2[-2:0:-1], segment2[-1:]])\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    # Spatial-proximity guided demand-balanced reinsertion\n    if len(new_solution) > 1 and random.random() < 0.7:\n        source_idx = random.randint(0, len(new_solution)-1)\n        target_idx = random.randint(0, len(new_solution)-1)\n        if source_idx != target_idx:\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                customer_pos = random.randint(1, len(source_route)-2)\n                customer = source_route[customer_pos]\n\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    best_pos = 1\n                    min_increase = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_target = np.concatenate([target_route[:pos], [customer], target_route[pos:]])\n                        dist_increase = (distance_matrix[target_route[pos-1]][customer] +\n                                        distance_matrix[customer][target_route[pos]] -\n                                        distance_matrix[target_route[pos-1]][target_route[pos]])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    new_target = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n\n                    if is_feasible(new_source) and is_feasible(new_target):\n                        new_solution[source_idx] = new_source\n                        new_solution[target_idx] = new_target\n\n    # Dynamic capacity-constrained route inversion\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_stats = []\n        for route in new_solution:\n            if len(route) > 2:\n                total_demand = sum(demand[route[1:-1]])\n                route_stats.append((total_demand, route))\n\n        if len(route_stats) > 1:\n            route_stats.sort(key=lambda x: x[0])\n            for i in range(len(route_stats)-1):\n                j = len(route_stats)-1-i\n                if i >= j:\n                    break\n\n                route_i = route_stats[i][1]\n                route_j = route_stats[j][1]\n\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n\n                    if is_feasible(merged_route):\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6627008778277984,
            0.09661385416984558
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive demand-supply clustering with probabilistic spatial inversion and dynamic capacity-balanced reshaping, prioritizing Pareto-optimal trade-offs between distance and makespan. It intelligently selects solutions from the archive using a weighted scoring mechanism that balances exploration and exploitation, then applies hybrid local search operators including route splitting, customer reinsertion, and capacity-balanced merging to generate feasible neighbors while maintaining diversity in the search space. The approach emphasizes demand-based route balancing, spatial proximity optimization, and probabilistic route inversion to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def pareto_dominance_score(sol, obj):\n        dominated = 0\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated += 1\n        return dominated\n\n    def adaptive_weighted_score(sol, obj):\n        total_dist, makespan = obj\n        max_dist = max(o[0] for _, o in archive)\n        max_makespan = max(o[1] for _, o in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), pareto_dominance_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: (x[1], x[0]))\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-supply clustering with probabilistic inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.6:\n            customers = route[1:-1]\n            demands = demand[customers]\n            supply = np.cumsum(demands)\n            target_supply = supply[-1] / 2\n\n            split_pos = np.argmin(np.abs(supply - target_supply)) + 1\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(segment1) and is_feasible(segment2):\n                if random.random() < 0.4:\n                    segment2 = np.concatenate([[0], segment2[-2:0:-1], segment2[-1:]])\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    # Spatial-proximity guided customer reinsertion\n    if len(new_solution) > 1 and random.random() < 0.7:\n        source_idx = random.randint(0, len(new_solution)-1)\n        target_idx = random.randint(0, len(new_solution)-1)\n        if source_idx != target_idx:\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                customer_pos = random.randint(1, len(source_route)-2)\n                customer = source_route[customer_pos]\n\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    best_pos = 1\n                    min_increase = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_target = np.concatenate([target_route[:pos], [customer], target_route[pos:]])\n                        dist_increase = (distance_matrix[target_route[pos-1]][customer] +\n                                        distance_matrix[customer][target_route[pos]] -\n                                        distance_matrix[target_route[pos-1]][target_route[pos]])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    new_target = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n\n                    if is_feasible(new_source) and is_feasible(new_target):\n                        new_solution[source_idx] = new_source\n                        new_solution[target_idx] = new_target\n\n    # Dynamic capacity-balanced route reshaping\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_stats = []\n        for route in new_solution:\n            if len(route) > 2:\n                total_demand = sum(demand[route[1:-1]])\n                route_stats.append((total_demand, route))\n\n        if len(route_stats) > 1:\n            route_stats.sort(key=lambda x: x[0])\n            for i in range(len(route_stats)-1):\n                j = len(route_stats)-1-i\n                if i >= j:\n                    break\n\n                route_i = route_stats[i][1]\n                route_j = route_stats[j][1]\n\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n\n                    if is_feasible(merged_route):\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7815457256216266,
            0.10443207621574402
        ]
    },
    {
        "algorithm": "This algorithm implements an adaptive multi-objective local search that combines demand-aware route merging, probabilistic spatial inversion, and dynamic capacity-balancing segment swaps, while using a time-varying objective weighting scheme to prioritize solutions with balanced trade-offs between total distance and makespan, and maintains feasibility through capacity-constrained route modifications and demand-sensitive splitting. The algorithm selects promising solutions from the archive based on an adaptive weighting scheme that oscillates between prioritizing distance and makespan, then applies a series of specialized operators to improve the solution while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighting(solution, objectives, iteration):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        phase = np.sin(iteration / 20) * 0.5 + 0.5  # Smooth phase between 0 and 1\n        weight = 0.4 * phase + 0.2  # Weight oscillates between 0.2 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    iteration = len(archive)\n    scored_solutions = [(adaptive_weighting(sol, obj, iteration), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-aware route merging with spatial proximity\n    if len(new_solution) > 1 and random.random() < 0.4:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_demand = sum(demand[route[1:-1]])\n                route_centroid = np.mean(coords[route[1:-1]], axis=0)\n                route_data.append((route_centroid, route_demand, route))\n\n        if len(route_data) > 1:\n            for i in range(len(route_data)-1):\n                for j in range(i+1, len(route_data)):\n                    centroid_i, demand_i, route_i = route_data[i]\n                    centroid_j, demand_j, route_j = route_data[j]\n                    spatial_dist = np.linalg.norm(centroid_i - centroid_j)\n                    demand_ratio = min(demand_i, demand_j) / max(demand_i, demand_j)\n\n                    if spatial_dist < 1.5 * np.mean(distance_matrix) and demand_ratio > 0.6:\n                        if demand_i + demand_j <= capacity:\n                            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                            new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                            new_solution.append(merged_route)\n                            break\n\n    # Probabilistic spatial inversion with demand balance\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.3:\n            # Select a spatial segment for inversion\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            distances = np.linalg.norm(route_coords - centroid, axis=1)\n            farthest_idx = np.argmax(distances)\n            segment_start = max(1, farthest_idx - 1)\n            segment_end = min(len(route)-2, farthest_idx + 2)\n\n            inverted_segment = route[segment_start:segment_end][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end:]])\n            if is_feasible(new_route):\n                new_solution[route_idx] = new_route\n\n    # Dynamic capacity-balancing segment swaps\n    if len(new_solution) > 1 and random.random() < 0.5:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Find segments with balanced demand\n            demand_i = sum(demand[route_i[1:-1]])\n            demand_j = sum(demand[route_j[1:-1]])\n            target_demand = (demand_i + demand_j) / 2\n\n            best_i, best_j = None, None\n            min_diff = float('inf')\n\n            for a in range(1, len(route_i)-1):\n                for b in range(1, len(route_j)-1):\n                    seg_i_demand = sum(demand[route_i[1:a]])\n                    seg_j_demand = sum(demand[route_j[1:b]])\n                    new_demand_i = demand_i - seg_i_demand + seg_j_demand\n                    new_demand_j = demand_j - seg_j_demand + seg_i_demand\n\n                    if (new_demand_i <= capacity and new_demand_j <= capacity):\n                        current_diff = abs(new_demand_i - target_demand) + abs(new_demand_j - target_demand)\n                        if current_diff < min_diff:\n                            min_diff = current_diff\n                            best_i, best_j = a, b\n\n            if best_i is not None and best_j is not None:\n                new_route_i = np.concatenate([\n                    route_i[:best_i],\n                    route_j[best_j:-1],\n                    route_i[-1:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:best_j],\n                    route_i[best_i:-1],\n                    route_j[-1:]\n                ])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Demand-sensitive route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > 0.8 * capacity:\n                # Find split point that balances demand\n                best_split = None\n                min_diff = float('inf')\n\n                for i in range(2, len(route)-2):\n                    segment_demand = sum(demand[route[1:i]])\n                    remaining_demand = total_demand - segment_demand\n                    current_diff = abs(segment_demand - remaining_demand)\n                    if current_diff < min_diff:\n                        min_diff = current_diff\n                        best_split = i\n\n                if best_split and min_diff < capacity * 0.25:\n                    segment1 = route[:best_split+1]\n                    segment2 = np.concatenate([[0], route[best_split+1:]])\n                    if is_feasible(segment1) and is_feasible(segment2):\n                        new_solution[route_idx] = segment1\n                        new_solution.insert(route_idx+1, segment2)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.877543969183217,
            0.5999010503292084
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive spatial-demand clustering with probabilistic route restructuring, selecting solutions based on normalized objective trade-off scores and applying novel transformations like demand-aware merging, capacity-balanced splitting, and spatially informed inversion while ensuring feasibility through continuous validation. It prioritizes Pareto-efficient regions by dynamically adjusting weights between distance and makespan objectives, with higher emphasis on makespan during selection (via adaptive_weight) and probabilistic application of transformations (merge, split, invert). Critical variables like spatial distance and demand differences guide route modifications, while feasibility checks maintain vehicle capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def calculate_spatial_demand_score(route1, route2):\n        score = 0\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                spatial_dist = distance_matrix[route1[i]][route2[j]]\n                demand_diff = abs(demand[route1[i]] - demand[route2[j]])\n                score += (1 / (spatial_dist + 1e-6)) * (1 / (demand_diff + 1e-6))\n        return score\n\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def adaptive_weight():\n        return 0.3 + 0.7 * (random.random())\n\n    def normalized_objective_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = adaptive_weight()\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(normalized_objective_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                    score = calculate_spatial_demand_score(route_i, route_j)\n                    route_pairs.append((score, i, j))\n\n        if route_pairs:\n            route_pairs.sort(reverse=True, key=lambda x: x[0])\n            for _, i, j in route_pairs[:min(3, len(route_pairs))]:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                best_merge_point = None\n                best_score = -float('inf')\n                for a in range(1, len(route_i)-1):\n                    for b in range(1, len(route_j)-1):\n                        spatial_dist = distance_matrix[route_i[a]][route_j[b]]\n                        demand_match = 1 / (abs(demand[route_i[a]] - demand[route_j[b]]) + 1e-6)\n                        score = -spatial_dist * demand_match\n                        if score > best_score:\n                            best_score = score\n                            best_merge_point = (a, b)\n\n                if best_merge_point:\n                    a, b = best_merge_point\n                    merged_route = np.concatenate([route_i[:a+1], route_j[b:-1], route_i[-1:]])\n                    if is_feasible(merged_route):\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.5:\n            split_pos = random.randint(2, len(route)-3)\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(segment1) and is_feasible(segment2):\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.4:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n\n            spatial_center = np.mean(coords[route[start:end]], axis=0)\n            original_dist = np.sum([distance_matrix[route[i]][route[i+1]] for i in range(start, end-1)])\n            inverted_dist = np.sum([distance_matrix[inverted_segment[i]][inverted_segment[i+1]] for i in range(len(inverted_segment)-1)])\n\n            if inverted_dist < original_dist and is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    for route in new_solution:\n        if not is_feasible(route):\n            for i in range(len(new_solution)):\n                if np.array_equal(new_solution[i], route):\n                    new_solution[i] = selected_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8496531653483852,
            0.3905726671218872
        ]
    }
]