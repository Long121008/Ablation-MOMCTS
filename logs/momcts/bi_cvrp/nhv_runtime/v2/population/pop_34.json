[
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that combines adaptive route clustering based on spatial and demand proximity, a demand-balanced route reshaping operator, and probabilistic route inversion, while ensuring feasibility through continuous capacity validation and repair. It prioritizes solutions with balanced objective trade-offs by selecting from the top half of the archive, and applies novel transformations to explore alternative configurations while maintaining vehicle capacity constraints. The key design ideas are the spatial-demand-aware route merging, segment-based demand balancing, and probabilistic route inversion, all integrated within a feasibility-preserving framework.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 2:\n        candidates = archive_sorted[:len(archive)//2]\n        base_solution = random.choice(candidates)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route clustering based on spatial and demand proximity\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Group routes by spatial proximity and demand similarity\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = np.sum(demand[route[1:-1]])\n                route_centroids.append((centroid, total_demand))\n\n        # Find closest route pairs\n        closest_pairs = []\n        for i in range(len(route_centroids)):\n            for j in range(i+1, len(route_centroids)):\n                dist = np.linalg.norm(route_centroids[i][0] - route_centroids[j][0])\n                demand_diff = abs(route_centroids[i][1] - route_centroids[j][1])\n                closest_pairs.append((dist + demand_diff, i, j))\n\n        if closest_pairs:\n            closest_pairs.sort()\n            # Select top 3 closest pairs\n            for _, i, j in closest_pairs[:min(3, len(closest_pairs))]:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                # Try to merge if capacity allows\n                if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                    # Find optimal merge point\n                    min_dist = float('inf')\n                    best_i, best_j = 0, 0\n                    for a in range(1, len(route_i)-1):\n                        for b in range(1, len(route_j)-1):\n                            dist = distance_matrix[route_i[a]][route_j[b]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_i, best_j = a, b\n\n                    merged_route = np.concatenate([\n                        route_i[:best_i+1],\n                        route_j[best_j:-1],\n                        route_i[-1:]\n                    ])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    # Demand-balanced route reshaping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Find segments with demand imbalance\n            total_route_demand = np.sum(demand[route[1:-1]])\n            target_demand = total_route_demand / (len(route)-2)\n\n            # Find the most imbalanced segment\n            max_diff = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                segment_demand = np.sum(demand[route[1:i]])\n                diff = abs(segment_demand - target_demand * (i-1))\n                if diff > max_diff:\n                    max_diff = diff\n                    split_pos = i\n\n            if split_pos > 1 and split_pos < len(route)-2:\n                # Try to split and balance\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                # Check capacity constraints\n                if (np.sum(demand[segment1[1:-1]]) <= capacity and\n                    np.sum(demand[segment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Probabilistic route inversion\n    if random.random() < 0.3:\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 5:\n                # Select a random segment to invert\n                start = random.randint(1, len(route)-3)\n                end = random.randint(start+1, len(route)-2)\n\n                # Check capacity constraint\n                if np.sum(demand[route[start:end]]) == np.sum(demand[route[start:end][::-1]]):\n                    new_route = np.concatenate([\n                        route[:start],\n                        route[start:end][::-1],\n                        route[end:]\n                    ])\n                    new_solution[route_idx] = new_route\n\n    # Capacity validation and repair\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If route is over capacity, try to split it\n            cumulative_demand = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > capacity:\n                    split_pos = i\n                    break\n\n            if split_pos > 1:\n                # Perform split\n                route1 = np.concatenate([route[:split_pos], [0]])\n                route2 = np.concatenate([[0], route[split_pos:]])\n                # Replace the over-capacity route\n                for i in range(len(new_solution)):\n                    if np.array_equal(new_solution[i], route):\n                        new_solution[i] = route1\n                        new_solution.insert(i+1, route2)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8304065435505548,
            0.2735443413257599
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto scoring with a hybrid local search strategy that prioritizes demand-balanced route merging while probabilistically applying route inversion to improve both distance and makespan objectives, all while maintaining feasibility through capacity-aware operations. It first selects promising solutions based on normalized objective trade-offs, then applies dynamic route reshaping (inversion and merging) to balance objectives, with special attention to spatially close and demand-complementary routes. The algorithm emphasizes capacity constraints through rigorous checks during route modifications and splitting.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_pareto_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_pareto_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Dynamic Pareto-aware route inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.5:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n            if is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Adaptive demand-centric clustering\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                route_centroids.append(centroid)\n\n        if len(route_centroids) > 1:\n            closest_pairs = []\n            for i in range(len(route_centroids)):\n                for j in range(i+1, len(route_centroids)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demands[i] - route_demands[j])\n                    closest_pairs.append((dist + 0.3*demand_diff, i, j))\n\n            if closest_pairs:\n                closest_pairs.sort()\n                for _, i, j in closest_pairs[:min(2, len(closest_pairs))]:\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                        min_dist = float('inf')\n                        best_i, best_j = 0, 0\n                        for a in range(1, len(route_i)-1):\n                            for b in range(1, len(route_j)-1):\n                                dist = distance_matrix[route_i[a]][route_j[b]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_i, best_j = a, b\n                        merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    # Capacity-aware route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and sum(demand[route[1:-1]]) > 0.8 * capacity:\n            split_pos = random.randint(2, len(route)-3)\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n            if is_feasible(segment1) and is_feasible(segment2):\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8680926223332354,
            0.32213422656059265
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive using an oscillating weighting scheme between distance and makespan, then applies a hybrid local search combining route balancing (splitting high-demand routes), probabilistic segment swapping (exchanging route segments), and spatial-demand-aware insertion (placing customers based on proximity and demand compatibility), all while ensuring feasibility through capacity checks. The weighting oscillates between prioritizing distance (30-60%) and makespan (40-70%) based on archive size, and the local search operators are applied probabilistically to explore diverse improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def dynamic_weighting(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.3 + 0.3 * (np.sin(len(archive) / 15) + 1)  # Oscillating weight between 0.3 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(dynamic_weighting(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Route balancing with demand threshold\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            total_demand = sum(demand[route[1:-1]])\n            threshold = capacity * 0.6\n            if total_demand > threshold:\n                best_split = None\n                min_diff = float('inf')\n                for i in range(2, len(route)-2):\n                    segment_demand = sum(demand[route[1:i]])\n                    remaining_demand = total_demand - segment_demand\n                    current_diff = abs(segment_demand - remaining_demand)\n                    if current_diff < min_diff:\n                        min_diff = current_diff\n                        best_split = i\n                if best_split and min_diff < capacity * 0.2:\n                    segment1 = route[:best_split+1]\n                    segment2 = np.concatenate([[0], route[best_split+1:]])\n                    if is_feasible(segment1) and is_feasible(segment2):\n                        new_solution[route_idx] = segment1\n                        new_solution.insert(route_idx+1, segment2)\n                        break\n\n    # Probabilistic segment swapping\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n        if len(route1) > 3 and len(route2) > 3:\n            start1 = random.randint(1, len(route1)-2)\n            end1 = random.randint(start1, len(route1)-1)\n            start2 = random.randint(1, len(route2)-2)\n            end2 = random.randint(start2, len(route2)-1)\n            swapped_route1 = np.concatenate([route1[:start1], route2[start2:end2], route1[end1:]])\n            swapped_route2 = np.concatenate([route2[:start2], route1[start1:end1], route2[end2:]])\n            if is_feasible(swapped_route1) and is_feasible(swapped_route2):\n                new_solution[route1_idx] = swapped_route1\n                new_solution[route2_idx] = swapped_route2\n\n    # Spatial-demand-aware insertion\n    if random.random() < 0.5:\n        unassigned = set(range(1, len(demand))) - set(np.concatenate([route[1:-1] for route in new_solution]))\n        if unassigned:\n            customer = random.choice(list(unassigned))\n            best_route = None\n            best_cost = float('inf')\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n                for i in range(len(route)-1):\n                    cost = (distance_matrix[route[i]][customer] +\n                           distance_matrix[customer][route[i+1]] -\n                           distance_matrix[route[i]][route[i+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = (route_idx, i)\n            if best_route:\n                route_idx, insert_pos = best_route\n                new_route = np.concatenate([\n                    new_solution[route_idx][:insert_pos+1],\n                    [customer],\n                    new_solution[route_idx][insert_pos+1:]\n                ])\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7668509365902616,
            0.13662391901016235
        ]
    },
    {
        "algorithm": "The algorithm implements a novel hybrid local search strategy that combines adaptive spatial-demand clustering with probabilistic route inversion and segment swapping, while dynamically balancing distance and makespan objectives through an oscillating weighting scheme and ensuring feasibility through capacity-aware route modifications and splitting. It prioritizes solutions with better normalized objective scores, applies spatial clustering to merge similar routes, probabilistically inverts route segments, swaps segments between routes while maintaining capacity, and splits overloaded routes for better demand balance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def dynamic_weighting(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.3 + 0.3 * (np.sin(len(archive) / 10) + 1)  # Oscillating weight between 0.3 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(dynamic_weighting(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Adaptive spatial-demand clustering\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = sum(demand[route[1:-1]])\n                route_data.append((centroid, total_demand, route))\n\n        if len(route_data) > 1:\n            clusters = []\n            while len(route_data) > 0:\n                base = route_data.pop(0)\n                cluster = [base]\n                i = 0\n                while i < len(route_data):\n                    centroid, demand_val, _ = route_data[i]\n                    dist = np.linalg.norm(base[0] - centroid)\n                    demand_diff = abs(base[1] - demand_val)\n                    if dist < 1.2 * np.mean(distance_matrix) and demand_diff < 0.4 * capacity:\n                        cluster.append(route_data.pop(i))\n                    else:\n                        i += 1\n                clusters.append(cluster)\n\n            for cluster in clusters:\n                if len(cluster) > 1:\n                    for i in range(len(cluster)-1):\n                        for j in range(i+1, len(cluster)):\n                            route_i = cluster[i][2]\n                            route_j = cluster[j][2]\n                            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                                min_dist = float('inf')\n                                best_i, best_j = 0, 0\n                                for a in range(1, len(route_i)-1):\n                                    for b in range(1, len(route_j)-1):\n                                        dist = distance_matrix[route_i[a]][route_j[b]]\n                                        if dist < min_dist:\n                                            min_dist = dist\n                                            best_i, best_j = a, b\n                                merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                                new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                                new_solution.append(merged_route)\n                                break\n\n    # Probabilistic route inversion with capacity check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.4:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n            if is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Segment swapping with demand balance consideration\n    if len(new_solution) > 1 and random.random() < 0.6:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            seg_i_start = random.randint(1, len(route_i)-3)\n            seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n            seg_j_start = random.randint(1, len(route_j)-3)\n            seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n            demand_i = sum(demand[route_i[seg_i_start:seg_i_end]])\n            demand_j = sum(demand[route_j[seg_j_start:seg_j_end]])\n\n            if (sum(demand[route_i[1:-1]]) - demand_i + demand_j <= capacity and\n                sum(demand[route_j[1:-1]]) - demand_j + demand_i <= capacity):\n\n                new_route_i = np.concatenate([\n                    route_i[:seg_i_start],\n                    route_j[seg_j_start:seg_j_end],\n                    route_i[seg_i_end:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:seg_j_start],\n                    route_i[seg_i_start:seg_i_end],\n                    route_j[seg_j_end:]\n                ])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Capacity-aware route splitting with demand balancing\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and sum(demand[route[1:-1]]) > 0.7 * capacity:\n            total_demand = sum(demand[route[1:-1]])\n            best_split = None\n            min_diff = float('inf')\n            for i in range(2, len(route)-2):\n                segment_demand = sum(demand[route[1:i]])\n                remaining_demand = total_demand - segment_demand\n                current_diff = abs(segment_demand - remaining_demand)\n                if current_diff < min_diff:\n                    min_diff = current_diff\n                    best_split = i\n            if best_split and min_diff < capacity * 0.3:\n                segment1 = route[:best_split+1]\n                segment2 = np.concatenate([[0], route[best_split+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8857202748740283,
            0.3450027406215668
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that adaptively balances distance and makespan objectives through a dynamic weighting scheme, combining demand-balanced route splitting, probabilistic segment swapping with spatial consideration, and spatial-demand-aware customer reinsertion while maintaining feasibility through continuous capacity validation. It prioritizes solutions with lower normalized objective values, particularly focusing on route segments with high demand imbalance, spatial proximity, and insertion points that minimize additional travel distance. The approach oscillates between emphasizing distance and makespan objectives through a time-varying weight, with higher probabilities for more disruptive operations when solution quality plateaus.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def adaptive_weighting(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.4 + 0.2 * (np.sin(len(archive) / 12) + 1)  # Oscillating weight between 0.4 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighting(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.35 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Adaptive demand-balanced route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            total_demand = sum(demand[route[1:-1]])\n            threshold = capacity * 0.65\n            if total_demand > threshold:\n                best_split = None\n                min_diff = float('inf')\n                for i in range(2, len(route)-2):\n                    segment_demand = sum(demand[route[1:i]])\n                    remaining_demand = total_demand - segment_demand\n                    current_diff = abs(segment_demand - remaining_demand)\n                    if current_diff < min_diff:\n                        min_diff = current_diff\n                        best_split = i\n                if best_split and min_diff < capacity * 0.25:\n                    segment1 = route[:best_split+1]\n                    segment2 = np.concatenate([[0], route[best_split+1:]])\n                    if is_feasible(segment1) and is_feasible(segment2):\n                        new_solution[route_idx] = segment1\n                        new_solution.insert(route_idx+1, segment2)\n                        break\n\n    # Probabilistic segment swapping with spatial consideration\n    if len(new_solution) > 1 and random.random() < 0.55:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            seg_i_start = random.randint(1, len(route_i)-3)\n            seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n            seg_j_start = random.randint(1, len(route_j)-3)\n            seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n            demand_i = sum(demand[route_i[seg_i_start:seg_i_end]])\n            demand_j = sum(demand[route_j[seg_j_start:seg_j_end]])\n\n            # Check spatial proximity\n            centroid_i = np.mean(coords[route_i[seg_i_start:seg_i_end]], axis=0)\n            centroid_j = np.mean(coords[route_j[seg_j_start:seg_j_end]], axis=0)\n            spatial_dist = np.linalg.norm(centroid_i - centroid_j)\n\n            if (sum(demand[route_i[1:-1]]) - demand_i + demand_j <= capacity and\n                sum(demand[route_j[1:-1]]) - demand_j + demand_i <= capacity and\n                spatial_dist < 1.5 * np.mean(distance_matrix)):\n\n                new_route_i = np.concatenate([\n                    route_i[:seg_i_start],\n                    route_j[seg_j_start:seg_j_end],\n                    route_i[seg_i_end:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:seg_j_start],\n                    route_i[seg_i_start:seg_i_end],\n                    route_j[seg_j_end:]\n                ])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Spatial-demand-aware customer reinsertion\n    if random.random() < 0.45:\n        unassigned = set(range(1, len(demand))) - set(np.concatenate([route[1:-1] for route in new_solution]))\n        if unassigned:\n            for customer in unassigned:\n                best_route = None\n                best_cost = float('inf')\n                best_demand = sum(demand)\n\n                for route_idx in range(len(new_solution)):\n                    route = new_solution[route_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    if current_demand + demand[customer] > capacity:\n                        continue\n\n                    # Find best insertion point\n                    for i in range(len(route)-1):\n                        cost = (distance_matrix[route[i]][customer] +\n                               distance_matrix[customer][route[i+1]] -\n                               distance_matrix[route[i]][route[i+1]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = (route_idx, i)\n                            best_demand = current_demand\n\n                if best_route:\n                    route_idx, insert_pos = best_route\n                    new_route = np.concatenate([\n                        new_solution[route_idx][:insert_pos+1],\n                        [customer],\n                        new_solution[route_idx][insert_pos+1:]\n                    ])\n                    new_solution[route_idx] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8297435914532563,
            0.1521044373512268
        ]
    },
    {
        "algorithm": "This algorithm implements an adaptive multi-objective local search that combines demand-aware route merging, probabilistic spatial inversion, and dynamic capacity-balancing segment swaps, while using a time-varying objective weighting scheme to prioritize solutions with balanced trade-offs between total distance and makespan, and maintains feasibility through capacity-constrained route modifications and demand-sensitive splitting. The algorithm selects promising solutions from the archive based on an adaptive weighting scheme that oscillates between prioritizing distance and makespan, then applies a series of specialized operators to improve the solution while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def adaptive_weighting(solution, objectives, iteration):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        phase = np.sin(iteration / 20) * 0.5 + 0.5  # Smooth phase between 0 and 1\n        weight = 0.4 * phase + 0.2  # Weight oscillates between 0.2 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    iteration = len(archive)\n    scored_solutions = [(adaptive_weighting(sol, obj, iteration), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-aware route merging with spatial proximity\n    if len(new_solution) > 1 and random.random() < 0.4:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_demand = sum(demand[route[1:-1]])\n                route_centroid = np.mean(coords[route[1:-1]], axis=0)\n                route_data.append((route_centroid, route_demand, route))\n\n        if len(route_data) > 1:\n            for i in range(len(route_data)-1):\n                for j in range(i+1, len(route_data)):\n                    centroid_i, demand_i, route_i = route_data[i]\n                    centroid_j, demand_j, route_j = route_data[j]\n                    spatial_dist = np.linalg.norm(centroid_i - centroid_j)\n                    demand_ratio = min(demand_i, demand_j) / max(demand_i, demand_j)\n\n                    if spatial_dist < 1.5 * np.mean(distance_matrix) and demand_ratio > 0.6:\n                        if demand_i + demand_j <= capacity:\n                            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                            new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                            new_solution.append(merged_route)\n                            break\n\n    # Probabilistic spatial inversion with demand balance\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.3:\n            # Select a spatial segment for inversion\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            distances = np.linalg.norm(route_coords - centroid, axis=1)\n            farthest_idx = np.argmax(distances)\n            segment_start = max(1, farthest_idx - 1)\n            segment_end = min(len(route)-2, farthest_idx + 2)\n\n            inverted_segment = route[segment_start:segment_end][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end:]])\n            if is_feasible(new_route):\n                new_solution[route_idx] = new_route\n\n    # Dynamic capacity-balancing segment swaps\n    if len(new_solution) > 1 and random.random() < 0.5:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Find segments with balanced demand\n            demand_i = sum(demand[route_i[1:-1]])\n            demand_j = sum(demand[route_j[1:-1]])\n            target_demand = (demand_i + demand_j) / 2\n\n            best_i, best_j = None, None\n            min_diff = float('inf')\n\n            for a in range(1, len(route_i)-1):\n                for b in range(1, len(route_j)-1):\n                    seg_i_demand = sum(demand[route_i[1:a]])\n                    seg_j_demand = sum(demand[route_j[1:b]])\n                    new_demand_i = demand_i - seg_i_demand + seg_j_demand\n                    new_demand_j = demand_j - seg_j_demand + seg_i_demand\n\n                    if (new_demand_i <= capacity and new_demand_j <= capacity):\n                        current_diff = abs(new_demand_i - target_demand) + abs(new_demand_j - target_demand)\n                        if current_diff < min_diff:\n                            min_diff = current_diff\n                            best_i, best_j = a, b\n\n            if best_i is not None and best_j is not None:\n                new_route_i = np.concatenate([\n                    route_i[:best_i],\n                    route_j[best_j:-1],\n                    route_i[-1:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:best_j],\n                    route_i[best_i:-1],\n                    route_j[-1:]\n                ])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Demand-sensitive route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > 0.8 * capacity:\n                # Find split point that balances demand\n                best_split = None\n                min_diff = float('inf')\n\n                for i in range(2, len(route)-2):\n                    segment_demand = sum(demand[route[1:i]])\n                    remaining_demand = total_demand - segment_demand\n                    current_diff = abs(segment_demand - remaining_demand)\n                    if current_diff < min_diff:\n                        min_diff = current_diff\n                        best_split = i\n\n                if best_split and min_diff < capacity * 0.25:\n                    segment1 = route[:best_split+1]\n                    segment2 = np.concatenate([[0], route[best_split+1:]])\n                    if is_feasible(segment1) and is_feasible(segment2):\n                        new_solution[route_idx] = segment1\n                        new_solution.insert(route_idx+1, segment2)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.877543969183217,
            0.5999010503292084
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using an adaptive weighted scoring that balances distance and makespan, then applies a hybrid local search combining route merging, demand-aware customer reinsertion, and route splitting to generate feasible neighbor solutions, prioritizing distance reduction and makespan optimization with randomized selection and feasibility checks. The method emphasizes intelligent route transformations with adaptive weights and probabilistic operations to explore diverse neighborhoods while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.6 if random.random() < 0.5 else 0.4\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    for _ in range(2):\n        if len(new_solution) > 1 and random.random() < 0.4:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i, route_j = new_solution[i], new_solution[j]\n            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                min_dist = float('inf')\n                best_pair = (0, 0)\n                for a in range(1, len(route_i)):\n                    for b in range(1, len(route_j)):\n                        dist = distance_matrix[route_i[a]][route_j[b]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pair = (a, b)\n                merged_route = np.concatenate([route_i[:best_pair[0]+1], route_j[best_pair[1]:-1], route_i[-1:]])\n                new_solution = [route for idx, route in enumerate(new_solution) if idx not in [i, j]] + [merged_route]\n                break\n\n    for _ in range(3):\n        if len(new_solution) > 1 and random.random() < 0.6:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route_i, route_j = new_solution[i], new_solution[j]\n            if len(route_i) > 3:\n                customer_pos = random.randint(1, len(route_i)-2)\n                customer = route_i[customer_pos]\n                if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                    min_cost = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(route_j)):\n                        cost = (distance_matrix[route_j[pos-1]][customer] +\n                               distance_matrix[customer][route_j[pos]] -\n                               distance_matrix[route_j[pos-1]][route_j[pos]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n                    new_route_i = np.concatenate([route_i[:customer_pos], route_i[customer_pos+1:]])\n                    new_route_j = np.concatenate([route_j[:best_pos], [customer], route_j[best_pos:]])\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n\n    for _ in range(2):\n        if len(new_solution) > 1 and random.random() < 0.3:\n            i = random.randint(0, len(new_solution)-1)\n            route = new_solution[i]\n            if len(route) > 5:\n                split_pos = random.randint(2, len(route)-3)\n                if sum(demand[route[1:split_pos]]) <= capacity and sum(demand[route[split_pos:-1]]) <= capacity:\n                    new_route1 = np.concatenate([route[:split_pos], [0]])\n                    new_route2 = np.concatenate([[0], route[split_pos:]])\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.4700528493331201,
            0.18445441126823425
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects solutions from the archive using a dynamic weighted scoring that prioritizes makespan reduction, then applies a hybrid local search combining demand-aware route splitting, probabilistic segment relocation, spatial-balanced route merging, and adaptive route segment transfer to improve both total distance and makespan while maintaining feasibility. It emphasizes makespan reduction by focusing on longer routes and uses spatial information to guide merging operations, with probabilistic operators to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.3 + 0.4 * (random.random() - 0.5)  # Emphasize makespan more\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-aware route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.5:\n            max_demand = max(demand[route[1:-1]])\n            split_pos = np.where(demand[route[1:-1]] == max_demand)[0][0] + 1\n            if split_pos > 1 and split_pos < len(route)-2:\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Probabilistic segment relocation\n    if len(new_solution) > 1 and random.random() < 0.6:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3:\n            seg_start = random.randint(1, len(route_i)-3)\n            seg_end = random.randint(seg_start, len(route_i)-2)\n            segment = route_i[seg_start:seg_end]\n\n            if sum(demand[segment]) + sum(demand[route_j[1:-1]]) <= capacity:\n                new_route_i = np.concatenate([route_i[:seg_start], route_i[seg_end:]])\n                new_route_j = np.concatenate([route_j[:1], segment, route_j[1:]])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Spatial-balanced route merging\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                route_data.append((centroid, route))\n\n        if len(route_data) > 1:\n            closest_pair = None\n            min_dist = float('inf')\n            for i in range(len(route_data)):\n                for j in range(i+1, len(route_data)):\n                    dist = np.linalg.norm(route_data[i][0] - route_data[j][0])\n                    if dist < min_dist:\n                        min_dist = dist\n                        closest_pair = (i, j)\n\n            if closest_pair:\n                i, j = closest_pair\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                    new_solution = [r for k, r in enumerate(new_solution) if k not in [i, j]]\n                    new_solution.append(merged_route)\n\n    # Adaptive route segment transfer\n    if len(new_solution) > 1 and random.random() < 0.7:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Transfer from longer to shorter route\n            if len(route_i) > len(route_j):\n                source, target = route_i, route_j\n            else:\n                source, target = route_j, route_i\n\n            seg_start = random.randint(1, len(source)-3)\n            seg_end = random.randint(seg_start, len(source)-2)\n            segment = source[seg_start:seg_end]\n\n            if (sum(demand[segment]) + sum(demand[target[1:-1]]) <= capacity and\n                sum(demand[source[1:seg_start]] + sum(demand[source[seg_end:-1]])) <= capacity):\n                new_source = np.concatenate([source[:seg_start], source[seg_end:]])\n                new_target = np.concatenate([target[:1], segment, target[1:]])\n\n                if is_feasible(new_source) and is_feasible(new_target):\n                    if len(route_i) > len(route_j):\n                        new_solution[i] = new_source\n                        new_solution[j] = new_target\n                    else:\n                        new_solution[j] = new_source\n                        new_solution[i] = new_target\n\n    return new_solution\n\n",
        "score": [
            -0.7075712107134143,
            0.2411479353904724
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive demand-aware clustering with probabilistic spatial inversion and capacity-balanced route merging, using dynamic multi-objective scoring to prioritize Pareto-efficient regions while ensuring feasibility through iterative spatial and demand checks. It selectively applies route splitting, merging, and reshaping operators with time-varying weights, balancing distance and makespan improvements by leveraging spatial proximity and demand patterns while maintaining solution feasibility. The method dynamically adjusts weights between objectives and probabilistically applies transformations to explore diverse neighborhoods in the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def dynamic_pareto_score(solution, objectives, iteration):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.3 + 0.4 * (iteration % 100) / 100.0  # Time-varying weight\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    iteration = len(archive)\n    scored_solutions = [(dynamic_pareto_score(sol, obj, iteration), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.2 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-clustered route splitting with spatial inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.6:\n            # Cluster customers by demand\n            demands = demand[route[1:-1]]\n            clusters = np.unique(np.digitize(demands, np.percentile(demands, [33, 66])))\n            if len(clusters) > 1:\n                # Split at cluster boundary\n                split_pos = np.where(np.diff(clusters) != 0)[0][0] + 1\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    # Invert one segment probabilistically\n                    if random.random() < 0.5:\n                        segment2 = np.concatenate([[0], segment2[-2:0:-1], segment2[-1:]])\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Capacity-balanced route merging with spatial inversion\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_stats = []\n        for route in new_solution:\n            if len(route) > 2:\n                total_demand = sum(demand[route[1:-1]])\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                route_stats.append((centroid, total_demand, route))\n\n        if len(route_stats) > 1:\n            # Find closest routes with demand balance\n            closest_pairs = []\n            for i in range(len(route_stats)):\n                for j in range(i+1, len(route_stats)):\n                    dist = np.linalg.norm(route_stats[i][0] - route_stats[j][0])\n                    demand_diff = abs(route_stats[i][1] - route_stats[j][1])\n                    closest_pairs.append((dist + 0.2*demand_diff, i, j))\n            if closest_pairs:\n                closest_pairs.sort()\n                for _, i, j in closest_pairs[:min(2, len(closest_pairs))]:\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    combined_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n                    if combined_demand <= capacity:\n                        # Merge with spatial inversion\n                        if random.random() < 0.4:\n                            route_i = np.concatenate([route_i[:1], route_i[-2:0:-1], route_i[-1:]])\n                        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                        if is_feasible(merged_route):\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Probabilistic route reshaping with demand balance\n    if len(new_solution) > 1 and random.random() < 0.7:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Transfer demand-balanced segments\n            demands_i = demand[route_i[1:-1]]\n            demands_j = demand[route_j[1:-1]]\n            mean_demand_i = np.mean(demands_i)\n            mean_demand_j = np.mean(demands_j)\n\n            if mean_demand_i > mean_demand_j:\n                # Transfer smaller demand customers from route_i to route_j\n                small_customers = np.where(demands_i < mean_demand_i)[0]\n                if len(small_customers) > 0:\n                    transfer_pos = random.choice(small_customers) + 1\n                    customer = route_i[transfer_pos]\n                    if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                        new_route_i = np.concatenate([route_i[:transfer_pos], route_i[transfer_pos+1:]])\n                        new_route_j = np.concatenate([route_j[:1], [customer], route_j[1:]])\n                        if is_feasible(new_route_i) and is_feasible(new_route_j):\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n            else:\n                # Transfer larger demand customers from route_j to route_i\n                large_customers = np.where(demands_j > mean_demand_j)[0]\n                if len(large_customers) > 0:\n                    transfer_pos = random.choice(large_customers) + 1\n                    customer = route_j[transfer_pos]\n                    if sum(demand[route_i[1:-1]]) + demand[customer] <= capacity:\n                        new_route_j = np.concatenate([route_j[:transfer_pos], route_j[transfer_pos+1:]])\n                        new_route_i = np.concatenate([route_i[:1], [customer], route_i[1:]])\n                        if is_feasible(new_route_i) and is_feasible(new_route_j):\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.847536365529037,
            0.3441774249076843
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects promising solutions from an archive using a dynamic weighted scoring that balances distance and makespan objectives, then applies a hybrid local search combining spatial-demand-aware clustering, probabilistic route inversion with capacity checks, demand-balanced route reshaping, and a novel route segment swapping operator to improve solution quality while maintaining feasibility. The selection prioritizes solutions with better normalized objective values, while the local search operators focus on spatial proximity, demand balance, and segment swaps to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighted_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.2 * (random.random() - 0.5)\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Spatial-demand-aware clustering\n    if len(new_solution) > 1 and random.random() < 0.4:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = sum(demand[route[1:-1]])\n                route_data.append((centroid, total_demand, route))\n\n        if len(route_data) > 1:\n            clusters = []\n            while len(route_data) > 0:\n                base = route_data.pop(0)\n                cluster = [base]\n                i = 0\n                while i < len(route_data):\n                    centroid, demand_val, _ = route_data[i]\n                    dist = np.linalg.norm(base[0] - centroid)\n                    demand_diff = abs(base[1] - demand_val)\n                    if dist < 1.5 * np.mean(distance_matrix) and demand_diff < 0.3 * capacity:\n                        cluster.append(route_data.pop(i))\n                    else:\n                        i += 1\n                clusters.append(cluster)\n\n            for cluster in clusters:\n                if len(cluster) > 1:\n                    for i in range(len(cluster)-1):\n                        for j in range(i+1, len(cluster)):\n                            route_i = cluster[i][2]\n                            route_j = cluster[j][2]\n                            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                                min_dist = float('inf')\n                                best_i, best_j = 0, 0\n                                for a in range(1, len(route_i)-1):\n                                    for b in range(1, len(route_j)-1):\n                                        dist = distance_matrix[route_i[a]][route_j[b]]\n                                        if dist < min_dist:\n                                            min_dist = dist\n                                            best_i, best_j = a, b\n                                merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                                new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                                new_solution.append(merged_route)\n                                break\n\n    # Probabilistic route inversion with capacity check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.3:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            if is_feasible(np.concatenate([route[:start], route[start:end][::-1], route[end:]])):\n                new_route = np.concatenate([route[:start], route[start:end][::-1], route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Demand-balanced route reshaping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            total_route_demand = sum(demand[route[1:-1]])\n            target_demand = total_route_demand / (len(route)-2)\n            max_diff = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                segment_demand = sum(demand[route[1:i]])\n                diff = abs(segment_demand - target_demand * (i-1))\n                if diff > max_diff:\n                    max_diff = diff\n                    split_pos = i\n            if split_pos > 1 and split_pos < len(route)-2:\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Novel route segment swapping operator\n    if len(new_solution) > 1 and random.random() < 0.5:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Select random segments from each route\n            seg_i_start = random.randint(1, len(route_i)-3)\n            seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n            seg_j_start = random.randint(1, len(route_j)-3)\n            seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n            # Check capacity constraints\n            if (sum(demand[route_i[seg_i_start:seg_i_end]]) + sum(demand[route_j[1:-1]]) <= capacity and\n                sum(demand[route_j[seg_j_start:seg_j_end]]) + sum(demand[route_i[1:-1]]) <= capacity):\n                # Perform the swap\n                new_route_i = np.concatenate([\n                    route_i[:seg_i_start],\n                    route_j[seg_j_start:seg_j_end],\n                    route_i[seg_i_end:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:seg_j_start],\n                    route_i[seg_i_start:seg_i_end],\n                    route_j[seg_j_end:]\n                ])\n\n                # Update solution\n                new_solution[i] = new_route_i\n                new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.8022699717026534,
            0.2725068926811218
        ]
    }
]