[
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that combines adaptive route clustering based on spatial and demand proximity, a demand-balanced route reshaping operator, and probabilistic route inversion, while ensuring feasibility through continuous capacity validation and repair. It prioritizes solutions with balanced objective trade-offs by selecting from the top half of the archive, and applies novel transformations to explore alternative configurations while maintaining vehicle capacity constraints. The key design ideas are the spatial-demand-aware route merging, segment-based demand balancing, and probabilistic route inversion, all integrated within a feasibility-preserving framework.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 2:\n        candidates = archive_sorted[:len(archive)//2]\n        base_solution = random.choice(candidates)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route clustering based on spatial and demand proximity\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Group routes by spatial proximity and demand similarity\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = np.sum(demand[route[1:-1]])\n                route_centroids.append((centroid, total_demand))\n\n        # Find closest route pairs\n        closest_pairs = []\n        for i in range(len(route_centroids)):\n            for j in range(i+1, len(route_centroids)):\n                dist = np.linalg.norm(route_centroids[i][0] - route_centroids[j][0])\n                demand_diff = abs(route_centroids[i][1] - route_centroids[j][1])\n                closest_pairs.append((dist + demand_diff, i, j))\n\n        if closest_pairs:\n            closest_pairs.sort()\n            # Select top 3 closest pairs\n            for _, i, j in closest_pairs[:min(3, len(closest_pairs))]:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                # Try to merge if capacity allows\n                if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                    # Find optimal merge point\n                    min_dist = float('inf')\n                    best_i, best_j = 0, 0\n                    for a in range(1, len(route_i)-1):\n                        for b in range(1, len(route_j)-1):\n                            dist = distance_matrix[route_i[a]][route_j[b]]\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_i, best_j = a, b\n\n                    merged_route = np.concatenate([\n                        route_i[:best_i+1],\n                        route_j[best_j:-1],\n                        route_i[-1:]\n                    ])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    break\n\n    # Demand-balanced route reshaping\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Find segments with demand imbalance\n            total_route_demand = np.sum(demand[route[1:-1]])\n            target_demand = total_route_demand / (len(route)-2)\n\n            # Find the most imbalanced segment\n            max_diff = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                segment_demand = np.sum(demand[route[1:i]])\n                diff = abs(segment_demand - target_demand * (i-1))\n                if diff > max_diff:\n                    max_diff = diff\n                    split_pos = i\n\n            if split_pos > 1 and split_pos < len(route)-2:\n                # Try to split and balance\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n                # Check capacity constraints\n                if (np.sum(demand[segment1[1:-1]]) <= capacity and\n                    np.sum(demand[segment2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Probabilistic route inversion\n    if random.random() < 0.3:\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 5:\n                # Select a random segment to invert\n                start = random.randint(1, len(route)-3)\n                end = random.randint(start+1, len(route)-2)\n\n                # Check capacity constraint\n                if np.sum(demand[route[start:end]]) == np.sum(demand[route[start:end][::-1]]):\n                    new_route = np.concatenate([\n                        route[:start],\n                        route[start:end][::-1],\n                        route[end:]\n                    ])\n                    new_solution[route_idx] = new_route\n\n    # Capacity validation and repair\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If route is over capacity, try to split it\n            cumulative_demand = 0\n            split_pos = -1\n            for i in range(1, len(route)-1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > capacity:\n                    split_pos = i\n                    break\n\n            if split_pos > 1:\n                # Perform split\n                route1 = np.concatenate([route[:split_pos], [0]])\n                route2 = np.concatenate([[0], route[split_pos:]])\n                # Replace the over-capacity route\n                for i in range(len(new_solution)):\n                    if np.array_equal(new_solution[i], route):\n                        new_solution[i] = route1\n                        new_solution.insert(i+1, route2)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8304065435505548,
            0.2735443413257599
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto scoring with a hybrid local search strategy that prioritizes demand-balanced route merging while probabilistically applying route inversion to improve both distance and makespan objectives, all while maintaining feasibility through capacity-aware operations. It first selects promising solutions based on normalized objective trade-offs, then applies dynamic route reshaping (inversion and merging) to balance objectives, with special attention to spatially close and demand-complementary routes. The algorithm emphasizes capacity constraints through rigorous checks during route modifications and splitting.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_pareto_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_pareto_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Dynamic Pareto-aware route inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.5:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n            if is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Adaptive demand-centric clustering\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                route_centroids.append(centroid)\n\n        if len(route_centroids) > 1:\n            closest_pairs = []\n            for i in range(len(route_centroids)):\n                for j in range(i+1, len(route_centroids)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_diff = abs(route_demands[i] - route_demands[j])\n                    closest_pairs.append((dist + 0.3*demand_diff, i, j))\n\n            if closest_pairs:\n                closest_pairs.sort()\n                for _, i, j in closest_pairs[:min(2, len(closest_pairs))]:\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                        min_dist = float('inf')\n                        best_i, best_j = 0, 0\n                        for a in range(1, len(route_i)-1):\n                            for b in range(1, len(route_j)-1):\n                                dist = distance_matrix[route_i[a]][route_j[b]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_i, best_j = a, b\n                        merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    # Capacity-aware route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and sum(demand[route[1:-1]]) > 0.8 * capacity:\n            split_pos = random.randint(2, len(route)-3)\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n            if is_feasible(segment1) and is_feasible(segment2):\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8680926223332354,
            0.32213422656059265
        ]
    },
    {
        "algorithm": "The algorithm implements a novel hybrid local search strategy that combines adaptive spatial-demand clustering with probabilistic route inversion and segment swapping, while dynamically balancing distance and makespan objectives through an oscillating weighting scheme and ensuring feasibility through capacity-aware route modifications and splitting. It prioritizes solutions with better normalized objective scores, applies spatial clustering to merge similar routes, probabilistically inverts route segments, swaps segments between routes while maintaining capacity, and splits overloaded routes for better demand balance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def dynamic_weighting(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.3 + 0.3 * (np.sin(len(archive) / 10) + 1)  # Oscillating weight between 0.3 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(dynamic_weighting(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Adaptive spatial-demand clustering\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                total_demand = sum(demand[route[1:-1]])\n                route_data.append((centroid, total_demand, route))\n\n        if len(route_data) > 1:\n            clusters = []\n            while len(route_data) > 0:\n                base = route_data.pop(0)\n                cluster = [base]\n                i = 0\n                while i < len(route_data):\n                    centroid, demand_val, _ = route_data[i]\n                    dist = np.linalg.norm(base[0] - centroid)\n                    demand_diff = abs(base[1] - demand_val)\n                    if dist < 1.2 * np.mean(distance_matrix) and demand_diff < 0.4 * capacity:\n                        cluster.append(route_data.pop(i))\n                    else:\n                        i += 1\n                clusters.append(cluster)\n\n            for cluster in clusters:\n                if len(cluster) > 1:\n                    for i in range(len(cluster)-1):\n                        for j in range(i+1, len(cluster)):\n                            route_i = cluster[i][2]\n                            route_j = cluster[j][2]\n                            if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                                min_dist = float('inf')\n                                best_i, best_j = 0, 0\n                                for a in range(1, len(route_i)-1):\n                                    for b in range(1, len(route_j)-1):\n                                        dist = distance_matrix[route_i[a]][route_j[b]]\n                                        if dist < min_dist:\n                                            min_dist = dist\n                                            best_i, best_j = a, b\n                                merged_route = np.concatenate([route_i[:best_i+1], route_j[best_j:-1], route_i[-1:]])\n                                new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                                new_solution.append(merged_route)\n                                break\n\n    # Probabilistic route inversion with capacity check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.4:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n            if is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    # Segment swapping with demand balance consideration\n    if len(new_solution) > 1 and random.random() < 0.6:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            seg_i_start = random.randint(1, len(route_i)-3)\n            seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n            seg_j_start = random.randint(1, len(route_j)-3)\n            seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n            demand_i = sum(demand[route_i[seg_i_start:seg_i_end]])\n            demand_j = sum(demand[route_j[seg_j_start:seg_j_end]])\n\n            if (sum(demand[route_i[1:-1]]) - demand_i + demand_j <= capacity and\n                sum(demand[route_j[1:-1]]) - demand_j + demand_i <= capacity):\n\n                new_route_i = np.concatenate([\n                    route_i[:seg_i_start],\n                    route_j[seg_j_start:seg_j_end],\n                    route_i[seg_i_end:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:seg_j_start],\n                    route_i[seg_i_start:seg_i_end],\n                    route_j[seg_j_end:]\n                ])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Capacity-aware route splitting with demand balancing\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and sum(demand[route[1:-1]]) > 0.7 * capacity:\n            total_demand = sum(demand[route[1:-1]])\n            best_split = None\n            min_diff = float('inf')\n            for i in range(2, len(route)-2):\n                segment_demand = sum(demand[route[1:i]])\n                remaining_demand = total_demand - segment_demand\n                current_diff = abs(segment_demand - remaining_demand)\n                if current_diff < min_diff:\n                    min_diff = current_diff\n                    best_split = i\n            if best_split and min_diff < capacity * 0.3:\n                segment1 = route[:best_split+1]\n                segment2 = np.concatenate([[0], route[best_split+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8857202748740283,
            0.3450027406215668
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that adaptively balances distance and makespan objectives through a dynamic weighting scheme, combining demand-balanced route splitting, probabilistic segment swapping with spatial consideration, and spatial-demand-aware customer reinsertion while maintaining feasibility through continuous capacity validation. It prioritizes solutions with lower normalized objective values, particularly focusing on route segments with high demand imbalance, spatial proximity, and insertion points that minimize additional travel distance. The approach oscillates between emphasizing distance and makespan objectives through a time-varying weight, with higher probabilities for more disruptive operations when solution quality plateaus.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighting(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.4 + 0.2 * (np.sin(len(archive) / 12) + 1)  # Oscillating weight between 0.4 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    scored_solutions = [(adaptive_weighting(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.35 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Adaptive demand-balanced route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            total_demand = sum(demand[route[1:-1]])\n            threshold = capacity * 0.65\n            if total_demand > threshold:\n                best_split = None\n                min_diff = float('inf')\n                for i in range(2, len(route)-2):\n                    segment_demand = sum(demand[route[1:i]])\n                    remaining_demand = total_demand - segment_demand\n                    current_diff = abs(segment_demand - remaining_demand)\n                    if current_diff < min_diff:\n                        min_diff = current_diff\n                        best_split = i\n                if best_split and min_diff < capacity * 0.25:\n                    segment1 = route[:best_split+1]\n                    segment2 = np.concatenate([[0], route[best_split+1:]])\n                    if is_feasible(segment1) and is_feasible(segment2):\n                        new_solution[route_idx] = segment1\n                        new_solution.insert(route_idx+1, segment2)\n                        break\n\n    # Probabilistic segment swapping with spatial consideration\n    if len(new_solution) > 1 and random.random() < 0.55:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            seg_i_start = random.randint(1, len(route_i)-3)\n            seg_i_end = random.randint(seg_i_start, len(route_i)-2)\n            seg_j_start = random.randint(1, len(route_j)-3)\n            seg_j_end = random.randint(seg_j_start, len(route_j)-2)\n\n            demand_i = sum(demand[route_i[seg_i_start:seg_i_end]])\n            demand_j = sum(demand[route_j[seg_j_start:seg_j_end]])\n\n            # Check spatial proximity\n            centroid_i = np.mean(coords[route_i[seg_i_start:seg_i_end]], axis=0)\n            centroid_j = np.mean(coords[route_j[seg_j_start:seg_j_end]], axis=0)\n            spatial_dist = np.linalg.norm(centroid_i - centroid_j)\n\n            if (sum(demand[route_i[1:-1]]) - demand_i + demand_j <= capacity and\n                sum(demand[route_j[1:-1]]) - demand_j + demand_i <= capacity and\n                spatial_dist < 1.5 * np.mean(distance_matrix)):\n\n                new_route_i = np.concatenate([\n                    route_i[:seg_i_start],\n                    route_j[seg_j_start:seg_j_end],\n                    route_i[seg_i_end:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:seg_j_start],\n                    route_i[seg_i_start:seg_i_end],\n                    route_j[seg_j_end:]\n                ])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Spatial-demand-aware customer reinsertion\n    if random.random() < 0.45:\n        unassigned = set(range(1, len(demand))) - set(np.concatenate([route[1:-1] for route in new_solution]))\n        if unassigned:\n            for customer in unassigned:\n                best_route = None\n                best_cost = float('inf')\n                best_demand = sum(demand)\n\n                for route_idx in range(len(new_solution)):\n                    route = new_solution[route_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    if current_demand + demand[customer] > capacity:\n                        continue\n\n                    # Find best insertion point\n                    for i in range(len(route)-1):\n                        cost = (distance_matrix[route[i]][customer] +\n                               distance_matrix[customer][route[i+1]] -\n                               distance_matrix[route[i]][route[i+1]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = (route_idx, i)\n                            best_demand = current_demand\n\n                if best_route:\n                    route_idx, insert_pos = best_route\n                    new_route = np.concatenate([\n                        new_solution[route_idx][:insert_pos+1],\n                        [customer],\n                        new_solution[route_idx][insert_pos+1:]\n                    ])\n                    new_solution[route_idx] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8297435914532563,
            0.1521044373512268
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that combines adaptive demand-aware route splitting, spatial-proximity guided demand-balanced reinsertion, and dynamic capacity-balanced route reshaping, prioritizing solutions with balanced distance and makespan objectives while ensuring capacity feasibility. It intelligently selects promising solutions from the archive using an adaptive weighted scoring mechanism, then applies probabilistic route transformations to improve both objectives. The method dynamically balances exploration and exploitation through weighted selection and conditional probabilistic operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def adaptive_weighted_score(sol, obj):\n        total_dist, makespan = obj\n        max_dist = max(o[0] for _, o in archive)\n        max_makespan = max(o[1] for _, o in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-aware route splitting with probabilistic inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.6:\n            customers = route[1:-1]\n            demands = demand[customers]\n            supply = np.cumsum(demands)\n            target_supply = supply[-1] / 2\n\n            split_pos = np.argmin(np.abs(supply - target_supply)) + 1\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(segment1) and is_feasible(segment2):\n                if random.random() < 0.4:\n                    segment2 = np.concatenate([[0], segment2[-2:0:-1], segment2[-1:]])\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    # Spatial-proximity guided demand-balanced reinsertion\n    if len(new_solution) > 1 and random.random() < 0.7:\n        source_idx = random.randint(0, len(new_solution)-1)\n        target_idx = random.randint(0, len(new_solution)-1)\n        if source_idx != target_idx:\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                customer_pos = random.randint(1, len(source_route)-2)\n                customer = source_route[customer_pos]\n\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    best_pos = 1\n                    min_increase = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_target = np.concatenate([target_route[:pos], [customer], target_route[pos:]])\n                        dist_increase = (distance_matrix[target_route[pos-1]][customer] +\n                                        distance_matrix[customer][target_route[pos]] -\n                                        distance_matrix[target_route[pos-1]][target_route[pos]])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    new_target = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n\n                    if is_feasible(new_source) and is_feasible(new_target):\n                        new_solution[source_idx] = new_source\n                        new_solution[target_idx] = new_target\n\n    # Dynamic capacity-balanced route reshaping\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_stats = []\n        for route in new_solution:\n            if len(route) > 2:\n                total_demand = sum(demand[route[1:-1]])\n                route_stats.append((total_demand, route))\n\n        if len(route_stats) > 1:\n            route_stats.sort(key=lambda x: x[0])\n            for i in range(len(route_stats)-1):\n                j = len(route_stats)-1-i\n                if i >= j:\n                    break\n\n                route_i = route_stats[i][1]\n                route_j = route_stats[j][1]\n\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n\n                    if is_feasible(merged_route):\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8222700764257004,
            0.09269183874130249
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive demand-aware clustering with probabilistic spatial inversion and capacity-balanced route merging, using dynamic multi-objective scoring to prioritize Pareto-efficient regions while ensuring feasibility through iterative spatial and demand checks. It selectively applies route splitting, merging, and reshaping operators with time-varying weights, balancing distance and makespan improvements by leveraging spatial proximity and demand patterns while maintaining solution feasibility. The method dynamically adjusts weights between objectives and probabilistically applies transformations to explore diverse neighborhoods in the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def dynamic_pareto_score(solution, objectives, iteration):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.3 + 0.4 * (iteration % 100) / 100.0  # Time-varying weight\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    iteration = len(archive)\n    scored_solutions = [(dynamic_pareto_score(sol, obj, iteration), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.2 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-clustered route splitting with spatial inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.6:\n            # Cluster customers by demand\n            demands = demand[route[1:-1]]\n            clusters = np.unique(np.digitize(demands, np.percentile(demands, [33, 66])))\n            if len(clusters) > 1:\n                # Split at cluster boundary\n                split_pos = np.where(np.diff(clusters) != 0)[0][0] + 1\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    # Invert one segment probabilistically\n                    if random.random() < 0.5:\n                        segment2 = np.concatenate([[0], segment2[-2:0:-1], segment2[-1:]])\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Capacity-balanced route merging with spatial inversion\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_stats = []\n        for route in new_solution:\n            if len(route) > 2:\n                total_demand = sum(demand[route[1:-1]])\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                route_stats.append((centroid, total_demand, route))\n\n        if len(route_stats) > 1:\n            # Find closest routes with demand balance\n            closest_pairs = []\n            for i in range(len(route_stats)):\n                for j in range(i+1, len(route_stats)):\n                    dist = np.linalg.norm(route_stats[i][0] - route_stats[j][0])\n                    demand_diff = abs(route_stats[i][1] - route_stats[j][1])\n                    closest_pairs.append((dist + 0.2*demand_diff, i, j))\n            if closest_pairs:\n                closest_pairs.sort()\n                for _, i, j in closest_pairs[:min(2, len(closest_pairs))]:\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    combined_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n                    if combined_demand <= capacity:\n                        # Merge with spatial inversion\n                        if random.random() < 0.4:\n                            route_i = np.concatenate([route_i[:1], route_i[-2:0:-1], route_i[-1:]])\n                        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                        if is_feasible(merged_route):\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Probabilistic route reshaping with demand balance\n    if len(new_solution) > 1 and random.random() < 0.7:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Transfer demand-balanced segments\n            demands_i = demand[route_i[1:-1]]\n            demands_j = demand[route_j[1:-1]]\n            mean_demand_i = np.mean(demands_i)\n            mean_demand_j = np.mean(demands_j)\n\n            if mean_demand_i > mean_demand_j:\n                # Transfer smaller demand customers from route_i to route_j\n                small_customers = np.where(demands_i < mean_demand_i)[0]\n                if len(small_customers) > 0:\n                    transfer_pos = random.choice(small_customers) + 1\n                    customer = route_i[transfer_pos]\n                    if sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                        new_route_i = np.concatenate([route_i[:transfer_pos], route_i[transfer_pos+1:]])\n                        new_route_j = np.concatenate([route_j[:1], [customer], route_j[1:]])\n                        if is_feasible(new_route_i) and is_feasible(new_route_j):\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n            else:\n                # Transfer larger demand customers from route_j to route_i\n                large_customers = np.where(demands_j > mean_demand_j)[0]\n                if len(large_customers) > 0:\n                    transfer_pos = random.choice(large_customers) + 1\n                    customer = route_j[transfer_pos]\n                    if sum(demand[route_i[1:-1]]) + demand[customer] <= capacity:\n                        new_route_j = np.concatenate([route_j[:transfer_pos], route_j[transfer_pos+1:]])\n                        new_route_i = np.concatenate([route_i[:1], [customer], route_i[1:]])\n                        if is_feasible(new_route_i) and is_feasible(new_route_j):\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n\n    return new_solution\n\n",
        "score": [
            -0.847536365529037,
            0.3441774249076843
        ]
    },
    {
        "algorithm": "This algorithm implements an adaptive multi-objective local search that combines demand-aware route merging, probabilistic spatial inversion, and dynamic capacity-balancing segment swaps, while using a time-varying objective weighting scheme to prioritize solutions with balanced trade-offs between total distance and makespan, and maintains feasibility through capacity-constrained route modifications and demand-sensitive splitting. The algorithm selects promising solutions from the archive based on an adaptive weighting scheme that oscillates between prioritizing distance and makespan, then applies a series of specialized operators to improve the solution while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_weighting(solution, objectives, iteration):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        phase = np.sin(iteration / 20) * 0.5 + 0.5  # Smooth phase between 0 and 1\n        weight = 0.4 * phase + 0.2  # Weight oscillates between 0.2 and 0.6\n        return weight * norm_dist + (1 - weight) * norm_makespan\n\n    iteration = len(archive)\n    scored_solutions = [(adaptive_weighting(sol, obj, iteration), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-aware route merging with spatial proximity\n    if len(new_solution) > 1 and random.random() < 0.4:\n        route_data = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_demand = sum(demand[route[1:-1]])\n                route_centroid = np.mean(coords[route[1:-1]], axis=0)\n                route_data.append((route_centroid, route_demand, route))\n\n        if len(route_data) > 1:\n            for i in range(len(route_data)-1):\n                for j in range(i+1, len(route_data)):\n                    centroid_i, demand_i, route_i = route_data[i]\n                    centroid_j, demand_j, route_j = route_data[j]\n                    spatial_dist = np.linalg.norm(centroid_i - centroid_j)\n                    demand_ratio = min(demand_i, demand_j) / max(demand_i, demand_j)\n\n                    if spatial_dist < 1.5 * np.mean(distance_matrix) and demand_ratio > 0.6:\n                        if demand_i + demand_j <= capacity:\n                            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                            new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                            new_solution.append(merged_route)\n                            break\n\n    # Probabilistic spatial inversion with demand balance\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.3:\n            # Select a spatial segment for inversion\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            distances = np.linalg.norm(route_coords - centroid, axis=1)\n            farthest_idx = np.argmax(distances)\n            segment_start = max(1, farthest_idx - 1)\n            segment_end = min(len(route)-2, farthest_idx + 2)\n\n            inverted_segment = route[segment_start:segment_end][::-1]\n            new_route = np.concatenate([route[:segment_start], inverted_segment, route[segment_end:]])\n            if is_feasible(new_route):\n                new_solution[route_idx] = new_route\n\n    # Dynamic capacity-balancing segment swaps\n    if len(new_solution) > 1 and random.random() < 0.5:\n        i, j = random.sample(range(len(new_solution)), 2)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        if len(route_i) > 3 and len(route_j) > 3:\n            # Find segments with balanced demand\n            demand_i = sum(demand[route_i[1:-1]])\n            demand_j = sum(demand[route_j[1:-1]])\n            target_demand = (demand_i + demand_j) / 2\n\n            best_i, best_j = None, None\n            min_diff = float('inf')\n\n            for a in range(1, len(route_i)-1):\n                for b in range(1, len(route_j)-1):\n                    seg_i_demand = sum(demand[route_i[1:a]])\n                    seg_j_demand = sum(demand[route_j[1:b]])\n                    new_demand_i = demand_i - seg_i_demand + seg_j_demand\n                    new_demand_j = demand_j - seg_j_demand + seg_i_demand\n\n                    if (new_demand_i <= capacity and new_demand_j <= capacity):\n                        current_diff = abs(new_demand_i - target_demand) + abs(new_demand_j - target_demand)\n                        if current_diff < min_diff:\n                            min_diff = current_diff\n                            best_i, best_j = a, b\n\n            if best_i is not None and best_j is not None:\n                new_route_i = np.concatenate([\n                    route_i[:best_i],\n                    route_j[best_j:-1],\n                    route_i[-1:]\n                ])\n                new_route_j = np.concatenate([\n                    route_j[:best_j],\n                    route_i[best_i:-1],\n                    route_j[-1:]\n                ])\n\n                if is_feasible(new_route_i) and is_feasible(new_route_j):\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n\n    # Demand-sensitive route splitting\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > 0.8 * capacity:\n                # Find split point that balances demand\n                best_split = None\n                min_diff = float('inf')\n\n                for i in range(2, len(route)-2):\n                    segment_demand = sum(demand[route[1:i]])\n                    remaining_demand = total_demand - segment_demand\n                    current_diff = abs(segment_demand - remaining_demand)\n                    if current_diff < min_diff:\n                        min_diff = current_diff\n                        best_split = i\n\n                if best_split and min_diff < capacity * 0.25:\n                    segment1 = route[:best_split+1]\n                    segment2 = np.concatenate([[0], route[best_split+1:]])\n                    if is_feasible(segment1) and is_feasible(segment2):\n                        new_solution[route_idx] = segment1\n                        new_solution.insert(route_idx+1, segment2)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.877543969183217,
            0.5999010503292084
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive spatial-demand clustering with probabilistic route restructuring, selecting solutions based on normalized objective trade-off scores and applying novel transformations like demand-aware merging, capacity-balanced splitting, and spatially informed inversion while ensuring feasibility through continuous validation. It prioritizes Pareto-efficient regions by dynamically adjusting weights between distance and makespan objectives, with higher emphasis on makespan during selection (via adaptive_weight) and probabilistic application of transformations (merge, split, invert). Critical variables like spatial distance and demand differences guide route modifications, while feasibility checks maintain vehicle capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def calculate_spatial_demand_score(route1, route2):\n        score = 0\n        for i in range(1, len(route1)-1):\n            for j in range(1, len(route2)-1):\n                spatial_dist = distance_matrix[route1[i]][route2[j]]\n                demand_diff = abs(demand[route1[i]] - demand[route2[j]])\n                score += (1 / (spatial_dist + 1e-6)) * (1 / (demand_diff + 1e-6))\n        return score\n\n    def is_feasible(route):\n        return np.sum(demand[route[1:-1]]) <= capacity\n\n    def adaptive_weight():\n        return 0.3 + 0.7 * (random.random())\n\n    def normalized_objective_score(solution, objectives):\n        total_dist, makespan = objectives\n        max_dist = max(obj[0] for _, obj in archive)\n        max_makespan = max(obj[1] for _, obj in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = adaptive_weight()\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(normalized_objective_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                if np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]]) <= capacity:\n                    score = calculate_spatial_demand_score(route_i, route_j)\n                    route_pairs.append((score, i, j))\n\n        if route_pairs:\n            route_pairs.sort(reverse=True, key=lambda x: x[0])\n            for _, i, j in route_pairs[:min(3, len(route_pairs))]:\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                best_merge_point = None\n                best_score = -float('inf')\n                for a in range(1, len(route_i)-1):\n                    for b in range(1, len(route_j)-1):\n                        spatial_dist = distance_matrix[route_i[a]][route_j[b]]\n                        demand_match = 1 / (abs(demand[route_i[a]] - demand[route_j[b]]) + 1e-6)\n                        score = -spatial_dist * demand_match\n                        if score > best_score:\n                            best_score = score\n                            best_merge_point = (a, b)\n\n                if best_merge_point:\n                    a, b = best_merge_point\n                    merged_route = np.concatenate([route_i[:a+1], route_j[b:-1], route_i[-1:]])\n                    if is_feasible(merged_route):\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.5:\n            split_pos = random.randint(2, len(route)-3)\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(segment1) and is_feasible(segment2):\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.4:\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            inverted_segment = route[start:end][::-1]\n\n            spatial_center = np.mean(coords[route[start:end]], axis=0)\n            original_dist = np.sum([distance_matrix[route[i]][route[i+1]] for i in range(start, end-1)])\n            inverted_dist = np.sum([distance_matrix[inverted_segment[i]][inverted_segment[i+1]] for i in range(len(inverted_segment)-1)])\n\n            if inverted_dist < original_dist and is_feasible(np.concatenate([route[:start], inverted_segment, route[end:]])):\n                new_route = np.concatenate([route[:start], inverted_segment, route[end:]])\n                new_solution[route_idx] = new_route\n\n    for route in new_solution:\n        if not is_feasible(route):\n            for i in range(len(new_solution)):\n                if np.array_equal(new_solution[i], route):\n                    new_solution[i] = selected_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8496531653483852,
            0.3905726671218872
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive demand-supply clustering with probabilistic spatial inversion and dynamic capacity-balanced reshaping, prioritizing Pareto-optimal trade-offs between distance and makespan. It intelligently selects solutions from the archive using a weighted scoring mechanism that balances exploration and exploitation, then applies hybrid local search operators including route splitting, customer reinsertion, and capacity-balanced merging to generate feasible neighbors while maintaining diversity in the search space. The approach emphasizes demand-based route balancing, spatial proximity optimization, and probabilistic route inversion to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def pareto_dominance_score(sol, obj):\n        dominated = 0\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated += 1\n        return dominated\n\n    def adaptive_weighted_score(sol, obj):\n        total_dist, makespan = obj\n        max_dist = max(o[0] for _, o in archive)\n        max_makespan = max(o[1] for _, o in archive)\n        norm_dist = total_dist / max_dist if max_dist > 0 else 0\n        norm_makespan = makespan / max_makespan if max_makespan > 0 else 0\n        weight = 0.5 + 0.3 * (random.random() - 0.5)\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(adaptive_weighted_score(sol, obj), pareto_dominance_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: (x[1], x[0]))\n    top_k = max(1, int(0.3 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Demand-supply clustering with probabilistic inversion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4 and random.random() < 0.6:\n            customers = route[1:-1]\n            demands = demand[customers]\n            supply = np.cumsum(demands)\n            target_supply = supply[-1] / 2\n\n            split_pos = np.argmin(np.abs(supply - target_supply)) + 1\n            segment1 = route[:split_pos+1]\n            segment2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if is_feasible(segment1) and is_feasible(segment2):\n                if random.random() < 0.4:\n                    segment2 = np.concatenate([[0], segment2[-2:0:-1], segment2[-1:]])\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx+1, segment2)\n                break\n\n    # Spatial-proximity guided customer reinsertion\n    if len(new_solution) > 1 and random.random() < 0.7:\n        source_idx = random.randint(0, len(new_solution)-1)\n        target_idx = random.randint(0, len(new_solution)-1)\n        if source_idx != target_idx:\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                customer_pos = random.randint(1, len(source_route)-2)\n                customer = source_route[customer_pos]\n\n                if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    best_pos = 1\n                    min_increase = float('inf')\n\n                    for pos in range(1, len(target_route)):\n                        new_target = np.concatenate([target_route[:pos], [customer], target_route[pos:]])\n                        dist_increase = (distance_matrix[target_route[pos-1]][customer] +\n                                        distance_matrix[customer][target_route[pos]] -\n                                        distance_matrix[target_route[pos-1]][target_route[pos]])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_pos = pos\n\n                    new_target = np.concatenate([target_route[:best_pos], [customer], target_route[best_pos:]])\n\n                    if is_feasible(new_source) and is_feasible(new_target):\n                        new_solution[source_idx] = new_source\n                        new_solution[target_idx] = new_target\n\n    # Dynamic capacity-balanced route reshaping\n    if len(new_solution) > 1 and random.random() < 0.5:\n        route_stats = []\n        for route in new_solution:\n            if len(route) > 2:\n                total_demand = sum(demand[route[1:-1]])\n                route_stats.append((total_demand, route))\n\n        if len(route_stats) > 1:\n            route_stats.sort(key=lambda x: x[0])\n            for i in range(len(route_stats)-1):\n                j = len(route_stats)-1-i\n                if i >= j:\n                    break\n\n                route_i = route_stats[i][1]\n                route_j = route_stats[j][1]\n\n                if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n\n                    if is_feasible(merged_route):\n                        new_solution = [r for r in new_solution if not np.array_equal(r, route_i) and not np.array_equal(r, route_j)]\n                        new_solution.append(merged_route)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7815457256216266,
            0.10443207621574402
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search approach that adaptively selects and transforms solutions from an archive, prioritizing routes with high demand imbalance or spatial proximity, while using demand-balanced splitting and merging operations to improve both total distance and makespan objectives. It focuses on over-capacity routes (90% of capacity) and underutilized routes (70% of capacity) for merging, while also probabilistically splitting excessively long routes (>5 nodes) to maintain solution diversity. The method balances spatial awareness with capacity constraints through centroid-based route selection and proximity-aware merging points.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    def adaptive_pareto_score(solution, objectives):\n        total_dist, makespan = objectives\n        min_dist = min(obj[0] for _, obj in archive)\n        min_makespan = min(obj[1] for _, obj in archive)\n        norm_dist = (total_dist - min_dist) / (max(obj[0] for _, obj in archive) - min_dist + 1e-8)\n        norm_makespan = (makespan - min_makespan) / (max(obj[1] for _, obj in archive) - min_makespan + 1e-8)\n        weight = 0.4 + 0.3 * (random.random() - 0.5)\n        return (1 - weight) * norm_dist + weight * norm_makespan\n\n    scored_solutions = [(adaptive_pareto_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    top_k = max(1, int(0.4 * len(scored_solutions)))\n    selected_solution = random.choice([sol for _, sol in scored_solutions[:top_k]])\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Adaptive route clustering with demand balancing\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        demand_avg = sum(route_demands) / len(route_demands)\n        over_capacity = [i for i, d in enumerate(route_demands) if d > 0.9 * capacity]\n\n        if over_capacity:\n            target_route = random.choice(over_capacity)\n            cluster_candidates = []\n            for i in range(len(new_solution)):\n                if i != target_route and route_demands[i] < 0.7 * capacity:\n                    dist = np.linalg.norm(np.mean(coords[new_solution[i][1:-1]], axis=0) -\n                                        np.mean(coords[new_solution[target_route][1:-1]], axis=0))\n                    cluster_candidates.append((dist, i))\n\n            if cluster_candidates:\n                cluster_candidates.sort()\n                for _, i in cluster_candidates[:min(2, len(cluster_candidates))]:\n                    if sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[target_route][1:-1]]) <= capacity:\n                        min_dist = float('inf')\n                        best_i, best_j = 0, 0\n                        for a in range(1, len(new_solution[i])-1):\n                            for b in range(1, len(new_solution[target_route])-1):\n                                dist = distance_matrix[new_solution[i][a]][new_solution[target_route][b]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_i, best_j = a, b\n                        merged_route = np.concatenate([new_solution[i][:best_i+1],\n                                                    new_solution[target_route][best_j:-1],\n                                                    new_solution[i][-1:]])\n                        if is_feasible(merged_route):\n                            new_solution[i] = merged_route\n                            new_solution.pop(target_route)\n                            break\n\n    # Demand-balanced route splitting with spatial consideration\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 5 and random.random() < 0.5:\n            total_demand = sum(demand[route[1:-1]])\n            if total_demand > 0.6 * capacity:\n                split_pos = random.randint(2, len(route)-3)\n                segment1 = route[:split_pos+1]\n                segment2 = np.concatenate([[0], route[split_pos+1:]])\n                if is_feasible(segment1) and is_feasible(segment2):\n                    new_solution[route_idx] = segment1\n                    new_solution.insert(route_idx+1, segment2)\n                    break\n\n    # Spatial-aware route merging with capacity constraints\n    if len(new_solution) > 1 and random.random() < 0.4:\n        route_centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                route_centroids.append(centroid)\n\n        if len(route_centroids) > 1:\n            merge_candidates = []\n            for i in range(len(route_centroids)):\n                for j in range(i+1, len(route_centroids)):\n                    spatial_dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    merge_candidates.append((spatial_dist, i, j))\n\n            if merge_candidates:\n                merge_candidates.sort()\n                for _, i, j in merge_candidates[:min(2, len(merge_candidates))]:\n                    if sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]]) <= capacity:\n                        min_dist = float('inf')\n                        best_i, best_j = 0, 0\n                        for a in range(1, len(new_solution[i])-1):\n                            for b in range(1, len(new_solution[j])-1):\n                                dist = distance_matrix[new_solution[i][a]][new_solution[j][b]]\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_i, best_j = a, b\n                        merged_route = np.concatenate([new_solution[i][:best_i+1],\n                                                    new_solution[j][best_j:-1],\n                                                    new_solution[i][-1:]])\n                        if is_feasible(merged_route):\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.8205101258276497,
            0.24094343185424805
        ]
    }
]