[
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan from the archive to prioritize reducing the longest route, then applies a hybrid local search that randomly splits long routes or performs 2-opt exchanges while ensuring demand feasibility. The method balances exploration (random selection) and exploitation (demand checks) to generate feasible neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Split long routes and apply 2-opt with demand checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Try splitting the route at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check if split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            continue\n\n        # If split not feasible, try 2-opt with demand checks\n        for _ in range(3):  # Try a few 2-opt attempts\n            a, b = np.random.choice(len(route)-2, 2, replace=False)\n            a, b = min(a, b), max(a, b)\n\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n            # Check demand feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6387737338342709,
            0.11363464593887329
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest total distance from the archive to prioritize reducing travel distance, then applies a hybrid local search combining 3-opt exchanges and route merging, ensuring capacity constraints are met. It balances exploration (random selection) and exploitation (demand checks) to generate improved solutions, favoring longer routes for distance reduction while occasionally merging routes to balance makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try 3-opt exchange\n        for _ in range(2):\n            a, b, c = np.random.choice(len(route)-2, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n\n            # Reverse segments between a-b and b-c\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:c+1][::-1], route[c+1:]])\n\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n        # Try merging with another route if possible\n        if len(new_solution) > 1 and np.random.rand() < 0.3:\n            j = np.random.randint(0, len(new_solution))\n            if i != j:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n\n    return new_solution\n\n",
        "score": [
            -0.9086821471873222,
            0.2986367642879486
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted sum of total distance (70%) and makespan (30%), then applies a hybrid local search combining route merging/splitting and intra-route relocations to improve the solution while maintaining feasibility. It prioritizes distance reduction and ensures capacity constraints are respected during all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])  # More weight on total distance to prioritize distance reduction\n    scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest combined score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: combine route splitting, merging, and intra-route relocation\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n    else:\n        # If only one route, try splitting it\n        route = new_solution[0]\n        if len(route) > 4:  # Ensure there are enough nodes to split\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution = [route1, route2]\n\n    # Perform intra-route relocation to improve the solution\n    for route in new_solution:\n        if len(route) > 3:  # Ensure there are nodes to relocate\n            # Select a random node to relocate (excluding depot)\n            node_idx = random.randint(1, len(route) - 2)\n            node = route[node_idx]\n            # Try inserting it at a different position\n            new_pos = random.randint(1, len(route) - 2)\n            if new_pos > node_idx:\n                new_pos += 1\n            new_route = np.concatenate([route[:node_idx], route[node_idx+1:]])\n            new_route = np.insert(new_route, new_pos, node)\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5512119999709378,
            0.22333717346191406
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a probability inversely proportional to its makespan, then applies a hybrid local search combining route segmentation, cross-exchange between routes, and capacity-aware insertions to generate a feasible neighbor solution. It prioritizes routes with longer makespans (lower weights) for improvement while ensuring vehicle capacity constraints are met, and handles missing nodes by creating new routes if needed. The method avoids pure 2-opt by incorporating novel route splitting, cross-exchange, and intelligent insertion strategies.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_makespan = sum(obj[1] for _, obj in archive)\n    if total_makespan == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [1.0 / (obj[1] + 1e-6) for _, obj in archive]\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip routes that are too short\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route segmentation - split the route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Step 2: Cross-exchange - exchange parts between routes if possible\n        if len(new_solution) > 0 and len(part2) > 2:\n            other_route_idx = random.randint(0, len(new_solution) - 1)\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 3:\n                split_point_other = random.randint(1, len(other_route) - 2)\n                part1_other = other_route[:split_point_other + 1]\n                part2_other = other_route[split_point_other:]\n\n                # Check capacity constraints\n                if (np.sum(demand[part1[1:-1]]) + np.sum(demand[part2_other[1:-1]]) <= capacity and\n                    np.sum(demand[part1_other[1:-1]]) + np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[other_route_idx] = np.concatenate([part1_other, part2[1:-1], [0]])\n                    part2 = np.concatenate([part1[1:-1], part2_other[1:-1], [0]])\n\n        # Step 3: Capacity-aware insertion - try to insert nodes from part2 into other routes\n        nodes_to_insert = part2[1:-1]\n        for node in nodes_to_insert:\n            inserted = False\n            for i, r in enumerate(new_solution):\n                if np.sum(demand[r[1:-1]]) + demand[node] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(r)):\n                        increase = (distance_matrix[r[pos-1], node] +\n                                   distance_matrix[node, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    new_route = np.concatenate([r[:best_pos], [node], r[best_pos:]])\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                part1 = np.concatenate([part1, [node]])\n\n        new_solution.append(part1)\n\n    # Ensure all nodes are visited (in case of failed insertions)\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in new_solution:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    if missing_nodes:\n        # Create new routes for missing nodes\n        for node in missing_nodes:\n            new_route = np.array([0, node, 0])\n            if demand[node] <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.8274840483696377,
            1.3882957100868225
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = [obj[1] for _, obj in archive]\n    max_makespan = max(makespans)\n    weights = [(max_makespan - obj[1] + 1e-6) / sum(max_makespan - obj[1] + 1e-6 for _, obj in archive) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route clustering based on spatial proximity\n    if len(new_solution) > 1:\n        # Calculate centroids of each route\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n\n        # Find the two closest routes to merge\n        min_dist = float('inf')\n        merge_pair = None\n        for i in range(len(centroids)):\n            for j in range(i+1, len(centroids)):\n                dist = np.linalg.norm(centroids[i] - centroids[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    merge_pair = (i, j)\n\n        if merge_pair:\n            i, j = merge_pair\n            route1, route2 = new_solution[i], new_solution[j]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution.pop(max(i, j))\n                new_solution.pop(min(i, j))\n                new_solution.append(merged_route)\n\n    # Step 2: Demand-balanced route splitting\n    for route in new_solution[:]:\n        if len(route) > 4:\n            # Find the best split point to balance demand\n            total_demand = np.sum(demand[route[1:-1]])\n            half_demand = total_demand / 2\n            current_demand = 0\n            best_split = 1\n            for i in range(1, len(route)-1):\n                current_demand += demand[route[i]]\n                if abs(current_demand - half_demand) < abs(current_demand - demand[route[best_split]] - half_demand):\n                    best_split = i\n\n            route1 = np.concatenate([route[:best_split+1], [0]])\n            route2 = np.concatenate([[0], route[best_split+1:]])\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.remove(route)\n                new_solution.extend([route1, route2])\n\n    # Step 3: Cross-route demand redistribution\n    if len(new_solution) > 1:\n        # Find the route with highest demand and the route with lowest demand\n        demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        max_demand_idx = np.argmax(demands)\n        min_demand_idx = np.argmin(demands)\n\n        max_route = new_solution[max_demand_idx]\n        min_route = new_solution[min_demand_idx]\n\n        # Try to move nodes from max to min route\n        for node in max_route[1:-1]:\n            new_min_route = np.concatenate([min_route, [node]])\n            new_max_route = np.array([x for x in max_route if x != node])\n\n            if (np.sum(demand[new_min_route[1:-1]]) <= capacity and\n                np.sum(demand[new_max_route[1:-1]]) <= capacity):\n                new_solution[min_demand_idx] = new_min_route\n                new_solution[max_demand_idx] = new_max_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7536367093981653,
            0.6592921614646912
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the smallest total distance from the archive, then applies a hybrid local search combining route merging (when demands allow), demand-aware 3-opt exchanges (with capacity checks), and adaptive route balancing (by moving segments between routes to reduce makespan). The method prioritizes reducing total distance while ensuring feasibility, with randomized operations to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Merge routes, 3-opt with demand checks, and adaptive balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try merging with another route if demand allows\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[other_route[1:-1]])\n            if combined_demand <= capacity:\n                merged_route = np.concatenate([route[:-1], other_route[1:]])\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n                break\n\n        # Perform demand-aware 3-opt\n        for _ in range(2):\n            if len(route) < 5:\n                break\n            a, b, c = np.random.choice(len(route)-2, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n            new_route = np.concatenate([route[:a+1], route[b+1:c+1], route[a+1:b+1], route[c+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n        # Adaptive route balancing\n        if len(new_solution) > 1 and len(route) > 5:\n            # Try to move a segment to another route if it reduces makespan\n            for j in range(len(new_solution)):\n                if i == j:\n                    continue\n                other_route = new_solution[j]\n                if len(route) < 5 or len(other_route) > 15:\n                    continue\n                split_pos = np.random.randint(1, len(route)-2)\n                segment = route[split_pos:-1]\n                if np.sum(demand[segment]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                    new_solution[i] = np.concatenate([route[:split_pos+1], [0]])\n                    new_solution[j] = np.concatenate([other_route, segment, [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.8621572221550167,
            1.8054722249507904
        ]
    },
    {
        "algorithm": "The algorithm implements a demand-aware, spatially guided local search that prioritizes improving long routes (high makespan) by merging, splitting, and rebalancing routes based on spatial proximity and demand distribution. It selectively merges closest routes, transfers nodes between high/low-demand routes, and splits long routes at spatially distant nodes, while ensuring feasibility through capacity checks. The selection of solutions for improvement is weighted by inverse makespan, favoring solutions with longer routes for targeted optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    max_makespan = max(makespans)\n    weights = [(max_makespan - obj[1] + 1e-6) / sum(max_makespan - obj[1] + 1e-6 for _, obj in archive) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Spatial clustering of routes\n    if len(new_solution) > 1:\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0) if len(route_coords) > 0 else coords[0]\n            centroids.append(centroid)\n\n        # Find closest route pairs\n        min_dist = float('inf')\n        merge_pair = None\n        for i in range(len(centroids)):\n            for j in range(i+1, len(centroids)):\n                dist = np.linalg.norm(centroids[i] - centroids[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    merge_pair = (i, j)\n\n        # Attempt to merge closest routes if feasible\n        if merge_pair:\n            i, j = merge_pair\n            route1, route2 = new_solution[i], new_solution[j]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution.pop(max(i, j))\n                new_solution.pop(min(i, j))\n                new_solution.append(merged_route)\n\n    # Step 3: Demand-aware cross-exchanges\n    if len(new_solution) > 1:\n        demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        max_demand_idx = np.argmax(demands)\n        min_demand_idx = np.argmin(demands)\n\n        max_route = new_solution[max_demand_idx]\n        min_route = new_solution[min_demand_idx]\n\n        # Try moving nodes from max to min route\n        for node in max_route[1:-1]:\n            new_min_route = np.concatenate([min_route, [node]])\n            new_max_route = np.array([x for x in max_route if x != node])\n\n            if (np.sum(demand[new_min_route[1:-1]]) <= capacity and\n                np.sum(demand[new_max_route[1:-1]]) <= capacity):\n                new_solution[min_demand_idx] = new_min_route\n                new_solution[max_demand_idx] = new_max_route\n                break\n\n    # Step 4: Spatial-aware insertions\n    for route in new_solution[:]:\n        if len(route) > 4:\n            # Find best split point based on spatial proximity\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            distances = [np.linalg.norm(coords[node] - centroid) for node in route[1:-1]]\n            split_pos = np.argmax(distances) + 1  # Split at farthest node\n\n            route1 = np.concatenate([route[:split_pos+1], [0]])\n            route2 = np.concatenate([[0], route[split_pos+1:]])\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.remove(route)\n                new_solution.extend([route1, route2])\n\n    # Ensure all nodes are visited\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in new_solution:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    if missing_nodes:\n        for node in missing_nodes:\n            new_route = np.array([0, node, 0])\n            if demand[node] <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.8227672981293341,
            1.0097754895687103
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing high total distance and low makespan, then applies a hybrid local search that fragments routes and reinserts segments into other routes or creates new ones, ensuring feasibility by checking capacity constraints. The method focuses on balancing objectives by dynamically adjusting route segments while maintaining feasibility through demand checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search: route fragmentation and demand-based reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to fragment\n        start = random.randint(1, len(route) - 3)\n        end = random.randint(start + 1, len(route) - 2)\n\n        # Extract the segment and remove it from the route\n        segment = route[start:end]\n        remaining_route = np.concatenate([route[:start], route[end:]])\n\n        # Try to reinsert the segment into another route or create a new route\n        inserted = False\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = new_solution[other_route_idx]\n\n            # Check if the segment can be inserted into this route\n            for pos in range(1, len(other_route)):\n                # Check capacity constraint\n                if sum(demand[segment]) + sum(demand[other_route[1:-1]]) <= capacity:\n                    # Insert the segment\n                    new_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n                    new_solution[other_route_idx] = new_route\n                    inserted = True\n                    break\n            if inserted:\n                break\n\n        # If not inserted, try to create a new route\n        if not inserted and sum(demand[segment]) <= capacity:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n        # Update the original route\n        new_solution[route_idx] = remaining_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8224486324328129,
            1.7617380023002625
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted sum of total distance and makespan, then applies a hybrid local search combining route merging, splitting, and inter-route relocations to balance makespan reduction while ensuring capacity constraints. It prioritizes makespan improvement by evaluating potential moves based on distance savings and feasibility, favoring solutions with shorter longest routes. The selection and search are guided by equal weighting of both objectives, with randomness introduced in route selection and split/merge operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weight on both objectives\n    scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # Try merging two routes based on makespan reduction\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n    else:\n        # Split the longest route if possible\n        route = new_solution[0]\n        if len(route) > 4:\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution = [route1, route2]\n\n    # Perform inter-route relocation to balance makespan\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        if len(route1) > 3 and len(route2) > 2:\n            # Select a node from route1 to move to route2\n            node_idx = random.randint(1, len(route1) - 2)\n            node = route1[node_idx]\n            # Check if moving this node to route2 is feasible\n            if np.sum(demand[route2[1:-1]]) + demand[node] <= capacity:\n                # Try inserting at all possible positions in route2\n                best_pos = None\n                best_improvement = 0\n                for pos in range(1, len(route2) - 1):\n                    # Calculate makespan improvement\n                    old_route1_dist = distance_matrix[route1[node_idx-1], route1[node_idx]] + distance_matrix[route1[node_idx], route1[node_idx+1]]\n                    new_route1_dist = distance_matrix[route1[node_idx-1], route1[node_idx+1]]\n                    old_route2_dist = distance_matrix[route2[pos-1], route2[pos]] + distance_matrix[route2[pos], route2[pos+1]]\n                    new_route2_dist = distance_matrix[route2[pos-1], node] + distance_matrix[node, route2[pos]] + distance_matrix[node, route2[pos+1]] - distance_matrix[route2[pos], route2[pos+1]]\n                    improvement = (old_route1_dist - new_route1_dist) + (new_route2_dist - old_route2_dist)\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = pos\n                if best_pos is not None:\n                    # Perform the relocation\n                    new_route1 = np.concatenate([route1[:node_idx], route1[node_idx+1:]])\n                    new_route2 = np.insert(route2, best_pos, node)\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.5110793896528679,
            0.23822006583213806
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive using a dynamic weighted combination of distance and makespan, then applies a three-phase local search: first merging high-load routes to improve efficiency, second relocating nodes between routes while maintaining demand balance, and finally refining routes with an angular-constrained 2-opt variant to reduce route lengths while respecting capacity constraints. The method prioritizes demand-aware operations and spatial coherence (via angle-based swaps) to balance both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    norm_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-6)\n    norm_make = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-6)\n    weights = 0.6 * norm_dist + 0.4 * norm_make  # Dynamic weighting\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        route_loads = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = np.argsort(route_loads)[::-1]  # Highest to lowest load\n        for i in range(len(sorted_indices)):\n            for j in range(i+1, len(sorted_indices)):\n                r1, r2 = sorted_indices[i], sorted_indices[j]\n                merged = np.concatenate([new_solution[r1][:-1], new_solution[r2][1:]])\n                if np.sum(demand[merged[1:-1]]) <= capacity:\n                    new_solution[r1] = merged\n                    new_solution.pop(r2)\n                    break\n\n    # Phase 2: Cross-route relocation with demand balance\n    for _ in range(3):  # Limited iterations for efficiency\n        if len(new_solution) < 2:\n            break\n        r1, r2 = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[r1], new_solution[r2]\n        if len(route1) <= 3 or len(route2) <= 3:\n            continue\n\n        # Select node from route1 that improves demand balance\n        demands_route1 = demand[route1[1:-1]]\n        avg_demand = np.mean(demands_route1)\n        candidate_nodes = [i for i, d in enumerate(demands_route1) if abs(d - avg_demand) > 0.2 * avg_demand]\n        if not candidate_nodes:\n            continue\n        node_pos = random.choice(candidate_nodes) + 1  # +1 for depot offset\n        node = route1[node_pos]\n\n        # Find best insertion position in route2\n        best_pos = -1\n        best_cost = float('inf')\n        for pos in range(1, len(route2)-1):\n            new_route = np.insert(route2, pos, node)\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                cost = (distance_matrix[route2[pos-1]][node] +\n                        distance_matrix[node][route2[pos]] -\n                        distance_matrix[route2[pos-1]][route2[pos]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n        if best_pos != -1:\n            route2 = np.insert(route2, best_pos, node)\n            route1 = np.delete(route1, node_pos)\n            new_solution[r1] = route1 if len(route1) > 2 else []\n            new_solution[r2] = route2\n            if len(new_solution[r1]) == 0:\n                new_solution.pop(r1)\n\n    # Phase 3: Capacity-constrained angular 2-opt\n    for route in new_solution:\n        if len(route) <= 4:\n            continue\n\n        # Find nodes with similar angles to depot\n        depot_pos = coords[0]\n        angles = []\n        for node in route[1:-1]:\n            vec = coords[node] - depot_pos\n            angles.append(np.arctan2(vec[1], vec[0]))\n        sorted_nodes = np.argsort(angles)\n\n        # Try swapping adjacent nodes with similar angles\n        for i in range(len(sorted_nodes)-1):\n            a, b = sorted_nodes[i], sorted_nodes[i+1]\n            if abs(angles[a] - angles[b]) > np.pi/4:  # Skip if angles differ too much\n                continue\n\n            # Create candidate route\n            candidate = route.copy()\n            candidate[a+1], candidate[b+1] = candidate[b+1], candidate[a+1]\n\n            # Check feasibility\n            if (np.sum(demand[candidate[1:-1]]) <= capacity and\n                distance_matrix[candidate[a]][candidate[a+1]] + distance_matrix[candidate[b]][candidate[b+1]] <\n                distance_matrix[candidate[a]][candidate[b]] + distance_matrix[candidate[a+1]][candidate[b+1]]):\n                route[:] = candidate\n                break\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6466361221615117,
            1.5348389744758606
        ]
    }
]