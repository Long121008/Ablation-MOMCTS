[
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan from the archive to prioritize reducing the longest route, then applies a hybrid local search that randomly splits long routes or performs 2-opt exchanges while ensuring demand feasibility. The method balances exploration (random selection) and exploitation (demand checks) to generate feasible neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Split long routes and apply 2-opt with demand checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Try splitting the route at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check if split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            continue\n\n        # If split not feasible, try 2-opt with demand checks\n        for _ in range(3):  # Try a few 2-opt attempts\n            a, b = np.random.choice(len(route)-2, 2, replace=False)\n            a, b = min(a, b), max(a, b)\n\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n            # Check demand feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6387737338342709,
            0.11363464593887329
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest total distance from the archive to prioritize reducing travel distance, then applies a hybrid local search combining 3-opt exchanges and route merging, ensuring capacity constraints are met. It balances exploration (random selection) and exploitation (demand checks) to generate improved solutions, favoring longer routes for distance reduction while occasionally merging routes to balance makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try 3-opt exchange\n        for _ in range(2):\n            a, b, c = np.random.choice(len(route)-2, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n\n            # Reverse segments between a-b and b-c\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:c+1][::-1], route[c+1:]])\n\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n        # Try merging with another route if possible\n        if len(new_solution) > 1 and np.random.rand() < 0.3:\n            j = np.random.randint(0, len(new_solution))\n            if i != j:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n\n    return new_solution\n\n",
        "score": [
            -0.9086821471873222,
            0.2986367642879486
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid selection criterion that balances normalized total distance and makespan, then applies a novel route-merging and demand-balanced splitting operator to generate a neighbor solution by intelligently redistributing customers while respecting capacity constraints and improving both objectives. It prioritizes solutions with better balance between distance and makespan (weighted 70% distance, 30% makespan) and performs local improvements through capacity-constrained customer swaps. The selection prioritizes solutions with better balance between objectives, while the local search focuses on route merging/splitting and customer reordering to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    norm_dist = (total_distances - total_distances.min()) / (total_distances.max() - total_distances.min() + 1e-6)\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-6)\n\n    weights = 0.7  # Prefer solutions with better balance between distance and makespan\n    scores = weights * norm_dist + (1 - weights) * norm_makespan\n    probabilities = 1 / (scores + 1e-6)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route-merging and demand-balanced splitting operator\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Combine the routes (excluding depots)\n        combined_route = np.concatenate([route1[1:-1], route2[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        # Split into new routes while balancing demand\n        if combined_demand <= capacity:\n            # Simple case: merge into one route if possible\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[route1_idx] = new_route\n            del new_solution[route2_idx]\n        else:\n            # More complex case: split into two balanced routes\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n\n            # Find split point that balances demand\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[route1_idx] = route1_new\n            new_solution[route2_idx] = route2_new\n\n    # Additional local improvements with capacity checks\n    for route in new_solution:\n        if len(route) > 3:\n            # Try to improve by moving customers between consecutive positions\n            for _ in range(3):\n                a = random.randint(1, len(route)-2)\n                b = a + 1 if a < len(route)-2 else a - 1\n\n                # Swap positions if feasible\n                new_route = route.copy()\n                new_route[a], new_route[b] = new_route[b], new_route[a]\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8224852005278709,
            0.1528381109237671
        ]
    },
    {
        "algorithm": "The algorithm combines inverse-makespan-weighted selection with a multi-step transformation strategy that prioritizes long routes and high-demand customers, applying demand-balanced segment swaps, geometric straightening, and probabilistic customer redistribution while maintaining feasibility. It dynamically balances distance and makespan optimization by focusing on routes with high makespan variance and using spatial and demand-aware operations. The selection and transformations are guided by normalized makespan probabilities and capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-6)\n    probabilities = 1 / (norm_makespan + 1e-6)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify high-demand clusters and long routes\n    demand_threshold = 0.3 * capacity\n    high_demand_nodes = np.where(demand > demand_threshold)[0]\n    long_routes = [i for i, route in enumerate(new_solution) if len(route) > 5]\n\n    if long_routes:\n        # Select a long route for transformation\n        route_idx = np.random.choice(long_routes)\n        route = new_solution[route_idx]\n\n        # First transformation: demand-balanced segment swap\n        if len(route) > 4:\n            split_pos = len(route) // 2\n            segment1 = route[:split_pos]\n            segment2 = route[split_pos:-1]\n\n            # Check if swapping segments would balance demand better\n            segment1_demand = np.sum(demand[segment1[1:-1]])\n            segment2_demand = np.sum(demand[segment2[1:-1]])\n\n            if abs(segment1_demand - segment2_demand) > 0.2 * capacity:\n                new_route = np.concatenate([segment1, segment2[1:], [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Second transformation: geometric route straightening\n        if len(route) > 3:\n            a, b = sorted(np.random.choice(len(route)-2, 2, replace=False))\n            new_segment = [route[a], route[b]]\n            if a + 1 < b:\n                new_route = np.concatenate([route[:a+1], new_segment, route[b+1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Third transformation: probabilistic customer redistribution\n        if len(new_solution) > 1 and np.random.rand() < 0.5:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Find a customer to move\n            if len(route) > 3:\n                customer_idx = np.random.randint(1, len(route)-1)\n                customer = route[customer_idx]\n\n                # Check if moving this customer would improve balance\n                current_demand = np.sum(demand[route[1:-1]])\n                new_demand = current_demand - demand[customer]\n                other_demand = np.sum(demand[other_route[1:-1]])\n\n                if (new_demand <= capacity and\n                    other_demand + demand[customer] <= capacity and\n                    abs(new_demand - capacity/2) < abs(current_demand - capacity/2)):\n                    # Move customer\n                    new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                    new_other_route = np.concatenate([other_route[:-1], [customer], [0]])\n\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[route_idx] = new_route\n                        new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.6240829346124065,
            0.14945513010025024
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive demand-driven route decomposition with spatial-temporal harmony search, prioritizing high-demand nodes and balancing distance reduction with makespan optimization through probabilistic segment reassembly and geometric transformations while maintaining capacity constraints. It first fragments routes based on demand clusters, then reassembles them using a harmony-based approach that probabilistically selects segments to maximize geometric harmony (minimizing insertion cost) while dynamically adjusting to capacity limits, and finally applies geometric transformations for exploration. The solution emphasizes demand-aware decomposition and harmony-driven reassembly, with capacity constraints enforced throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Calculate demand clusters\n    demand_threshold = 0.3 * capacity\n    high_demand_nodes = np.where(demand > demand_threshold)[0]\n\n    # Fragment routes based on demand clusters\n    fragmented_segments = []\n    for route in new_solution:\n        if len(route) <= 3:\n            fragmented_segments.append([route])\n            continue\n\n        segments = [route[:1]]\n        current_segment = [route[0]]\n        current_demand = 0\n\n        for node in route[1:-1]:\n            current_demand += demand[node]\n            current_segment.append(node)\n\n            # Split if current segment is too large or contains high-demand node\n            if (current_demand > demand_threshold or node in high_demand_nodes) and len(current_segment) > 2:\n                current_segment.append(route[0])\n                segments.append(np.array(current_segment))\n                current_segment = [route[0]]\n                current_demand = 0\n\n        if len(current_segment) > 1:\n            current_segment.append(route[0])\n            segments.append(np.array(current_segment))\n\n        fragmented_segments.append(segments)\n\n    # Flatten and shuffle segments\n    all_segments = [seg for seg_list in fragmented_segments for seg in seg_list if len(seg) > 2]\n    np.random.shuffle(all_segments)\n\n    # Reassemble using harmony search approach\n    reassembled_routes = []\n    current_route = [0]\n    current_demand = 0\n\n    for segment in all_segments:\n        segment_demand = np.sum(demand[segment[1:-1]])\n\n        # Calculate geometric harmony score\n        if len(current_route) > 1:\n            last_node = current_route[-1]\n            first_segment_node = segment[1]\n            harmony_score = 1 / (1 + distance_matrix[last_node, first_segment_node] *\n                                (1 + abs(current_demand + segment_demand - capacity/2)))\n        else:\n            harmony_score = 1.0\n\n        # Probabilistically add segment\n        if (current_demand + segment_demand <= capacity and\n            (len(current_route) == 1 or np.random.rand() < harmony_score * 0.7)):\n            current_route.extend(segment[1:-1])\n            current_demand += segment_demand\n        else:\n            if len(current_route) > 1:\n                current_route.append(0)\n                reassembled_routes.append(np.array(current_route))\n            current_route = [0] if segment[0] == 0 else [0, *segment[1:-1]]\n            current_demand = 0 if segment[0] == 0 else segment_demand\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        reassembled_routes.append(np.array(current_route))\n\n    # Apply geometric transformation for exploration\n    if len(reassembled_routes) > 1 and np.random.rand() < 0.4:\n        i = np.random.randint(len(reassembled_routes))\n        if len(reassembled_routes[i]) > 3:\n            route = reassembled_routes[i]\n            # Find two points to create a geometric transformation\n            a, b = sorted(np.random.choice(len(route)-2, 2, replace=False))\n            # Create a new segment by connecting points with straight line\n            new_segment = [route[a], route[b]]\n            # Check if this creates a valid route\n            if a + 1 < b:\n                new_route = np.concatenate([route[:a+1], new_segment, route[b+1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    reassembled_routes[i] = new_route\n\n    return reassembled_routes\n\n",
        "score": [
            -0.8853941871874763,
            0.6955144107341766
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest total distance from the archive, then applies a hybrid local search combining reverse segment insertion (with capacity checks) and probabilistic route merging to balance distance optimization and makespan reduction while ensuring feasibility. It prioritizes distance optimization by initially selecting the shortest-distance solution and uses demand-aware operations to maintain capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try reverse segment insertion (modified 2-opt with capacity check)\n        for _ in range(3):\n            a, b = np.random.choice(len(route)-2, 2, replace=False)\n            a, b = sorted([a, b])\n\n            # Create new route by reversing segment between a and b\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n            # Check capacity constraint\n            segment_demand = np.sum(demand[new_route[a+1:b+1]])\n            if segment_demand <= capacity:\n                full_route_demand = np.sum(demand[new_route[1:-1]])\n                if full_route_demand <= capacity:\n                    new_solution[i] = new_route\n                    break\n\n        # Try merging with another route if possible\n        if len(new_solution) > 1 and np.random.rand() < 0.3:\n            j = np.random.choice([k for k in range(len(new_solution)) if k != i])\n            other_route = new_solution[j]\n\n            # Try inserting a segment from the current route into the other route\n            if len(route) > 3:\n                a, b = np.random.choice(len(route)-2, 2, replace=False)\n                a, b = sorted([a, b])\n                segment = route[a+1:b+1]\n                segment_demand = np.sum(demand[segment])\n\n                # Find best insertion point in other route\n                best_insert_pos = -1\n                best_distance = float('inf')\n                for pos in range(1, len(other_route)):\n                    new_other_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n                    if np.sum(demand[new_other_route[1:-1]]) <= capacity:\n                        # Calculate distance change\n                        old_dist = (distance_matrix[other_route[pos-1], other_route[pos]] +\n                                   distance_matrix[segment[0], segment[-1]] +\n                                   distance_matrix[segment[-1], other_route[pos]])\n                        new_dist = (distance_matrix[other_route[pos-1], segment[0]] +\n                                   distance_matrix[segment[0], segment[-1]] +\n                                   distance_matrix[segment[-1], other_route[pos]])\n                        dist_change = new_dist - old_dist\n                        if dist_change < best_distance:\n                            best_distance = dist_change\n                            best_insert_pos = pos\n\n                if best_insert_pos != -1:\n                    new_other_route = np.concatenate([other_route[:best_insert_pos], segment, other_route[best_insert_pos:]])\n                    new_solution[j] = new_other_route\n                    new_solution[i] = np.concatenate([route[:a+1], route[b+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.864920491432454,
            0.545938640832901
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive demand clustering with spatial-aware segment swaps, prioritizing solutions with high makespan and demand variance by probabilistically transferring route segments between clusters while maintaining feasibility through capacity checks and optional spatial inversions. It balances exploration (random segment transfers) and exploitation (demand-constrained swaps) to improve both distance and makespan, with a 50% chance of spatial inversion for further optimization. The selection process weights solutions based on makespan and demand variance, ensuring diverse exploration of the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    demand_vars = [np.var([np.sum(demand[route[1:-1]]) for route in sol[0]]) for sol in archive]\n    weights = [makespans[i] * demand_vars[i] for i in range(len(archive))]\n    weights = [w / sum(weights) if sum(weights) > 0 else 1/len(weights) for w in weights]\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Cluster routes by spatial proximity and demand\n    clusters = []\n    for route in new_solution:\n        if len(route) <= 3:\n            clusters.append([route])\n            continue\n\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        distances = [np.linalg.norm(coords[node] - centroid) for node in route[1:-1]]\n\n        # Split into clusters based on demand and spatial distance\n        cluster_points = [0]\n        for i in range(1, len(route)-2):\n            if distances[i] > np.mean(distances) and np.random.rand() < demand[route[i+1]]/np.sum(demand[route[1:-1]]):\n                cluster_points.append(i)\n\n        cluster_points.append(len(route)-2)\n        route_clusters = []\n        for j in range(len(cluster_points)-1):\n            start, end = cluster_points[j], cluster_points[j+1]\n            cluster = route[start:end+1]\n            route_clusters.append(cluster)\n        clusters.append(route_clusters)\n\n    # Step 3: Cross-route segment swaps with adaptive probabilistic transfers\n    all_segments = [seg for route_clusters in clusters for seg in route_clusters]\n    np.random.shuffle(all_segments)\n\n    reassembled_routes = []\n    current_route = [0]\n    current_demand = 0\n\n    for i, seg in enumerate(all_segments):\n        seg_demand = np.sum(demand[seg[1:-1]])\n        if current_demand + seg_demand <= capacity:\n            current_route.extend(seg[1:-1])\n            current_demand += seg_demand\n        else:\n            current_route.append(0)\n            reassembled_routes.append(np.array(current_route))\n            current_route = [0, *seg[1:-1]]\n            current_demand = seg_demand\n\n        # Probabilistically transfer segments between routes\n        if np.random.rand() < 0.6 and i < len(all_segments)-1:\n            next_seg = all_segments[i+1]\n            next_demand = np.sum(demand[next_seg[1:-1]])\n            if current_demand + next_demand <= capacity:\n                current_route.extend(next_seg[1:-1])\n                current_demand += next_demand\n                i += 1\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        reassembled_routes.append(np.array(current_route))\n\n    # Step 4: Spatial inversion for exploration\n    if np.random.rand() < 0.5 and len(reassembled_routes) > 1:\n        i = np.random.randint(len(reassembled_routes))\n        if len(reassembled_routes[i]) > 4:\n            route = reassembled_routes[i]\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            distances = [np.linalg.norm(coords[node] - centroid) for node in route[1:-1]]\n            split_pos = np.argmax(distances) + 1\n\n            new_route = np.concatenate([route[:split_pos+1], route[split_pos+1:][::-1], [0]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                reassembled_routes[i] = new_route\n\n    # Ensure all nodes are visited\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in reassembled_routes:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    if missing_nodes:\n        for node in missing_nodes:\n            new_route = np.array([0, node, 0])\n            if demand[node] <= capacity:\n                reassembled_routes.append(new_route)\n\n    return reassembled_routes\n\n",
        "score": [
            -0.8995357040918754,
            2.078373044729233
        ]
    },
    {
        "algorithm": "The algorithm combines **adaptive spatial-temporal clustering** with **demand-weighted route fragmentation and reassembly**, prioritizing high-demand nodes while dynamically adjusting fragmentation granularity based on inverse makespan weights. It balances exploration (via probabilistic route inversions) and exploitation (via demand-weighted segment swaps) while ensuring capacity constraints through feasibility checks. The solution is selected from the archive, fragmented into segments, probabilistically reassembled, and optionally inverted for non-sequential exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Calculate demand weights for each route\n    demand_weights = [np.sum(demand[route[1:-1]]) for route in new_solution]\n    total_demand = sum(demand_weights)\n    demand_probs = [w/total_demand for w in demand_weights]\n\n    # Cluster routes by spatial proximity\n    centroids = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n        else:\n            centroids.append(coords[0])\n\n    # Perform demand-weighted route fragmentation\n    fragmented_segments = []\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:\n            fragmented_segments.append([route])\n            continue\n\n        # Calculate fragmentation points based on demand and distance\n        cumulative_demand = np.cumsum(demand[route[1:-1]])\n        demand_threshold = demand_weights[i] * 0.7  # 70% of route demand\n\n        split_points = [0]\n        for j in range(1, len(route)-2):\n            if cumulative_demand[j-1] >= demand_threshold and np.random.rand() < demand_probs[i]:\n                split_points.append(j)\n\n        split_points.append(len(route)-2)\n\n        # Create segments\n        segments = []\n        for k in range(len(split_points)-1):\n            start, end = split_points[k], split_points[k+1]\n            segments.append(route[start:end+1])\n\n        fragmented_segments.append(segments)\n\n    # Reassemble segments into new routes\n    all_segments = [seg for seg_list in fragmented_segments for seg in seg_list]\n    np.random.shuffle(all_segments)\n\n    reassembled_routes = []\n    current_route = [0]\n    current_demand = 0\n\n    for segment in all_segments:\n        segment_demand = np.sum(demand[segment[1:-1]])\n        if current_demand + segment_demand <= capacity:\n            current_route.extend(segment[1:-1])\n            current_demand += segment_demand\n        else:\n            current_route.append(0)\n            reassembled_routes.append(np.array(current_route))\n            current_route = [0, *segment[1:-1]]\n            current_demand = segment_demand\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        reassembled_routes.append(np.array(current_route))\n\n    # Apply occasional route inversion for exploration\n    if np.random.rand() < 0.3 and len(reassembled_routes) > 1:\n        i = np.random.randint(len(reassembled_routes))\n        if len(reassembled_routes[i]) > 3:\n            route = reassembled_routes[i]\n            a, b = sorted(np.random.choice(len(route)-2, 2, replace=False))\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                reassembled_routes[i] = new_route\n\n    return reassembled_routes\n\n",
        "score": [
            -0.8134299656504937,
            0.3530265688896179
        ]
    },
    {
        "algorithm": "The algorithm combines **spatial-temporal clustering with demand-aware route segmentation**, using **inverse distance weights** to prioritize fragmentation of longer routes, **probabilistic segment merges** for controlled reassembly, and **capacity-constrained inversions** to exploit demand similarity for local improvements. It balances exploration (route fragmentation) and exploitation (segment merging/inversion) while ensuring feasibility through strict capacity checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Calculate inverse distance weights for fragmentation\n    distance_weights = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_distances = distance_matrix[route[:-1], route[1:]]\n            avg_distance = np.mean(route_distances)\n            distance_weights.append(1.0 / avg_distance if avg_distance > 0 else 0)\n        else:\n            distance_weights.append(0)\n\n    total_weight = sum(distance_weights) if sum(distance_weights) > 0 else 1\n    frag_probs = [w/total_weight for w in distance_weights]\n\n    # Fragment routes with higher inverse distance probability\n    fragmented_segments = []\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:\n            fragmented_segments.append([route])\n            continue\n\n        if np.random.rand() < frag_probs[i]:\n            # Split at highest demand node\n            demands = demand[route[1:-1]]\n            split_idx = np.argmax(demands) + 1\n            segments = [\n                route[:split_idx+1],\n                route[split_idx:]\n            ]\n        else:\n            segments = [route]\n\n        fragmented_segments.append(segments)\n\n    # Reassemble with probabilistic merges\n    all_segments = [seg for seg_list in fragmented_segments for seg in seg_list]\n    np.random.shuffle(all_segments)\n\n    reassembled_routes = []\n    current_route = [0]\n    current_demand = 0\n\n    for segment in all_segments:\n        segment_demand = np.sum(demand[segment[1:-1]])\n        if current_demand + segment_demand <= capacity and np.random.rand() < 0.7:\n            current_route.extend(segment[1:-1])\n            current_demand += segment_demand\n        else:\n            current_route.append(0)\n            reassembled_routes.append(np.array(current_route))\n            current_route = [0, *segment[1:-1]]\n            current_demand = segment_demand\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        reassembled_routes.append(np.array(current_route))\n\n    # Apply capacity-constrained inversions\n    if np.random.rand() < 0.4 and len(reassembled_routes) > 1:\n        i = np.random.randint(len(reassembled_routes))\n        if len(reassembled_routes[i]) > 4:\n            route = reassembled_routes[i]\n            # Find two points with similar demands\n            demands = demand[route[1:-1]]\n            diffs = np.abs(demands[:, None] - demands[None, :])\n            a, b = np.unravel_index(np.argmin(diffs), diffs.shape)\n            a, b = sorted([a, b])\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                reassembled_routes[i] = new_route\n\n    return reassembled_routes\n\n",
        "score": [
            -0.7879906998656968,
            0.21043884754180908
        ]
    },
    {
        "algorithm": "The algorithm selects solutions with high makespan and low distance using a weighted scoring system, then applies a hybrid local search combining route merging (with capacity checks) and spatial-aware customer swaps to improve both objectives while respecting capacity constraints. It prioritizes distance reduction (60% weight) over makespan minimization and uses probabilistic feasibility checks during swaps. The critical design ideas are the weighted selection of solutions and the spatial-aware route merging/splitting strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    norm_dist = (total_distances - total_distances.min()) / (total_distances.max() - total_distances.min() + 1e-6)\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-6)\n\n    weights = 0.6\n    scores = weights * norm_dist + (1 - weights) * norm_makespan\n    probabilities = 1 / (scores + 1e-6)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        combined_route = np.concatenate([route1[1:-1], route2[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        if combined_demand <= capacity:\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[route1_idx] = new_route\n            del new_solution[route2_idx]\n        else:\n            centroid1 = np.mean(coords[route1[1:-1]], axis=0)\n            centroid2 = np.mean(coords[route2[1:-1]], axis=0)\n\n            sorted_indices = np.argsort(np.linalg.norm(coords[combined_route] - centroid1, axis=1))\n            split_pos = np.argmax(np.cumsum(demand[combined_route[sorted_indices]]) <= capacity) + 1\n\n            route1_new = np.concatenate([[0], combined_route[sorted_indices][:split_pos], [0]])\n            route2_new = np.concatenate([[0], combined_route[sorted_indices][split_pos:], [0]])\n\n            new_solution[route1_idx] = route1_new\n            new_solution[route2_idx] = route2_new\n\n    for route in new_solution:\n        if len(route) > 3:\n            for _ in range(3):\n                a = random.randint(1, len(route)-2)\n                b = random.randint(1, len(route)-2)\n                if a == b:\n                    continue\n\n                new_route = route.copy()\n                new_route[a], new_route[b] = new_route[b], new_route[a]\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity and np.random.rand() < 0.7:\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6529738998577298,
            0.20500540733337402
        ]
    }
]