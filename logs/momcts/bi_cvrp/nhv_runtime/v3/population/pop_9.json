[
    {
        "algorithm": "The algorithm selects the solution with the smallest makespan from the archive to prioritize reducing the longest route, then applies a hybrid local search that randomly splits long routes or performs 2-opt exchanges while ensuring demand feasibility. The method balances exploration (random selection) and exploitation (demand checks) to generate feasible neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Split long routes and apply 2-opt with demand checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Try splitting the route at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check if split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            continue\n\n        # If split not feasible, try 2-opt with demand checks\n        for _ in range(3):  # Try a few 2-opt attempts\n            a, b = np.random.choice(len(route)-2, 2, replace=False)\n            a, b = min(a, b), max(a, b)\n\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n            # Check demand feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6387737338342709,
            0.11363464593887329
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a probability inversely proportional to its makespan, then applies a hybrid local search combining route segmentation, cross-exchange between routes, and capacity-aware insertions to generate a feasible neighbor solution. It prioritizes routes with longer makespans (lower weights) for improvement while ensuring vehicle capacity constraints are met, and handles missing nodes by creating new routes if needed. The method avoids pure 2-opt by incorporating novel route splitting, cross-exchange, and intelligent insertion strategies.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_makespan = sum(obj[1] for _, obj in archive)\n    if total_makespan == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [1.0 / (obj[1] + 1e-6) for _, obj in archive]\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip routes that are too short\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route segmentation - split the route into two parts\n        split_point = random.randint(1, len(route) - 2)\n        part1 = route[:split_point + 1]\n        part2 = route[split_point:]\n\n        # Step 2: Cross-exchange - exchange parts between routes if possible\n        if len(new_solution) > 0 and len(part2) > 2:\n            other_route_idx = random.randint(0, len(new_solution) - 1)\n            other_route = new_solution[other_route_idx]\n            if len(other_route) > 3:\n                split_point_other = random.randint(1, len(other_route) - 2)\n                part1_other = other_route[:split_point_other + 1]\n                part2_other = other_route[split_point_other:]\n\n                # Check capacity constraints\n                if (np.sum(demand[part1[1:-1]]) + np.sum(demand[part2_other[1:-1]]) <= capacity and\n                    np.sum(demand[part1_other[1:-1]]) + np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[other_route_idx] = np.concatenate([part1_other, part2[1:-1], [0]])\n                    part2 = np.concatenate([part1[1:-1], part2_other[1:-1], [0]])\n\n        # Step 3: Capacity-aware insertion - try to insert nodes from part2 into other routes\n        nodes_to_insert = part2[1:-1]\n        for node in nodes_to_insert:\n            inserted = False\n            for i, r in enumerate(new_solution):\n                if np.sum(demand[r[1:-1]]) + demand[node] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(r)):\n                        increase = (distance_matrix[r[pos-1], node] +\n                                   distance_matrix[node, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n                    new_route = np.concatenate([r[:best_pos], [node], r[best_pos:]])\n                    new_solution[i] = new_route\n                    inserted = True\n                    break\n            if not inserted:\n                part1 = np.concatenate([part1, [node]])\n\n        new_solution.append(part1)\n\n    # Ensure all nodes are visited (in case of failed insertions)\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in new_solution:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    if missing_nodes:\n        # Create new routes for missing nodes\n        for node in missing_nodes:\n            new_route = np.array([0, node, 0])\n            if demand[node] <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.8274840483696377,
            1.3882957100868225
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    max_makespan = max(makespans)\n    weights = [(max_makespan - obj[1] + 1e-6) / sum(max_makespan - obj[1] + 1e-6 for _, obj in archive) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route clustering based on spatial proximity\n    if len(new_solution) > 1:\n        # Calculate centroids of each route\n        centroids = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n\n        # Find the two closest routes to merge\n        min_dist = float('inf')\n        merge_pair = None\n        for i in range(len(centroids)):\n            for j in range(i+1, len(centroids)):\n                dist = np.linalg.norm(centroids[i] - centroids[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    merge_pair = (i, j)\n\n        if merge_pair:\n            i, j = merge_pair\n            route1, route2 = new_solution[i], new_solution[j]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution.pop(max(i, j))\n                new_solution.pop(min(i, j))\n                new_solution.append(merged_route)\n\n    # Step 2: Demand-balanced route splitting\n    for route in new_solution[:]:\n        if len(route) > 4:\n            # Find the best split point to balance demand\n            total_demand = np.sum(demand[route[1:-1]])\n            half_demand = total_demand / 2\n            current_demand = 0\n            best_split = 1\n            for i in range(1, len(route)-1):\n                current_demand += demand[route[i]]\n                if abs(current_demand - half_demand) < abs(current_demand - demand[route[best_split]] - half_demand):\n                    best_split = i\n\n            route1 = np.concatenate([route[:best_split+1], [0]])\n            route2 = np.concatenate([[0], route[best_split+1:]])\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.remove(route)\n                new_solution.extend([route1, route2])\n\n    # Step 3: Cross-route demand redistribution\n    if len(new_solution) > 1:\n        # Find the route with highest demand and the route with lowest demand\n        demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        max_demand_idx = np.argmax(demands)\n        min_demand_idx = np.argmin(demands)\n\n        max_route = new_solution[max_demand_idx]\n        min_route = new_solution[min_demand_idx]\n\n        # Try to move nodes from max to min route\n        for node in max_route[1:-1]:\n            new_min_route = np.concatenate([min_route, [node]])\n            new_max_route = np.array([x for x in max_route if x != node])\n\n            if (np.sum(demand[new_min_route[1:-1]]) <= capacity and\n                np.sum(demand[new_max_route[1:-1]]) <= capacity):\n                new_solution[min_demand_idx] = new_min_route\n                new_solution[max_demand_idx] = new_max_route\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7536367093981653,
            0.6592921614646912
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted sum of total distance (70%) and makespan (30%), then applies a hybrid local search combining route merging/splitting and intra-route relocations to improve the solution while maintaining feasibility. It prioritizes distance reduction and ensures capacity constraints are respected during all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])  # More weight on total distance to prioritize distance reduction\n    scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest combined score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a deep copy of the solution to modify\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: combine route splitting, merging, and intra-route relocation\n    if len(new_solution) > 1:\n        # Try merging two routes if feasible\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n    else:\n        # If only one route, try splitting it\n        route = new_solution[0]\n        if len(route) > 4:  # Ensure there are enough nodes to split\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate([route[:split_pos], [0]])\n            route2 = np.concatenate([[0], route[split_pos:]])\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution = [route1, route2]\n\n    # Perform intra-route relocation to improve the solution\n    for route in new_solution:\n        if len(route) > 3:  # Ensure there are nodes to relocate\n            # Select a random node to relocate (excluding depot)\n            node_idx = random.randint(1, len(route) - 2)\n            node = route[node_idx]\n            # Try inserting it at a different position\n            new_pos = random.randint(1, len(route) - 2)\n            if new_pos > node_idx:\n                new_pos += 1\n            new_route = np.concatenate([route[:node_idx], route[node_idx+1:]])\n            new_route = np.insert(new_route, new_pos, node)\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5512119999709378,
            0.22333717346191406
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing high total distance and low makespan, then applies a hybrid local search that fragments routes and reinserts segments into other routes or creates new ones, ensuring feasibility by checking capacity constraints. The method focuses on balancing objectives by dynamically adjusting route segments while maintaining feasibility through demand checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1]))[0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply hybrid local search: route fragmentation and demand-based reinsertion\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Randomly select a segment to fragment\n        start = random.randint(1, len(route) - 3)\n        end = random.randint(start + 1, len(route) - 2)\n\n        # Extract the segment and remove it from the route\n        segment = route[start:end]\n        remaining_route = np.concatenate([route[:start], route[end:]])\n\n        # Try to reinsert the segment into another route or create a new route\n        inserted = False\n        for other_route_idx in range(len(new_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = new_solution[other_route_idx]\n\n            # Check if the segment can be inserted into this route\n            for pos in range(1, len(other_route)):\n                # Check capacity constraint\n                if sum(demand[segment]) + sum(demand[other_route[1:-1]]) <= capacity:\n                    # Insert the segment\n                    new_route = np.concatenate([other_route[:pos], segment, other_route[pos:]])\n                    new_solution[other_route_idx] = new_route\n                    inserted = True\n                    break\n            if inserted:\n                break\n\n        # If not inserted, try to create a new route\n        if not inserted and sum(demand[segment]) <= capacity:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n        # Update the original route\n        new_solution[route_idx] = remaining_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8224486324328129,
            1.7617380023002625
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a probability proportional to its total distance, then applies a hybrid local search combining adaptive route splitting, cross-route demand-aware exchanges, and intelligent insertion to generate a feasible neighbor solution while prioritizing capacity constraints and balancing both objectives. It first splits routes when demand allows, then exchanges segments between routes if feasible, and finally inserts unvisited nodes into the most promising routes with minimal distance increase. The method emphasizes demand-aware operations and intelligent node insertion to improve both distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance = sum(obj[0] for _, obj in archive)\n    if total_distance == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [obj[0] / total_distance for _, obj in archive]\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with adaptive operations\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Adaptive route splitting with demand check\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            continue\n\n        # Cross-route demand-aware exchange\n        if len(new_solution) > 1 and np.random.rand() < 0.5:\n            other_idx = np.random.randint(0, len(new_solution))\n            if other_idx != i and len(new_solution[other_idx]) > 3:\n                other_route = new_solution[other_idx]\n                split_pos_other = np.random.randint(1, len(other_route)-1)\n                part1_other = other_route[:split_pos_other+1]\n                part2_other = other_route[split_pos_other:]\n\n                if (np.sum(demand[part1[1:-1]]) + np.sum(demand[part2_other[1:-1]]) <= capacity and\n                    np.sum(demand[part1_other[1:-1]]) + np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[i] = np.concatenate([part1, part2_other[1:-1], [0]])\n                    new_solution[other_idx] = np.concatenate([part1_other, part2[1:-1], [0]])\n\n    # Intelligent insertion for unvisited nodes\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in new_solution:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    for node in missing_nodes:\n        best_route = -1\n        best_pos = -1\n        min_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if np.sum(demand[route[1:-1]]) + demand[node] > capacity:\n                continue\n\n            for pos in range(1, len(route)):\n                increase = (distance_matrix[route[pos-1], node] +\n                           distance_matrix[node, route[pos]] -\n                           distance_matrix[route[pos-1], route[pos]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_route = i\n                    best_pos = pos\n\n        if best_route != -1:\n            new_route = np.concatenate([new_solution[best_route][:best_pos], [node], new_solution[best_route][best_pos:]])\n            new_solution[best_route] = new_route\n        else:\n            new_solution.append(np.array([0, node, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7867713186371166,
            2.1492561399936676
        ]
    },
    {
        "algorithm": "The algorithm prioritizes reducing the makespan by selecting the solution with the shortest longest route from the archive, then applies a hybrid local search that splits overloaded routes and reinserts nodes into other feasible routes to balance distance and makespan while ensuring capacity constraints. It intelligently reinserts nodes by minimizing insertion cost and creates new routes only when necessary, focusing on feasibility and multi-objective trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: split long routes and reinsert nodes from overloaded routes\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Check if route exceeds capacity\n        route_demand = sum(demand[route[1:-1]])\n        if route_demand > capacity:\n            # Split the route into two parts\n            split_pos = len(route) // 2\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n            part2[0] = 0  # Ensure part2 starts with depot\n\n            # Reinsert nodes from the overloaded part into other routes\n            for node in part2[1:-1]:\n                inserted = False\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    candidate_route = new_solution[j]\n                    candidate_demand = sum(demand[candidate_route[1:-1]])\n                    if candidate_demand + demand[node] <= capacity:\n                        # Find best insertion position\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(candidate_route)):\n                            cost = (distance_matrix[candidate_route[pos-1], node] +\n                                   distance_matrix[node, candidate_route[pos]] -\n                                   distance_matrix[candidate_route[pos-1], candidate_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        # Insert node\n                        candidate_route = np.insert(candidate_route, best_pos, node)\n                        new_solution[j] = candidate_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # If not inserted, create a new route\n                    new_route = np.array([0, node, 0])\n                    new_solution.append(new_route)\n\n            # Update the split parts\n            new_solution[i] = part1\n            if len(part2) > 2:  # Only add if part2 has nodes\n                new_solution.append(part2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6118910883005869,
            2.9781546592712402
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its total distance, then applies a hybrid local search combining route merging, node reallocation, and capacity-constrained swaps to generate a neighbor solution, prioritizing routes with shorter distances while ensuring vehicle capacity constraints are met. It intelligently reallocates nodes between routes to minimize distance increases and handles missing nodes by creating new single-node routes. The method emphasizes reducing total distance by focusing on high-probability solutions and carefully validating capacity constraints during all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance = sum(obj[0] for _, obj in archive)\n    if total_distance == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [1.0 / (obj[0] + 1e-6) for _, obj in archive]\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Route merging - try to merge with another route if possible\n        merged = False\n        for i, other_route in enumerate(new_solution):\n            if len(other_route) > 3 and not merged:\n                combined_load = np.sum(demand[route[1:-1]]) + np.sum(demand[other_route[1:-1]])\n                if combined_load <= capacity:\n                    merged_route = np.concatenate([route[:-1], other_route[1:]])\n                    new_solution[i] = merged_route\n                    merged = True\n                    break\n\n        if not merged:\n            # Step 2: Node reallocation - try to reallocate nodes to other routes\n            nodes_to_reallocate = route[1:-1].copy()\n            for node in nodes_to_reallocate:\n                reallocated = False\n                for i, r in enumerate(new_solution):\n                    if np.sum(demand[r[1:-1]]) + demand[node] <= capacity:\n                        # Find the best position to insert\n                        best_pos = 1\n                        min_increase = float('inf')\n                        for pos in range(1, len(r)):\n                            increase = (distance_matrix[r[pos-1], node] +\n                                       distance_matrix[node, r[pos]] -\n                                       distance_matrix[r[pos-1], r[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        new_route = np.concatenate([r[:best_pos], [node], r[best_pos:]])\n                        new_solution[i] = new_route\n                        reallocated = True\n                        break\n                if not reallocated:\n                    # Step 3: Capacity-constrained swap - try to swap nodes with other routes\n                    for i, r in enumerate(new_solution):\n                        if len(r) > 3:\n                            for node_other in r[1:-1]:\n                                if (np.sum(demand[route[1:-1]]) - demand[node] + demand[node_other] <= capacity and\n                                    np.sum(demand[r[1:-1]]) - demand[node_other] + demand[node] <= capacity):\n                                    # Perform the swap\n                                    route_idx = np.where(route == node)[0][0]\n                                    other_route_idx = np.where(r == node_other)[0][0]\n                                    route[route_idx] = node_other\n                                    r[other_route_idx] = node\n                                    new_solution[i] = r\n                                    break\n                            else:\n                                continue\n                            break\n\n            if not reallocated:\n                new_solution.append(route.copy())\n\n    # Ensure all nodes are visited\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in new_solution:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    if missing_nodes:\n        for node in missing_nodes:\n            new_route = np.array([0, node, 0])\n            if demand[node] <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.754819341443648,
            6.835149377584457
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (biased toward shorter total distances) and applies a hybrid local search combining adaptive route merging (for low-demand routes), demand-balanced route splitting (for overloaded routes), and intelligent node reallocation (to balance makespan by moving nodes between routes). It prioritizes capacity constraints and makespan minimization while ensuring all nodes are visited.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance = sum(obj[0] for _, obj in archive)\n    if total_distance == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [1.0 / (obj[0] + 1e-6) for _, obj in archive]\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n\n    new_solution = []\n    unassigned_nodes = set()\n\n    # Step 1: Adaptive route merging - combine routes with low demand utilization\n    for i in range(len(base_solution)):\n        route = base_solution[i]\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        current_demand = np.sum(demand[route[1:-1]])\n        if current_demand < capacity * 0.3:  # Low utilization threshold\n            merged = False\n            for j in range(len(new_solution)):\n                other_route = new_solution[j]\n                other_demand = np.sum(demand[other_route[1:-1]])\n                if other_demand + current_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([other_route[:-1], route[1:]])\n                    new_solution[j] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                new_solution.append(route.copy())\n        else:\n            new_solution.append(route.copy())\n\n    # Step 2: Demand-balanced route splitting - split overloaded routes\n    temp_solution = []\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Split the route into two balanced parts\n            nodes = route[1:-1]\n            total_demand = np.sum(demand[nodes])\n            split_pos = 1\n            current_demand = 0\n            for i in range(len(nodes)):\n                current_demand += demand[nodes[i]]\n                if current_demand > total_demand / 2:\n                    split_pos = i + 1\n                    break\n\n            part1 = np.concatenate([[0], nodes[:split_pos], [0]])\n            part2 = np.concatenate([[0], nodes[split_pos:], [0]])\n\n            if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                temp_solution.append(part1)\n                temp_solution.append(part2)\n            else:\n                temp_solution.append(route.copy())\n        else:\n            temp_solution.append(route.copy())\n\n    new_solution = temp_solution\n\n    # Step 3: Intelligent node reallocation - move nodes between routes to balance makespan\n    for _ in range(3):  # Multiple iterations for better improvement\n        makespans = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(makespans)\n        shortest_route_idx = np.argmin(makespans)\n\n        if longest_route_idx != shortest_route_idx:\n            longest_route = new_solution[longest_route_idx]\n            shortest_route = new_solution[shortest_route_idx]\n\n            # Try to move nodes from longest to shortest route\n            for node in longest_route[1:-1]:\n                if (np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity and\n                    np.sum(demand[longest_route[1:-1]]) - demand[node] <= capacity):\n\n                    # Find best insertion position in shortest route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(shortest_route)):\n                        increase = (distance_matrix[shortest_route[pos-1], node] +\n                                   distance_matrix[node, shortest_route[pos]] -\n                                   distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Calculate potential makespan changes\n                    original_longest = makespans[longest_route_idx]\n                    original_shortest = makespans[shortest_route_idx]\n\n                    # Remove node from longest route\n                    new_longest = np.concatenate([longest_route[:np.where(longest_route == node)[0][0]],\n                                                 longest_route[np.where(longest_route == node)[0][0]+1:]])\n                    new_longest_makespan = np.sum(distance_matrix[new_longest[:-1], new_longest[1:]])\n\n                    # Insert node into shortest route\n                    new_shortest = np.concatenate([shortest_route[:best_pos], [node], shortest_route[best_pos:]])\n                    new_shortest_makespan = np.sum(distance_matrix[new_shortest[:-1], new_shortest[1:]])\n\n                    # Check if this improves the makespan difference\n                    if max(new_longest_makespan, new_shortest_makespan) < max(original_longest, original_shortest):\n                        new_solution[longest_route_idx] = new_longest\n                        new_solution[shortest_route_idx] = new_shortest\n                        break\n\n    # Ensure all nodes are visited\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in new_solution:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    if missing_nodes:\n        # Create new routes for missing nodes\n        for node in missing_nodes:\n            new_route = np.array([0, node, 0])\n            if demand[node] <= capacity:\n                new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.44576305341137934,
            3.482593387365341
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from an archive using adaptive weighted objective scoring, then applies a three-phase local search: route rebalancing transfers nodes between routes to reduce makespan, demand-aware clustering groups unserved nodes by proximity and demand to form new routes or insert into existing ones, and adaptive insertion optimizes node positions within routes while maintaining capacity constraints. The method prioritizes balanced solutions and employs context-aware transformations beyond standard local search operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distance = sum(obj[0] for _, obj in archive)\n    total_makespan = sum(obj[1] for _, obj in archive)\n    if total_distance == 0 or total_makespan == 0:\n        weights = [0.5, 0.5]\n    else:\n        # Shift weight toward makespan when distance is already optimized\n        avg_distance = total_distance / len(archive)\n        avg_makespan = total_makespan / len(archive)\n        distance_weight = max(0.3, 1 - (avg_distance / (avg_distance + avg_makespan)))\n        weights = [distance_weight, 1 - distance_weight]\n\n    scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Multi-phase local search\n    # Phase 1: Route rebalancing\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_idx = np.argmax(lengths)\n        shortest_idx = np.argmin(lengths)\n\n        # Transfer nodes from longest to shortest if feasible\n        longest_route = new_solution[longest_idx]\n        shortest_route = new_solution[shortest_idx]\n\n        for i in range(1, len(longest_route) - 1):\n            node = longest_route[i]\n            if np.sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                # Find best insertion position in shortest route\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(shortest_route)):\n                    increase = (distance_matrix[shortest_route[pos-1], node] +\n                               distance_matrix[node, shortest_route[pos]] -\n                               distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Update routes\n                new_longest = np.concatenate([longest_route[:i], longest_route[i+1:]])\n                new_shortest = np.concatenate([shortest_route[:best_pos], [node], shortest_route[best_pos:]])\n\n                # Check if transfer improves both routes\n                old_longest_len = lengths[longest_idx]\n                old_shortest_len = lengths[shortest_idx]\n                new_longest_len = np.sum(distance_matrix[new_longest[:-1], new_longest[1:]])\n                new_shortest_len = np.sum(distance_matrix[new_shortest[:-1], new_shortest[1:]])\n\n                if (new_longest_len < old_longest_len or new_shortest_len < old_shortest_len):\n                    new_solution[longest_idx] = new_longest\n                    new_solution[shortest_idx] = new_shortest\n                    break\n\n    # Phase 2: Demand-aware clustering\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in new_solution:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    if missing_nodes:\n        # Cluster nodes by demand and proximity\n        nodes = list(missing_nodes)\n        demands = demand[nodes]\n        coords_nodes = coords[nodes]\n\n        # Simple k-means clustering with k=min(len(nodes), number of routes)\n        k = min(len(nodes), len(new_solution) + 1)\n        if k > 1:\n            centroids = coords_nodes[np.random.choice(len(nodes), k, replace=False)]\n            for _ in range(10):  # Simple clustering iterations\n                clusters = [[] for _ in range(k)]\n                for i, node in enumerate(nodes):\n                    distances = np.sum((coords_nodes[i] - centroids)**2, axis=1)\n                    clusters[np.argmin(distances)].append(node)\n\n                # Update centroids\n                new_centroids = []\n                for cluster in clusters:\n                    if cluster:\n                        new_centroids.append(np.mean(coords[cluster], axis=0))\n                    else:\n                        new_centroids.append(centroids[np.random.randint(k)])\n                centroids = np.array(new_centroids)\n\n            # Assign clusters to routes\n            for cluster in clusters:\n                if not cluster:\n                    continue\n                total_demand = np.sum(demand[cluster])\n                if total_demand > capacity:\n                    # Split cluster if demand exceeds capacity\n                    sorted_nodes = sorted(cluster, key=lambda x: demand[x], reverse=True)\n                    current_route = [0]\n                    current_demand = 0\n                    for node in sorted_nodes:\n                        if current_demand + demand[node] <= capacity:\n                            current_route.append(node)\n                            current_demand += demand[node]\n                        else:\n                            current_route.append(0)\n                            new_solution.append(np.array(current_route))\n                            current_route = [0, node]\n                            current_demand = demand[node]\n                    if len(current_route) > 1:\n                        current_route.append(0)\n                        new_solution.append(np.array(current_route))\n                else:\n                    # Find best route to insert cluster\n                    best_route_idx = -1\n                    best_insertion = None\n                    min_increase = float('inf')\n\n                    for i, route in enumerate(new_solution):\n                        if np.sum(demand[route[1:-1]]) + total_demand <= capacity:\n                            # Try inserting at different positions\n                            for pos in range(1, len(route)):\n                                new_route = np.concatenate([route[:pos], cluster, route[pos:]])\n                                new_len = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                                old_len = np.sum(distance_matrix[route[:-1], route[1:]])\n                                increase = new_len - old_len\n                                if increase < min_increase:\n                                    min_increase = increase\n                                    best_route_idx = i\n                                    best_insertion = new_route\n\n                    if best_route_idx != -1:\n                        new_solution[best_route_idx] = best_insertion\n                    else:\n                        # Create new route if no suitable existing route\n                        new_route = np.concatenate([[0], cluster, [0]])\n                        new_solution.append(new_route)\n\n    # Phase 3: Adaptive insertion\n    for _ in range(5):  # Multiple attempts to improve\n        for i, route in enumerate(new_solution):\n            if len(route) > 3:\n                # Select a random node to relocate\n                node_idx = random.randint(1, len(route) - 2)\n                node = route[node_idx]\n\n                # Find best position in same route\n                best_pos = node_idx\n                min_increase = 0\n                for pos in range(1, len(route)):\n                    if pos == node_idx or pos == node_idx + 1:\n                        continue\n                    new_route = np.concatenate([route[:node_idx], route[node_idx+1:]])\n                    new_route = np.insert(new_route, pos, node)\n                    new_len = np.sum(distance_matrix[new_route[:-1], new_route[1:]])\n                    old_len = np.sum(distance_matrix[route[:-1], route[1:]])\n                    increase = new_len - old_len\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                if best_pos != node_idx:\n                    new_route = np.concatenate([route[:node_idx], route[node_idx+1:]])\n                    new_route = np.insert(new_route, best_pos, node)\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.39525017131603535,
            9.216582030057907
        ]
    }
]