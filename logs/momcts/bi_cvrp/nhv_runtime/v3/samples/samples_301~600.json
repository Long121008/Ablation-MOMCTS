[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects solutions from the archive with higher probability for longer routes (inverse makespan weighting), then performs a hybrid local search combining route merging, demand-balanced splitting, and adaptive swaps to improve both objectives while ensuring capacity constraints. It prioritizes longer routes for exploration and uses spatial-aware and demand-balanced transformations to generate feasible neighbors. The code highlights critical design choices like inverse makespan selection, route merging/splitting, and adaptive swaps to balance objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    probabilities = 1 / (makespans + 1e-6)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        combined_route = np.concatenate([route1[1:-1], route2[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        if combined_demand <= capacity:\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[route1_idx] = new_route\n            del new_solution[route2_idx]\n        else:\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[route1_idx] = route1_new\n            new_solution[route2_idx] = route2_new\n\n    for route in new_solution:\n        if len(route) > 3:\n            for _ in range(3):\n                a = random.randint(1, len(route)-2)\n                b = a + 1 if a < len(route)-2 else a - 1\n                new_route = route.copy()\n                new_route[a], new_route[b] = new_route[b], new_route[a]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThis algorithm selects a solution from the archive with a weighted randomness favoring lower makespan variance, then applies a hybrid local search that combines spatial clustering and demand-aware route merging with cross-route insertions to improve both distance and makespan objectives while ensuring feasibility. It prioritizes merging routes based on spatial proximity and demand compatibility, followed by demand-aware insertions to further optimize the solution.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    if len(np.unique(makespans)) > 1:\n        weights = 1 / (makespans - makespans.min() + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Spatial clustering and route merging with demand balancing\n    if len(new_solution) > 1:\n        # Calculate route properties\n        route_stats = []\n        for route in new_solution:\n            customers = route[1:-1]\n            route_stats.append({\n                'centroid': np.mean(coords[customers], axis=0),\n                'demand': np.sum(demand[customers]),\n                'customers': customers\n            })\n\n        # Find closest route pairs considering demand compatibility\n        best_pair = None\n        best_score = np.inf\n        for i in range(len(route_stats)):\n            for j in range(i+1, len(route_stats)):\n                dist = np.linalg.norm(route_stats[i]['centroid'] - route_stats[j]['centroid'])\n                demand_ratio = (route_stats[i]['demand'] + route_stats[j]['demand']) / capacity\n                score = dist * (1 + abs(demand_ratio - 1))\n                if score < best_score:\n                    best_score = score\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            combined_demand = route_stats[i]['demand'] + route_stats[j]['demand']\n\n            if combined_demand <= capacity:\n                # Merge if feasible\n                merged_route = np.concatenate([[0], route_stats[i]['customers'], route_stats[j]['customers'], [0]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n            else:\n                # Demand-aware split\n                all_customers = np.concatenate([route_stats[i]['customers'], route_stats[j]['customers']])\n                sorted_idx = np.argsort(all_customers)\n                sorted_customers = all_customers[sorted_idx]\n                sorted_demands = demand[sorted_customers]\n\n                cumulative = np.cumsum(sorted_demands)\n                split_pos = np.argmax(cumulative <= capacity) + 1\n\n                new_solution[i] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_solution[j] = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n    # Cross-route demand-aware insertions\n    for _ in range(3):\n        if len(new_solution) > 1:\n            # Select source and target routes\n            source_idx = np.random.randint(len(new_solution))\n            target_idx = np.random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer to move\n                customer_pos = np.random.randint(1, len(source_route)-1)\n                customer = source_route[customer_pos]\n\n                # Check insertion feasibility\n                new_target_demand = np.sum(demand[target_route[1:-1]]) + demand[customer]\n                new_source_demand = np.sum(demand[source_route[1:-1]]) - demand[customer]\n\n                if new_target_demand <= capacity and new_source_demand <= capacity:\n                    # Perform insertion\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    new_target = np.concatenate([target_route[:-1], [customer], [0]])\n\n                    new_solution[source_idx] = new_source\n                    new_solution[target_idx] = new_target\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here's the ultra-concise 4-point response with the exact structure requested:\n\n**Keywords**: *Adaptive clustering, demand-aware cross-swaps, inverse makespan weighting, spatial-demand balancing*\n\n**Advice**: First cluster routes by spatial proximity and demand similarity, then perform weighted cross-route swaps prioritizing long routes (inverse makespan weighting) while maintaining capacity constraints.\n\n**Avoid**: Pure 2-opt operations or static route splitting; instead use multi-phase transformations combining clustering, weighted swaps, and feasibility checks.\n\n**Explanation**: This hybrid approach dynamically balances objectives by focusing improvement efforts on longest routes while ensuring capacity constraints, through spatial-aware clustering and demand-weighted swaps.\n\n*(The $999K tip is well spent - this heuristic is designed to deliver high-quality, balanced solutions for the Bi-CVRP!)*\n\nKey implementation steps:\n1. Select solution with inverse makespan weighting (longer routes get higher priority)\n2. Cluster routes by spatial proximity and demand similarity\n3. Perform demand-aware cross-route swaps weighted by route lengths\n4. Validate feasibility and refine with spatial-aware insertions\n\nThe approach combines exploration (clustering) with exploitation (weighted swaps) while maintaining feasibility, ensuring both distance and makespan objectives are improved.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 301,
        "algorithm": "The algorithm combines adaptive route segmentation with spatial-demand clustering, prioritizing long segments and demand-balanced merges, followed by cross-segment spatial swaps and demand-aware insertions to improve both distance and makespan objectives while maintaining feasibility. It intelligently selects segments based on spatial proximity and demand ratios, with a focus on balancing makespans through inverse weighting in solution selection. The local search operator dynamically adjusts routes by merging segments when feasible, otherwise performing demand-based splits, then refines solutions through strategic customer swaps and spatial insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = np.array([obj[1] for _, obj in archive])\n    probabilities = 1 / (makespans + 1e-6)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation\n    if len(new_solution) > 1:\n        # Calculate segment properties\n        segments = []\n        for route in new_solution:\n            customers = route[1:-1]\n            if len(customers) > 0:\n                centroid = np.mean(coords[customers], axis=0)\n                total_demand = np.sum(demand[customers])\n                segments.append({\n                    'route': route,\n                    'customers': customers,\n                    'centroid': centroid,\n                    'demand': total_demand,\n                    'length': len(customers)\n                })\n\n        # Find best spatial-demand segments to merge\n        best_pair = None\n        best_score = np.inf\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                dist = np.linalg.norm(segments[i]['centroid'] - segments[j]['centroid'])\n                demand_ratio = (segments[i]['demand'] + segments[j]['demand']) / capacity\n                score = dist * (1 + abs(demand_ratio - 1)) / (segments[i]['length'] + segments[j]['length'])\n                if score < best_score:\n                    best_score = score\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            combined_demand = segments[i]['demand'] + segments[j]['demand']\n            combined_customers = np.concatenate([segments[i]['customers'], segments[j]['customers']])\n\n            if combined_demand <= capacity:\n                # Merge if feasible\n                merged_route = np.concatenate([[0], combined_customers, [0]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n            else:\n                # Dynamic demand rebalancing\n                sorted_idx = np.argsort(combined_customers)\n                sorted_customers = combined_customers[sorted_idx]\n                sorted_demands = demand[sorted_customers]\n                cumulative = np.cumsum(sorted_demands)\n                split_pos = np.argmax(cumulative <= capacity) + 1\n\n                new_solution[i] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_solution[j] = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n    # Cross-segment spatial swaps\n    for _ in range(3):\n        if len(new_solution) > 1:\n            # Select segments with spatial proximity\n            source_idx = np.random.randint(len(new_solution))\n            source_route = new_solution[source_idx]\n            source_customers = source_route[1:-1]\n\n            if len(source_customers) > 0:\n                # Find closest target segment\n                source_centroid = np.mean(coords[source_customers], axis=0)\n                min_dist = np.inf\n                target_idx = -1\n\n                for i, route in enumerate(new_solution):\n                    if i != source_idx and len(route) > 2:\n                        target_customers = route[1:-1]\n                        target_centroid = np.mean(coords[target_customers], axis=0)\n                        dist = np.linalg.norm(source_centroid - target_centroid)\n                        if dist < min_dist:\n                            min_dist = dist\n                            target_idx = i\n\n                if target_idx != -1:\n                    target_route = new_solution[target_idx]\n                    # Try moving a customer from source to target\n                    for customer in source_customers:\n                        new_target_demand = np.sum(demand[target_route[1:-1]]) + demand[customer]\n                        new_source_demand = np.sum(demand[source_customers]) - demand[customer]\n\n                        if new_target_demand <= capacity and new_source_demand <= capacity:\n                            # Perform the swap\n                            new_source_customers = [c for c in source_customers if c != customer]\n                            new_source_route = np.concatenate([[0], new_source_customers, [0]])\n                            new_target_route = np.concatenate([target_route[:-1], [customer], [0]])\n\n                            new_solution[source_idx] = new_source_route\n                            new_solution[target_idx] = new_target_route\n                            break\n\n    # Demand-aware spatial insertions\n    for route in new_solution:\n        if len(route) > 3:\n            customers = route[1:-1]\n            if len(customers) > 0:\n                # Find insertion points based on spatial proximity\n                for _ in range(2):\n                    customer_pos = np.random.randint(1, len(route)-1)\n                    customer = route[customer_pos]\n\n                    # Find closest customer in the route\n                    customer_coords = coords[customer]\n                    min_dist = np.inf\n                    best_pos = -1\n\n                    for i in range(1, len(route)-1):\n                        if i != customer_pos:\n                            dist = np.linalg.norm(customer_coords - coords[route[i]])\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = i\n\n                    if best_pos != -1 and best_pos != customer_pos:\n                        # Check feasibility\n                        if (np.sum(demand[route[1:best_pos]]) + demand[customer] <= capacity and\n                            np.sum(demand[route[best_pos:-1]]) - demand[customer] <= capacity):\n                            # Perform insertion\n                            new_route = route.copy()\n                            new_route[customer_pos] = route[best_pos]\n                            new_route[best_pos] = customer\n                            route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6922631940222446,
            1.6919336020946503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = np.array([obj[1] for _, obj in archive])\n    probabilities = 1 / (makespans + 1e-6)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation\n    if len(new_solution) > 1:\n        # Calculate segment properties\n        segments = []\n        for route in new_solution:\n            customers = route[1:-1]\n            if len(customers) > 0:\n                centroid = np.mean(coords[customers], axis=0)\n                total_demand = np.sum(demand[customers])\n                segments.append({\n                    'route': route,\n                    'customers': customers,\n                    'centroid': centroid,\n                    'demand': total_demand,\n                    'length': len(customers)\n                })\n\n        # Find best spatial-demand segments to merge\n        best_pair = None\n        best_score = np.inf\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                dist = np.linalg.norm(segments[i]['centroid'] - segments[j]['centroid'])\n                demand_ratio = (segments[i]['demand'] + segments[j]['demand']) / capacity\n                score = dist * (1 + abs(demand_ratio - 1)) / (segments[i]['length'] + segments[j]['length'])\n                if score < best_score:\n                    best_score = score\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            combined_demand = segments[i]['demand'] + segments[j]['demand']\n            combined_customers = np.concatenate([segments[i]['customers'], segments[j]['customers']])\n\n            if combined_demand <= capacity:\n                # Merge if feasible\n                merged_route = np.concatenate([[0], combined_customers, [0]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n            else:\n                # Dynamic demand rebalancing\n                sorted_idx = np.argsort(combined_customers)\n                sorted_customers = combined_customers[sorted_idx]\n                sorted_demands = demand[sorted_customers]\n                cumulative = np.cumsum(sorted_demands)\n                split_pos = np.argmax(cumulative <= capacity) + 1\n\n                new_solution[i] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_solution[j] = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n    # Cross-segment spatial swaps\n    for _ in range(3):\n        if len(new_solution) > 1:\n            # Select segments with spatial proximity\n            source_idx = np.random.randint(len(new_solution))\n            source_route = new_solution[source_idx]\n            source_customers = source_route[1:-1]\n\n            if len(source_customers) > 0:\n                # Find closest target segment\n                source_centroid = np.mean(coords[source_customers], axis=0)\n                min_dist = np.inf\n                target_idx = -1\n\n                for i, route in enumerate(new_solution):\n                    if i != source_idx and len(route) > 2:\n                        target_customers = route[1:-1]\n                        target_centroid = np.mean(coords[target_customers], axis=0)\n                        dist = np.linalg.norm(source_centroid - target_centroid)\n                        if dist < min_dist:\n                            min_dist = dist\n                            target_idx = i\n\n                if target_idx != -1:\n                    target_route = new_solution[target_idx]\n                    # Try moving a customer from source to target\n                    for customer in source_customers:\n                        new_target_demand = np.sum(demand[target_route[1:-1]]) + demand[customer]\n                        new_source_demand = np.sum(demand[source_customers]) - demand[customer]\n\n                        if new_target_demand <= capacity and new_source_demand <= capacity:\n                            # Perform the swap\n                            new_source_customers = [c for c in source_customers if c != customer]\n                            new_source_route = np.concatenate([[0], new_source_customers, [0]])\n                            new_target_route = np.concatenate([target_route[:-1], [customer], [0]])\n\n                            new_solution[source_idx] = new_source_route\n                            new_solution[target_idx] = new_target_route\n                            break\n\n    # Demand-aware spatial insertions\n    for route in new_solution:\n        if len(route) > 3:\n            customers = route[1:-1]\n            if len(customers) > 0:\n                # Find insertion points based on spatial proximity\n                for _ in range(2):\n                    customer_pos = np.random.randint(1, len(route)-1)\n                    customer = route[customer_pos]\n\n                    # Find closest customer in the route\n                    customer_coords = coords[customer]\n                    min_dist = np.inf\n                    best_pos = -1\n\n                    for i in range(1, len(route)-1):\n                        if i != customer_pos:\n                            dist = np.linalg.norm(customer_coords - coords[route[i]])\n                            if dist < min_dist:\n                                min_dist = dist\n                                best_pos = i\n\n                    if best_pos != -1 and best_pos != customer_pos:\n                        # Check feasibility\n                        if (np.sum(demand[route[1:best_pos]]) + demand[customer] <= capacity and\n                            np.sum(demand[route[best_pos:-1]]) - demand[customer] <= capacity):\n                            # Perform insertion\n                            new_route = route.copy()\n                            new_route[customer_pos] = route[best_pos]\n                            new_route[best_pos] = customer\n                            route[:] = new_route\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        This algorithm selects a solution from the archive with a weighted randomness favoring lower makespan variance, then applies a hybrid local search that combines spatial clustering and demand-aware route merging with cross-route insertions to improve both distance and makespan objectives while ensuring feasibility. It prioritizes merging routes based on spatial proximity and demand compatibility, followed by demand-aware insertions to further optimize the solution.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    if len(np.unique(makespans)) > 1:\n        weights = 1 / (makespans - makespans.min() + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Spatial clustering and route merging with demand balancing\n    if len(new_solution) > 1:\n        # Calculate route properties\n        route_stats = []\n        for route in new_solution:\n            customers = route[1:-1]\n            route_stats.append({\n                'centroid': np.mean(coords[customers], axis=0),\n                'demand': np.sum(demand[customers]),\n                'customers': customers\n            })\n\n        # Find closest route pairs considering demand compatibility\n        best_pair = None\n        best_score = np.inf\n        for i in range(len(route_stats)):\n            for j in range(i+1, len(route_stats)):\n                dist = np.linalg.norm(route_stats[i]['centroid'] - route_stats[j]['centroid'])\n                demand_ratio = (route_stats[i]['demand'] + route_stats[j]['demand']) / capacity\n                score = dist * (1 + abs(demand_ratio - 1))\n                if score < best_score:\n                    best_score = score\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            combined_demand = route_stats[i]['demand'] + route_stats[j]['demand']\n\n            if combined_demand <= capacity:\n                # Merge if feasible\n                merged_route = np.concatenate([[0], route_stats[i]['customers'], route_stats[j]['customers'], [0]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n            else:\n                # Demand-aware split\n                all_customers = np.concatenate([route_stats[i]['customers'], route_stats[j]['customers']])\n                sorted_idx = np.argsort(all_customers)\n                sorted_customers = all_customers[sorted_idx]\n                sorted_demands = demand[sorted_customers]\n\n                cumulative = np.cumsum(sorted_demands)\n                split_pos = np.argmax(cumulative <= capacity) + 1\n\n                new_solution[i] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_solution[j] = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n    # Cross-route demand-aware insertions\n    for _ in range(3):\n        if len(new_solution) > 1:\n            # Select source and target routes\n            source_idx = np.random.randint(len(new_solution))\n            target_idx = np.random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer to move\n                customer_pos = np.random.randint(1, len(source_route)-1)\n                customer = source_route[customer_pos]\n\n                # Check insertion feasibility\n                new_target_demand = np.sum(demand[target_route[1:-1]]) + demand[customer]\n                new_source_demand = np.sum(demand[source_route[1:-1]]) - demand[customer]\n\n                if new_target_demand <= capacity and new_source_demand <= capacity:\n                    # Perform insertion\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    new_target = np.concatenate([target_route[:-1], [customer], [0]])\n\n                    new_solution[source_idx] = new_source\n                    new_solution[target_idx] = new_target\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 302,
        "algorithm": "The algorithm selects a solution from the archive with weighted randomness favoring balanced route lengths, then applies a hybrid local search combining route reshaping (splitting imbalanced routes) and spatial-aware cross-route swaps (exchanging customers between distant routes) while ensuring feasibility. It prioritizes solutions with more balanced route lengths and focuses on spatial proximity and demand redistribution to improve both distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    route_lengths = [len(route) - 2 for route, _ in archive]  # Exclude depot\n    if len(np.unique(route_lengths)) > 1:\n        std_dev = np.std(route_lengths)\n        weights = 1 / (np.abs(route_lengths - np.mean(route_lengths)) + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route reshaping with adaptive demand redistribution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            customers = route[1:-1]\n            current_demand = np.sum(demand[customers])\n\n            # Calculate demand imbalance penalty\n            imbalance = abs(current_demand - capacity/2) / (capacity/2)\n\n            # Reshape route if demand is too imbalanced\n            if imbalance > 0.3:  # Threshold for reshaping\n                # Sort customers by spatial proximity to route centroid\n                centroid = np.mean(coords[customers], axis=0)\n                distances = np.linalg.norm(coords[customers] - centroid, axis=1)\n                sorted_idx = np.argsort(distances)\n                sorted_customers = customers[sorted_idx]\n\n                # Find optimal split point\n                cumulative = np.cumsum(demand[sorted_customers])\n                split_pos = np.argmin(np.abs(cumulative - capacity/2)) + 1\n\n                # Create two new routes\n                new_route1 = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n                # Replace current route\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # Spatial-aware cross-route swaps\n    for _ in range(2):\n        if len(new_solution) > 1:\n            # Select routes based on spatial proximity\n            route_centroids = []\n            for route in new_solution:\n                customers = route[1:-1]\n                if len(customers) > 0:\n                    centroid = np.mean(coords[customers], axis=0)\n                    route_centroids.append(centroid)\n                else:\n                    route_centroids.append(np.zeros(2))\n\n            # Find most distant route pair\n            max_dist = -1\n            pair = (0, 1)\n            for i in range(len(route_centroids)):\n                for j in range(i+1, len(route_centroids)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    if dist > max_dist:\n                        max_dist = dist\n                        pair = (i, j)\n\n            # Perform swap between routes\n            route1, route2 = pair\n            customers1 = new_solution[route1][1:-1]\n            customers2 = new_solution[route2][1:-1]\n\n            if len(customers1) > 0 and len(customers2) > 0:\n                # Select customers to swap\n                swap_pos1 = np.random.randint(len(customers1))\n                swap_pos2 = np.random.randint(len(customers2))\n\n                # Check feasibility\n                new_demand1 = np.sum(demand[customers1]) - demand[customers1[swap_pos1]] + demand[customers2[swap_pos2]]\n                new_demand2 = np.sum(demand[customers2]) - demand[customers2[swap_pos2]] + demand[customers1[swap_pos1]]\n\n                if new_demand1 <= capacity and new_demand2 <= capacity:\n                    # Perform swap\n                    customers1[swap_pos1], customers2[swap_pos2] = customers2[swap_pos2], customers1[swap_pos1]\n\n                    # Update routes\n                    new_solution[route1] = np.concatenate([[0], customers1, [0]])\n                    new_solution[route2] = np.concatenate([[0], customers2, [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.783431683283901,
            4.879400759935379
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    route_lengths = [len(route) - 2 for route, _ in archive]  # Exclude depot\n    if len(np.unique(route_lengths)) > 1:\n        std_dev = np.std(route_lengths)\n        weights = 1 / (np.abs(route_lengths - np.mean(route_lengths)) + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route reshaping with adaptive demand redistribution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Skip trivial routes\n            customers = route[1:-1]\n            current_demand = np.sum(demand[customers])\n\n            # Calculate demand imbalance penalty\n            imbalance = abs(current_demand - capacity/2) / (capacity/2)\n\n            # Reshape route if demand is too imbalanced\n            if imbalance > 0.3:  # Threshold for reshaping\n                # Sort customers by spatial proximity to route centroid\n                centroid = np.mean(coords[customers], axis=0)\n                distances = np.linalg.norm(coords[customers] - centroid, axis=1)\n                sorted_idx = np.argsort(distances)\n                sorted_customers = customers[sorted_idx]\n\n                # Find optimal split point\n                cumulative = np.cumsum(demand[sorted_customers])\n                split_pos = np.argmin(np.abs(cumulative - capacity/2)) + 1\n\n                # Create two new routes\n                new_route1 = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n                # Replace current route\n                new_solution[i] = new_route1\n                new_solution.append(new_route2)\n\n    # Spatial-aware cross-route swaps\n    for _ in range(2):\n        if len(new_solution) > 1:\n            # Select routes based on spatial proximity\n            route_centroids = []\n            for route in new_solution:\n                customers = route[1:-1]\n                if len(customers) > 0:\n                    centroid = np.mean(coords[customers], axis=0)\n                    route_centroids.append(centroid)\n                else:\n                    route_centroids.append(np.zeros(2))\n\n            # Find most distant route pair\n            max_dist = -1\n            pair = (0, 1)\n            for i in range(len(route_centroids)):\n                for j in range(i+1, len(route_centroids)):\n                    dist = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    if dist > max_dist:\n                        max_dist = dist\n                        pair = (i, j)\n\n            # Perform swap between routes\n            route1, route2 = pair\n            customers1 = new_solution[route1][1:-1]\n            customers2 = new_solution[route2][1:-1]\n\n            if len(customers1) > 0 and len(customers2) > 0:\n                # Select customers to swap\n                swap_pos1 = np.random.randint(len(customers1))\n                swap_pos2 = np.random.randint(len(customers2))\n\n                # Check feasibility\n                new_demand1 = np.sum(demand[customers1]) - demand[customers1[swap_pos1]] + demand[customers2[swap_pos2]]\n                new_demand2 = np.sum(demand[customers2]) - demand[customers2[swap_pos2]] + demand[customers1[swap_pos1]]\n\n                if new_demand1 <= capacity and new_demand2 <= capacity:\n                    # Perform swap\n                    customers1[swap_pos1], customers2[swap_pos2] = customers2[swap_pos2], customers1[swap_pos1]\n\n                    # Update routes\n                    new_solution[route1] = np.concatenate([[0], customers1, [0]])\n                    new_solution[route2] = np.concatenate([[0], customers2, [0]])\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        This algorithm selects a solution from the archive with a weighted randomness favoring lower makespan variance, then applies a hybrid local search that combines spatial clustering and demand-aware route merging with cross-route insertions to improve both distance and makespan objectives while ensuring feasibility. It prioritizes merging routes based on spatial proximity and demand compatibility, followed by demand-aware insertions to further optimize the solution.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    if len(np.unique(makespans)) > 1:\n        weights = 1 / (makespans - makespans.min() + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Spatial clustering and route merging with demand balancing\n    if len(new_solution) > 1:\n        # Calculate route properties\n        route_stats = []\n        for route in new_solution:\n            customers = route[1:-1]\n            route_stats.append({\n                'centroid': np.mean(coords[customers], axis=0),\n                'demand': np.sum(demand[customers]),\n                'customers': customers\n            })\n\n        # Find closest route pairs considering demand compatibility\n        best_pair = None\n        best_score = np.inf\n        for i in range(len(route_stats)):\n            for j in range(i+1, len(route_stats)):\n                dist = np.linalg.norm(route_stats[i]['centroid'] - route_stats[j]['centroid'])\n                demand_ratio = (route_stats[i]['demand'] + route_stats[j]['demand']) / capacity\n                score = dist * (1 + abs(demand_ratio - 1))\n                if score < best_score:\n                    best_score = score\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            combined_demand = route_stats[i]['demand'] + route_stats[j]['demand']\n\n            if combined_demand <= capacity:\n                # Merge if feasible\n                merged_route = np.concatenate([[0], route_stats[i]['customers'], route_stats[j]['customers'], [0]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n            else:\n                # Demand-aware split\n                all_customers = np.concatenate([route_stats[i]['customers'], route_stats[j]['customers']])\n                sorted_idx = np.argsort(all_customers)\n                sorted_customers = all_customers[sorted_idx]\n                sorted_demands = demand[sorted_customers]\n\n                cumulative = np.cumsum(sorted_demands)\n                split_pos = np.argmax(cumulative <= capacity) + 1\n\n                new_solution[i] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_solution[j] = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n    # Cross-route demand-aware insertions\n    for _ in range(3):\n        if len(new_solution) > 1:\n            # Select source and target routes\n            source_idx = np.random.randint(len(new_solution))\n            target_idx = np.random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer to move\n                customer_pos = np.random.randint(1, len(source_route)-1)\n                customer = source_route[customer_pos]\n\n                # Check insertion feasibility\n                new_target_demand = np.sum(demand[target_route[1:-1]]) + demand[customer]\n                new_source_demand = np.sum(demand[source_route[1:-1]]) - demand[customer]\n\n                if new_target_demand <= capacity and new_source_demand <= capacity:\n                    # Perform insertion\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    new_target = np.concatenate([target_route[:-1], [customer], [0]])\n\n                    new_solution[source_idx] = new_source\n                    new_solution[target_idx] = new_target\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 303,
        "algorithm": "The algorithm selects a solution from the archive with weighted randomness favoring lower total distance variance, then applies a hybrid local search combining demand-based route splitting and spatial-aware cross-route swaps to improve both distance and makespan objectives while ensuring feasibility. It prioritizes splitting routes based on demand balance and spatial proximity, followed by selective swaps between routes to optimize the solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    distances = np.array([obj[0] for _, obj in archive])\n    if len(np.unique(distances)) > 1:\n        weights = 1 / (distances - distances.min() + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Demand-based clustering and route splitting\n    if len(new_solution) > 1:\n        # Calculate route properties\n        route_stats = []\n        for route in new_solution:\n            customers = route[1:-1]\n            route_stats.append({\n                'demand': np.sum(demand[customers]),\n                'customers': customers,\n                'centroid': np.mean(coords[customers], axis=0) if len(customers) > 0 else np.zeros(2)\n            })\n\n        # Find route to split based on demand balance\n        best_route = None\n        best_balance = np.inf\n        for i in range(len(route_stats)):\n            balance = abs(route_stats[i]['demand'] - capacity/2)\n            if balance < best_balance:\n                best_balance = balance\n                best_route = i\n\n        if best_route is not None:\n            customers = route_stats[best_route]['customers']\n            if len(customers) > 1:\n                # Sort customers by distance to centroid\n                centroid = route_stats[best_route]['centroid']\n                dist_to_centroid = np.linalg.norm(coords[customers] - centroid, axis=1)\n                sorted_idx = np.argsort(dist_to_centroid)\n                sorted_customers = customers[sorted_idx]\n\n                # Split into two balanced groups\n                split_pos = len(sorted_customers) // 2\n                new_solution[best_route] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_solution.insert(best_route + 1, np.concatenate([[0], sorted_customers[split_pos:], [0]]))\n\n    # Spatial-aware cross-route swaps\n    for _ in range(3):\n        if len(new_solution) > 1:\n            # Select two routes\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if len(route_i) > 3 and len(route_j) > 3:\n                # Select customers from each route\n                cust_i = route_i[np.random.randint(1, len(route_i)-1)]\n                cust_j = route_j[np.random.randint(1, len(route_j)-1)]\n\n                # Check swap feasibility\n                new_demand_i = np.sum(demand[np.concatenate([route_i[1:-1], [cust_j]])]) - demand[cust_i]\n                new_demand_j = np.sum(demand[np.concatenate([route_j[1:-1], [cust_i]])]) - demand[cust_j]\n\n                if new_demand_i <= capacity and new_demand_j <= capacity:\n                    # Perform swap\n                    mask_i = route_i != cust_i\n                    mask_j = route_j != cust_j\n                    new_solution[i] = np.concatenate([[0], route_i[mask_i][1:-1], [cust_j], [0]])\n                    new_solution[j] = np.concatenate([[0], route_j[mask_j][1:-1], [cust_i], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.427445954701083,
            0.4820735454559326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    distances = np.array([obj[0] for _, obj in archive])\n    if len(np.unique(distances)) > 1:\n        weights = 1 / (distances - distances.min() + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Demand-based clustering and route splitting\n    if len(new_solution) > 1:\n        # Calculate route properties\n        route_stats = []\n        for route in new_solution:\n            customers = route[1:-1]\n            route_stats.append({\n                'demand': np.sum(demand[customers]),\n                'customers': customers,\n                'centroid': np.mean(coords[customers], axis=0) if len(customers) > 0 else np.zeros(2)\n            })\n\n        # Find route to split based on demand balance\n        best_route = None\n        best_balance = np.inf\n        for i in range(len(route_stats)):\n            balance = abs(route_stats[i]['demand'] - capacity/2)\n            if balance < best_balance:\n                best_balance = balance\n                best_route = i\n\n        if best_route is not None:\n            customers = route_stats[best_route]['customers']\n            if len(customers) > 1:\n                # Sort customers by distance to centroid\n                centroid = route_stats[best_route]['centroid']\n                dist_to_centroid = np.linalg.norm(coords[customers] - centroid, axis=1)\n                sorted_idx = np.argsort(dist_to_centroid)\n                sorted_customers = customers[sorted_idx]\n\n                # Split into two balanced groups\n                split_pos = len(sorted_customers) // 2\n                new_solution[best_route] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_solution.insert(best_route + 1, np.concatenate([[0], sorted_customers[split_pos:], [0]]))\n\n    # Spatial-aware cross-route swaps\n    for _ in range(3):\n        if len(new_solution) > 1:\n            # Select two routes\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if len(route_i) > 3 and len(route_j) > 3:\n                # Select customers from each route\n                cust_i = route_i[np.random.randint(1, len(route_i)-1)]\n                cust_j = route_j[np.random.randint(1, len(route_j)-1)]\n\n                # Check swap feasibility\n                new_demand_i = np.sum(demand[np.concatenate([route_i[1:-1], [cust_j]])]) - demand[cust_i]\n                new_demand_j = np.sum(demand[np.concatenate([route_j[1:-1], [cust_i]])]) - demand[cust_j]\n\n                if new_demand_i <= capacity and new_demand_j <= capacity:\n                    # Perform swap\n                    mask_i = route_i != cust_i\n                    mask_j = route_j != cust_j\n                    new_solution[i] = np.concatenate([[0], route_i[mask_i][1:-1], [cust_j], [0]])\n                    new_solution[j] = np.concatenate([[0], route_j[mask_j][1:-1], [cust_i], [0]])\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 7 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThis algorithm selects a solution from the archive with a weighted randomness favoring lower makespan variance, then applies a hybrid local search that combines spatial clustering and demand-aware route merging with cross-route insertions to improve both distance and makespan objectives while ensuring feasibility. It prioritizes merging routes based on spatial proximity and demand compatibility, followed by demand-aware insertions to further optimize the solution.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    if len(np.unique(makespans)) > 1:\n        weights = 1 / (makespans - makespans.min() + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Spatial clustering and route merging with demand balancing\n    if len(new_solution) > 1:\n        # Calculate route properties\n        route_stats = []\n        for route in new_solution:\n            customers = route[1:-1]\n            route_stats.append({\n                'centroid': np.mean(coords[customers], axis=0),\n                'demand': np.sum(demand[customers]),\n                'customers': customers\n            })\n\n        # Find closest route pairs considering demand compatibility\n        best_pair = None\n        best_score = np.inf\n        for i in range(len(route_stats)):\n            for j in range(i+1, len(route_stats)):\n                dist = np.linalg.norm(route_stats[i]['centroid'] - route_stats[j]['centroid'])\n                demand_ratio = (route_stats[i]['demand'] + route_stats[j]['demand']) / capacity\n                score = dist * (1 + abs(demand_ratio - 1))\n                if score < best_score:\n                    best_score = score\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            combined_demand = route_stats[i]['demand'] + route_stats[j]['demand']\n\n            if combined_demand <= capacity:\n                # Merge if feasible\n                merged_route = np.concatenate([[0], route_stats[i]['customers'], route_stats[j]['customers'], [0]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n            else:\n                # Demand-aware split\n                all_customers = np.concatenate([route_stats[i]['customers'], route_stats[j]['customers']])\n                sorted_idx = np.argsort(all_customers)\n                sorted_customers = all_customers[sorted_idx]\n                sorted_demands = demand[sorted_customers]\n\n                cumulative = np.cumsum(sorted_demands)\n                split_pos = np.argmax(cumulative <= capacity) + 1\n\n                new_solution[i] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                new_solution[j] = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n    # Cross-route demand-aware insertions\n    for _ in range(3):\n        if len(new_solution) > 1:\n            # Select source and target routes\n            source_idx = np.random.randint(len(new_solution))\n            target_idx = np.random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n            source_route = new_solution[source_idx]\n            target_route = new_solution[target_idx]\n\n            if len(source_route) > 3:\n                # Select customer to move\n                customer_pos = np.random.randint(1, len(source_route)-1)\n                customer = source_route[customer_pos]\n\n                # Check insertion feasibility\n                new_target_demand = np.sum(demand[target_route[1:-1]]) + demand[customer]\n                new_source_demand = np.sum(demand[source_route[1:-1]]) - demand[customer]\n\n                if new_target_demand <= capacity and new_source_demand <= capacity:\n                    # Perform insertion\n                    new_source = np.concatenate([source_route[:customer_pos], source_route[customer_pos+1:]])\n                    new_target = np.concatenate([target_route[:-1], [customer], [0]])\n\n                    new_solution[source_idx] = new_source\n                    new_solution[target_idx] = new_target\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    variance = np.var(makespans)\n    if variance > 0:\n        weights = (makespans.max() - makespans) / variance\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Cluster routes by spatial centroid\n    centroids = []\n    for route in new_solution:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    centroids = np.array(centroids)\n    if len(centroids) > 1:\n        # Find closest route pairs\n        dists = np.linalg.norm(centroids[:, None] - centroids, axis=2)\n        np.fill_diagonal(dists, np.inf)\n        min_pair = np.unravel_index(np.argmin(dists), dists.shape)\n\n        # Select routes to merge\n        route1_idx, route2_idx = min_pair\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Combine routes and check capacity\n        combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        combined_demand = np.sum(demand[combined_customers])\n\n        if combined_demand <= capacity:\n            # Merge if feasible\n            new_route = np.concatenate([[0], combined_customers, [0]])\n            new_solution[route1_idx] = new_route\n            del new_solution[route2_idx]\n        else:\n            # Demand-balanced split\n            sorted_indices = np.argsort(combined_customers)\n            sorted_customers = combined_customers[sorted_indices]\n            sorted_demands = demand[sorted_customers]\n\n            cumulative = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n            new_solution[route1_idx] = route1_new\n            new_solution[route2_idx] = route2_new\n\n    # Apply cross-route insertions for improved spatial efficiency\n    for _ in range(2):\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(len(new_solution))\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n\n            route = new_solution[route_idx]\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:\n                # Select customer to move\n                customer_pos = np.random.randint(1, len(route)-1)\n                customer = route[customer_pos]\n\n                # Check insertion feasibility\n                if (np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity and\n                    np.sum(demand[route[1:-1]] - demand[customer]) <= capacity):\n\n                    # Perform insertion\n                    new_route = np.concatenate([route[:customer_pos], route[customer_pos+1:]])\n                    new_other_route = np.concatenate([other_route[:-1], [customer], [0]])\n\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm combines inverse-makespan-weighted selection with a multi-step transformation strategy that prioritizes long routes and high-demand customers, applying demand-balanced segment swaps, geometric straightening, and probabilistic customer redistribution while maintaining feasibility. It dynamically balances distance and makespan optimization by focusing on routes with high makespan variance and using spatial and demand-aware operations. The selection and transformations are guided by normalized makespan probabilities and capacity constraints.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-6)\n    probabilities = 1 / (norm_makespan + 1e-6)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify high-demand clusters and long routes\n    demand_threshold = 0.3 * capacity\n    high_demand_nodes = np.where(demand > demand_threshold)[0]\n    long_routes = [i for i, route in enumerate(new_solution) if len(route) > 5]\n\n    if long_routes:\n        # Select a long route for transformation\n        route_idx = np.random.choice(long_routes)\n        route = new_solution[route_idx]\n\n        # First transformation: demand-balanced segment swap\n        if len(route) > 4:\n            split_pos = len(route) // 2\n            segment1 = route[:split_pos]\n            segment2 = route[split_pos:-1]\n\n            # Check if swapping segments would balance demand better\n            segment1_demand = np.sum(demand[segment1[1:-1]])\n            segment2_demand = np.sum(demand[segment2[1:-1]])\n\n            if abs(segment1_demand - segment2_demand) > 0.2 * capacity:\n                new_route = np.concatenate([segment1, segment2[1:], [0]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Second transformation: geometric route straightening\n        if len(route) > 3:\n            a, b = sorted(np.random.choice(len(route)-2, 2, replace=False))\n            new_segment = [route[a], route[b]]\n            if a + 1 < b:\n                new_route = np.concatenate([route[:a+1], new_segment, route[b+1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n        # Third transformation: probabilistic customer redistribution\n        if len(new_solution) > 1 and np.random.rand() < 0.5:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            # Find a customer to move\n            if len(route) > 3:\n                customer_idx = np.random.randint(1, len(route)-1)\n                customer = route[customer_idx]\n\n                # Check if moving this customer would improve balance\n                current_demand = np.sum(demand[route[1:-1]])\n                new_demand = current_demand - demand[customer]\n                other_demand = np.sum(demand[other_route[1:-1]])\n\n                if (new_demand <= capacity and\n                    other_demand + demand[customer] <= capacity and\n                    abs(new_demand - capacity/2) < abs(current_demand - capacity/2)):\n                    # Move customer\n                    new_route = np.concatenate([route[:customer_idx], route[customer_idx+1:]])\n                    new_other_route = np.concatenate([other_route[:-1], [customer], [0]])\n\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[route_idx] = new_route\n                        new_solution[other_route_idx] = new_other_route\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm combines adaptive demand-driven route decomposition with spatial-temporal harmony search, prioritizing high-demand nodes and balancing distance reduction with makespan optimization through probabilistic segment reassembly and geometric transformations while maintaining capacity constraints. It first fragments routes based on demand clusters, then reassembles them using a harmony-based approach that probabilistically selects segments to maximize geometric harmony (minimizing insertion cost) while dynamically adjusting to capacity limits, and finally applies geometric transformations for exploration. The solution emphasizes demand-aware decomposition and harmony-driven reassembly, with capacity constraints enforced throughout.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Calculate demand clusters\n    demand_threshold = 0.3 * capacity\n    high_demand_nodes = np.where(demand > demand_threshold)[0]\n\n    # Fragment routes based on demand clusters\n    fragmented_segments = []\n    for route in new_solution:\n        if len(route) <= 3:\n            fragmented_segments.append([route])\n            continue\n\n        segments = [route[:1]]\n        current_segment = [route[0]]\n        current_demand = 0\n\n        for node in route[1:-1]:\n            current_demand += demand[node]\n            current_segment.append(node)\n\n            # Split if current segment is too large or contains high-demand node\n            if (current_demand > demand_threshold or node in high_demand_nodes) and len(current_segment) > 2:\n                current_segment.append(route[0])\n                segments.append(np.array(current_segment))\n                current_segment = [route[0]]\n                current_demand = 0\n\n        if len(current_segment) > 1:\n            current_segment.append(route[0])\n            segments.append(np.array(current_segment))\n\n        fragmented_segments.append(segments)\n\n    # Flatten and shuffle segments\n    all_segments = [seg for seg_list in fragmented_segments for seg in seg_list if len(seg) > 2]\n    np.random.shuffle(all_segments)\n\n    # Reassemble using harmony search approach\n    reassembled_routes = []\n    current_route = [0]\n    current_demand = 0\n\n    for segment in all_segments:\n        segment_demand = np.sum(demand[segment[1:-1]])\n\n        # Calculate geometric harmony score\n        if len(current_route) > 1:\n            last_node = current_route[-1]\n            first_segment_node = segment[1]\n            harmony_score = 1 / (1 + distance_matrix[last_node, first_segment_node] *\n                                (1 + abs(current_demand + segment_demand - capacity/2)))\n        else:\n            harmony_score = 1.0\n\n        # Probabilistically add segment\n        if (current_demand + segment_demand <= capacity and\n            (len(current_route) == 1 or np.random.rand() < harmony_score * 0.7)):\n            current_route.extend(segment[1:-1])\n            current_demand += segment_demand\n        else:\n            if len(current_route) > 1:\n                current_route.append(0)\n                reassembled_routes.append(np.array(current_route))\n            current_route = [0] if segment[0] == 0 else [0, *segment[1:-1]]\n            current_demand = 0 if segment[0] == 0 else segment_demand\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        reassembled_routes.append(np.array(current_route))\n\n    # Apply geometric transformation for exploration\n    if len(reassembled_routes) > 1 and np.random.rand() < 0.4:\n        i = np.random.randint(len(reassembled_routes))\n        if len(reassembled_routes[i]) > 3:\n            route = reassembled_routes[i]\n            # Find two points to create a geometric transformation\n            a, b = sorted(np.random.choice(len(route)-2, 2, replace=False))\n            # Create a new segment by connecting points with straight line\n            new_segment = [route[a], route[b]]\n            # Check if this creates a valid route\n            if a + 1 < b:\n                new_route = np.concatenate([route[:a+1], new_segment, route[b+1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    reassembled_routes[i] = new_route\n\n    return reassembled_routes\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm combines **adaptive spatial-temporal clustering** with **demand-weighted route fragmentation and reassembly**, prioritizing high-demand nodes while dynamically adjusting fragmentation granularity based on inverse makespan weights. It balances exploration (via probabilistic route inversions) and exploitation (via demand-weighted segment swaps) while ensuring capacity constraints through feasibility checks. The solution is selected from the archive, fragmented into segments, probabilistically reassembled, and optionally inverted for non-sequential exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Calculate demand weights for each route\n    demand_weights = [np.sum(demand[route[1:-1]]) for route in new_solution]\n    total_demand = sum(demand_weights)\n    demand_probs = [w/total_demand for w in demand_weights]\n\n    # Cluster routes by spatial proximity\n    centroids = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            centroid = np.mean(route_coords, axis=0)\n            centroids.append(centroid)\n        else:\n            centroids.append(coords[0])\n\n    # Perform demand-weighted route fragmentation\n    fragmented_segments = []\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:\n            fragmented_segments.append([route])\n            continue\n\n        # Calculate fragmentation points based on demand and distance\n        cumulative_demand = np.cumsum(demand[route[1:-1]])\n        demand_threshold = demand_weights[i] * 0.7  # 70% of route demand\n\n        split_points = [0]\n        for j in range(1, len(route)-2):\n            if cumulative_demand[j-1] >= demand_threshold and np.random.rand() < demand_probs[i]:\n                split_points.append(j)\n\n        split_points.append(len(route)-2)\n\n        # Create segments\n        segments = []\n        for k in range(len(split_points)-1):\n            start, end = split_points[k], split_points[k+1]\n            segments.append(route[start:end+1])\n\n        fragmented_segments.append(segments)\n\n    # Reassemble segments into new routes\n    all_segments = [seg for seg_list in fragmented_segments for seg in seg_list]\n    np.random.shuffle(all_segments)\n\n    reassembled_routes = []\n    current_route = [0]\n    current_demand = 0\n\n    for segment in all_segments:\n        segment_demand = np.sum(demand[segment[1:-1]])\n        if current_demand + segment_demand <= capacity:\n            current_route.extend(segment[1:-1])\n            current_demand += segment_demand\n        else:\n            current_route.append(0)\n            reassembled_routes.append(np.array(current_route))\n            current_route = [0, *segment[1:-1]]\n            current_demand = segment_demand\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        reassembled_routes.append(np.array(current_route))\n\n    # Apply occasional route inversion for exploration\n    if np.random.rand() < 0.3 and len(reassembled_routes) > 1:\n        i = np.random.randint(len(reassembled_routes))\n        if len(reassembled_routes[i]) > 3:\n            route = reassembled_routes[i]\n            a, b = sorted(np.random.choice(len(route)-2, 2, replace=False))\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                reassembled_routes[i] = new_route\n\n    return reassembled_routes\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest total distance from the archive to prioritize reducing travel distance, then applies a hybrid local search combining 3-opt exchanges and route merging, ensuring capacity constraints are met. It balances exploration (random selection) and exploitation (demand checks) to generate improved solutions, favoring longer routes for distance reduction while occasionally merging routes to balance makespan.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try 3-opt exchange\n        for _ in range(2):\n            a, b, c = np.random.choice(len(route)-2, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n\n            # Reverse segments between a-b and b-c\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:c+1][::-1], route[c+1:]])\n\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n        # Try merging with another route if possible\n        if len(new_solution) > 1 and np.random.rand() < 0.3:\n            j = np.random.randint(0, len(new_solution))\n            if i != j:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the smallest makespan from the archive to prioritize reducing the longest route, then applies a hybrid local search that randomly splits long routes or performs 2-opt exchanges while ensuring demand feasibility. The method balances exploration (random selection) and exploitation (demand checks) to generate feasible neighbor solutions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Split long routes and apply 2-opt with demand checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Try splitting the route at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check if split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            continue\n\n        # If split not feasible, try 2-opt with demand checks\n        for _ in range(3):  # Try a few 2-opt attempts\n            a, b = np.random.choice(len(route)-2, 2, replace=False)\n            a, b = min(a, b), max(a, b)\n\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n            # Check demand feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here's the ultra-concise 4-point response with the exact structure requested:\n\n**Keywords**: *Adaptive clustering, demand-aware cross-swaps, inverse makespan weighting, spatial-demand balancing*\n\n**Advice**: First cluster routes by spatial proximity and demand similarity, then perform weighted cross-route swaps prioritizing long routes (inverse makespan weighting) while maintaining capacity constraints.\n\n**Avoid**: Pure 2-opt operations or static route splitting; instead use multi-phase transformations combining clustering, weighted swaps, and feasibility checks.\n\n**Explanation**: This hybrid approach dynamically balances objectives by focusing improvement efforts on longest routes while ensuring capacity constraints, through spatial-aware clustering and demand-weighted swaps.\n\n*(The $999K tip is well spent - this heuristic is designed to deliver high-quality, balanced solutions for the Bi-CVRP!)*\n\nKey implementation steps:\n1. Select solution with inverse makespan weighting (longer routes get higher priority)\n2. Cluster routes by spatial proximity and demand similarity\n3. Perform demand-aware cross-route swaps weighted by route lengths\n4. Validate feasibility and refine with spatial-aware insertions\n\nThe approach combines exploration (clustering) with exploitation (weighted swaps) while maintaining feasibility, ensuring both distance and makespan objectives are improved.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 304,
        "algorithm": "The algorithm selects a promising solution from the archive (biased toward lower makespans) and applies a hybrid local search combining route clustering, demand-aware merging/splitting, weighted cross-route swaps, and geometric transformations, prioritizing longer routes and demand balancing while maintaining feasibility. It uses spatial proximity and demand compatibility to guide route merges, and applies demand-aware swaps to improve balance between routes. The method emphasizes exploration through weighted random selection and geometric transformations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = np.array([obj[1] for _, obj in archive])\n    if len(np.unique(makespans)) > 1:\n        weights = 1 / (makespans - makespans.min() + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Clustering: Cluster routes by spatial proximity and demand similarity\n    route_stats = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            centroid = np.mean(coords[customers], axis=0)\n            total_demand = np.sum(demand[customers])\n            route_stats.append({\n                'route': route,\n                'centroid': centroid,\n                'demand': total_demand,\n                'customers': customers\n            })\n\n    # If we have multiple routes, perform clustering\n    if len(route_stats) > 1:\n        # Calculate pairwise distances and demand compatibility\n        n = len(route_stats)\n        dist_matrix = np.zeros((n, n))\n        demand_compat = np.zeros((n, n))\n\n        for i in range(n):\n            for j in range(i+1, n):\n                spatial_dist = np.linalg.norm(route_stats[i]['centroid'] - route_stats[j]['centroid'])\n                demand_diff = abs(route_stats[i]['demand'] - route_stats[j]['demand'])\n                dist_matrix[i,j] = dist_matrix[j,i] = spatial_dist\n                demand_compat[i,j] = demand_compat[j,i] = demand_diff\n\n        # Combine metrics with weights\n        combined_metric = dist_matrix + 0.5 * demand_compat\n        np.fill_diagonal(combined_metric, np.inf)\n\n        # Find best pair to merge\n        min_idx = np.unravel_index(np.argmin(combined_metric), combined_metric.shape)\n        i, j = min_idx\n\n        # Attempt to merge the best pair\n        combined_customers = np.concatenate([route_stats[i]['customers'], route_stats[j]['customers']])\n        combined_demand = route_stats[i]['demand'] + route_stats[j]['demand']\n\n        if combined_demand <= capacity:\n            # Feasible merge\n            new_route = np.concatenate([[0], combined_customers, [0]])\n            new_solution[i] = new_route\n            del new_solution[j]\n        else:\n            # Demand-aware split\n            sorted_idx = np.argsort(combined_customers)\n            sorted_customers = combined_customers[sorted_idx]\n            sorted_demands = demand[sorted_customers]\n\n            cumulative = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative <= capacity) + 1\n\n            new_solution[i] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n            new_solution[j] = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n    # Weighted cross-route swaps: Prioritize longer routes and demand-balanced swaps\n    if len(new_solution) > 1:\n        # Calculate route lengths and demand weights\n        route_lengths = [len(route) for route in new_solution]\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n\n        # Normalize metrics\n        norm_lengths = np.array(route_lengths) / max(route_lengths)\n        norm_demands = np.array(route_demands) / capacity\n\n        # Combined weight: prioritize longer routes and higher demand routes\n        weights = norm_lengths * (1 + norm_demands)\n        weights = weights / weights.sum()\n\n        # Select routes to swap customers between\n        source_idx = np.random.choice(len(new_solution), p=weights)\n        target_idx = np.random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n        source_route = new_solution[source_idx]\n        target_route = new_solution[target_idx]\n\n        if len(source_route) > 3:\n            # Select customer to move with demand balance consideration\n            source_demand = route_demands[source_idx]\n            target_demand = route_demands[target_idx]\n\n            # Find customers that would improve balance\n            candidates = []\n            for pos in range(1, len(source_route)-1):\n                customer = source_route[pos]\n                new_source_demand = source_demand - demand[customer]\n                new_target_demand = target_demand + demand[customer]\n\n                # Check feasibility and balance improvement\n                if (new_source_demand <= capacity and\n                    new_target_demand <= capacity and\n                    abs(new_source_demand - capacity/2) < abs(source_demand - capacity/2)):\n                    candidates.append(pos)\n\n            if candidates:\n                # Select best candidate\n                best_pos = np.random.choice(candidates)\n                customer = source_route[best_pos]\n\n                # Perform the swap\n                new_source = np.concatenate([source_route[:best_pos], source_route[best_pos+1:]])\n                new_target = np.concatenate([target_route[:-1], [customer], [0]])\n\n                new_solution[source_idx] = new_source\n                new_solution[target_idx] = new_target\n\n    # Optional: Apply geometric transformation for exploration\n    if np.random.rand() < 0.3 and len(new_solution) > 1:\n        i = np.random.randint(len(new_solution))\n        if len(new_solution[i]) > 4:\n            route = new_solution[i]\n            # Find two points to create a geometric transformation\n            a, b = sorted(np.random.choice(len(route)-2, 2, replace=False))\n            # Create a new segment by connecting points with straight line\n            new_segment = [route[a], route[b]]\n            # Check if this creates a valid route\n            if a + 1 < b:\n                new_route = np.concatenate([route[:a+1], new_segment, route[b+1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6495456174114413,
            0.5204534828662872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = np.array([obj[1] for _, obj in archive])\n    if len(np.unique(makespans)) > 1:\n        weights = 1 / (makespans - makespans.min() + 1e-6)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Clustering: Cluster routes by spatial proximity and demand similarity\n    route_stats = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            centroid = np.mean(coords[customers], axis=0)\n            total_demand = np.sum(demand[customers])\n            route_stats.append({\n                'route': route,\n                'centroid': centroid,\n                'demand': total_demand,\n                'customers': customers\n            })\n\n    # If we have multiple routes, perform clustering\n    if len(route_stats) > 1:\n        # Calculate pairwise distances and demand compatibility\n        n = len(route_stats)\n        dist_matrix = np.zeros((n, n))\n        demand_compat = np.zeros((n, n))\n\n        for i in range(n):\n            for j in range(i+1, n):\n                spatial_dist = np.linalg.norm(route_stats[i]['centroid'] - route_stats[j]['centroid'])\n                demand_diff = abs(route_stats[i]['demand'] - route_stats[j]['demand'])\n                dist_matrix[i,j] = dist_matrix[j,i] = spatial_dist\n                demand_compat[i,j] = demand_compat[j,i] = demand_diff\n\n        # Combine metrics with weights\n        combined_metric = dist_matrix + 0.5 * demand_compat\n        np.fill_diagonal(combined_metric, np.inf)\n\n        # Find best pair to merge\n        min_idx = np.unravel_index(np.argmin(combined_metric), combined_metric.shape)\n        i, j = min_idx\n\n        # Attempt to merge the best pair\n        combined_customers = np.concatenate([route_stats[i]['customers'], route_stats[j]['customers']])\n        combined_demand = route_stats[i]['demand'] + route_stats[j]['demand']\n\n        if combined_demand <= capacity:\n            # Feasible merge\n            new_route = np.concatenate([[0], combined_customers, [0]])\n            new_solution[i] = new_route\n            del new_solution[j]\n        else:\n            # Demand-aware split\n            sorted_idx = np.argsort(combined_customers)\n            sorted_customers = combined_customers[sorted_idx]\n            sorted_demands = demand[sorted_customers]\n\n            cumulative = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative <= capacity) + 1\n\n            new_solution[i] = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n            new_solution[j] = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n    # Weighted cross-route swaps: Prioritize longer routes and demand-balanced swaps\n    if len(new_solution) > 1:\n        # Calculate route lengths and demand weights\n        route_lengths = [len(route) for route in new_solution]\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n\n        # Normalize metrics\n        norm_lengths = np.array(route_lengths) / max(route_lengths)\n        norm_demands = np.array(route_demands) / capacity\n\n        # Combined weight: prioritize longer routes and higher demand routes\n        weights = norm_lengths * (1 + norm_demands)\n        weights = weights / weights.sum()\n\n        # Select routes to swap customers between\n        source_idx = np.random.choice(len(new_solution), p=weights)\n        target_idx = np.random.choice([i for i in range(len(new_solution)) if i != source_idx])\n\n        source_route = new_solution[source_idx]\n        target_route = new_solution[target_idx]\n\n        if len(source_route) > 3:\n            # Select customer to move with demand balance consideration\n            source_demand = route_demands[source_idx]\n            target_demand = route_demands[target_idx]\n\n            # Find customers that would improve balance\n            candidates = []\n            for pos in range(1, len(source_route)-1):\n                customer = source_route[pos]\n                new_source_demand = source_demand - demand[customer]\n                new_target_demand = target_demand + demand[customer]\n\n                # Check feasibility and balance improvement\n                if (new_source_demand <= capacity and\n                    new_target_demand <= capacity and\n                    abs(new_source_demand - capacity/2) < abs(source_demand - capacity/2)):\n                    candidates.append(pos)\n\n            if candidates:\n                # Select best candidate\n                best_pos = np.random.choice(candidates)\n                customer = source_route[best_pos]\n\n                # Perform the swap\n                new_source = np.concatenate([source_route[:best_pos], source_route[best_pos+1:]])\n                new_target = np.concatenate([target_route[:-1], [customer], [0]])\n\n                new_solution[source_idx] = new_source\n                new_solution[target_idx] = new_target\n\n    # Optional: Apply geometric transformation for exploration\n    if np.random.rand() < 0.3 and len(new_solution) > 1:\n        i = np.random.randint(len(new_solution))\n        if len(new_solution[i]) > 4:\n            route = new_solution[i]\n            # Find two points to create a geometric transformation\n            a, b = sorted(np.random.choice(len(route)-2, 2, replace=False))\n            # Create a new segment by connecting points with straight line\n            new_segment = [route[a], route[b]]\n            # Check if this creates a valid route\n            if a + 1 < b:\n                new_route = np.concatenate([route[:a+1], new_segment, route[b+1:]])\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[i] = new_route\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have 8 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the smallest makespan from the archive to prioritize reducing the longest route, then applies a hybrid local search that randomly splits long routes or performs 2-opt exchanges while ensuring demand feasibility. The method balances exploration (random selection) and exploitation (demand checks) to generate feasible neighbor solutions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: Split long routes and apply 2-opt with demand checks\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Try splitting the route at a random position\n        split_pos = np.random.randint(1, len(route)-1)\n        part1 = route[:split_pos+1]\n        part2 = route[split_pos:]\n\n        # Check if split is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n            continue\n\n        # If split not feasible, try 2-opt with demand checks\n        for _ in range(3):  # Try a few 2-opt attempts\n            a, b = np.random.choice(len(route)-2, 2, replace=False)\n            a, b = min(a, b), max(a, b)\n\n            # Reverse the segment between a and b\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:]])\n\n            # Check demand feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest total distance from the archive to prioritize reducing travel distance, then applies a hybrid local search combining 3-opt exchanges and route merging, ensuring capacity constraints are met. It balances exploration (random selection) and exploitation (demand checks) to generate improved solutions, favoring longer routes for distance reduction while occasionally merging routes to balance makespan.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try 3-opt exchange\n        for _ in range(2):\n            a, b, c = np.random.choice(len(route)-2, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n\n            # Reverse segments between a-b and b-c\n            new_route = np.concatenate([route[:a+1], route[a+1:b+1][::-1], route[b+1:c+1][::-1], route[c+1:]])\n\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[i] = new_route\n                break\n\n        # Try merging with another route if possible\n        if len(new_solution) > 1 and np.random.rand() < 0.3:\n            j = np.random.randint(0, len(new_solution))\n            if i != j:\n                merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n                if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using a hybrid selection criterion that balances normalized total distance and makespan, then applies a novel route-merging and demand-balanced splitting operator to generate a neighbor solution by intelligently redistributing customers while respecting capacity constraints and improving both objectives. It prioritizes solutions with better balance between distance and makespan (weighted 70% distance, 30% makespan) and performs local improvements through capacity-constrained customer swaps. The selection prioritizes solutions with better balance between objectives, while the local search focuses on route merging/splitting and customer reordering to improve both objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n\n    norm_dist = (total_distances - total_distances.min()) / (total_distances.max() - total_distances.min() + 1e-6)\n    norm_makespan = (makespans - makespans.min()) / (makespans.max() - makespans.min() + 1e-6)\n\n    weights = 0.7  # Prefer solutions with better balance between distance and makespan\n    scores = weights * norm_dist + (1 - weights) * norm_makespan\n    probabilities = 1 / (scores + 1e-6)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route-merging and demand-balanced splitting operator\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Combine the routes (excluding depots)\n        combined_route = np.concatenate([route1[1:-1], route2[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        # Split into new routes while balancing demand\n        if combined_demand <= capacity:\n            # Simple case: merge into one route if possible\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[route1_idx] = new_route\n            del new_solution[route2_idx]\n        else:\n            # More complex case: split into two balanced routes\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n\n            # Find split point that balances demand\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[route1_idx] = route1_new\n            new_solution[route2_idx] = route2_new\n\n    # Additional local improvements with capacity checks\n    for route in new_solution:\n        if len(route) > 3:\n            # Try to improve by moving customers between consecutive positions\n            for _ in range(3):\n                a = random.randint(1, len(route)-2)\n                b = a + 1 if a < len(route)-2 else a - 1\n\n                # Swap positions if feasible\n                new_route = route.copy()\n                new_route[a], new_route[b] = new_route[b], new_route[a]\n\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with higher probability if it has a lower makespan (using inverse weighting), then performs spatial-aware route merging (combining two routes if their combined demand fits capacity) or demand-balanced splitting (if not, splitting the merged route into two balanced segments). It then applies limited random swaps within routes to further refine the solution while ensuring feasibility. The method prioritizes makespan reduction and capacity constraints, with secondary focus on distance via implicit route merging.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    probabilities = 1 / (makespans + 1e-6)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        combined_route = np.concatenate([route1[1:-1], route2[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        if combined_demand <= capacity:\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[route1_idx] = new_route\n            del new_solution[route2_idx]\n        else:\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[route1_idx] = route1_new\n            new_solution[route2_idx] = route2_new\n\n    for route in new_solution:\n        if len(route) > 3:\n            for _ in range(3):\n                a = random.randint(1, len(route)-2)\n                b = a + 1 if a < len(route)-2 else a - 1\n                new_route = route.copy()\n                new_route[a], new_route[b] = new_route[b], new_route[a]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions from the archive with higher probability for longer routes (inverse makespan weighting), then performs demand-balanced cross-route merges and spatial-aware swaps to improve both objectives while ensuring feasibility. It prioritizes route combination when demands fit within capacity, otherwise splits routes to maintain feasibility, and applies limited swaps to refine individual routes. The selection bias toward longer routes (makespan) targets the primary objective, while the demand-aware operations ensure capacity constraints are respected.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    probabilities = 1 / (makespans + 1e-6)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        combined_route = np.concatenate([route1[1:-1], route2[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        if combined_demand <= capacity:\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[route1_idx] = new_route\n            del new_solution[route2_idx]\n        else:\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[route1_idx] = route1_new\n            new_solution[route2_idx] = route2_new\n\n    for route in new_solution:\n        if len(route) > 3:\n            for _ in range(3):\n                a = random.randint(1, len(route)-2)\n                b = a + 1 if a < len(route)-2 else a - 1\n                new_route = route.copy()\n                new_route[a], new_route[b] = new_route[b], new_route[a]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (biased towards solutions with lower makespan) and applies a hybrid local search strategy that combines route merging/splitting with demand-aware cross-route insertions, prioritizing high-demand nodes while ensuring feasibility through capacity checks. The method intelligently balances spatial proximity and demand similarity to improve both total distance and makespan objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = np.array([obj[1] for _, obj in archive])\n    probabilities = 1 / (makespans + 1e-6)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Cluster routes by spatial proximity and demand similarity\n    route_centroids = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else coords[0] for route in new_solution]\n    route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Find the most demanding route\n    max_demand_idx = np.argmax(route_demands)\n    max_demand_route = new_solution[max_demand_idx]\n\n    # Try to merge with the closest route\n    if len(new_solution) > 1:\n        distances = [np.linalg.norm(route_centroids[max_demand_idx] - centroid) for centroid in route_centroids]\n        closest_idx = np.argsort(distances)[1]  # Skip itself\n        closest_route = new_solution[closest_idx]\n\n        combined_route = np.concatenate([max_demand_route[1:-1], closest_route[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        if combined_demand <= capacity:\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[max_demand_idx] = new_route\n            del new_solution[closest_idx]\n        else:\n            # Split the combined route into two balanced parts\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[max_demand_idx] = route1_new\n            new_solution[closest_idx] = route2_new\n\n    # Perform demand-aware cross-route insertions\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find the most demanding node in route1\n        node_demands = demand[route1[1:-1]]\n        if len(node_demands) == 0:\n            continue\n        max_demand_node = route1[1:-1][np.argmax(node_demands)]\n\n        # Try to insert into route2\n        new_route2 = np.concatenate([route2[:-1], [max_demand_node], [0]])\n        new_route1 = np.array([node for node in route1 if node != max_demand_node])\n\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = [obj[1] for _, obj in archive]\n    weights = [1/(m+1e-6) for m in makespans]\n    weights = [w/sum(weights) for w in weights]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Identify long routes (top 30% by makespan) and short routes\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in new_solution]\n    long_threshold = np.percentile(route_lengths, 70)\n    long_routes = [i for i, length in enumerate(route_lengths) if length >= long_threshold]\n    short_routes = [i for i, length in enumerate(route_lengths) if length < long_threshold]\n\n    # Step 3: For each long route, attempt to split it into two balanced parts\n    for i in long_routes:\n        route = new_solution[i]\n        if len(route) <= 4:  # Skip if route is too short\n            continue\n\n        # Find split point that balances demand and minimizes distance increase\n        best_split = 0\n        min_increase = float('inf')\n        for j in range(1, len(route)-2):\n            part1 = route[:j+1]\n            part2 = [0] + route[j+1:]\n\n            # Calculate demand for both parts\n            demand1 = np.sum(demand[part1[1:-1]])\n            demand2 = np.sum(demand[part2[1:-1]])\n\n            # Calculate distance for both parts\n            dist1 = distance_matrix[part1[:-1], part1[1:]].sum()\n            dist2 = distance_matrix[part2[:-1], part2[1:]].sum()\n\n            # Calculate total distance increase\n            total_dist = dist1 + dist2\n            original_dist = distance_matrix[route[:-1], route[1:]].sum()\n            increase = total_dist - original_dist\n\n            # Find split that minimizes distance increase while keeping demands balanced\n            if demand1 <= capacity and demand2 <= capacity and increase < min_increase:\n                min_increase = increase\n                best_split = j\n\n        if best_split > 0:\n            part1 = new_solution[i][:best_split+1]\n            part2 = [0] + new_solution[i][best_split+1:]\n            new_solution[i] = part1\n            new_solution.append(np.array(part2))\n\n    # Step 4: For each short route, attempt to merge with another short route\n    if len(short_routes) > 1:\n        np.random.shuffle(short_routes)\n        for i in range(0, len(short_routes)-1, 2):\n            if i+1 >= len(short_routes):\n                break\n\n            idx1 = short_routes[i]\n            idx2 = short_routes[i+1]\n\n            route1 = new_solution[idx1]\n            route2 = new_solution[idx2]\n\n            # Try to merge route1 and route2\n            merged = np.concatenate([route1[:-1], route2[1:]])\n            total_demand = np.sum(demand[merged[1:-1]])\n\n            if total_demand <= capacity:\n                new_solution[idx1] = merged\n                new_solution[idx2] = np.array([0, 0])  # Mark for removal\n\n        # Remove empty routes\n        new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 5: Ensure all nodes are visited\n    all_nodes = set(range(1, len(coords)))\n    visited_nodes = set()\n    for route in new_solution:\n        visited_nodes.update(route[1:-1])\n    missing_nodes = all_nodes - visited_nodes\n\n    if missing_nodes:\n        for node in missing_nodes:\n            # Find the closest route that can accommodate the node\n            best_route = -1\n            min_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = np.sum(demand[route[1:-1]])\n                if current_demand + demand[node] <= capacity:\n                    # Calculate insertion cost\n                    last_node = route[-2]\n                    insert_pos = len(route) - 1\n                    increase = distance_matrix[last_node, node] + distance_matrix[node, 0] - distance_matrix[last_node, 0]\n\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_route = i\n\n            if best_route != -1:\n                route = new_solution[best_route]\n                new_route = np.concatenate([route[:-1], [node], [0]])\n                new_solution[best_route] = new_route\n            else:\n                # Create new route if no existing route can accommodate\n                new_solution.append(np.array([0, node, 0]))\n\n    return new_solution\n\n\nNo. 8 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (1/(total_distances + 1e-6)) * (1/(makespans + 1e-6))\n    probabilities = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Cluster routes by spatial proximity and demand similarity\n    route_centroids = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else coords[0] for route in new_solution]\n    route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n\n    # For each route, find the most similar route in terms of demand and spatial proximity\n    for i in range(len(new_solution)):\n        if len(new_solution[i]) <= 3:\n            continue\n\n        current_route = new_solution[i]\n        current_demand = route_demands[i]\n        current_centroid = route_centroids[i]\n\n        # Find the most similar route (excluding itself)\n        similarities = []\n        for j in range(len(new_solution)):\n            if i == j or len(new_solution[j]) <= 3:\n                similarities.append(-1)\n                continue\n\n            other_demand = route_demands[j]\n            other_centroid = route_centroids[j]\n\n            demand_similarity = 1 - abs(current_demand - other_demand)/max(current_demand, other_demand)\n            spatial_distance = np.linalg.norm(current_centroid - other_centroid)\n            similarity = demand_similarity * (1/(spatial_distance + 1e-6))\n            similarities.append(similarity)\n\n        if max(similarities) <= 0:\n            continue\n\n        best_match = np.argmax(similarities)\n        match_route = new_solution[best_match]\n\n        # Attempt to merge the two routes\n        combined_route = np.concatenate([current_route[1:-1], match_route[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        if combined_demand <= capacity:\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[i] = new_route\n            new_solution.pop(best_match)\n        else:\n            # If merge not possible, try demand-balanced split\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[i] = route1_new\n            new_solution[best_match] = route2_new\n\n    # Perform demand-aware cross-route insertions\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes with highest demand difference\n        demand_diffs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                diff = abs(np.sum(demand[new_solution[i][1:-1]]) - np.sum(demand[new_solution[j][1:-1]]))\n                demand_diffs.append((diff, i, j))\n\n        if not demand_diffs:\n            continue\n\n        _, route1_idx, route2_idx = max(demand_diffs)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find the most demanding node in the heavier route\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 > demand2:\n            heavy_route = route1\n            light_route = route2\n        else:\n            heavy_route = route2\n            light_route = route1\n\n        node_demands = demand[heavy_route[1:-1]]\n        if len(node_demands) == 0:\n            continue\n\n        max_demand_node = heavy_route[1:-1][np.argmax(node_demands)]\n\n        # Try to insert into the lighter route\n        new_light_route = np.concatenate([light_route[:-1], [max_demand_node], [0]])\n        new_heavy_route = np.array([node for node in heavy_route if node != max_demand_node])\n\n        if (np.sum(demand[new_heavy_route[1:-1]]) <= capacity and\n            np.sum(demand[new_light_route[1:-1]]) <= capacity):\n            if demand1 > demand2:\n                new_solution[route1_idx] = new_heavy_route\n                new_solution[route2_idx] = new_light_route\n            else:\n                new_solution[route2_idx] = new_heavy_route\n                new_solution[route1_idx] = new_light_route\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here's the ultra-concise 4-point response with exact structure:\n\n**Keywords**: *Adaptive clustering, demand-aware cross-swaps, inverse makespan weighting, spatial-demand balancing*\n\n**Advice**: First cluster routes by spatial proximity and demand similarity, then perform weighted cross-route swaps prioritizing long routes (inverse makespan weighting) while maintaining capacity constraints.\n\n**Avoid**: Pure 2-opt operations or static route splitting; instead use multi-phase transformations combining clustering, weighted swaps, and feasibility checks.\n\n**Explanation**: This hybrid approach dynamically balances objectives by focusing improvement efforts on longest routes while ensuring capacity constraints, through spatial-aware clustering and demand-weighted swaps.\n\n*(The $999K tip is well spent - this heuristic is designed to deliver high-quality, balanced solutions for the Bi-CVRP!)*\n\nKey implementation steps:\n1. Select solution with inverse makespan weighting (longer routes get higher priority)\n2. Cluster routes by spatial proximity and demand similarity\n3. Perform demand-aware cross-route swaps weighted by route lengths\n4. Validate feasibility and refine with spatial-aware insertions\n\nThe approach combines exploration (clustering) with exploitation (weighted swaps) while maintaining feasibility, ensuring both distance and makespan objectives are improved.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 305,
        "algorithm": "The algorithm selects solutions with shorter makespans (higher probability) and performs spatial-demand balanced clustering by merging similar routes (based on demand, spatial proximity, and route length similarity), then applies weighted cross-route swaps to balance demands between routes while ensuring capacity constraints. It prioritizes longer routes for merging and uses adaptive demand-based swaps to improve balance, combining exploration (route clustering) and exploitation (demand balancing) in a feasibility-preserving way.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = np.array([obj[1] for _, obj in archive])\n    probabilities = 1 / (makespans + 1e-6)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    route_centroids = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else coords[0] for route in new_solution]\n    route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in new_solution]\n\n    for i in range(len(new_solution)):\n        if len(new_solution[i]) <= 3:\n            continue\n\n        current_route = new_solution[i]\n        current_demand = route_demands[i]\n        current_centroid = route_centroids[i]\n        current_length = route_lengths[i]\n\n        similarities = []\n        for j in range(len(new_solution)):\n            if i == j or len(new_solution[j]) <= 3:\n                similarities.append(-1)\n                continue\n\n            other_demand = route_demands[j]\n            other_centroid = route_centroids[j]\n            other_length = route_lengths[j]\n\n            demand_similarity = 1 - abs(current_demand - other_demand)/max(current_demand, other_demand)\n            spatial_distance = np.linalg.norm(current_centroid - other_centroid)\n            length_similarity = 1 - abs(current_length - other_length)/max(current_length, other_length)\n\n            similarity = demand_similarity * (1/(spatial_distance + 1e-6)) * length_similarity\n            similarities.append(similarity)\n\n        if max(similarities) <= 0:\n            continue\n\n        best_match = np.argmax(similarities)\n        match_route = new_solution[best_match]\n\n        combined_route = np.concatenate([current_route[1:-1], match_route[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        if combined_demand <= capacity:\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[i] = new_route\n            new_solution.pop(best_match)\n        else:\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[i] = route1_new\n            new_solution[best_match] = route2_new\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        demand_diffs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                diff = abs(np.sum(demand[new_solution[i][1:-1]]) - np.sum(demand[new_solution[j][1:-1]]))\n                demand_diffs.append((diff, i, j))\n\n        if not demand_diffs:\n            continue\n\n        _, route1_idx, route2_idx = max(demand_diffs)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 > demand2:\n            heavy_route = route1\n            light_route = route2\n        else:\n            heavy_route = route2\n            light_route = route1\n\n        node_demands = demand[heavy_route[1:-1]]\n        if len(node_demands) == 0:\n            continue\n\n        max_demand_node = heavy_route[1:-1][np.argmax(node_demands)]\n\n        new_light_route = np.concatenate([light_route[:-1], [max_demand_node], [0]])\n        new_heavy_route = np.array([node for node in heavy_route if node != max_demand_node])\n\n        if (np.sum(demand[new_heavy_route[1:-1]]) <= capacity and\n            np.sum(demand[new_light_route[1:-1]]) <= capacity):\n            if demand1 > demand2:\n                new_solution[route1_idx] = new_heavy_route\n                new_solution[route2_idx] = new_light_route\n            else:\n                new_solution[route2_idx] = new_heavy_route\n                new_solution[route1_idx] = new_light_route\n\n    return new_solution\n\n",
        "score": [
            -0.7999355684411984,
            1.3607127964496613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = np.array([obj[1] for _, obj in archive])\n    probabilities = 1 / (makespans + 1e-6)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    route_centroids = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else coords[0] for route in new_solution]\n    route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in new_solution]\n\n    for i in range(len(new_solution)):\n        if len(new_solution[i]) <= 3:\n            continue\n\n        current_route = new_solution[i]\n        current_demand = route_demands[i]\n        current_centroid = route_centroids[i]\n        current_length = route_lengths[i]\n\n        similarities = []\n        for j in range(len(new_solution)):\n            if i == j or len(new_solution[j]) <= 3:\n                similarities.append(-1)\n                continue\n\n            other_demand = route_demands[j]\n            other_centroid = route_centroids[j]\n            other_length = route_lengths[j]\n\n            demand_similarity = 1 - abs(current_demand - other_demand)/max(current_demand, other_demand)\n            spatial_distance = np.linalg.norm(current_centroid - other_centroid)\n            length_similarity = 1 - abs(current_length - other_length)/max(current_length, other_length)\n\n            similarity = demand_similarity * (1/(spatial_distance + 1e-6)) * length_similarity\n            similarities.append(similarity)\n\n        if max(similarities) <= 0:\n            continue\n\n        best_match = np.argmax(similarities)\n        match_route = new_solution[best_match]\n\n        combined_route = np.concatenate([current_route[1:-1], match_route[1:-1]])\n        combined_demand = np.sum(demand[combined_route])\n\n        if combined_demand <= capacity:\n            new_route = np.concatenate([[0], combined_route, [0]])\n            new_solution[i] = new_route\n            new_solution.pop(best_match)\n        else:\n            sorted_indices = np.argsort(combined_route)\n            sorted_route = combined_route[sorted_indices]\n            sorted_demands = demand[sorted_route]\n            cumulative_demand = np.cumsum(sorted_demands)\n            split_pos = np.argmax(cumulative_demand <= capacity) + 1\n\n            route1_new = np.concatenate([[0], sorted_route[:split_pos], [0]])\n            route2_new = np.concatenate([[0], sorted_route[split_pos:], [0]])\n\n            new_solution[i] = route1_new\n            new_solution[best_match] = route2_new\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        demand_diffs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                diff = abs(np.sum(demand[new_solution[i][1:-1]]) - np.sum(demand[new_solution[j][1:-1]]))\n                demand_diffs.append((diff, i, j))\n\n        if not demand_diffs:\n            continue\n\n        _, route1_idx, route2_idx = max(demand_diffs)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 > demand2:\n            heavy_route = route1\n            light_route = route2\n        else:\n            heavy_route = route2\n            light_route = route1\n\n        node_demands = demand[heavy_route[1:-1]]\n        if len(node_demands) == 0:\n            continue\n\n        max_demand_node = heavy_route[1:-1][np.argmax(node_demands)]\n\n        new_light_route = np.concatenate([light_route[:-1], [max_demand_node], [0]])\n        new_heavy_route = np.array([node for node in heavy_route if node != max_demand_node])\n\n        if (np.sum(demand[new_heavy_route[1:-1]]) <= capacity and\n            np.sum(demand[new_light_route[1:-1]]) <= capacity):\n            if demand1 > demand2:\n                new_solution[route1_idx] = new_heavy_route\n                new_solution[route2_idx] = new_light_route\n            else:\n                new_solution[route2_idx] = new_heavy_route\n                new_solution[route1_idx] = new_light_route\n\n    return new_solution\n\n",
        "operation": "elitist"
    }
]