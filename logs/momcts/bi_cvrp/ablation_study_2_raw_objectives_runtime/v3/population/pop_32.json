[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of normalized distance and makespan objectives (60% distance, 40% makespan), then applies a hybrid local search combining route splitting, inter-route insertion, and modified 2-opt with capacity checks to generate an improved neighbor solution. It prioritizes distance reduction while balancing makespan optimization, and ensures feasibility through strict capacity validation at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives for selection\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Avoid division by zero\n    if max_dist == min_dist:\n        normalized_dist = np.ones_like(distances)\n    else:\n        normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n    if max_make == min_make:\n        normalized_make = np.ones_like(makespans)\n    else:\n        normalized_make = (makespans - min_make) / (max_make - min_make)\n\n    # Weighted sum (can be adjusted)\n    scores = 0.6 * normalized_dist + 0.4 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try route splitting\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # If split fails, try inter-route insertion\n        if len(base_solution) > 1:\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and not np.array_equal(r, route)])\n            if len(other_route) > 3:\n                # Find best insertion point\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(other_route)):\n                    new_route = np.insert(other_route, i, route[1:-1])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = (distance_matrix[new_route[i-1], route[1]] +\n                                distance_matrix[route[-2], new_route[i+len(route)-2]] -\n                                distance_matrix[new_route[i-1], new_route[i+len(route)-2]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    new_route = np.insert(other_route, best_pos, route[1:-1])\n                    new_solution.append(new_route)\n                    continue\n\n        # If all else fails, apply modified 2-opt\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Convert back to original format\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only include non-trivial routes\n            final_solution.append(route)\n\n    return np.array(final_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8948495283173388,
            0.5054986476898193
        ],
        "raw_score": [
            57.889668453293666,
            7.825081625352422
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive (favoring top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route restructuring (splitting routes at capacity-balanced points) and objective-aware node swapping (exchanging nodes between routes when it improves distance). It ensures feasibility through adaptive capacity checks and prioritizes high-potential solutions for further improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7310293206497563,
            0.16164618730545044
        ],
        "raw_score": [
            58.10752915940811,
            7.61725505871078
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive (prioritizing top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route restructuring, inter-route demand-aware swaps, and adaptive 2-opt, while ensuring feasibility through strict capacity checks. It emphasizes balancing demand across routes and minimizing distance increases during route splitting, with adaptive operations prioritizing nodes that show potential for improvement while maintaining capacity constraints. The solution selection and local search operations are designed to balance distance and makespan optimization while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand and minimizes distance increase\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split_pos = 1\n            min_dist_increase = float('inf')\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    # Calculate potential distance increase\n                    new_route1 = route[:i + 1]\n                    new_route2 = np.concatenate([[0], route[i + 1:]])\n                    dist_increase = (distance_matrix[new_route1[-2], 0] +\n                                    distance_matrix[0, new_route2[1]] -\n                                    distance_matrix[route[i-1], route[i]])\n\n                    if dist_increase < min_dist_increase:\n                        min_dist_increase = dist_increase\n                        best_split_pos = i\n\n            new_route1 = route[:best_split_pos + 1]\n            new_route2 = np.concatenate([[0], route[best_split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation with adaptive 2-opt\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement using adaptive 2-opt\n                best_improvement = 0\n                best_swap = None\n\n                for i in range(1, len(route1) - 1):\n                    for j in range(1, len(route2) - 1):\n                        # Calculate potential improvement\n                        old_dist = (distance_matrix[route1[i-1], route1[i]] +\n                                   distance_matrix[route1[i], route1[i+1]] +\n                                   distance_matrix[route2[j-1], route2[j]] +\n                                   distance_matrix[route2[j], route2[j+1]])\n\n                        new_dist = (distance_matrix[route1[i-1], route2[j]] +\n                                  distance_matrix[route2[j], route1[i+1]] +\n                                  distance_matrix[route2[j-1], route1[i]] +\n                                  distance_matrix[route1[i], route2[j+1]])\n\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            # Check capacity constraints\n                            new_route1 = route1.copy()\n                            new_route2 = route2.copy()\n                            new_route1[i] = route2[j]\n                            new_route2[j] = route1[i]\n\n                            if (sum(demand[new_route1]) <= capacity and\n                                sum(demand[new_route2]) <= capacity):\n                                best_improvement = improvement\n                                best_swap = (i, j)\n\n                if best_swap is not None:\n                    i, j = best_swap\n                    new_solution[route1_idx][i] = route2[j]\n                    new_solution[route2_idx][j] = route1[i]\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.7682058259568217,
            0.23147046566009521
        ],
        "raw_score": [
            58.06702696177532,
            7.500376429253305
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the top 20% of the archive (or top 30% with 20% probability) and applies a hybrid local search that alternates between demand-balanced route splitting (for long routes) and objective-aware inter-route node swaps (when swaps improve both distance and makespan). It dynamically adjusts search intensity based on archive diversity, prioritizing high-potential regions while ensuring feasibility through strict capacity checks. The method emphasizes balancing exploration (via random selection) and exploitation (via aggressive restructuring in low-diversity regions), with strict feasibility maintenance at every step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_30 = int(len(archive) * 0.3)\n    top_20 = int(len(archive) * 0.2)\n\n    # Dynamic selection: 80% chance to select from top 20%, 20% chance from top 30%\n    if random.random() < 0.8 and top_20 > 0:\n        selected_idx = random.randint(0, top_20 - 1)\n    else:\n        selected_idx = random.randint(0, min(top_30, len(archive) - 1))\n\n    selected_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Calculate archive diversity (number of unique solutions)\n    archive_diversity = len(set(tuple(route.tobytes() for route in sol[0]) for sol in archive))\n    low_diversity = archive_diversity < len(archive) * 0.5\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing (more aggressive when diversity is low)\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Objective-aware node swapping (more aggressive when diversity is low)\n        if n_routes >= 2 and (random.random() < 0.7 or low_diversity):\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select nodes excluding depot\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                               sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    old_makespan = max(\n                        sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))),\n                        sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2)))\n                    )\n                    new_makespan = max(\n                        sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))),\n                        sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2)))\n                    )\n\n                    if (new_dist < old_dist and new_makespan <= old_makespan) or low_diversity:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8375252380033713,
            0.2893610894680023
        ],
        "raw_score": [
            56.78575562547737,
            7.580634491502313
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search for the Bi-CVRP by first selecting promising solutions from the archive, then applying a combination of demand-balanced route restructuring, spatial-density clustering, and objective-driven segment swapping to generate feasible neighbors, with dynamic operator intensity based on archive diversity. It prioritizes solutions with better combined objective values and uses clustering to handle high-demand nodes, while ensuring capacity constraints and depot constraints are maintained throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% but include some randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20_percent = max(1, int(len(archive) * 0.2))\n    selection_pool = archive_sorted[:top_20_percent]\n\n    # With 20% probability, select randomly from the remaining solutions\n    if random.random() < 0.2 and len(archive) > top_20_percent:\n        selection_pool = archive[top_20_percent:]\n\n    # Select solution with probability inversely proportional to rank\n    weights = [1/(i+1) for i in range(len(selection_pool))]\n    selected_idx = random.choices(range(len(selection_pool)), weights=weights, k=1)[0]\n    base_solution = selection_pool[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate archive diversity to adjust operator intensity\n    diversity_threshold = 0.3\n    if len(archive) > 5:\n        unique_distances = len(set(x[1][0] for x in archive))\n        diversity_ratio = unique_distances / len(archive)\n        aggressive_search = diversity_ratio < diversity_threshold\n    else:\n        aggressive_search = True\n\n    # Hybrid local search operator\n    if len(new_solution) > 1:\n        # First try demand-balanced route restructuring\n        if random.random() < 0.5 or not aggressive_search:\n            # Select a route to potentially split based on demand balance\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find split point that balances demand\n                total_demand = sum(demand[route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                new_route1 = route[:split_pos + 1]\n                new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = new_route1\n                    new_solution.append(new_route2)\n        else:\n            # Try spatial-density clustering for high-demand nodes\n            high_demand_threshold = capacity * 0.6\n            high_demand_nodes = [i for i in range(1, len(demand)) if demand[i] > high_demand_threshold]\n\n            if high_demand_nodes and len(new_solution) > 1:\n                from sklearn.cluster import DBSCAN\n                coords_high_demand = coords[high_demand_nodes]\n                clustering = DBSCAN(eps=0.5, min_samples=2).fit(coords_high_demand)\n                clusters = clustering.labels_\n\n                # Assign clusters to routes\n                cluster_routes = {i: [] for i in np.unique(clusters) if i != -1}\n                for i, node in enumerate(high_demand_nodes):\n                    cluster_id = clusters[i]\n                    if cluster_id != -1:\n                        for route_idx, route in enumerate(new_solution):\n                            if node in route:\n                                cluster_routes[cluster_id].append((route_idx, node))\n                                break\n\n                # Merge routes with the same cluster\n                for cluster_id, nodes in cluster_routes.items():\n                    if len(nodes) > 1:\n                        routes_to_merge = set(route_idx for route_idx, _ in nodes)\n                        if len(routes_to_merge) > 1:\n                            routes_to_merge = list(routes_to_merge)\n                            route1_idx = routes_to_merge[0]\n                            route2_idx = routes_to_merge[1]\n\n                            route1 = new_solution[route1_idx]\n                            route2 = new_solution[route2_idx]\n\n                            # Find best insertion points\n                            best_cost = float('inf')\n                            best_insertion = None\n                            for i in range(1, len(route1)-1):\n                                for j in range(1, len(route2)-1):\n                                    cost = (distance_matrix[route1[i-1]][route2[j]] +\n                                            distance_matrix[route2[j-1]][route1[i]] -\n                                            distance_matrix[route1[i-1]][route1[i]] -\n                                            distance_matrix[route2[j-1]][route2[j]])\n\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_insertion = (i, j)\n\n                            if best_insertion:\n                                i, j = best_insertion\n                                merged_route = np.concatenate([route1[:i], route2[j:-1], [0]])\n                                if sum(demand[merged_route[1:-1]]) <= capacity:\n                                    new_solution[route1_idx] = merged_route\n                                    new_solution.pop(route2_idx)\n                                    break\n\n    # Objective-driven segment swapping when aggressive search is enabled\n    if aggressive_search and len(new_solution) > 1:\n        for _ in range(3 if aggressive_search else 1):\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find segments to swap based on demand balance\n                segment_length = min(2, len(route1)-2, len(route2)-2)\n                i = random.randint(1, len(route1)-segment_length)\n                j = random.randint(1, len(route2)-segment_length)\n\n                segment1 = route1[i:i+segment_length]\n                segment2 = route2[j:j+segment_length]\n\n                # Try swapping segments\n                new_route1 = np.concatenate([route1[:i], segment2, route1[i+segment_length:]])\n                new_route2 = np.concatenate([route2[:j], segment1, route2[j+segment_length:]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Feasibility checks and repairs\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # Split route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            new_solution.append(remaining_route)\n            new_solution[new_solution.index(route)] = new_route\n\n    # Ensure depot constraints\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.7869506061980014,
            0.2689986824989319
        ],
        "raw_score": [
            58.275310955992765,
            7.823955793721597
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route fragmentation (splitting long routes at optimal points) and cross-exchange (swapping segments between routes while maintaining capacity constraints). The method balances objectives by intelligently modifying routes to reduce the longest route while potentially improving total distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: route fragmentation + cross-exchange\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the increase in total distance\n        min_increase = float('inf')\n        best_split = None\n        for i in range(1, len(longest_route)-1):\n            dist_before = distance_matrix[longest_route[i-1]][longest_route[i]]\n            dist_after = distance_matrix[longest_route[i]][longest_route[i+1]]\n            dist_new = distance_matrix[longest_route[i-1]][0] + distance_matrix[0][longest_route[i]] + \\\n                       distance_matrix[longest_route[i]][0] + distance_matrix[0][longest_route[i+1]]\n\n            if dist_new - (dist_before + dist_after) < min_increase:\n                min_increase = dist_new - (dist_before + dist_after)\n                best_split = i\n\n        if best_split is not None:\n            # Split the route\n            new_route1 = np.concatenate([longest_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], longest_route[best_split:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Step 2: Cross-exchange between routes to balance makespan\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find feasible cross-exchange points\n            feasible_pairs = []\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:i]]) + sum(demand[route2[j:-1]]) <= capacity and\n                        sum(demand[route2[1:j]]) + sum(demand[route1[i:-1]]) <= capacity):\n                        feasible_pairs.append((i, j))\n\n            if feasible_pairs:\n                i, j = random.choice(feasible_pairs)\n                # Perform cross-exchange\n                new_route1 = np.concatenate([route1[:i], route2[j:], [0]])\n                new_route2 = np.concatenate([route2[:j], route1[i:], [0]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8851232325504997,
            1.6942464113235474
        ],
        "raw_score": [
            57.31227674884602,
            7.414957018161158
        ]
    },
    {
        "algorithm": "The algorithm combines elite solution selection with a hybrid local search that alternates between demand-balanced route restructuring and objective-aware node reallocation, prioritizing solutions with high potential for multi-objective improvement while maintaining feasibility through strict capacity checks. It selects promising solutions from the top 30% of the archive (sorted by combined objective values) and applies adaptive operators\u2014splitting routes to balance demand when feasible, or swapping nodes between routes to reduce total distance when beneficial\u2014but always ensures capacity constraints are met. The operator's aggressiveness is implicitly controlled by the solution's position in the archive, favoring exploration of high-potential regions while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Adaptive local search operator\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6255140612380136,
            0.18004998564720154
        ],
        "raw_score": [
            58.404306189036056,
            7.827867873817798
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects high-potential solutions from the archive (prioritizing top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route restructuring, spatial-aware clustering for high-demand nodes, and adaptive segment swapping between routes, while ensuring feasibility through strict capacity checks and dynamic operator intensity based on archive diversity. The selection process balances exploitation (top solutions) and exploration (randomness), while the local search operators focus on demand balancing, spatial proximity, and objective-driven improvements, with aggressive search modes triggered by low archive diversity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate archive diversity\n    diversity_threshold = 0.3\n    if len(archive) > 5:\n        unique_distances = len(set(x[1][0] for x in archive))\n        diversity_ratio = unique_distances / len(archive)\n        aggressive_search = diversity_ratio < diversity_threshold\n    else:\n        aggressive_search = True\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Route restructuring with demand balancing\n        if random.random() < 0.5 or not aggressive_search:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                total_demand = sum(demand[route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n                new_route1 = route[:split_pos + 1]\n                new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = new_route1\n                    new_solution.append(new_route2)\n        else:\n            # Spatial-aware clustering for high-demand nodes\n            high_demand_threshold = capacity * 0.7\n            high_demand_nodes = [i for i in range(1, len(demand)) if demand[i] > high_demand_threshold]\n            if high_demand_nodes and len(new_solution) > 1:\n                from sklearn.cluster import KMeans\n                coords_high_demand = coords[high_demand_nodes]\n                n_clusters = min(3, len(high_demand_nodes))\n                if n_clusters > 1:\n                    kmeans = KMeans(n_clusters=n_clusters).fit(coords_high_demand)\n                    clusters = kmeans.labels_\n                    cluster_routes = {i: [] for i in range(n_clusters)}\n                    for i, node in enumerate(high_demand_nodes):\n                        cluster_id = clusters[i]\n                        for route_idx, route in enumerate(new_solution):\n                            if node in route:\n                                cluster_routes[cluster_id].append((route_idx, node))\n                                break\n                    for cluster_id, nodes in cluster_routes.items():\n                        if len(nodes) > 1:\n                            routes_to_merge = set(route_idx for route_idx, _ in nodes)\n                            if len(routes_to_merge) > 1:\n                                routes_to_merge = list(routes_to_merge)\n                                route1_idx = routes_to_merge[0]\n                                route2_idx = routes_to_merge[1]\n                                route1 = new_solution[route1_idx]\n                                route2 = new_solution[route2_idx]\n                                best_cost = float('inf')\n                                best_insertion = None\n                                for i in range(1, len(route1)-1):\n                                    for j in range(1, len(route2)-1):\n                                        cost = (distance_matrix[route1[i-1]][route2[j]] +\n                                                distance_matrix[route2[j-1]][route1[i]] -\n                                                distance_matrix[route1[i-1]][route1[i]] -\n                                                distance_matrix[route2[j-1]][route2[j]])\n                                        if cost < best_cost:\n                                            best_cost = cost\n                                            best_insertion = (i, j)\n                                if best_insertion:\n                                    i, j = best_insertion\n                                    merged_route = np.concatenate([route1[:i], route2[j:-1], [0]])\n                                    if sum(demand[merged_route[1:-1]]) <= capacity:\n                                        new_solution[route1_idx] = merged_route\n                                        new_solution.pop(route2_idx)\n                                        break\n\n    # Objective-driven segment swapping\n    if aggressive_search and len(new_solution) > 1:\n        for _ in range(3 if aggressive_search else 1):\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            if len(route1) > 2 and len(route2) > 2:\n                segment_length = min(2, len(route1)-2, len(route2)-2)\n                i = random.randint(1, len(route1)-segment_length)\n                j = random.randint(1, len(route2)-segment_length)\n                segment1 = route1[i:i+segment_length]\n                segment2 = route2[j:j+segment_length]\n                new_route1 = np.concatenate([route1[:i], segment2, route1[i+segment_length:]])\n                new_route2 = np.concatenate([route2[:j], segment1, route2[j+segment_length:]])\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Feasibility checks and repairs\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            new_solution.append(remaining_route)\n            new_solution[new_solution.index(route)] = new_route\n\n    # Ensure depot constraints\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.7163201328317831,
            0.25421142578125
        ],
        "raw_score": [
            58.225382679634976,
            7.829071371668853
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top 30% of the archive (weighted equally between total distance and makespan), then applies an adaptive local search that alternates between capacity-balanced route splitting (when multiple routes exist) and distance-aware node relocation (when routes are small), with a strict 10% improvement threshold. It ensures feasibility by dynamically rebalancing demands and strictly enforcing capacity constraints. The method prioritizes route balancing and distance reduction while maintaining solution quality through intelligent random selection and threshold-based improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    if n_routes > 1:\n        # Capacity-balanced route splitting\n        target_load = sum(demand) / n_routes\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            best_split_pos = -1\n            best_balance = float('inf')\n\n            for i in range(1, len(route) - 1):\n                load1 = sum(demand[route[:i+1]])\n                load2 = sum(demand[route[i:]])\n\n                balance = abs(load1 - target_load) + abs(load2 - target_load)\n                if balance < best_balance and load1 <= capacity and load2 <= capacity:\n                    best_balance = balance\n                    best_split_pos = i\n\n            if best_split_pos != -1:\n                new_route1 = route[:best_split_pos+1]\n                new_route2 = np.concatenate([[0], route[best_split_pos+1:]])\n\n                if sum(demand[new_route1]) <= capacity and sum(demand[new_route2]) <= capacity:\n                    new_solution[route_idx] = new_route1\n                    new_solution.append(new_route2)\n\n        # Distance-aware node relocation\n        else:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                old_dist = (distance_matrix[route1[node1_pos-1]][node1] +\n                            distance_matrix[node1][route1[node1_pos+1]] +\n                            distance_matrix[route2[node2_pos-1]][node2] +\n                            distance_matrix[node2][route2[node2_pos+1]])\n\n                new_dist = (distance_matrix[route1[node1_pos-1]][node2] +\n                            distance_matrix[node2][route1[node1_pos+1]] +\n                            distance_matrix[route2[node2_pos-1]][node1] +\n                            distance_matrix[node1][route2[node2_pos+1]])\n\n                if new_dist < old_dist * 0.9:\n                    new_route1 = route1.copy()\n                    new_route2 = route2.copy()\n                    new_route1[node1_pos] = node2\n                    new_route2[node2_pos] = node1\n\n                    if (sum(demand[new_route1]) <= capacity and\n                        sum(demand[new_route2]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n    else:\n        # Dynamic demand rebalancing\n        route = new_solution[0]\n        if len(route) > 3:\n            node_pos = random.randint(1, len(route) - 2)\n            node = route[node_pos]\n\n            best_pos = -1\n            best_improvement = 0\n\n            for i in range(1, len(route)):\n                if i == node_pos or i == node_pos + 1:\n                    continue\n\n                old_dist = (distance_matrix[route[node_pos-1]][node] +\n                            distance_matrix[node][route[node_pos+1]] +\n                            distance_matrix[route[i-1]][route[i]])\n\n                new_dist = (distance_matrix[route[node_pos-1]][route[node_pos+1]] +\n                            distance_matrix[route[i-1]][node] +\n                            distance_matrix[node][route[i]])\n\n                improvement = old_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = i\n\n            if best_pos != -1 and best_improvement > 0:\n                new_route = route.copy()\n                new_route = np.concatenate([new_route[:node_pos], new_route[node_pos+1:]])\n                new_route = np.insert(new_route, best_pos, node)\n\n                if sum(demand[new_route]) <= capacity:\n                    new_solution[0] = new_route\n\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8027078770094358,
            0.29218751192092896
        ],
        "raw_score": [
            58.14067968452336,
            7.83183400722312
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects high-potential solutions from the archive (top 20% with 30% randomness) and applies a hybrid local search combining demand-balanced route splitting, inter-route swaps, and adaptive 3-opt operations, while dynamically adjusting search intensity based on archive diversity to optimize both distance and makespan. The method prioritizes solutions with better combined objective values, applies demand-aware restructuring, and uses probabilistic 3-opt swaps with feasibility checks, increasing exploration in low-diversity archives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 30% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.3:  # 30% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Calculate archive diversity\n    archive_diversity = len(set(tuple(route.tobytes() for route in sol[0]) for sol in archive))\n    low_diversity = archive_diversity < len(archive) * 0.5\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand and minimizes distance increase\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split_pos = 1\n            min_dist_increase = float('inf')\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    # Calculate potential distance increase\n                    new_route1 = route[:i + 1]\n                    new_route2 = np.concatenate([[0], route[i + 1:]])\n                    dist_increase = (distance_matrix[new_route1[-2], 0] +\n                                   distance_matrix[0, new_route2[1]] -\n                                   distance_matrix[route[i-1], route[i]])\n\n                    if dist_increase < min_dist_increase:\n                        min_dist_increase = dist_increase\n                        best_split_pos = i\n\n            new_route1 = route[:best_split_pos + 1]\n            new_route2 = np.concatenate([[0], route[best_split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Objective-aware node swapping with adaptive 3-opt\n        if n_routes >= 2 and (random.random() < 0.7 or low_diversity):\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select three nodes (one from each route)\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n\n                # Try 3-opt swap\n                if len(route1) > 3 and len(route2) > 3:\n                    # Select third node from another route\n                    route3_idx = random.choice([i for i in range(n_routes) if i not in (route1_idx, route2_idx)])\n                    route3 = new_solution[route3_idx]\n                    if len(route3) > 2:\n                        node3_pos = random.randint(1, len(route3) - 2)\n\n                        # Create new routes by swapping nodes\n                        new_route1 = route1.copy()\n                        new_route2 = route2.copy()\n                        new_route3 = route3.copy()\n\n                        new_route1[node1_pos] = route2[node2_pos]\n                        new_route2[node2_pos] = route3[node3_pos]\n                        new_route3[node3_pos] = route1[node1_pos]\n\n                        # Check capacity constraints\n                        if (sum(demand[new_route1]) <= capacity and\n                            sum(demand[new_route2]) <= capacity and\n                            sum(demand[new_route3]) <= capacity):\n\n                            # Calculate new objectives\n                            old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                       sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))) +\n                                       sum(distance_matrix[route3[k-1]][route3[k]] for k in range(1, len(route3))))\n\n                            new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                       sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))) +\n                                       sum(distance_matrix[new_route3[k-1]][new_route3[k]] for k in range(1, len(new_route3))))\n\n                            old_makespan = max(\n                                sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))),\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))),\n                                sum(distance_matrix[route3[k-1]][route3[k]] for k in range(1, len(route3)))\n                            )\n\n                            new_makespan = max(\n                                sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))),\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))),\n                                sum(distance_matrix[new_route3[k-1]][new_route3[k]] for k in range(1, len(new_route3)))\n                            )\n\n                            if (new_dist < old_dist and new_makespan <= old_makespan) or low_diversity:\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution[route3_idx] = new_route3\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8234785187607725,
            0.3723435699939728
        ],
        "raw_score": [
            57.37106989786277,
            7.495612073316964
        ]
    }
]