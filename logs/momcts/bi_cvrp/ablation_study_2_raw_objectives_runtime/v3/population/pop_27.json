[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of normalized distance and makespan objectives (60% distance, 40% makespan), then applies a hybrid local search combining route splitting, inter-route insertion, and modified 2-opt with capacity checks to generate an improved neighbor solution. It prioritizes distance reduction while balancing makespan optimization, and ensures feasibility through strict capacity validation at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives for selection\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Avoid division by zero\n    if max_dist == min_dist:\n        normalized_dist = np.ones_like(distances)\n    else:\n        normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n    if max_make == min_make:\n        normalized_make = np.ones_like(makespans)\n    else:\n        normalized_make = (makespans - min_make) / (max_make - min_make)\n\n    # Weighted sum (can be adjusted)\n    scores = 0.6 * normalized_dist + 0.4 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try route splitting\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # If split fails, try inter-route insertion\n        if len(base_solution) > 1:\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and not np.array_equal(r, route)])\n            if len(other_route) > 3:\n                # Find best insertion point\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(other_route)):\n                    new_route = np.insert(other_route, i, route[1:-1])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = (distance_matrix[new_route[i-1], route[1]] +\n                                distance_matrix[route[-2], new_route[i+len(route)-2]] -\n                                distance_matrix[new_route[i-1], new_route[i+len(route)-2]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    new_route = np.insert(other_route, best_pos, route[1:-1])\n                    new_solution.append(new_route)\n                    continue\n\n        # If all else fails, apply modified 2-opt\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Convert back to original format\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only include non-trivial routes\n            final_solution.append(route)\n\n    return np.array(final_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8948495283173388,
            0.5054986476898193
        ],
        "raw_score": [
            57.889668453293666,
            7.825081625352422
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive (favoring top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route restructuring (splitting routes at capacity-balanced points) and objective-aware node swapping (exchanging nodes between routes when it improves distance). It ensures feasibility through adaptive capacity checks and prioritizes high-potential solutions for further improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7310293206497563,
            0.16164618730545044
        ],
        "raw_score": [
            58.10752915940811,
            7.61725505871078
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive (prioritizing top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route restructuring, inter-route demand-aware swaps, and adaptive 2-opt, while ensuring feasibility through strict capacity checks. It emphasizes balancing demand across routes and minimizing distance increases during route splitting, with adaptive operations prioritizing nodes that show potential for improvement while maintaining capacity constraints. The solution selection and local search operations are designed to balance distance and makespan optimization while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand and minimizes distance increase\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split_pos = 1\n            min_dist_increase = float('inf')\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    # Calculate potential distance increase\n                    new_route1 = route[:i + 1]\n                    new_route2 = np.concatenate([[0], route[i + 1:]])\n                    dist_increase = (distance_matrix[new_route1[-2], 0] +\n                                    distance_matrix[0, new_route2[1]] -\n                                    distance_matrix[route[i-1], route[i]])\n\n                    if dist_increase < min_dist_increase:\n                        min_dist_increase = dist_increase\n                        best_split_pos = i\n\n            new_route1 = route[:best_split_pos + 1]\n            new_route2 = np.concatenate([[0], route[best_split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation with adaptive 2-opt\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement using adaptive 2-opt\n                best_improvement = 0\n                best_swap = None\n\n                for i in range(1, len(route1) - 1):\n                    for j in range(1, len(route2) - 1):\n                        # Calculate potential improvement\n                        old_dist = (distance_matrix[route1[i-1], route1[i]] +\n                                   distance_matrix[route1[i], route1[i+1]] +\n                                   distance_matrix[route2[j-1], route2[j]] +\n                                   distance_matrix[route2[j], route2[j+1]])\n\n                        new_dist = (distance_matrix[route1[i-1], route2[j]] +\n                                  distance_matrix[route2[j], route1[i+1]] +\n                                  distance_matrix[route2[j-1], route1[i]] +\n                                  distance_matrix[route1[i], route2[j+1]])\n\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            # Check capacity constraints\n                            new_route1 = route1.copy()\n                            new_route2 = route2.copy()\n                            new_route1[i] = route2[j]\n                            new_route2[j] = route1[i]\n\n                            if (sum(demand[new_route1]) <= capacity and\n                                sum(demand[new_route2]) <= capacity):\n                                best_improvement = improvement\n                                best_swap = (i, j)\n\n                if best_swap is not None:\n                    i, j = best_swap\n                    new_solution[route1_idx][i] = route2[j]\n                    new_solution[route2_idx][j] = route1[i]\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.7682058259568217,
            0.23147046566009521
        ],
        "raw_score": [
            58.06702696177532,
            7.500376429253305
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the top 20% of the archive (or top 30% with 20% probability) and applies a hybrid local search that alternates between demand-balanced route splitting (for long routes) and objective-aware inter-route node swaps (when swaps improve both distance and makespan). It dynamically adjusts search intensity based on archive diversity, prioritizing high-potential regions while ensuring feasibility through strict capacity checks. The method emphasizes balancing exploration (via random selection) and exploitation (via aggressive restructuring in low-diversity regions), with strict feasibility maintenance at every step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_30 = int(len(archive) * 0.3)\n    top_20 = int(len(archive) * 0.2)\n\n    # Dynamic selection: 80% chance to select from top 20%, 20% chance from top 30%\n    if random.random() < 0.8 and top_20 > 0:\n        selected_idx = random.randint(0, top_20 - 1)\n    else:\n        selected_idx = random.randint(0, min(top_30, len(archive) - 1))\n\n    selected_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Calculate archive diversity (number of unique solutions)\n    archive_diversity = len(set(tuple(route.tobytes() for route in sol[0]) for sol in archive))\n    low_diversity = archive_diversity < len(archive) * 0.5\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing (more aggressive when diversity is low)\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Objective-aware node swapping (more aggressive when diversity is low)\n        if n_routes >= 2 and (random.random() < 0.7 or low_diversity):\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select nodes excluding depot\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                               sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    old_makespan = max(\n                        sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))),\n                        sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2)))\n                    )\n                    new_makespan = max(\n                        sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))),\n                        sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2)))\n                    )\n\n                    if (new_dist < old_dist and new_makespan <= old_makespan) or low_diversity:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8375252380033713,
            0.2893610894680023
        ],
        "raw_score": [
            56.78575562547737,
            7.580634491502313
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route fragmentation (splitting long routes at optimal points) and cross-exchange (swapping segments between routes while maintaining capacity constraints). The method balances objectives by intelligently modifying routes to reduce the longest route while potentially improving total distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: route fragmentation + cross-exchange\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the increase in total distance\n        min_increase = float('inf')\n        best_split = None\n        for i in range(1, len(longest_route)-1):\n            dist_before = distance_matrix[longest_route[i-1]][longest_route[i]]\n            dist_after = distance_matrix[longest_route[i]][longest_route[i+1]]\n            dist_new = distance_matrix[longest_route[i-1]][0] + distance_matrix[0][longest_route[i]] + \\\n                       distance_matrix[longest_route[i]][0] + distance_matrix[0][longest_route[i+1]]\n\n            if dist_new - (dist_before + dist_after) < min_increase:\n                min_increase = dist_new - (dist_before + dist_after)\n                best_split = i\n\n        if best_split is not None:\n            # Split the route\n            new_route1 = np.concatenate([longest_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], longest_route[best_split:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Step 2: Cross-exchange between routes to balance makespan\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find feasible cross-exchange points\n            feasible_pairs = []\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:i]]) + sum(demand[route2[j:-1]]) <= capacity and\n                        sum(demand[route2[1:j]]) + sum(demand[route1[i:-1]]) <= capacity):\n                        feasible_pairs.append((i, j))\n\n            if feasible_pairs:\n                i, j = random.choice(feasible_pairs)\n                # Perform cross-exchange\n                new_route1 = np.concatenate([route1[:i], route2[j:], [0]])\n                new_route2 = np.concatenate([route2[:j], route1[i:], [0]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8851232325504997,
            1.6942464113235474
        ],
        "raw_score": [
            57.31227674884602,
            7.414957018161158
        ]
    },
    {
        "algorithm": "The algorithm combines elite solution selection with a hybrid local search that alternates between demand-balanced route restructuring and objective-aware node reallocation, prioritizing solutions with high potential for multi-objective improvement while maintaining feasibility through strict capacity checks. It selects promising solutions from the top 30% of the archive (sorted by combined objective values) and applies adaptive operators\u2014splitting routes to balance demand when feasible, or swapping nodes between routes to reduce total distance when beneficial\u2014but always ensures capacity constraints are met. The operator's aggressiveness is implicitly controlled by the solution's position in the archive, favoring exploration of high-potential regions while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Adaptive local search operator\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6255140612380136,
            0.18004998564720154
        ],
        "raw_score": [
            58.404306189036056,
            7.827867873817798
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top 30% of the archive (weighted equally between total distance and makespan), then applies an adaptive local search that alternates between capacity-balanced route splitting (when multiple routes exist) and distance-aware node relocation (when routes are small), with a strict 10% improvement threshold. It ensures feasibility by dynamically rebalancing demands and strictly enforcing capacity constraints. The method prioritizes route balancing and distance reduction while maintaining solution quality through intelligent random selection and threshold-based improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    if n_routes > 1:\n        # Capacity-balanced route splitting\n        target_load = sum(demand) / n_routes\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            best_split_pos = -1\n            best_balance = float('inf')\n\n            for i in range(1, len(route) - 1):\n                load1 = sum(demand[route[:i+1]])\n                load2 = sum(demand[route[i:]])\n\n                balance = abs(load1 - target_load) + abs(load2 - target_load)\n                if balance < best_balance and load1 <= capacity and load2 <= capacity:\n                    best_balance = balance\n                    best_split_pos = i\n\n            if best_split_pos != -1:\n                new_route1 = route[:best_split_pos+1]\n                new_route2 = np.concatenate([[0], route[best_split_pos+1:]])\n\n                if sum(demand[new_route1]) <= capacity and sum(demand[new_route2]) <= capacity:\n                    new_solution[route_idx] = new_route1\n                    new_solution.append(new_route2)\n\n        # Distance-aware node relocation\n        else:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                old_dist = (distance_matrix[route1[node1_pos-1]][node1] +\n                            distance_matrix[node1][route1[node1_pos+1]] +\n                            distance_matrix[route2[node2_pos-1]][node2] +\n                            distance_matrix[node2][route2[node2_pos+1]])\n\n                new_dist = (distance_matrix[route1[node1_pos-1]][node2] +\n                            distance_matrix[node2][route1[node1_pos+1]] +\n                            distance_matrix[route2[node2_pos-1]][node1] +\n                            distance_matrix[node1][route2[node2_pos+1]])\n\n                if new_dist < old_dist * 0.9:\n                    new_route1 = route1.copy()\n                    new_route2 = route2.copy()\n                    new_route1[node1_pos] = node2\n                    new_route2[node2_pos] = node1\n\n                    if (sum(demand[new_route1]) <= capacity and\n                        sum(demand[new_route2]) <= capacity):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n    else:\n        # Dynamic demand rebalancing\n        route = new_solution[0]\n        if len(route) > 3:\n            node_pos = random.randint(1, len(route) - 2)\n            node = route[node_pos]\n\n            best_pos = -1\n            best_improvement = 0\n\n            for i in range(1, len(route)):\n                if i == node_pos or i == node_pos + 1:\n                    continue\n\n                old_dist = (distance_matrix[route[node_pos-1]][node] +\n                            distance_matrix[node][route[node_pos+1]] +\n                            distance_matrix[route[i-1]][route[i]])\n\n                new_dist = (distance_matrix[route[node_pos-1]][route[node_pos+1]] +\n                            distance_matrix[route[i-1]][node] +\n                            distance_matrix[node][route[i]])\n\n                improvement = old_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = i\n\n            if best_pos != -1 and best_improvement > 0:\n                new_route = route.copy()\n                new_route = np.concatenate([new_route[:node_pos], new_route[node_pos+1:]])\n                new_route = np.insert(new_route, best_pos, node)\n\n                if sum(demand[new_route]) <= capacity:\n                    new_solution[0] = new_route\n\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8027078770094358,
            0.29218751192092896
        ],
        "raw_score": [
            58.14067968452336,
            7.83183400722312
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects high-potential solutions from the archive (top 20% with 30% randomness) and applies a hybrid local search combining demand-balanced route splitting, inter-route swaps, and adaptive 3-opt operations, while dynamically adjusting search intensity based on archive diversity to optimize both distance and makespan. The method prioritizes solutions with better combined objective values, applies demand-aware restructuring, and uses probabilistic 3-opt swaps with feasibility checks, increasing exploration in low-diversity archives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 30% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.3:  # 30% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Calculate archive diversity\n    archive_diversity = len(set(tuple(route.tobytes() for route in sol[0]) for sol in archive))\n    low_diversity = archive_diversity < len(archive) * 0.5\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand and minimizes distance increase\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split_pos = 1\n            min_dist_increase = float('inf')\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    # Calculate potential distance increase\n                    new_route1 = route[:i + 1]\n                    new_route2 = np.concatenate([[0], route[i + 1:]])\n                    dist_increase = (distance_matrix[new_route1[-2], 0] +\n                                   distance_matrix[0, new_route2[1]] -\n                                   distance_matrix[route[i-1], route[i]])\n\n                    if dist_increase < min_dist_increase:\n                        min_dist_increase = dist_increase\n                        best_split_pos = i\n\n            new_route1 = route[:best_split_pos + 1]\n            new_route2 = np.concatenate([[0], route[best_split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Objective-aware node swapping with adaptive 3-opt\n        if n_routes >= 2 and (random.random() < 0.7 or low_diversity):\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select three nodes (one from each route)\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n\n                # Try 3-opt swap\n                if len(route1) > 3 and len(route2) > 3:\n                    # Select third node from another route\n                    route3_idx = random.choice([i for i in range(n_routes) if i not in (route1_idx, route2_idx)])\n                    route3 = new_solution[route3_idx]\n                    if len(route3) > 2:\n                        node3_pos = random.randint(1, len(route3) - 2)\n\n                        # Create new routes by swapping nodes\n                        new_route1 = route1.copy()\n                        new_route2 = route2.copy()\n                        new_route3 = route3.copy()\n\n                        new_route1[node1_pos] = route2[node2_pos]\n                        new_route2[node2_pos] = route3[node3_pos]\n                        new_route3[node3_pos] = route1[node1_pos]\n\n                        # Check capacity constraints\n                        if (sum(demand[new_route1]) <= capacity and\n                            sum(demand[new_route2]) <= capacity and\n                            sum(demand[new_route3]) <= capacity):\n\n                            # Calculate new objectives\n                            old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                       sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))) +\n                                       sum(distance_matrix[route3[k-1]][route3[k]] for k in range(1, len(route3))))\n\n                            new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                       sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))) +\n                                       sum(distance_matrix[new_route3[k-1]][new_route3[k]] for k in range(1, len(new_route3))))\n\n                            old_makespan = max(\n                                sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))),\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))),\n                                sum(distance_matrix[route3[k-1]][route3[k]] for k in range(1, len(route3)))\n                            )\n\n                            new_makespan = max(\n                                sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))),\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))),\n                                sum(distance_matrix[new_route3[k-1]][new_route3[k]] for k in range(1, len(new_route3)))\n                            )\n\n                            if (new_dist < old_dist and new_makespan <= old_makespan) or low_diversity:\n                                new_solution[route1_idx] = new_route1\n                                new_solution[route2_idx] = new_route2\n                                new_solution[route3_idx] = new_route3\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8234785187607725,
            0.3723435699939728
        ],
        "raw_score": [
            57.37106989786277,
            7.495612073316964
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects high-potential solutions from the archive (top 20% with 30% randomness) and applies a hybrid local search that alternates between demand-balanced route splitting and spatial-density-aware node swapping (using DBSCAN clustering for high-demand nodes), while dynamically adjusting search intensity based on archive diversity to optimize both distance and makespan, with probabilistic acceptance of improvements that reduce either objective while always ensuring vehicle capacity constraints are met.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 30% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.3:  # 30% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Calculate archive diversity\n    archive_diversity = len(set(tuple(route.tobytes() for route in sol[0]) for sol in archive))\n    low_diversity = archive_diversity < len(archive) * 0.5\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Alternate between route splitting and node swapping\n        if random.random() < 0.6 or low_diversity:\n            # Route splitting with demand balancing\n            route_idx = random.randint(0, n_routes - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find split point that balances demand\n                total_demand = sum(demand[route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                best_split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= target_demand:\n                        best_split_pos = i\n                        break\n\n                new_route1 = route[:best_split_pos + 1]\n                new_route2 = np.concatenate([[0], route[best_split_pos + 1:]])\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    new_solution[route_idx] = new_route1\n                    new_solution.append(new_route2)\n        else:\n            # Spatial-density-aware node swapping for high-demand nodes\n            high_demand_nodes = [i for i in range(1, len(demand)) if demand[i] > capacity * 0.3]\n            if len(high_demand_nodes) > 1:\n                # Cluster high-demand nodes\n                from sklearn.cluster import DBSCAN\n                X = coords[high_demand_nodes]\n                clustering = DBSCAN(eps=0.5, min_samples=2).fit(X)\n                clusters = clustering.labels_\n\n                # Find nodes in the same cluster\n                cluster_nodes = {}\n                for i, node in enumerate(high_demand_nodes):\n                    cluster_id = clusters[i]\n                    if cluster_id != -1:\n                        if cluster_id not in cluster_nodes:\n                            cluster_nodes[cluster_id] = []\n                        cluster_nodes[cluster_id].append(node)\n\n                # Try to swap nodes from the same cluster\n                for cluster_id, nodes in cluster_nodes.items():\n                    if len(nodes) >= 2:\n                        node1 = nodes[0]\n                        node2 = nodes[1]\n\n                        # Find routes containing these nodes\n                        route1_idx = None\n                        route2_idx = None\n                        for r_idx, route in enumerate(new_solution):\n                            if node1 in route and node2 in route:\n                                continue\n                            if node1 in route:\n                                route1_idx = r_idx\n                            if node2 in route:\n                                route2_idx = r_idx\n                            if route1_idx is not None and route2_idx is not None:\n                                break\n\n                        if route1_idx is not None and route2_idx is not None:\n                            route1 = new_solution[route1_idx]\n                            route2 = new_solution[route2_idx]\n\n                            # Find positions of nodes in routes\n                            node1_pos = np.where(route1 == node1)[0][0]\n                            node2_pos = np.where(route2 == node2)[0][0]\n\n                            # Try swapping nodes\n                            new_route1 = route1.copy()\n                            new_route2 = route2.copy()\n                            new_route1[node1_pos] = node2\n                            new_route2[node2_pos] = node1\n\n                            if (sum(demand[new_route1]) <= capacity and\n                                sum(demand[new_route2]) <= capacity):\n                                # Calculate new objectives\n                                old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                           sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                                new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                           sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                                if new_dist < old_dist:\n                                    new_solution[route1_idx] = new_route1\n                                    new_solution[route2_idx] = new_route2\n                                    break\n    else:\n        # For single-route solutions, try demand-aware node reallocation\n        if n_routes == 1 and len(new_solution[0]) > 3:\n            route = new_solution[0]\n            # Find two nodes to swap\n            node1_pos = random.randint(1, len(route) - 2)\n            node2_pos = random.randint(1, len(route) - 2)\n            node1 = route[node1_pos]\n            node2 = route[node2_pos]\n\n            # Try swapping nodes\n            new_route = route.copy()\n            new_route[node1_pos] = node2\n            new_route[node2_pos] = node1\n\n            if sum(demand[new_route]) <= capacity:\n                # Calculate new distance\n                old_dist = sum(distance_matrix[route[k-1]][route[k]] for k in range(1, len(route)))\n                new_dist = sum(distance_matrix[new_route[k-1]][new_route[k]] for k in range(1, len(new_route)))\n\n                if new_dist < old_dist:\n                    new_solution[0] = new_route\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        if sum(demand[route]) > capacity:\n            # Split route if capacity is exceeded\n            split_pos = 1\n            current_load = 0\n            for j in range(1, len(route)-1):\n                current_load += demand[route[j]]\n                if current_load > capacity:\n                    split_pos = j\n                    break\n            new_route = np.concatenate([route[:split_pos], [0]])\n            remaining_route = np.concatenate([[0], route[split_pos:]])\n            new_solution.append(remaining_route)\n            new_solution[new_solution.index(route)] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.518626954610499,
            0.22996562719345093
        ],
        "raw_score": [
            55.98272273322016,
            7.162026829951223
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects high-potential solutions from the archive (prioritizing top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route splitting, adaptive edge swapping (with makespan-awareness and diversity-based intensity), and inter-route demand reallocation, while strictly enforcing capacity constraints and ensuring feasibility. The search intensity adapts based on archive diversity, with more aggressive operations when diversity is low, and prioritizes makespan improvement while balancing total distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Calculate archive diversity\n    archive_diversity = len(set(tuple(route.tobytes() for route in sol[0]) for sol in archive))\n    low_diversity = archive_diversity < len(archive) * 0.5\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand and minimizes distance increase\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split_pos = 1\n            min_dist_increase = float('inf')\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    # Calculate potential distance increase\n                    new_route1 = route[:i + 1]\n                    new_route2 = np.concatenate([[0], route[i + 1:]])\n                    dist_increase = (distance_matrix[new_route1[-2], 0] +\n                                    distance_matrix[0, new_route2[1]] -\n                                    distance_matrix[route[i-1], route[i]])\n\n                    if dist_increase < min_dist_increase:\n                        min_dist_increase = dist_increase\n                        best_split_pos = i\n\n            new_route1 = route[:best_split_pos + 1]\n            new_route2 = np.concatenate([[0], route[best_split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Makespan-aware edge swapping (more aggressive when diversity is low)\n        if n_routes >= 2 and (random.random() < 0.7 or low_diversity):\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select edges excluding depot\n                edge1_pos = random.randint(1, len(route1) - 2)\n                edge2_pos = random.randint(1, len(route2) - 2)\n\n                # Calculate current makespans\n                old_makespan1 = sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1)))\n                old_makespan2 = sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2)))\n\n                # Try swapping edges\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[edge1_pos], new_route2[edge2_pos] = new_route2[edge2_pos], new_route1[edge1_pos]\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new makespans\n                    new_makespan1 = sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1)))\n                    new_makespan2 = sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2)))\n\n                    # Accept if both makespans improve or at least one improves significantly\n                    if ((new_makespan1 < old_makespan1 and new_makespan2 < old_makespan2) or\n                        (new_makespan1 < old_makespan1 * 0.9 or new_makespan2 < old_makespan2 * 0.9)):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Inter-route demand reallocation when routes are too full\n    for i in range(n_routes):\n        route = new_solution[i]\n        if sum(demand[route]) > capacity * 0.9:  # If route is 90% full\n            # Find the most demanding customer\n            max_demand_pos = np.argmax(demand[route[1:-1]]) + 1\n            max_demand_customer = route[max_demand_pos]\n\n            # Try to move this customer to another route\n            for j in range(n_routes):\n                if i != j:\n                    other_route = new_solution[j]\n                    if sum(demand[other_route]) + demand[max_demand_customer] <= capacity:\n                        # Find best insertion point\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for k in range(1, len(other_route)):\n                            new_route = np.insert(other_route, k, max_demand_customer)\n                            cost = (distance_matrix[other_route[k-1], max_demand_customer] +\n                                    distance_matrix[max_demand_customer, other_route[k]] -\n                                    distance_matrix[other_route[k-1], other_route[k]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = k\n\n                        if best_cost < float('inf'):\n                            # Perform the move\n                            new_route = np.insert(other_route, best_pos, max_demand_customer)\n                            new_solution[j] = new_route\n                            new_solution[i] = np.delete(route, max_demand_pos)\n                            break\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8458568424617452,
            3.3554292023181915
        ],
        "raw_score": [
            56.162860278341,
            7.188380608146739
        ]
    }
]