[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of normalized distance and makespan objectives (60% distance, 40% makespan), then applies a hybrid local search combining route splitting, inter-route insertion, and modified 2-opt with capacity checks to generate an improved neighbor solution. It prioritizes distance reduction while balancing makespan optimization, and ensures feasibility through strict capacity validation at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives for selection\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Avoid division by zero\n    if max_dist == min_dist:\n        normalized_dist = np.ones_like(distances)\n    else:\n        normalized_dist = (distances - min_dist) / (max_dist - min_dist)\n\n    if max_make == min_make:\n        normalized_make = np.ones_like(makespans)\n    else:\n        normalized_make = (makespans - min_make) / (max_make - min_make)\n\n    # Weighted sum (can be adjusted)\n    scores = 0.6 * normalized_dist + 0.4 * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try route splitting\n        split_pos = len(route) // 2\n        new_route1 = route[:split_pos + 1]\n        new_route2 = np.concatenate([[0], route[split_pos:]])\n\n        # Check capacity for new routes\n        if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n            np.sum(demand[new_route2[1:-1]]) <= capacity):\n            new_solution.extend([new_route1, new_route2])\n            continue\n\n        # If split fails, try inter-route insertion\n        if len(base_solution) > 1:\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and not np.array_equal(r, route)])\n            if len(other_route) > 3:\n                # Find best insertion point\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(other_route)):\n                    new_route = np.insert(other_route, i, route[1:-1])\n                    if np.sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = (distance_matrix[new_route[i-1], route[1]] +\n                                distance_matrix[route[-2], new_route[i+len(route)-2]] -\n                                distance_matrix[new_route[i-1], new_route[i+len(route)-2]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    new_route = np.insert(other_route, best_pos, route[1:-1])\n                    new_solution.append(new_route)\n                    continue\n\n        # If all else fails, apply modified 2-opt\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    # Convert back to original format\n    final_solution = []\n    for route in new_solution:\n        if len(route) > 2:  # Only include non-trivial routes\n            final_solution.append(route)\n\n    return np.array(final_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8948495283173388,
            0.5054986476898193
        ],
        "raw_score": [
            57.889668453293666,
            7.825081625352422
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive (favoring top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route restructuring (splitting routes at capacity-balanced points) and objective-aware node swapping (exchanging nodes between routes when it improves distance). It ensures feasibility through adaptive capacity checks and prioritizes high-potential solutions for further improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7310293206497563,
            0.16164618730545044
        ],
        "raw_score": [
            58.10752915940811,
            7.61725505871078
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive (prioritizing top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route restructuring, inter-route demand-aware swaps, and adaptive 2-opt, while ensuring feasibility through strict capacity checks. It emphasizes balancing demand across routes and minimizing distance increases during route splitting, with adaptive operations prioritizing nodes that show potential for improvement while maintaining capacity constraints. The solution selection and local search operations are designed to balance distance and makespan optimization while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand and minimizes distance increase\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split_pos = 1\n            min_dist_increase = float('inf')\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    # Calculate potential distance increase\n                    new_route1 = route[:i + 1]\n                    new_route2 = np.concatenate([[0], route[i + 1:]])\n                    dist_increase = (distance_matrix[new_route1[-2], 0] +\n                                    distance_matrix[0, new_route2[1]] -\n                                    distance_matrix[route[i-1], route[i]])\n\n                    if dist_increase < min_dist_increase:\n                        min_dist_increase = dist_increase\n                        best_split_pos = i\n\n            new_route1 = route[:best_split_pos + 1]\n            new_route2 = np.concatenate([[0], route[best_split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation with adaptive 2-opt\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement using adaptive 2-opt\n                best_improvement = 0\n                best_swap = None\n\n                for i in range(1, len(route1) - 1):\n                    for j in range(1, len(route2) - 1):\n                        # Calculate potential improvement\n                        old_dist = (distance_matrix[route1[i-1], route1[i]] +\n                                   distance_matrix[route1[i], route1[i+1]] +\n                                   distance_matrix[route2[j-1], route2[j]] +\n                                   distance_matrix[route2[j], route2[j+1]])\n\n                        new_dist = (distance_matrix[route1[i-1], route2[j]] +\n                                  distance_matrix[route2[j], route1[i+1]] +\n                                  distance_matrix[route2[j-1], route1[i]] +\n                                  distance_matrix[route1[i], route2[j+1]])\n\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            # Check capacity constraints\n                            new_route1 = route1.copy()\n                            new_route2 = route2.copy()\n                            new_route1[i] = route2[j]\n                            new_route2[j] = route1[i]\n\n                            if (sum(demand[new_route1]) <= capacity and\n                                sum(demand[new_route2]) <= capacity):\n                                best_improvement = improvement\n                                best_swap = (i, j)\n\n                if best_swap is not None:\n                    i, j = best_swap\n                    new_solution[route1_idx][i] = route2[j]\n                    new_solution[route2_idx][j] = route1[i]\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.7682058259568217,
            0.23147046566009521
        ],
        "raw_score": [
            58.06702696177532,
            7.500376429253305
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the top 20% of the archive (or top 30% with 20% probability) and applies a hybrid local search that alternates between demand-balanced route splitting (for long routes) and objective-aware inter-route node swaps (when swaps improve both distance and makespan). It dynamically adjusts search intensity based on archive diversity, prioritizing high-potential regions while ensuring feasibility through strict capacity checks. The method emphasizes balancing exploration (via random selection) and exploitation (via aggressive restructuring in low-diversity regions), with strict feasibility maintenance at every step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_30 = int(len(archive) * 0.3)\n    top_20 = int(len(archive) * 0.2)\n\n    # Dynamic selection: 80% chance to select from top 20%, 20% chance from top 30%\n    if random.random() < 0.8 and top_20 > 0:\n        selected_idx = random.randint(0, top_20 - 1)\n    else:\n        selected_idx = random.randint(0, min(top_30, len(archive) - 1))\n\n    selected_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Calculate archive diversity (number of unique solutions)\n    archive_diversity = len(set(tuple(route.tobytes() for route in sol[0]) for sol in archive))\n    low_diversity = archive_diversity < len(archive) * 0.5\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Route restructuring with demand balancing (more aggressive when diversity is low)\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Objective-aware node swapping (more aggressive when diversity is low)\n        if n_routes >= 2 and (random.random() < 0.7 or low_diversity):\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select nodes excluding depot\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                               sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    old_makespan = max(\n                        sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))),\n                        sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2)))\n                    )\n                    new_makespan = max(\n                        sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))),\n                        sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2)))\n                    )\n\n                    if (new_dist < old_dist and new_makespan <= old_makespan) or low_diversity:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8375252380033713,
            0.2893610894680023
        ],
        "raw_score": [
            56.78575562547737,
            7.580634491502313
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route fragmentation (splitting long routes at optimal points) and cross-exchange (swapping segments between routes while maintaining capacity constraints). The method balances objectives by intelligently modifying routes to reduce the longest route while potentially improving total distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search: route fragmentation + cross-exchange\n    if len(new_solution) > 1:\n        # Step 1: Route fragmentation - split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the best split point to minimize the increase in total distance\n        min_increase = float('inf')\n        best_split = None\n        for i in range(1, len(longest_route)-1):\n            dist_before = distance_matrix[longest_route[i-1]][longest_route[i]]\n            dist_after = distance_matrix[longest_route[i]][longest_route[i+1]]\n            dist_new = distance_matrix[longest_route[i-1]][0] + distance_matrix[0][longest_route[i]] + \\\n                       distance_matrix[longest_route[i]][0] + distance_matrix[0][longest_route[i+1]]\n\n            if dist_new - (dist_before + dist_after) < min_increase:\n                min_increase = dist_new - (dist_before + dist_after)\n                best_split = i\n\n        if best_split is not None:\n            # Split the route\n            new_route1 = np.concatenate([longest_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], longest_route[best_split:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Step 2: Cross-exchange between routes to balance makespan\n        if len(new_solution) > 1:\n            # Select two different routes\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find feasible cross-exchange points\n            feasible_pairs = []\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check capacity constraints\n                    if (sum(demand[route1[1:i]]) + sum(demand[route2[j:-1]]) <= capacity and\n                        sum(demand[route2[1:j]]) + sum(demand[route1[i:-1]]) <= capacity):\n                        feasible_pairs.append((i, j))\n\n            if feasible_pairs:\n                i, j = random.choice(feasible_pairs)\n                # Perform cross-exchange\n                new_route1 = np.concatenate([route1[:i], route2[j:], [0]])\n                new_route2 = np.concatenate([route2[:j], route1[i:], [0]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8851232325504997,
            1.6942464113235474
        ],
        "raw_score": [
            57.31227674884602,
            7.414957018161158
        ]
    },
    {
        "algorithm": "The algorithm combines elite solution selection with a hybrid local search that alternates between demand-balanced route restructuring and objective-aware node reallocation, prioritizing solutions with high potential for multi-objective improvement while maintaining feasibility through strict capacity checks. It selects promising solutions from the top 30% of the archive (sorted by combined objective values) and applies adaptive operators\u2014splitting routes to balance demand when feasible, or swapping nodes between routes to reduce total distance when beneficial\u2014but always ensures capacity constraints are met. The operator's aggressiveness is implicitly controlled by the solution's position in the archive, favoring exploration of high-potential regions while preserving feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Adaptive local search operator\n    if n_routes > 1:\n        # Route restructuring with demand balancing\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Objective-aware node reallocation\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and objective improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new objectives\n                    old_dist = (sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1))) +\n                                sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2))))\n                    new_dist = (sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1))) +\n                                sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2))))\n\n                    if new_dist < old_dist:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6255140612380136,
            0.18004998564720154
        ],
        "raw_score": [
            58.404306189036056,
            7.827867873817798
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a high-performing solution from the archive (those with larger total distance or makespan) and applies a hybrid local search that combines route splitting (to reduce makespan) and demand-aware node swapping (to improve distance) while ensuring vehicle capacity constraints are never violated. It first tries route splitting if the solution has multiple routes, otherwise performs node swaps between routes, always checking feasibility before accepting changes. The selection prioritizes solutions with worse objectives to focus improvement efforts where they matter most.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search operator\n    if n_routes > 1 and random.random() < 0.5:\n        # Option 1: Route splitting and merging\n        # Select a random route to split\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Ensure route can be split\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            # Check capacity constraints\n            if (np.sum(demand[new_route1]) <= capacity and\n                np.sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Option 2: Demand-aware node swapping and capacity-aware merging\n        # Select two random routes\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find nodes to swap\n            if len(route1) > 2 and len(route2) > 2:\n                # Select nodes excluding depot\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity constraints after swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (np.sum(demand[new_route1]) <= capacity and\n                    np.sum(demand[new_route2]) <= capacity):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert np.sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7736218329232261,
            0.332954078912735
        ],
        "raw_score": [
            57.83281969568547,
            7.686027274006558
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a promising solution from the archive using a weighted combination of normalized distance and makespan objectives, where weights adapt based on archive diversity, and then applies a hybrid local search combining demand-aware route splitting, inter-route demand balancing, and a modified 2-opt with capacity checks to generate a feasible neighbor solution that improves both objectives while ensuring feasibility. The selection prioritizes solutions with balanced trade-offs between objectives, while the local search focuses on high-demand routes and demand-balanced transfers to improve efficiency.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted selection based on archive diversity\n    distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(distances), np.max(distances)\n    min_make, max_make = np.min(makespans), np.max(makespans)\n\n    # Calculate diversity-based weights\n    dist_range = max_dist - min_dist if max_dist != min_dist else 1\n    make_range = max_make - min_make if max_make != min_make else 1\n    dist_weight = 1 - (dist_range / (dist_range + make_range)) if (dist_range + make_range) > 0 else 0.5\n    make_weight = 1 - dist_weight\n\n    # Normalize objectives\n    normalized_dist = (distances - min_dist) / dist_range if dist_range > 0 else np.ones_like(distances)\n    normalized_make = (makespans - min_make) / make_range if make_range > 0 else np.ones_like(makespans)\n\n    # Weighted sum with dynamic weights\n    scores = dist_weight * normalized_dist + make_weight * normalized_make\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Try demand-aware route splitting\n        total_demand = np.sum(demand[route[1:-1]])\n        if total_demand > capacity * 0.7:  # Only split if demand is high\n            split_pos = len(route) // 2\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n\n            # Check capacity for new routes\n            if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                np.sum(demand[new_route2[1:-1]]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n                continue\n\n        # Try inter-route demand balancing\n        if len(base_solution) > 1:\n            # Find route with similar demand\n            target_demand = np.sum(demand[route[1:-1]])\n            for other_route in base_solution:\n                if len(other_route) > 3 and not np.array_equal(other_route, route):\n                    other_demand = np.sum(demand[other_route[1:-1]])\n                    if abs(other_demand - target_demand) < capacity * 0.3:\n                        # Try to transfer nodes\n                        for node in route[1:-1]:\n                            if demand[node] < capacity * 0.3:  # Only transfer small nodes\n                                new_other = np.insert(other_route, -1, node)\n                                new_route = np.delete(route, np.where(route == node)[0][0])\n                                if (np.sum(demand[new_other[1:-1]]) <= capacity and\n                                    np.sum(demand[new_route[1:-1]]) <= capacity):\n                                    new_solution.append(new_route)\n                                    other_route = new_other\n                                    break\n                        break\n\n        # Modified 2-opt with capacity checks\n        best_route = route.copy()\n        for i in range(1, len(route)-2):\n            for j in range(i+1, len(route)-1):\n                new_route = route.copy()\n                new_route[i:j+1] = route[j:i-1:-1]\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    current_cost = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_cost = (distance_matrix[route[i-1], route[j]] +\n                                distance_matrix[route[i], route[j+1]])\n                    if new_cost < current_cost:\n                        best_route = new_route\n        new_solution.append(best_route)\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [r for r in new_solution if len(r) > 2]\n    all_customers = set(range(1, len(coords)))\n    served = set()\n    for route in new_solution:\n        served.update(route[1:-1])\n    if served != all_customers:\n        # Recover missing customers by inserting them into the longest route\n        missing = list(all_customers - served)\n        longest_route = max(new_solution, key=lambda r: len(r))\n        for customer in missing:\n            best_pos = 1\n            best_cost = float('inf')\n            for i in range(1, len(longest_route)):\n                new_route = np.insert(longest_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) <= capacity:\n                    cost = (distance_matrix[longest_route[i-1], customer] +\n                            distance_matrix[customer, longest_route[i]] -\n                            distance_matrix[longest_route[i-1], longest_route[i]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_cost < float('inf'):\n                longest_route = np.insert(longest_route, best_pos, customer)\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8087014140793183,
            0.8795082271099091
        ],
        "raw_score": [
            57.945291588913435,
            7.622967802666784
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects high-potential solutions from the archive (favoring top 20% with 20% randomness) and applies a hybrid local search combining demand-aware route restructuring, inter-route insertion with capacity balancing, and adaptive 2-opt with objective-aware node swapping to optimize both distance and makespan while preserving feasibility. It prioritizes solutions with balanced demand distribution and minimizes distance increases during route modifications, while ensuring vehicle capacity constraints are never violated. The method intelligently explores the solution space by adaptively balancing exploration (randomness) and exploitation (targeted improvement) across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1:\n        # Demand-aware route restructuring\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand and minimizes distance increase\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            best_split_pos = 1\n            min_dist_increase = float('inf')\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    # Calculate potential distance increase\n                    new_route1 = route[:i + 1]\n                    new_route2 = np.concatenate([[0], route[i + 1:]])\n                    dist_increase = (distance_matrix[new_route1[-2], 0] +\n                                    distance_matrix[0, new_route2[1]] -\n                                    distance_matrix[route[i-1], route[i]])\n\n                    if dist_increase < min_dist_increase:\n                        min_dist_increase = dist_increase\n                        best_split_pos = i\n\n            new_route1 = route[:best_split_pos + 1]\n            new_route2 = np.concatenate([[0], route[best_split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n\n        # Inter-route insertion with capacity balancing\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find best insertion point that maintains capacity balance\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(route2)):\n                    new_route = np.insert(route2, i, route1[1:-1])\n                    if sum(demand[new_route]) <= capacity:\n                        cost = (distance_matrix[route2[i-1], route1[1]] +\n                                distance_matrix[route1[-2], route2[i]] -\n                                distance_matrix[route2[i-1], route2[i]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n\n                if best_cost < float('inf'):\n                    new_route = np.insert(route2, best_pos, route1[1:-1])\n                    if sum(demand[new_route]) <= capacity:\n                        new_solution[route1_idx] = np.array([0, 0])\n                        new_solution[route2_idx] = new_route\n\n    else:\n        # Adaptive 2-opt with objective-aware node swapping\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                best_improvement = 0\n                best_swap = None\n\n                for i in range(1, len(route1) - 1):\n                    for j in range(1, len(route2) - 1):\n                        # Calculate potential improvement\n                        old_dist = (distance_matrix[route1[i-1], route1[i]] +\n                                   distance_matrix[route1[i], route1[i+1]] +\n                                   distance_matrix[route2[j-1], route2[j]] +\n                                   distance_matrix[route2[j], route2[j+1]])\n\n                        new_dist = (distance_matrix[route1[i-1], route2[j]] +\n                                  distance_matrix[route2[j], route1[i+1]] +\n                                  distance_matrix[route2[j-1], route1[i]] +\n                                  distance_matrix[route1[i], route2[j+1]])\n\n                        improvement = old_dist - new_dist\n                        if improvement > best_improvement:\n                            # Check capacity constraints\n                            new_route1 = route1.copy()\n                            new_route2 = route2.copy()\n                            new_route1[i] = route2[j]\n                            new_route2[j] = route1[i]\n\n                            if (sum(demand[new_route1]) <= capacity and\n                                sum(demand[new_route2]) <= capacity):\n                                best_improvement = improvement\n                                best_swap = (i, j)\n\n                if best_swap is not None:\n                    i, j = best_swap\n                    new_solution[route1_idx][i] = route2[j]\n                    new_solution[route2_idx][j] = route1[i]\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.8069587082856106,
            0.5495399534702301
        ],
        "raw_score": [
            58.62756631982418,
            7.784396741794801
        ]
    },
    {
        "algorithm": "This algorithm dynamically selects promising solutions from an archive (favoring top 20% with 20% randomness) and applies a hybrid local search combining demand-balanced route splitting, makespan-aware adaptive swaps between routes, and inter-route demand reallocation to optimize both total distance and makespan while maintaining feasibility. The method prioritizes makespan improvement during swaps and uses demand-based heuristics for route restructuring, with capacity checks at each step to ensure feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize top 20% high-potential solutions, with 20% randomness\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_20 = int(len(archive) * 0.2)\n    if top_20 < 1:\n        top_20 = 1\n    if random.random() < 0.2:  # 20% chance to select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, top_20 - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n    n_routes = len(new_solution)\n\n    # Hybrid local search with adaptive intensity\n    if n_routes > 1 and random.random() < 0.7:  # 70% chance for route restructuring\n        # Demand-balanced route splitting\n        route_idx = random.randint(0, n_routes - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Find split point that balances demand\n            total_demand = sum(demand[route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(route) - 1):\n                current_demand += demand[route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            new_route1 = route[:split_pos + 1]\n            new_route2 = np.concatenate([[0], route[split_pos + 1:]])\n\n            if (sum(demand[new_route1]) <= capacity and\n                sum(demand[new_route2]) <= capacity):\n                new_solution[route_idx] = new_route1\n                new_solution.append(new_route2)\n    else:\n        # Makespan-aware adaptive 2-opt\n        if n_routes >= 2:\n            route1_idx, route2_idx = random.sample(range(n_routes), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find nodes with potential for makespan improvement\n                node1_pos = random.randint(1, len(route1) - 2)\n                node2_pos = random.randint(1, len(route2) - 2)\n                node1 = route1[node1_pos]\n                node2 = route2[node2_pos]\n\n                # Check capacity and makespan improvement\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[node1_pos] = node2\n                new_route2[node2_pos] = node1\n\n                if (sum(demand[new_route1]) <= capacity and\n                    sum(demand[new_route2]) <= capacity):\n                    # Calculate new makespans\n                    old_make1 = sum(distance_matrix[route1[k-1]][route1[k]] for k in range(1, len(route1)))\n                    old_make2 = sum(distance_matrix[route2[k-1]][route2[k]] for k in range(1, len(route2)))\n                    new_make1 = sum(distance_matrix[new_route1[k-1]][new_route1[k]] for k in range(1, len(new_route1)))\n                    new_make2 = sum(distance_matrix[new_route2[k-1]][new_route2[k]] for k in range(1, len(new_route2)))\n\n                    # Accept if both makespans improve or one improves significantly\n                    if (new_make1 < old_make1 and new_make2 < old_make2) or \\\n                       (new_make1 < old_make1 * 0.9 and new_make2 < old_make2 * 0.9):\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Inter-route demand reallocation if needed\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if sum(demand[route]) > capacity:\n            # Find a route with excess capacity\n            for j in range(len(new_solution)):\n                if i != j and sum(demand[new_solution[j]]) + sum(demand[route]) <= 2 * capacity:\n                    # Transfer customers with smallest demand\n                    sorted_nodes = sorted(route[1:-1], key=lambda x: demand[x])\n                    for node in sorted_nodes:\n                        if sum(demand[route]) - demand[node] >= 0 and \\\n                           sum(demand[new_solution[j]]) + demand[node] <= capacity:\n                            # Find best insertion point\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for k in range(1, len(new_solution[j])):\n                                new_route = np.insert(new_solution[j], k, node)\n                                cost = (distance_matrix[new_route[k-1], node] +\n                                        distance_matrix[node, new_route[k+1]] -\n                                        distance_matrix[new_route[k-1], new_route[k+1]])\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = k\n                            if best_cost < float('inf'):\n                                new_solution[j] = np.insert(new_solution[j], best_pos, node)\n                                route = np.delete(route, np.where(route == node)[0][0])\n                                new_solution[i] = route\n                            if sum(demand[route]) <= capacity:\n                                break\n\n    # Ensure solution remains feasible\n    for route in new_solution:\n        assert sum(demand[route]) <= capacity, \"Capacity constraint violated\"\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return np.array(new_solution, dtype=object)\n\n",
        "metric_score": [
            -0.6652727986640303,
            0.3699900507926941
        ],
        "raw_score": [
            41.8071279930501,
            5.681969234398256
        ]
    }
]