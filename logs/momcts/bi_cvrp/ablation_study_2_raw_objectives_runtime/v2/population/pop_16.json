[
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search that splits the longest route and rebalances customers between routes to minimize makespan while ensuring capacity constraints are met. It intelligently selects customers to move between routes based on insertion cost, avoiding pure 2-opt and instead combining route splitting and rebalancing for balanced multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route (highest makespan)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        route1 = np.concatenate([longest_route[:split_pos], [0]])\n        route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([route1, route2])\n\n        # Step 2: Rebalance customers between routes to minimize makespan\n        for route in new_solution:\n            if len(route) > 2:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != longest_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert the customer into the target route\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[longest_route_idx] = np.delete(route, customer_idx)\n                                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8872942947388127,
            10.71958303451538
        ],
        "raw_score": [
            58.54333419585228,
            7.716499608727731
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted Pareto-aware selection (prioritizing distance over makespan) and applies a hybrid local search that combines segment swaps with dynamic customer reallocation between routes, ensuring capacity feasibility while balancing improvements to both objectives. The selection weights (0.7 for distance, 0.3 for makespan) guide the focus toward distance optimization, while the segment swap and reallocation strategy introduces diversity and potential for multi-objective trade-offs. The solution is validated to ensure vehicle capacity constraints are met before returning the improved neighbor.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap with dynamic reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split each route at a random position\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Create segments\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine segments and reinsert customers\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        np.random.shuffle(combined_segments)\n\n        # Rebuild routes with capacity checks\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8333614876440076,
            0.3195435106754303
        ],
        "raw_score": [
            57.89115394559542,
            7.602944309570047
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower makespan and total distance), then applies a hybrid local search that merges two routes and reinserts their customers into new routes while respecting capacity constraints. The selected routes are removed, their customers are shuffled, and reinserted into new routes with a greedy approach, ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) >= 2:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge the two routes (excluding the depot)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the selected routes from the solution\n        del new_solution[max(route1_idx, route2_idx)]\n        del new_solution[min(route1_idx, route2_idx)]\n\n        # Reinsert customers from the merged route into new routes\n        remaining_customers = merged_route[1:-1]  # Exclude depots\n        np.random.shuffle(remaining_customers)\n\n        # Create new routes while respecting capacity\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in remaining_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.3859883488764832,
            0.4115249514579773
        ],
        "raw_score": [
            41.152501233435785,
            4.500788477866207
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a probability inversely proportional to its makespan, then applies a route-splitting local search by splitting the longest route into smaller segments, reinserting customers into new routes while ensuring capacity feasibility, and prioritizing routes with higher makespan for improvement. The method avoids standard 2-opt by focusing on strategic route decomposition and reinsertion, balancing both total distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = [sol[1][1] for sol in archive]\n    total_makespan = sum(makespans)\n    probs = [total_makespan / (m + 1e-6) for m in makespans]\n    probs = [p / sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Route-splitting local search\n    if len(new_solution) >= 1:\n        # Select the longest route\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the route at a random position\n        split_pos = random.randint(1, len(longest_route)-2)\n        first_part = longest_route[:split_pos+1]\n        second_part = longest_route[split_pos:]\n\n        # Remove the original long route\n        del new_solution[longest_route_idx]\n\n        # Reinsert customers from both parts into new routes\n        for part in [first_part, second_part]:\n            customers = part[1:-1]  # Exclude depots\n            np.random.shuffle(customers)\n\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8322810265757914,
            0.4726947844028473
        ],
        "raw_score": [
            58.50130341793871,
            7.765728630611369
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging and customer reallocation. It first attempts to merge two feasible routes, then reallocates a customer from one route to another using greedy insertion to minimize additional travel distance. The method balances objectives while ensuring feasibility by checking capacity constraints at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge (if possible)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by concatenating them (excluding the depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Remove the two routes and add the merged route\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Step 2: Randomly reallocate a customer from a route to another route (if possible)\n    if len(new_solution) > 1:\n        # Select a random route to remove a customer from\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 2:  # Ensure the route has customers to remove\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(source_route) - 2)\n            customer = source_route[customer_idx]\n\n            # Try to insert the customer into another route\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx != source_route_idx:\n                    target_route = new_solution[target_route_idx]\n                    # Check if adding the customer exceeds capacity\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert the customer into the target route (greedy insertion)\n                        best_position = 1  # Default to insert after depot\n                        best_cost = float('inf')\n                        for i in range(1, len(target_route)):\n                            # Cost of inserting customer between i-1 and i\n                            cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_position = i\n                        # Insert the customer\n                        new_route = np.insert(target_route, best_position, customer)\n                        new_solution[target_route_idx] = new_route\n                        # Remove the customer from the source route\n                        new_solution[source_route_idx] = np.delete(source_route, customer_idx)\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5551090437252774,
            0.6128853261470795
        ],
        "raw_score": [
            27.170352502309257,
            2.9091272372427848
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining route segment swapping and reinsertion while ensuring vehicle capacity constraints are maintained. It prioritizes solutions with better combined objective performance and focuses on modifying two randomly selected routes by exchanging customer segments, with optional 2-opt improvements for further optimization. The capacity constraints are strictly enforced at each modification step to maintain feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: segment swap with reinsertion\n    if len(new_solution) >= 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Segment from route1\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n            segment_demand1 = np.sum(demand[segment1])\n\n            # Segment from route2\n            start2 = random.randint(1, len(route2) - 2)\n            end2 = random.randint(start2, len(route2) - 2)\n            segment2 = route2[start2:end2 + 1]\n            segment_demand2 = np.sum(demand[segment2])\n\n            # Check capacity constraints\n            new_route1_demand = np.sum(demand[route1]) - segment_demand1 + segment_demand2\n            new_route2_demand = np.sum(demand[route2]) - segment_demand2 + segment_demand1\n\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Optional: Apply a simple 2-opt improvement on the modified routes\n                for i in [route1_idx, route2_idx]:\n                    route = new_solution[i]\n                    if len(route) > 3:\n                        # Try reversing a random segment\n                        a, b = sorted(random.sample(range(1, len(route)-1), 2))\n                        reversed_segment = route[a:b+1][::-1]\n                        new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n\n                        # Check capacity constraint\n                        if np.sum(demand[new_route]) <= capacity:\n                            new_solution[i] = new_route\n\n    # Handle cases where only one route exists (unlikely in practice)\n    elif len(new_solution) == 1 and len(new_solution[0]) > 3:\n        route = new_solution[0]\n        # Try reversing a random segment\n        a, b = sorted(random.sample(range(1, len(route)-1), 2))\n        reversed_segment = route[a:b+1][::-1]\n        new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route]) <= capacity:\n            new_solution[0] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.47906748423652423,
            0.5748716592788696
        ],
        "raw_score": [
            38.696631252475,
            4.405245693062968
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing makespan with a 70% weight and total distance with a 30% weight), then applies a hybrid local search that merges two nearby routes, reinserts customers greedily prioritizing high-demand nodes, and ensures capacity constraints are met by only inserting if it improves distance. The method intelligently balances demand and spatial proximity while avoiding standard 2-opt approaches.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (0.7 * x[1][1] + 0.3 * x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Select routes to potentially merge based on proximity of last customers\n        last_nodes = [route[-2] for route in new_solution]\n        distances = distance_matrix[last_nodes][:, last_nodes]\n        np.fill_diagonal(distances, np.inf)\n        route1_idx, route2_idx = np.unravel_index(np.argmin(distances), distances.shape)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge routes and calculate total demand\n        merged_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        total_demand = np.sum(demand[merged_customers])\n\n        # Remove selected routes\n        del new_solution[max(route1_idx, route2_idx)]\n        del new_solution[min(route1_idx, route2_idx)]\n\n        # Sort customers by demand (descending) to prioritize larger demands\n        sorted_indices = np.argsort(-demand[merged_customers])\n        sorted_customers = merged_customers[sorted_indices]\n\n        # Reinsert customers using a greedy approach considering both demand and distance\n        routes = []\n        for customer in sorted_customers:\n            placed = False\n            # Try to insert into existing routes\n            for route in routes:\n                last_node = route[-2]\n                new_load = np.sum(demand[route[1:-1]]) + demand[customer]\n                if new_load <= capacity:\n                    # Calculate insertion cost\n                    insertion_cost = (distance_matrix[last_node][customer] +\n                                     distance_matrix[customer][0] -\n                                     distance_matrix[last_node][0])\n                    if insertion_cost < 0:  # Only insert if it improves distance\n                        route.insert(-1, customer)\n                        placed = True\n                        break\n            if not placed:\n                # Create new route if not placed\n                routes.append(np.array([0, customer, 0]))\n\n        new_solution.extend(routes)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7911795064398087,
            3.184245675802231
        ],
        "raw_score": [
            58.055269227862055,
            7.651742802004327
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on inverse Pareto dominance, then applies a hybrid local search combining segment swaps with demand-aware reallocation to balance distance and makespan objectives while ensuring capacity constraints. It prioritizes routes with higher potential for improvement by dynamically reallocating customers between routes based on demand and distance considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: segment swap with demand-aware reallocation\n    if len(new_solution) >= 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Segment from route1\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n            segment_demand1 = np.sum(demand[segment1])\n\n            # Segment from route2\n            start2 = random.randint(1, len(route2) - 2)\n            end2 = random.randint(start2, len(route2) - 2)\n            segment2 = route2[start2:end2 + 1]\n            segment_demand2 = np.sum(demand[segment2])\n\n            # Check capacity constraints\n            new_route1_demand = np.sum(demand[route1]) - segment_demand1 + segment_demand2\n            new_route2_demand = np.sum(demand[route2]) - segment_demand2 + segment_demand1\n\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform the segment swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Demand-aware reallocation: move a customer from the longer route to the shorter one\n                route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n                longer_route_idx = np.argmax(route_lengths)\n                shorter_route_idx = np.argmin(route_lengths)\n\n                if longer_route_idx != shorter_route_idx:\n                    longer_route = new_solution[longer_route_idx]\n                    shorter_route = new_solution[shorter_route_idx]\n\n                    # Find a customer to move from longer to shorter route\n                    for customer in longer_route[1:-1]:\n                        if np.sum(demand[shorter_route[1:-1]]) + demand[customer] <= capacity:\n                            # Find best insertion position in shorter route\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for i in range(1, len(shorter_route)):\n                                cost = distance_matrix[shorter_route[i-1], customer] + distance_matrix[customer, shorter_route[i]] - distance_matrix[shorter_route[i-1], shorter_route[i]]\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = i\n\n                            # Insert customer and remove from longer route\n                            new_shorter = np.insert(shorter_route, best_pos, customer)\n                            new_longer = np.delete(longer_route, np.where(longer_route == customer)[0][0])\n\n                            # Update solution\n                            new_solution[shorter_route_idx] = new_shorter\n                            new_solution[longer_route_idx] = new_longer\n                            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7328345539884291,
            0.6620124876499176
        ],
        "raw_score": [
            34.997443169174346,
            3.9753367273236404
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search that first identifies imbalanced routes (based on demand deviation from average) and splits them into two capacity-feasible routes, then applies spatial-aware 2-opt improvements, while also optionally merging small routes when feasible. Priority is given to demand balancing, spatial awareness in segment selection, and capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: demand-aware customer clustering with spatial awareness\n    if len(new_solution) >= 2:\n        # Calculate route metrics (demand, spatial centroid, and makespan)\n        route_metrics = []\n        for route in new_solution:\n            route_demand = np.sum(demand[route[1:-1]])\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n            else:\n                centroid = coords[0]  # Depot coordinates if route is empty\n            makespan = distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1))\n            route_metrics.append((route_demand, centroid, makespan))\n\n        # Identify the most imbalanced route (largest demand deviation from average)\n        avg_demand = np.mean([m[0] for m in route_metrics])\n        imbalance_scores = [abs(m[0] - avg_demand) for m in route_metrics]\n        target_route_idx = imbalance_scores.index(max(imbalance_scores))\n        target_route = new_solution[target_route_idx]\n\n        # Try to split the most imbalanced route into two balanced routes\n        if len(target_route) > 4:  # Need at least 4 nodes to split (depot, two customers, depot)\n            # Find the best split point that balances demand\n            customers = target_route[1:-1]\n            best_split = None\n            best_balance = float('inf')\n\n            for i in range(1, len(customers)):\n                first_half = customers[:i]\n                second_half = customers[i:]\n\n                first_demand = np.sum(demand[first_half])\n                second_demand = np.sum(demand[second_half])\n\n                balance = abs(first_demand - second_demand)\n                if balance < best_balance and first_demand <= capacity and second_demand <= capacity:\n                    best_balance = balance\n                    best_split = i\n\n            if best_split is not None:\n                # Create two new routes\n                first_route = np.concatenate([[0], target_route[1:best_split+1], [0]])\n                second_route = np.concatenate([[0], target_route[best_split+1:], [0]])\n\n                # Replace the target route with the two new routes\n                new_solution[target_route_idx] = first_route\n                new_solution.insert(target_route_idx + 1, second_route)\n\n                # Apply spatial-aware 2-opt on the new routes\n                for route_idx in [target_route_idx, target_route_idx + 1]:\n                    route = new_solution[route_idx]\n                    if len(route) > 4:\n                        # Find the two most spatially distant customers in the route\n                        customers = route[1:-1]\n                        max_dist = -1\n                        a, b = 0, 0\n                        for i in range(len(customers)):\n                            for j in range(i+1, len(customers)):\n                                dist = np.linalg.norm(coords[customers[i]] - coords[customers[j]])\n                                if dist > max_dist:\n                                    max_dist = dist\n                                    a, b = i, j\n\n                        # Reverse the segment between these two customers\n                        if a > b:\n                            a, b = b, a\n                        reversed_segment = route[a+1:b+2][::-1]\n                        new_route = np.concatenate([route[:a+1], reversed_segment, route[b+2:]])\n\n                        # Check capacity constraint\n                        if np.sum(demand[new_route]) <= capacity:\n                            new_solution[route_idx] = new_route\n\n    # If no improvement was made, try a different approach: merge two small routes\n    if len(new_solution) > 2:\n        # Find the two smallest routes\n        route_lengths = [len(route) for route in new_solution]\n        smallest_indices = np.argsort(route_lengths)[:2]\n\n        # Check if merging is feasible\n        route1 = new_solution[smallest_indices[0]]\n        route2 = new_solution[smallest_indices[1]]\n\n        merged_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if merged_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Remove the two original routes and add the merged one\n            new_solution.pop(max(smallest_indices))\n            new_solution.pop(min(smallest_indices))\n            new_solution.append(merged_route)\n\n            # Apply 2-opt on the merged route\n            if len(merged_route) > 4:\n                # Try reversing a random segment\n                a, b = sorted(random.sample(range(1, len(merged_route)-1), 2))\n                reversed_segment = merged_route[a:b+1][::-1]\n                new_route = np.concatenate([merged_route[:a], reversed_segment, merged_route[b+1:]])\n\n                # Check capacity constraint\n                if np.sum(demand[new_route]) <= capacity:\n                    new_solution[-1] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.791531944796664,
            3.4822143614292145
        ],
        "raw_score": [
            57.9586098800148,
            7.553022250085908
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution in the archive (by total distance) and applies a hybrid local search: first merging routes if feasible, then reallocating customers to minimize total distance while balancing makespan, and finally splitting oversized routes to maintain capacity constraints. It prioritizes distance reduction while considering makespan, using intelligent customer insertion and route splitting to improve solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive[-1][0].copy()  # Select the worst in total distance (potential for improvement)\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route merging (if two routes have low total demand, merge them)\n    if len(new_solution) > 1:\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Calculate the potential distance reduction\n                    dist_before = np.sum(distance_matrix[np.concatenate([route1[:-1], [route1[1]]])]) + np.sum(distance_matrix[np.concatenate([route2[:-1], [route2[1]]])])\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    dist_after = np.sum(distance_matrix[np.concatenate([merged_route[:-1], [merged_route[1]]])])\n                    if dist_after < dist_before:\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        merged = True\n                        break\n            if merged:\n                break\n\n    # Step 2: Customer reallocation (move customers between routes to minimize total distance)\n    if len(new_solution) > 1:\n        # Find the route with the highest distance\n        route_distances = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n        max_dist_route_idx = np.argmax(route_distances)\n        max_route = new_solution[max_dist_route_idx]\n        max_customers = max_route[1:-1]\n\n        for customer in max_customers:\n            for i in range(len(new_solution)):\n                if i != max_dist_route_idx:\n                    candidate_route = new_solution[i]\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[customer] <= capacity:\n                        # Remove customer from max_route\n                        max_route = np.delete(max_route, np.where(max_route == customer)[0][0])\n                        # Insert customer into candidate_route (at best position)\n                        candidate_customers = candidate_route[1:-1]\n                        best_pos = 0\n                        min_added_distance = float('inf')\n                        for pos in range(len(candidate_customers) + 1):\n                            # Calculate the added distance\n                            if pos == 0:\n                                added_distance = distance_matrix[0, customer] + distance_matrix[customer, candidate_customers[0]] - distance_matrix[0, candidate_customers[0]]\n                            elif pos == len(candidate_customers):\n                                added_distance = distance_matrix[candidate_customers[-1], customer] + distance_matrix[customer, 0] - distance_matrix[candidate_customers[-1], 0]\n                            else:\n                                added_distance = distance_matrix[candidate_customers[pos-1], customer] + distance_matrix[customer, candidate_customers[pos]] - distance_matrix[candidate_customers[pos-1], candidate_customers[pos]]\n                            if added_distance < min_added_distance:\n                                min_added_distance = added_distance\n                                best_pos = pos\n                        # Insert customer at best position\n                        new_candidate_route = np.insert(candidate_route, best_pos + 1, customer)\n                        new_solution[i] = new_candidate_route\n                        new_solution[max_dist_route_idx] = max_route\n                        break\n            else:\n                continue\n            break\n\n    # Step 3: Route splitting (if a route has high demand, split it into two)\n    if len(new_solution) < len(coords) - 1:  # Avoid too many routes\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            customers = route[1:-1]\n            if len(customers) > 1:\n                total_demand = np.sum(demand[customers])\n                if total_demand > capacity:\n                    # Find the split point that minimizes the sum of distances on both sides\n                    best_split = 1\n                    min_total_distance = float('inf')\n                    for k in range(1, len(customers)):\n                        route1 = np.concatenate([[0], customers[:k], [0]])\n                        route2 = np.concatenate([[0], customers[k:], [0]])\n                        dist1 = np.sum(distance_matrix[np.concatenate([route1[:-1], [route1[1]]])])\n                        dist2 = np.sum(distance_matrix[np.concatenate([route2[:-1], [route2[1]]])])\n                        total_dist = dist1 + dist2\n                        if total_dist < min_total_distance:\n                            min_total_distance = total_dist\n                            best_split = k\n                    # Split the route\n                    route1 = np.concatenate([[0], customers[:best_split], [0]])\n                    route2 = np.concatenate([[0], customers[best_split:], [0]])\n                    new_solution[i] = route1\n                    new_solution.insert(i + 1, route2)\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7491317471402231,
            1.8885432481765747
        ],
        "raw_score": [
            57.78945623377851,
            7.5838423703139854
        ]
    }
]