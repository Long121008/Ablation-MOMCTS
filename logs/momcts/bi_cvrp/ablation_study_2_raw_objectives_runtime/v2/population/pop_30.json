[
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search that splits the longest route and rebalances customers between routes to minimize makespan while ensuring capacity constraints are met. It intelligently selects customers to move between routes based on insertion cost, avoiding pure 2-opt and instead combining route splitting and rebalancing for balanced multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route (highest makespan)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        route1 = np.concatenate([longest_route[:split_pos], [0]])\n        route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([route1, route2])\n\n        # Step 2: Rebalance customers between routes to minimize makespan\n        for route in new_solution:\n            if len(route) > 2:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != longest_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert the customer into the target route\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[longest_route_idx] = np.delete(route, customer_idx)\n                                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8872942947388127,
            10.71958303451538
        ],
        "raw_score": [
            58.54333419585228,
            7.716499608727731
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted Pareto-aware selection (prioritizing distance over makespan) and applies a hybrid local search that combines segment swaps with dynamic customer reallocation between routes, ensuring capacity feasibility while balancing improvements to both objectives. The selection weights (0.7 for distance, 0.3 for makespan) guide the focus toward distance optimization, while the segment swap and reallocation strategy introduces diversity and potential for multi-objective trade-offs. The solution is validated to ensure vehicle capacity constraints are met before returning the improved neighbor.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap with dynamic reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split each route at a random position\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Create segments\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine segments and reinsert customers\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        np.random.shuffle(combined_segments)\n\n        # Rebuild routes with capacity checks\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8333614876440076,
            0.3195435106754303
        ],
        "raw_score": [
            57.89115394559542,
            7.602944309570047
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using balanced Pareto-aware selection (equal weights for distance and makespan) and applies a novel local search combining route merging, customer reinsertion, and demand-aware splitting to improve both objectives while ensuring feasibility through strict capacity validation. The selected solution undergoes random merging of two routes, followed by shuffling and re-splitting customers to form new feasible routes, prioritizing demand constraints over distance reduction. The neighbor solution is returned if it maintains feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.5, 0.5])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Route merging with demand-aware splitting\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge routes and shuffle customers\n        merged_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        np.random.shuffle(merged_customers)\n\n        # Demand-aware splitting\n        temp_solution = []\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in merged_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8261492845593692,
            0.24679729342460632
        ],
        "raw_score": [
            58.198058125964096,
            7.815595584099687
        ]
    },
    {
        "algorithm": "The algorithm combines weighted Pareto-aware selection with dynamic segment swapping, demand-aware reallocation, and capacity-constrained route merging to balance distance and makespan improvements while ensuring feasibility. It prioritizes makespan reduction (weight=0.7) over distance (weight=0.3) when selecting solutions, and uses randomized segment swaps and demand-based reallocation to generate neighbors, followed by optional route merging to improve efficiency.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Dynamic segment swapping\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine and shuffle segments\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        # Demand-aware reallocation\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Capacity validation\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        # Route merging if beneficial\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                merged_demand = np.sum(demand[longest_route[1:-1]]) + np.sum(demand[shortest_route[1:-1]])\n                if merged_demand <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8587400056773007,
            0.4929153025150299
        ],
        "raw_score": [
            58.36680385170219,
            7.873125418411563
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-aware selection with a multi-step hybrid operator: it first merges underutilized routes to reduce makespan, then performs demand-aware segment relinking between routes by exchanging high-distance segments, and finally applies capacity-preserving segment inversion in the longest route to optimize the distance-makespan tradeoff. The selection prioritizes makespan (60%) over distance (40%) and focuses on routes with low demand and short distances for merging, while ensuring capacity constraints are respected throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    weights = np.array([0.4, 0.6])  # Slightly more emphasis on makespan\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Merge underutilized routes\n    if len(new_solution) >= 2:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find routes with low demand and short distance (potential for merging)\n        candidate_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if (route_demands[i] + route_demands[j] <= capacity * 0.8 and  # Leave some capacity slack\n                    route_distances[i] < np.mean(route_distances) and\n                    route_distances[j] < np.mean(route_distances)):\n                    candidate_pairs.append((i, j))\n\n        if candidate_pairs:\n            # Select the pair with the highest combined distance reduction potential\n            i, j = min(candidate_pairs, key=lambda x: route_distances[x[0]] + route_distances[x[1]])\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 2: Demand-aware segment relinking\n    if len(new_solution) >= 2:\n        # Calculate route characteristics\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find high-distance segments in each route\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            # Identify the longest segment in terms of distance\n            max_segment_distance = -1\n            best_segment = None\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    segment_distance = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                    if segment_distance > max_segment_distance:\n                        max_segment_distance = segment_distance\n                        best_segment = (i, j)\n\n            if best_segment:\n                i, j = best_segment\n                segment = route[i:j+1]\n                segment_demand = sum(demand[segment])\n\n                # Find compatible routes to exchange with\n                compatible_routes = []\n                for k in range(len(new_solution)):\n                    if k == route_idx:\n                        continue\n                    if sum(demand[new_solution[k][1:-1]]) + segment_demand <= capacity:\n                        compatible_routes.append(k)\n\n                if compatible_routes:\n                    # Select the route that would benefit most from the exchange\n                    best_route = min(compatible_routes, key=lambda k: sum(distance_matrix[new_solution[k][l]][new_solution[k][l+1]] for l in range(len(new_solution[k])-1)))\n                    target_route = new_solution[best_route]\n\n                    # Find insertion point in target route\n                    best_insertion = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(target_route)):\n                        insertion_distance = distance_matrix[target_route[pos-1]][segment[0]] + \\\n                                           distance_matrix[segment[-1]][target_route[pos]] - \\\n                                           distance_matrix[target_route[pos-1]][target_route[pos]]\n                        if insertion_distance < min_increase:\n                            min_increase = insertion_distance\n                            best_insertion = pos\n\n                    # Perform the exchange\n                    new_target_route = np.concatenate([target_route[:best_insertion], segment, target_route[best_insertion:]])\n                    new_solution[best_route] = new_target_route\n                    new_solution[route_idx] = np.concatenate([route[:i], route[j+1:]])\n\n    # Step 3: Capacity-preserving segment inversion\n    if len(new_solution) > 0:\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_distances)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:\n            # Find the segment with the most potential for distance reduction\n            max_potential = -1\n            best_segment = None\n            for i in range(1, len(longest_route)-2):\n                for j in range(i+1, len(longest_route)-1):\n                    original_distance = sum(distance_matrix[longest_route[k]][longest_route[k+1]] for k in range(i, j+1))\n                    reversed_distance = sum(distance_matrix[longest_route[k+1]][longest_route[k]] for k in range(i, j))\n                    potential = original_distance - reversed_distance\n                    if potential > max_potential and sum(demand[longest_route[i:j+1]]) <= capacity:\n                        max_potential = potential\n                        best_segment = (i, j)\n\n            if best_segment:\n                i, j = best_segment\n                reversed_segment = longest_route[i:j+1][::-1]\n                new_route = np.concatenate([longest_route[:i], reversed_segment, longest_route[j+1:]])\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8699461803648509,
            5.810759276151657
        ],
        "raw_score": [
            54.938909175611954,
            6.801893023072205
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a probability inversely proportional to its makespan, then applies a route-splitting local search by splitting the longest route into smaller segments, reinserting customers into new routes while ensuring capacity feasibility, and prioritizing routes with higher makespan for improvement. The method avoids standard 2-opt by focusing on strategic route decomposition and reinsertion, balancing both total distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    makespans = [sol[1][1] for sol in archive]\n    total_makespan = sum(makespans)\n    probs = [total_makespan / (m + 1e-6) for m in makespans]\n    probs = [p / sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Route-splitting local search\n    if len(new_solution) >= 1:\n        # Select the longest route\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the route at a random position\n        split_pos = random.randint(1, len(longest_route)-2)\n        first_part = longest_route[:split_pos+1]\n        second_part = longest_route[split_pos:]\n\n        # Remove the original long route\n        del new_solution[longest_route_idx]\n\n        # Reinsert customers from both parts into new routes\n        for part in [first_part, second_part]:\n            customers = part[1:-1]  # Exclude depots\n            np.random.shuffle(customers)\n\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8322810265757914,
            0.4726947844028473
        ],
        "raw_score": [
            58.50130341793871,
            7.765728630611369
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted scoring (70% makespan, 30% distance) and applies a hybrid local search that randomly splits two routes, shuffles segments, reallocates customers with demand checks, and reconstructs feasible routes while prioritizing capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7927952972949865,
            0.3386287987232208
        ],
        "raw_score": [
            58.26743417235241,
            7.749824575626347
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using inverse Pareto dominance weights, then applies a hybrid local search combining route merging (when feasible), demand-aware customer reallocation (balancing route lengths), and route splitting (to improve load balance) while ensuring capacity constraints. It prioritizes reducing the longest routes and merging shorter routes, with randomness in selection and splitting to explore diverse neighbors. The method balances distance and makespan objectives through targeted route modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Route merging with demand check\n        if len(route1) > 2 and len(route2) > 2:\n            merged_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if merged_demand <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n        # Demand-aware customer reallocation\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                for customer in longest_route[1:-1]:\n                    if np.sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for i in range(1, len(shortest_route)):\n                            cost = distance_matrix[shortest_route[i-1], customer] + distance_matrix[customer, shortest_route[i]] - distance_matrix[shortest_route[i-1], shortest_route[i]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = i\n\n                        new_shortest = np.insert(shortest_route, best_pos, customer)\n                        new_longest = np.delete(longest_route, np.where(longest_route == customer)[0][0])\n                        new_solution[shortest_route_idx] = new_shortest\n                        new_solution[longest_route_idx] = new_longest\n                        break\n\n        # Route splitting for better load balancing\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 3:\n                split_pos = random.randint(1, len(route) - 2)\n                first_part = route[:split_pos + 1]\n                second_part = np.concatenate([[0], route[split_pos + 1:]])\n\n                if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                    new_solution[i] = first_part\n                    new_solution.insert(i + 1, second_part)\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8548515546317587,
            0.559120774269104
        ],
        "raw_score": [
            57.95839860572578,
            7.571481775525301
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted Pareto-aware selection (30% distance, 70% makespan) and applies a hybrid local search combining segment swaps, random reallocation, and capacity-aware route merging to improve both objectives while ensuring feasibility. It prioritizes reducing the longest route (makespan) by strategically shuffling and merging segments while maintaining vehicle capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        if len(new_solution) > 2:\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    route_i = new_solution[i]\n                    route_j = new_solution[j]\n                    if sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]]) <= capacity:\n                        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                        temp_solution = [r for k, r in enumerate(new_solution) if k not in {i, j}]\n                        temp_solution.append(merged_route)\n                        if all(sum(demand[r[1:-1]]) <= capacity for r in temp_solution):\n                            new_solution = temp_solution\n                            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7591679682145136,
            0.37524330615997314
        ],
        "raw_score": [
            57.79661661624829,
            7.724984232083177
        ]
    },
    {
        "algorithm": "This hybrid local search algorithm prioritizes high-demand-imbalance routes for splitting, longest routes with high segment diversity for segment relocation, and demand-balanced route merging, while intelligently shuffling segments based on both demand and distance to optimize both total travel distance and makespan in the Bi-CVRP. It adaptively selects routes for improvement using demand variance and makespan metrics, and ensures feasibility by strictly enforcing vehicle capacity constraints throughout all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (np.max(objectives, axis=0) + 1e-10)\n    weights = 1 / (normalized[:, 0] + normalized[:, 1] + 1e-10)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Adaptive route clustering based on demand and distance\n    if len(new_solution) > 2:\n        # Calculate demand and distance metrics for each route\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find the most imbalanced route (highest demand variance)\n        demand_variances = [np.var(demand[route[1:-1]]) if len(route) > 2 else 0 for route in new_solution]\n        target_route_idx = np.argmax(demand_variances)\n        target_route = new_solution[target_route_idx]\n\n        if len(target_route) > 3:\n            # Split the route at a point that balances demand and distance\n            total_demand = route_demands[target_route_idx]\n            split_pos = 1\n            current_demand = 0\n            best_balance = float('inf')\n\n            for i in range(1, len(target_route)-1):\n                current_demand += demand[target_route[i]]\n                demand_balance = abs(current_demand - (total_demand - current_demand))\n                distance_balance = abs((i - len(target_route)//2) * distance_matrix[target_route[i-1]][target_route[i]])\n\n                if demand_balance + distance_balance < best_balance:\n                    best_balance = demand_balance + distance_balance\n                    split_pos = i\n\n            # Create two new routes\n            route1 = np.concatenate([target_route[:split_pos+1], [0]])\n            route2 = np.concatenate([[0], target_route[split_pos+1:]])\n\n            # Check capacity constraints\n            if np.sum(demand[route1]) <= capacity and np.sum(demand[route2]) <= capacity:\n                new_solution[target_route_idx] = route1\n                new_solution.append(route2)\n\n    # Step 3: Intelligent segment shuffling\n    if len(new_solution) > 1:\n        # Find the longest route with high demand variance\n        makespans = [distance_matrix[route[-2]][0] + sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        demand_variances = [np.var(demand[route[1:-1]]) if len(route) > 2 else 0 for route in new_solution]\n        combined_scores = [makespans[i] * demand_variances[i] for i in range(len(new_solution))]\n        longest_route_idx = np.argmax(combined_scores)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:\n            # Select segments based on both demand and distance\n            segment_scores = []\n            for i in range(1, len(longest_route)-2):\n                segment_demand = np.sum(demand[longest_route[i:i+2]])\n                segment_distance = distance_matrix[longest_route[i-1]][longest_route[i]] + distance_matrix[longest_route[i+1]][longest_route[i+2]]\n                segment_scores.append(segment_demand / (segment_distance + 1e-10))\n\n            if segment_scores:\n                # Select top 2 segments to shuffle\n                top_segments = np.argsort(segment_scores)[-2:]\n                segments = [longest_route[i:i+2] for i in top_segments + 1]\n\n                # Find best positions to insert these segments in other routes\n                for segment in segments:\n                    best_route_idx = -1\n                    best_position = -1\n                    best_improvement = 0\n                    segment_demand = np.sum(demand[segment])\n\n                    for i, route in enumerate(new_solution):\n                        if i == longest_route_idx or len(route) == 2:\n                            continue\n\n                        if np.sum(demand[route]) + segment_demand <= capacity:\n                            for j in range(1, len(route)):\n                                # Calculate potential improvement\n                                old_distance = distance_matrix[route[j-1]][route[j]]\n                                new_distance = distance_matrix[route[j-1]][segment[0]] + distance_matrix[segment[1]][route[j]]\n                                improvement = old_distance - new_distance\n\n                                if improvement > best_improvement:\n                                    best_improvement = improvement\n                                    best_route_idx = i\n                                    best_position = j\n\n                    if best_route_idx != -1 and best_improvement > 0:\n                        # Insert the segment\n                        best_route = new_solution[best_route_idx]\n                        new_route = np.insert(best_route, best_position, segment)\n                        new_solution[best_route_idx] = new_route\n\n                        # Remove the segment from the longest route\n                        segment_pos = np.where((longest_route == segment[0]) & (np.roll(longest_route, -1) == segment[1]))[0][0]\n                        new_longest_route = np.delete(longest_route, [segment_pos, segment_pos+1])\n                        new_solution[longest_route_idx] = new_longest_route\n\n                        if len(new_longest_route) <= 2:\n                            del new_solution[longest_route_idx]\n                            break\n\n    # Step 4: Demand-balanced route merging\n    if len(new_solution) > 2:\n        # Find the two routes with most similar demands\n        demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        min_diff = float('inf')\n        candidate1, candidate2 = -1, -1\n\n        for i in range(len(demands)):\n            for j in range(i+1, len(demands)):\n                if abs(demands[i] - demands[j]) < min_diff:\n                    min_diff = abs(demands[i] - demands[j])\n                    candidate1, candidate2 = i, j\n\n        if candidate1 != -1 and demands[candidate1] + demands[candidate2] <= capacity:\n            # Merge the two routes\n            route1 = new_solution[candidate1]\n            route2 = new_solution[candidate2]\n\n            # Calculate the best merge point based on distance and demand balance\n            best_merge_point = (0, 0)\n            best_merge_score = float('inf')\n\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    dist = distance_matrix[route1[i-1]][route2[j]] + distance_matrix[route2[j-1]][route1[i]]\n                    demand_balance = abs((i - len(route1)//2) - (j - len(route2)//2))\n                    score = dist + demand_balance\n\n                    if score < best_merge_score:\n                        best_merge_score = score\n                        best_merge_point = (i, j)\n\n            # Create merged route\n            i, j = best_merge_point\n            merged_route = np.concatenate([route1[:i], route2[j:], [0]])\n\n            # Update solution\n            new_solution[candidate1] = merged_route\n            del new_solution[candidate2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8342802909608135,
            3.1014640033245087
        ],
        "raw_score": [
            56.736148110572515,
            7.136707596544673
        ]
    }
]