[
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower makespan and total distance), then applies a hybrid local search that merges two routes and reinserts their customers into new routes while respecting capacity constraints. The selected routes are removed, their customers are shuffled, and reinserted into new routes with a greedy approach, ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two routes and reinsert customers\n    if len(new_solution) >= 2:\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge the two routes (excluding the depot)\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n        # Remove the selected routes from the solution\n        del new_solution[max(route1_idx, route2_idx)]\n        del new_solution[min(route1_idx, route2_idx)]\n\n        # Reinsert customers from the merged route into new routes\n        remaining_customers = merged_route[1:-1]  # Exclude depots\n        np.random.shuffle(remaining_customers)\n\n        # Create new routes while respecting capacity\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in remaining_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.3859883488764832,
            0.4115249514579773
        ],
        "raw_score": [
            41.152501233435785,
            4.500788477866207
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search that splits the longest route and rebalances customers between routes to minimize makespan while ensuring capacity constraints are met. It intelligently selects customers to move between routes based on insertion cost, avoiding pure 2-opt and instead combining route splitting and rebalancing for balanced multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route (highest makespan)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        route1 = np.concatenate([longest_route[:split_pos], [0]])\n        route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([route1, route2])\n\n        # Step 2: Rebalance customers between routes to minimize makespan\n        for route in new_solution:\n            if len(route) > 2:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != longest_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert the customer into the target route\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[longest_route_idx] = np.delete(route, customer_idx)\n                                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8872942947388127,
            10.71958303451538
        ],
        "raw_score": [
            58.54333419585228,
            7.716499608727731
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a probability inversely proportional to its makespan, then applies a route-splitting local search by splitting the longest route into smaller segments, reinserting customers into new routes while ensuring capacity feasibility, and prioritizing routes with higher makespan for improvement. The method avoids standard 2-opt by focusing on strategic route decomposition and reinsertion, balancing both total distance and makespan objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [sol[1][1] for sol in archive]\n    total_makespan = sum(makespans)\n    probs = [total_makespan / (m + 1e-6) for m in makespans]\n    probs = [p / sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Route-splitting local search\n    if len(new_solution) >= 1:\n        # Select the longest route\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the route at a random position\n        split_pos = random.randint(1, len(longest_route)-2)\n        first_part = longest_route[:split_pos+1]\n        second_part = longest_route[split_pos:]\n\n        # Remove the original long route\n        del new_solution[longest_route_idx]\n\n        # Reinsert customers from both parts into new routes\n        for part in [first_part, second_part]:\n            customers = part[1:-1]  # Exclude depots\n            np.random.shuffle(customers)\n\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8322810265757914,
            0.4726947844028473
        ],
        "raw_score": [
            58.50130341793871,
            7.765728630611369
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging and customer reallocation. It first attempts to merge two feasible routes, then reallocates a customer from one route to another using greedy insertion to minimize additional travel distance. The method balances objectives while ensuring feasibility by checking capacity constraints at each step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge (if possible)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes by concatenating them (excluding the depot)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Remove the two routes and add the merged route\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Step 2: Randomly reallocate a customer from a route to another route (if possible)\n    if len(new_solution) > 1:\n        # Select a random route to remove a customer from\n        source_route_idx = random.randint(0, len(new_solution) - 1)\n        source_route = new_solution[source_route_idx]\n        if len(source_route) > 2:  # Ensure the route has customers to remove\n            # Select a random customer to move\n            customer_idx = random.randint(1, len(source_route) - 2)\n            customer = source_route[customer_idx]\n\n            # Try to insert the customer into another route\n            for target_route_idx in range(len(new_solution)):\n                if target_route_idx != source_route_idx:\n                    target_route = new_solution[target_route_idx]\n                    # Check if adding the customer exceeds capacity\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        # Insert the customer into the target route (greedy insertion)\n                        best_position = 1  # Default to insert after depot\n                        best_cost = float('inf')\n                        for i in range(1, len(target_route)):\n                            # Cost of inserting customer between i-1 and i\n                            cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_position = i\n                        # Insert the customer\n                        new_route = np.insert(target_route, best_position, customer)\n                        new_solution[target_route_idx] = new_route\n                        # Remove the customer from the source route\n                        new_solution[source_route_idx] = np.delete(source_route, customer_idx)\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5551090437252774,
            0.6128853261470795
        ],
        "raw_score": [
            27.170352502309257,
            2.9091272372427848
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining route segment swapping and reinsertion while ensuring vehicle capacity constraints are maintained. It prioritizes solutions with better combined objective performance and focuses on modifying two randomly selected routes by exchanging customer segments, with optional 2-opt improvements for further optimization. The capacity constraints are strictly enforced at each modification step to maintain feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: segment swap with reinsertion\n    if len(new_solution) >= 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Segment from route1\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n            segment_demand1 = np.sum(demand[segment1])\n\n            # Segment from route2\n            start2 = random.randint(1, len(route2) - 2)\n            end2 = random.randint(start2, len(route2) - 2)\n            segment2 = route2[start2:end2 + 1]\n            segment_demand2 = np.sum(demand[segment2])\n\n            # Check capacity constraints\n            new_route1_demand = np.sum(demand[route1]) - segment_demand1 + segment_demand2\n            new_route2_demand = np.sum(demand[route2]) - segment_demand2 + segment_demand1\n\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Optional: Apply a simple 2-opt improvement on the modified routes\n                for i in [route1_idx, route2_idx]:\n                    route = new_solution[i]\n                    if len(route) > 3:\n                        # Try reversing a random segment\n                        a, b = sorted(random.sample(range(1, len(route)-1), 2))\n                        reversed_segment = route[a:b+1][::-1]\n                        new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n\n                        # Check capacity constraint\n                        if np.sum(demand[new_route]) <= capacity:\n                            new_solution[i] = new_route\n\n    # Handle cases where only one route exists (unlikely in practice)\n    elif len(new_solution) == 1 and len(new_solution[0]) > 3:\n        route = new_solution[0]\n        # Try reversing a random segment\n        a, b = sorted(random.sample(range(1, len(route)-1), 2))\n        reversed_segment = route[a:b+1][::-1]\n        new_route = np.concatenate([route[:a], reversed_segment, route[b+1:]])\n\n        # Check capacity constraint\n        if np.sum(demand[new_route]) <= capacity:\n            new_solution[0] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.47906748423652423,
            0.5748716592788696
        ],
        "raw_score": [
            38.696631252475,
            4.405245693062968
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing makespan with a 70% weight and total distance with a 30% weight), then applies a hybrid local search that merges two nearby routes, reinserts customers greedily prioritizing high-demand nodes, and ensures capacity constraints are met by only inserting if it improves distance. The method intelligently balances demand and spatial proximity while avoiding standard 2-opt approaches.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (0.7 * x[1][1] + 0.3 * x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Select routes to potentially merge based on proximity of last customers\n        last_nodes = [route[-2] for route in new_solution]\n        distances = distance_matrix[last_nodes][:, last_nodes]\n        np.fill_diagonal(distances, np.inf)\n        route1_idx, route2_idx = np.unravel_index(np.argmin(distances), distances.shape)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge routes and calculate total demand\n        merged_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        total_demand = np.sum(demand[merged_customers])\n\n        # Remove selected routes\n        del new_solution[max(route1_idx, route2_idx)]\n        del new_solution[min(route1_idx, route2_idx)]\n\n        # Sort customers by demand (descending) to prioritize larger demands\n        sorted_indices = np.argsort(-demand[merged_customers])\n        sorted_customers = merged_customers[sorted_indices]\n\n        # Reinsert customers using a greedy approach considering both demand and distance\n        routes = []\n        for customer in sorted_customers:\n            placed = False\n            # Try to insert into existing routes\n            for route in routes:\n                last_node = route[-2]\n                new_load = np.sum(demand[route[1:-1]]) + demand[customer]\n                if new_load <= capacity:\n                    # Calculate insertion cost\n                    insertion_cost = (distance_matrix[last_node][customer] +\n                                     distance_matrix[customer][0] -\n                                     distance_matrix[last_node][0])\n                    if insertion_cost < 0:  # Only insert if it improves distance\n                        route.insert(-1, customer)\n                        placed = True\n                        break\n            if not placed:\n                # Create new route if not placed\n                routes.append(np.array([0, customer, 0]))\n\n        new_solution.extend(routes)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7911795064398087,
            3.184245675802231
        ],
        "raw_score": [
            58.055269227862055,
            7.651742802004327
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on inverse Pareto dominance, then applies a hybrid local search combining segment swaps with demand-aware reallocation to balance distance and makespan objectives while ensuring capacity constraints. It prioritizes routes with higher potential for improvement by dynamically reallocating customers between routes based on demand and distance considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: segment swap with demand-aware reallocation\n    if len(new_solution) >= 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Select random segments from each route (excluding depot)\n        if len(route1) > 2 and len(route2) > 2:\n            # Segment from route1\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n            segment_demand1 = np.sum(demand[segment1])\n\n            # Segment from route2\n            start2 = random.randint(1, len(route2) - 2)\n            end2 = random.randint(start2, len(route2) - 2)\n            segment2 = route2[start2:end2 + 1]\n            segment_demand2 = np.sum(demand[segment2])\n\n            # Check capacity constraints\n            new_route1_demand = np.sum(demand[route1]) - segment_demand1 + segment_demand2\n            new_route2_demand = np.sum(demand[route2]) - segment_demand2 + segment_demand1\n\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform the segment swap\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Demand-aware reallocation: move a customer from the longer route to the shorter one\n                route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n                longer_route_idx = np.argmax(route_lengths)\n                shorter_route_idx = np.argmin(route_lengths)\n\n                if longer_route_idx != shorter_route_idx:\n                    longer_route = new_solution[longer_route_idx]\n                    shorter_route = new_solution[shorter_route_idx]\n\n                    # Find a customer to move from longer to shorter route\n                    for customer in longer_route[1:-1]:\n                        if np.sum(demand[shorter_route[1:-1]]) + demand[customer] <= capacity:\n                            # Find best insertion position in shorter route\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for i in range(1, len(shorter_route)):\n                                cost = distance_matrix[shorter_route[i-1], customer] + distance_matrix[customer, shorter_route[i]] - distance_matrix[shorter_route[i-1], shorter_route[i]]\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = i\n\n                            # Insert customer and remove from longer route\n                            new_shorter = np.insert(shorter_route, best_pos, customer)\n                            new_longer = np.delete(longer_route, np.where(longer_route == customer)[0][0])\n\n                            # Update solution\n                            new_solution[shorter_route_idx] = new_shorter\n                            new_solution[longer_route_idx] = new_longer\n                            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7328345539884291,
            0.6620124876499176
        ],
        "raw_score": [
            34.997443169174346,
            3.9753367273236404
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with low makespan and total distance from the archive, then applies a hybrid local search that splits routes at random positions and reinserts customers into existing routes or creates new ones, ensuring feasibility by checking vehicle capacity constraints. It handles missing customers by creating new routes, balancing both objectives while maintaining solution feasibility. The key innovation is the combination of route-splitting with demand-aware reinsertion, avoiding standard methods like pure 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Hybrid local search: route-splitting with demand-aware reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Reinsert customers from the second part back into the solution\n        customers_to_reinsert = part2[1:-1]  # Exclude depots\n        new_solution.append(part1.copy())\n\n        # Try to insert customers into existing routes or create new ones\n        for customer in customers_to_reinsert:\n            inserted = False\n            for i in range(len(new_solution)):\n                temp_route = np.insert(new_solution[i], -1, customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    new_solution[i] = temp_route\n                    inserted = True\n                    break\n\n            if not inserted:\n                new_solution.append(np.array([0, customer, 0]))\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = set(range(1, len(demand))) - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        for customer in missing_customers:\n            new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7816711410201282,
            7.224736332893372
        ],
        "raw_score": [
            57.95259418000826,
            7.6711049661801844
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with high makespan for improvement) and applies a hybrid local search strategy: first attempting route merging if feasible, then splitting oversized routes to balance demand, and finally reallocating customers between routes to reduce the longest route (makespan) while ensuring capacity constraints are met. The method intelligently combines these operations to balance both total distance and makespan objectives.\n\n*(Key design points: prioritizes makespan reduction, merges routes when possible, splits routes to balance demand, and reallocates customers to minimize the longest route, all while maintaining feasibility.)*",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][1], x[1][0]))  # Sort by makespan, then total distance\n    selected_solution = archive[-1][0].copy()  # Select the worst in makespan (potential for improvement)\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route merging (if two routes have low total demand, merge them)\n    if len(new_solution) > 1:\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge route2 into route1\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    new_solution.pop(j)\n                    merged = True\n                    break\n            if merged:\n                break\n\n    # Step 2: Route splitting (if a route has high demand, split it into two)\n    if not merged and len(new_solution) < len(coords) - 1:  # Avoid too many routes\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            customers = route[1:-1]\n            if len(customers) > 1:\n                # Find a split point that balances the route\n                total_demand = np.sum(demand[customers])\n                if total_demand > capacity:\n                    # Find the split point that minimizes the sum of demands on both sides\n                    best_split = 1\n                    min_diff = float('inf')\n                    for k in range(1, len(customers)):\n                        left_demand = np.sum(demand[customers[:k]])\n                        right_demand = total_demand - left_demand\n                        diff = abs(left_demand - right_demand)\n                        if diff < min_diff:\n                            min_diff = diff\n                            best_split = k\n                    # Split the route\n                    route1 = np.concatenate([[0], customers[:best_split], [0]])\n                    route2 = np.concatenate([[0], customers[best_split:], [0]])\n                    new_solution[i] = route1\n                    new_solution.insert(i + 1, route2)\n                    break\n\n    # Step 3: Customer reallocation (move customers between routes to balance makespan)\n    if len(new_solution) > 1:\n        # Find the route with the highest makespan\n        max_makespan_route_idx = np.argmax([np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution])\n        max_route = new_solution[max_makespan_route_idx]\n        max_customers = max_route[1:-1]\n\n        # Try to move a customer from this route to another\n        for customer in max_customers:\n            for i in range(len(new_solution)):\n                if i != max_makespan_route_idx:\n                    candidate_route = new_solution[i]\n                    if np.sum(demand[candidate_route[1:-1]]) + demand[customer] <= capacity:\n                        # Remove customer from max_route\n                        max_route = np.delete(max_route, np.where(max_route == customer)[0][0])\n                        # Insert customer into candidate_route (at best position)\n                        candidate_customers = candidate_route[1:-1]\n                        best_pos = 0\n                        min_added_distance = float('inf')\n                        for pos in range(len(candidate_customers) + 1):\n                            # Calculate the added distance\n                            if pos == 0:\n                                added_distance = distance_matrix[0, customer] + distance_matrix[customer, candidate_customers[0]] - distance_matrix[0, candidate_customers[0]]\n                            elif pos == len(candidate_customers):\n                                added_distance = distance_matrix[candidate_customers[-1], customer] + distance_matrix[customer, 0] - distance_matrix[candidate_customers[-1], 0]\n                            else:\n                                added_distance = distance_matrix[candidate_customers[pos-1], customer] + distance_matrix[customer, candidate_customers[pos]] - distance_matrix[candidate_customers[pos-1], candidate_customers[pos]]\n                            if added_distance < min_added_distance:\n                                min_added_distance = added_distance\n                                best_pos = pos\n                        # Insert customer at best position\n                        new_candidate_route = np.insert(candidate_route, best_pos + 1, customer)\n                        new_solution[i] = new_candidate_route\n                        new_solution[max_makespan_route_idx] = max_route\n                        break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7183271987983886,
            1.8778762817382812
        ],
        "raw_score": [
            57.11386094756787,
            7.615842585356178
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive based on makespan and total distance, then applies a hybrid local search combining route segment exchange and demand-aware reinsertion to balance both objectives while ensuring capacity constraints. It prioritizes solutions with shorter makespan first, then total distance, and intelligently exchanges segments between routes while reinserting customers to improve efficiency. The method ensures feasibility by checking capacity constraints before each operation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) > 1:\n        # Hybrid local search: segment exchange with demand-aware reinsertion\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select segments from both routes\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n            segment_demand1 = np.sum(demand[segment1])\n\n            start2 = random.randint(1, len(route2) - 2)\n            end2 = random.randint(start2, len(route2) - 2)\n            segment2 = route2[start2:end2 + 1]\n            segment_demand2 = np.sum(demand[segment2])\n\n            # Check capacity constraints\n            new_route1_demand = np.sum(demand[route1]) - segment_demand1 + segment_demand2\n            new_route2_demand = np.sum(demand[route2]) - segment_demand2 + segment_demand1\n\n            if new_route1_demand <= capacity and new_route2_demand <= capacity:\n                # Perform the exchange\n                new_route1 = np.concatenate([route1[:start1], segment2, route1[end1+1:]])\n                new_route2 = np.concatenate([route2[:start2], segment1, route2[end2+1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Demand-aware reinsertion for further improvement\n                for route_idx in [route1_idx, route2_idx]:\n                    route = new_solution[route_idx]\n                    customers = route[1:-1]\n                    for i in range(len(customers)):\n                        customer = customers[i]\n                        # Try to reinsert customer into another route\n                        for target_idx in range(len(new_solution)):\n                            if target_idx != route_idx:\n                                target_route = new_solution[target_idx]\n                                if np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                    # Find best insertion position\n                                    best_pos = 1\n                                    best_cost = float('inf')\n                                    for pos in range(1, len(target_route)):\n                                        cost = distance_matrix[target_route[pos-1], customer] + distance_matrix[customer, target_route[pos]] - distance_matrix[target_route[pos-1], target_route[pos]]\n                                        if cost < best_cost:\n                                            best_cost = cost\n                                            best_pos = pos\n                                    # Perform insertion\n                                    new_route = np.insert(target_route, best_pos, customer)\n                                    new_solution[target_idx] = new_route\n                                    # Remove from original route\n                                    new_solution[route_idx] = np.delete(route, i + 1)\n                                    break\n                        else:\n                            continue\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4632079984267319,
            0.6977574229240417
        ],
        "raw_score": [
            30.98157695498189,
            3.4502149940461893
        ]
    }
]