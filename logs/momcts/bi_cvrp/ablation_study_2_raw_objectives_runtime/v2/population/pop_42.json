[
    {
        "algorithm": "The algorithm prioritizes solutions with lower total distance, applies a hybrid local search that splits the longest route and rebalances customers between routes to minimize makespan while ensuring capacity constraints are met. It intelligently selects customers to move between routes based on insertion cost, avoiding pure 2-opt and instead combining route splitting and rebalancing for balanced multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance, then makespan\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: combine route splitting and customer rebalancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the longest route (highest makespan)\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        route1 = np.concatenate([longest_route[:split_pos], [0]])\n        route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n        # Check capacity constraints for both new routes\n        if (sum(demand[route1[1:-1]]) <= capacity) and (sum(demand[route2[1:-1]]) <= capacity):\n            new_solution.pop(longest_route_idx)\n            new_solution.extend([route1, route2])\n\n        # Step 2: Rebalance customers between routes to minimize makespan\n        for route in new_solution:\n            if len(route) > 2:\n                # Find a customer to move to another route\n                for customer_idx in range(1, len(route)-1):\n                    customer = route[customer_idx]\n                    current_demand = sum(demand[route[1:-1]])\n                    for target_route_idx in range(len(new_solution)):\n                        if target_route_idx != longest_route_idx:\n                            target_route = new_solution[target_route_idx]\n                            if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                                # Insert the customer into the target route\n                                best_position = 1\n                                best_cost = float('inf')\n                                for i in range(1, len(target_route)):\n                                    cost = distance_matrix[target_route[i-1], customer] + distance_matrix[customer, target_route[i]] - distance_matrix[target_route[i-1], target_route[i]]\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_position = i\n                                new_route = np.insert(target_route, best_position, customer)\n                                new_solution[target_route_idx] = new_route\n                                new_solution[longest_route_idx] = np.delete(route, customer_idx)\n                                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8872942947388127,
            10.71958303451538
        ],
        "raw_score": [
            58.54333419585228,
            7.716499608727731
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted Pareto-aware selection (prioritizing distance over makespan) and applies a hybrid local search that combines segment swaps with dynamic customer reallocation between routes, ensuring capacity feasibility while balancing improvements to both objectives. The selection weights (0.7 for distance, 0.3 for makespan) guide the focus toward distance optimization, while the segment swap and reallocation strategy introduces diversity and potential for multi-objective trade-offs. The solution is validated to ensure vehicle capacity constraints are met before returning the improved neighbor.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.7, 0.3])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swap with dynamic reallocation\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Split each route at a random position\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        # Create segments\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        # Combine segments and reinsert customers\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        np.random.shuffle(combined_segments)\n\n        # Rebuild routes with capacity checks\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            np.random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8333614876440076,
            0.3195435106754303
        ],
        "raw_score": [
            57.89115394559542,
            7.602944309570047
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using balanced Pareto-aware selection (equal weights for distance and makespan) and applies a novel local search combining route merging, customer reinsertion, and demand-aware splitting to improve both objectives while ensuring feasibility through strict capacity validation. The selected solution undergoes random merging of two routes, followed by shuffling and re-splitting customers to form new feasible routes, prioritizing demand constraints over distance reduction. The neighbor solution is returned if it maintains feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.5, 0.5])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Route merging with demand-aware splitting\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge routes and shuffle customers\n        merged_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n        np.random.shuffle(merged_customers)\n\n        # Demand-aware splitting\n        temp_solution = []\n        current_route = [0]\n        current_load = 0.0\n\n        for customer in merged_customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8261492845593692,
            0.24679729342460632
        ],
        "raw_score": [
            58.198058125964096,
            7.815595584099687
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted Pareto-aware approach (prioritizing makespan over distance) and applies a hybrid local search combining dynamic segment swaps, demand-aware reallocation, and capacity-preserving route merging to balance objectives while ensuring feasibility. The solution is chosen based on normalized scores (30% distance, 70% makespan), and the local search operator dynamically reshuffles route segments, reallocates customers based on demand, and merges routes when feasible. The method prioritizes reducing the longest route (makespan) while maintaining capacity constraints and improving overall distance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 2:\n        # Dynamic segment swaps\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        # Demand-aware reallocation\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n        # Capacity-preserving route merging\n        if len(new_solution) > 1:\n            route_lengths = [np.sum(distance_matrix[np.concatenate([route[:-1], [route[1]]])]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            shortest_route_idx = np.argmin(route_lengths)\n\n            if longest_route_idx != shortest_route_idx:\n                longest_route = new_solution[longest_route_idx]\n                shortest_route = new_solution[shortest_route_idx]\n\n                merged_demand = sum(demand[longest_route[1:-1]]) + sum(demand[shortest_route[1:-1]])\n                if merged_demand <= capacity:\n                    merged_route = np.concatenate([longest_route[:-1], shortest_route[1:]])\n                    new_solution[longest_route_idx] = merged_route\n                    del new_solution[shortest_route_idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8783333941848286,
            0.48017948865890503
        ],
        "raw_score": [
            58.35236354794543,
            7.822289637698152
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a combined objective score (sum of distance and makespan) to identify promising candidates, then applies a hybrid local search that splits routes and intelligently reinserts customers based on weighted distance savings and makespan reduction, while ensuring capacity constraints through dynamic validation and a multi-step rebalancing phase that redistributes customers between routes to improve both objectives. The method prioritizes distance savings in reinsertion decisions and focuses on the most significant improvements during the rebalancing phase.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[0] + obj[1]) for obj in [x[1] for x in archive]]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: route splitting with intelligent reinsertion\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Split route at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        seg1, seg2 = route[:split_pos + 1], route[split_pos:]\n\n        # Remove original route\n        del new_solution[route_idx]\n\n        # Reinsert customers from both segments into new routes\n        customers = np.concatenate([seg1[1:-1], seg2[1:-1]])\n        np.random.shuffle(customers)\n\n        # Create new routes with weighted reinsertion (distance + makespan)\n        current_route = [0]\n        current_load = 0.0\n        temp_solution = []\n\n        for customer in customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Multi-step rebalancing phase\n        if len(temp_solution) > 1:\n            # Calculate potential improvements for each customer\n            improvements = []\n            for i, route in enumerate(temp_solution):\n                for j, customer in enumerate(route[1:-1]):\n                    # Calculate distance savings if moved to another route\n                    prev_node = route[j]\n                    next_node = route[j + 2] if j + 2 < len(route) else 0\n                    current_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n                    # Find best alternative route\n                    best_dist = float('inf')\n                    best_route_idx = -1\n                    for k, alt_route in enumerate(temp_solution):\n                        if k == i:\n                            continue\n                        # Check if adding to this route is feasible\n                        if sum(demand[alt_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate insertion cost\n                            for l in range(len(alt_route) - 1):\n                                insert_dist = (distance_matrix[alt_route[l], customer] +\n                                              distance_matrix[customer, alt_route[l + 1]] -\n                                              distance_matrix[alt_route[l], alt_route[l + 1]])\n                                if insert_dist < best_dist:\n                                    best_dist = insert_dist\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        improvements.append((i, j, best_route_idx, current_dist - best_dist))\n\n            # Sort improvements by potential savings (distance + makespan)\n            improvements.sort(key=lambda x: x[3], reverse=True)\n\n            # Apply the best improvements\n            for i, j, best_route_idx, _ in improvements[:min(3, len(improvements))]:\n                route = temp_solution[i]\n                customer = route[j + 1]\n\n                # Remove from current route\n                route = np.concatenate([route[:j + 1], route[j + 2:]])\n                if len(route) == 1:\n                    del temp_solution[i]\n                else:\n                    temp_solution[i] = route\n\n                # Insert into best alternative route\n                alt_route = temp_solution[best_route_idx]\n                best_pos = 0\n                best_insert_cost = float('inf')\n\n                # Find best insertion position\n                for k in range(len(alt_route) - 1):\n                    insert_cost = (distance_matrix[alt_route[k], customer] +\n                                 distance_matrix[customer, alt_route[k + 1]] -\n                                 distance_matrix[alt_route[k], alt_route[k + 1]])\n                    if insert_cost < best_insert_cost:\n                        best_insert_cost = insert_cost\n                        best_pos = k + 1\n\n                # Insert customer\n                alt_route = np.insert(alt_route, best_pos, customer)\n                temp_solution[best_route_idx] = alt_route\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.772006348641767,
            0.11216071248054504
        ],
        "raw_score": [
            58.28389963977137,
            7.708597926304895
        ]
    },
    {
        "algorithm": "The algorithm implements a Pareto-aware hybrid local search that dynamically selects between four novel operators (route expansion, demand-aware segment relocation, adaptive route splitting, and balanced route balancing) based on the current solution's objective trade-off, prioritizing distance reduction when routes are highly imbalanced, improving makespan by relocating incompatible demand segments between routes when distance dominates, splitting routes when beneficial for both objectives, and balancing route lengths to improve both objectives simultaneously. The selection of operators is guided by route length metrics (e.g., makespan vs. average route distance), and all operations ensure feasibility by respecting vehicle capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    makespan = max(route_distances)\n\n    # Operator selection based on current trade-off\n    if len(new_solution) >= 2 and makespan > 1.3 * np.mean(route_distances):  # Route expansion\n        # Add a node from one route to another to balance makespan\n        shortest_idx = np.argmin(route_distances)\n        shortest_route = new_solution[shortest_idx]\n\n        if len(shortest_route) > 3:\n            # Find node to move that maximizes makespan improvement\n            best_improvement = 0\n            best_node = None\n            for node in shortest_route[1:-1]:\n                # Calculate potential makespan improvement if this node is moved\n                temp_route = np.delete(shortest_route, np.where(shortest_route == node)[0][0])\n                temp_distance = sum(distance_matrix[temp_route[i]][temp_route[i+1]] for i in range(len(temp_route)-1))\n                improvement = route_distances[shortest_idx] - temp_distance\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = node\n\n            if best_node is not None:\n                # Find best route to insert the node into\n                best_route = None\n                best_pos = None\n                best_cost = float('inf')\n\n                for i in range(len(new_solution)):\n                    if i != shortest_idx:\n                        route = new_solution[i]\n                        for pos in range(1, len(route)):\n                            cost = (distance_matrix[route[pos-1]][best_node] +\n                                    distance_matrix[best_node][route[pos]] -\n                                    distance_matrix[route[pos-1]][route[pos]])\n                            if cost < best_cost and sum(demand[route[1:-1]]) + demand[best_node] <= capacity:\n                                best_cost = cost\n                                best_route = i\n                                best_pos = pos\n\n                if best_route is not None:\n                    new_route = np.insert(new_solution[best_route], best_pos, best_node)\n                    new_solution[best_route] = new_route\n                    new_solution[shortest_idx] = np.delete(shortest_route, np.where(shortest_route == best_node)[0][0])\n    elif makespan < 0.8 * np.mean(route_distances):  # Demand-aware segment relocation\n        # Move segments between routes to improve both objectives\n        candidate_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(len(new_solution)):\n                if i != j and route_demands[i] + route_demands[j] <= capacity:\n                    candidate_pairs.append((i, j))\n\n        if candidate_pairs:\n            i, j = random.choice(candidate_pairs)\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Find compatible segment in route_j to insert into route_i\n            for k in range(1, len(route_j)-1):\n                segment = route_j[k]\n                if sum(demand[route_i[1:-1]]) + demand[segment] <= capacity:\n                    # Find best insertion point in route_i\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route_i)):\n                        cost = (distance_matrix[route_i[pos-1]][segment] +\n                                distance_matrix[segment][route_i[pos]] -\n                                distance_matrix[route_i[pos-1]][route_i[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    # Perform insertion\n                    new_route_i = np.insert(route_i, best_pos, segment)\n                    new_route_j = np.delete(route_j, k)\n                    new_solution[i] = new_route_i\n                    new_solution[j] = new_route_j\n                    break\n    elif len(new_solution) >= 3:  # Adaptive route splitting\n        # Split a long route into two to improve makespan\n        longest_idx = np.argmax(route_distances)\n        longest_route = new_solution[longest_idx]\n\n        if len(longest_route) > 5:\n            # Find best split point that balances the two new routes\n            best_split = None\n            best_balance = float('inf')\n\n            for split in range(2, len(longest_route)-2):\n                first_part = longest_route[:split+1]\n                second_part = np.concatenate([[0], longest_route[split:]])\n\n                first_demand = sum(demand[first_part[1:-1]])\n                second_demand = sum(demand[second_part[1:-1]])\n\n                if first_demand <= capacity and second_demand <= capacity:\n                    first_distance = sum(distance_matrix[first_part[i]][first_part[i+1]] for i in range(len(first_part)-1))\n                    second_distance = sum(distance_matrix[second_part[i]][second_part[i+1]] for i in range(len(second_part)-1))\n                    balance = abs(first_distance - second_distance)\n\n                    if balance < best_balance:\n                        best_balance = balance\n                        best_split = split\n\n            if best_split is not None:\n                first_part = longest_route[:best_split+1]\n                second_part = np.concatenate([[0], longest_route[best_split:]])\n                new_solution[longest_idx] = first_part\n                new_solution.insert(longest_idx+1, second_part)\n    else:  # Balanced route balancing\n        # Adjust routes to balance their lengths\n        avg_distance = np.mean(route_distances)\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            current_distance = route_distances[i]\n\n            if current_distance > avg_distance * 1.1:  # Long route\n                # Try to move a node to a shorter route\n                for j in range(len(new_solution)):\n                    if j != i and route_distances[j] < avg_distance * 0.9:\n                        for k in range(1, len(route)-1):\n                            node = route[k]\n                            if sum(demand[new_solution[j][1:-1]]) + demand[node] <= capacity:\n                                # Find best insertion point\n                                best_pos = 1\n                                best_cost = float('inf')\n                                for pos in range(1, len(new_solution[j])):\n                                    cost = (distance_matrix[new_solution[j][pos-1]][node] +\n                                            distance_matrix[node][new_solution[j][pos]] -\n                                            distance_matrix[new_solution[j][pos-1]][new_solution[j][pos]])\n                                    if cost < best_cost:\n                                        best_cost = cost\n                                        best_pos = pos\n\n                                # Perform move\n                                new_solution[j] = np.insert(new_solution[j], best_pos, node)\n                                new_solution[i] = np.delete(route, k)\n                                break\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8798906749034159,
            5.043903201818466
        ],
        "raw_score": [
            53.54446400826593,
            7.311524815169616
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted scoring (70% makespan, 30% distance) and applies a hybrid local search that randomly splits two routes, shuffles segments, reallocates customers with demand checks, and reconstructs feasible routes while prioritizing capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([0.3, 0.7])\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]), obj[1] / max(o[1] for o in [x[1] for x in archive])) for obj in [x[1] for x in archive]])\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        split1 = random.randint(1, len(route1)-2)\n        split2 = random.randint(1, len(route2)-2)\n\n        seg1a, seg1b = route1[:split1+1], route1[split1:]\n        seg2a, seg2b = route2[:split2+1], route2[split2:]\n\n        combined_segments = [seg1a, seg1b, seg2a, seg2b]\n        random.shuffle(combined_segments)\n\n        temp_solution = []\n        for seg in combined_segments:\n            customers = seg[1:-1]\n            random.shuffle(customers)\n            current_route = [0]\n            current_load = 0.0\n\n            for customer in customers:\n                if current_load + demand[customer] <= capacity:\n                    current_route.append(customer)\n                    current_load += demand[customer]\n                else:\n                    current_route.append(0)\n                    temp_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7927952972949865,
            0.3386287987232208
        ],
        "raw_score": [
            58.26743417235241,
            7.749824575626347
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-aware solution selection with a novel \"objective-balanced route partitioning\" strategy, prioritizing distance (60%) over makespan (40%) to guide neighbor generation. It dynamically partitions routes into segments, merges underutilized segments into other routes while balancing demand, and splits overloaded routes to maintain feasibility, emphasizing both distance reduction and makespan minimization through weighted improvements. The code ensures feasibility through continuous capacity checks and dynamic rebalancing.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.6 * obj[0] + 0.4 * obj[1] for obj in [x[1] for x in archive]]\n    selected_idx = np.argmin(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Objective-balanced route partitioning\n    if len(new_solution) >= 2:\n        # Calculate route characteristics\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find routes with extreme characteristics\n        min_demand_idx = np.argmin(route_demands)\n        max_length_idx = np.argmax(route_lengths)\n\n        # Partition and reallocate segments\n        if min_demand_idx != max_length_idx:\n            # Split the shortest route into segments\n            short_route = new_solution[min_demand_idx]\n            split_pos = random.randint(1, len(short_route) - 2)\n            seg1, seg2 = short_route[:split_pos + 1], short_route[split_pos:]\n\n            # Calculate segment characteristics\n            seg1_demand = sum(demand[seg1[1:-1]])\n            seg2_demand = sum(demand[seg2[1:-1]])\n\n            # Try to merge segments into other routes\n            for seg, seg_demand in [(seg1, seg1_demand), (seg2, seg2_demand)]:\n                if seg_demand == 0:\n                    continue\n\n                # Find best target route for merge\n                best_route_idx = -1\n                best_improvement = -float('inf')\n\n                for i, route in enumerate(new_solution):\n                    if i == min_demand_idx:\n                        continue\n\n                    # Check capacity constraint\n                    if sum(demand[route[1:-1]]) + seg_demand > capacity:\n                        continue\n\n                    # Calculate potential improvement (distance + demand balance)\n                    current_dist = sum(distance_matrix[route[j]][route[j+1]] for j in range(len(route)-1))\n                    new_route = np.concatenate([route[:-1], seg[1:-1], [0]])\n                    new_dist = sum(distance_matrix[new_route[j]][new_route[j+1]] for j in range(len(new_route)-1))\n                    improvement = (current_dist - new_dist) * 0.7 + (abs(seg_demand - capacity/2) - abs(sum(demand[route[1:-1]]) - capacity/2)) * 0.3\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = i\n\n                # Perform merge if beneficial\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    merged_route = np.concatenate([target_route[:-1], seg[1:-1], [0]])\n                    new_solution[best_route_idx] = merged_route\n\n            # Remove the original short route if segments were successfully merged\n            if all(len(route) == 1 for route in [seg1, seg2]):\n                del new_solution[min_demand_idx]\n\n        # Load-balanced splits for long routes\n        for i, route in enumerate(new_solution):\n            if len(route) > 4 and sum(demand[route[1:-1]]) < capacity * 0.7:\n                # Find split position that balances load\n                best_split = -1\n                best_balance = float('inf')\n\n                for j in range(1, len(route) - 2):\n                    left_demand = sum(demand[route[1:j+1]])\n                    right_demand = sum(demand[route[j+1:-1]])\n                    balance = abs(left_demand - right_demand)\n\n                    if balance < best_balance:\n                        best_balance = balance\n                        best_split = j\n\n                if best_split != -1:\n                    # Create two new routes\n                    left_route = np.concatenate([route[:best_split+1], [0]])\n                    right_route = np.concatenate([[0], route[best_split+1:]])\n\n                    # Check capacity constraints\n                    if (sum(demand[left_route[1:-1]]) <= capacity and\n                        sum(demand[right_route[1:-1]]) <= capacity):\n                        new_solution[i] = left_route\n                        new_solution.append(right_route)\n\n    # Validate and return the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8589854142232323,
            3.9389526546001434
        ],
        "raw_score": [
            55.91306692761313,
            7.270834948519293
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted objective score (70% makespan, 30% distance) to prioritize balanced trade-offs, then applies a hybrid local search combining segment swaps, weighted reallocation, and dynamic capacity checks. It splits routes into segments, reinserts customers into new routes while prioritizing distance savings and makespan reduction, and performs multi-step rebalancing to redistribute customers between routes. Finally, it uses a chain segment swap operator to further improve both objectives by swapping segments between routes and reallocating customers based on weighted savings.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = [0.7 * obj[1] + 0.3 * obj[0] for obj in [x[1] for x in archive]]\n    selected_idx = np.argmin(weights)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) >= 2:\n        # Hybrid local search: segment swaps + weighted reallocation\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Split route into segments\n        split_pos = random.randint(1, len(route) - 2)\n        seg1, seg2 = route[:split_pos + 1], route[split_pos:]\n\n        # Remove original route\n        del new_solution[route_idx]\n\n        # Reinsert customers from both segments into new routes\n        customers = np.concatenate([seg1[1:-1], seg2[1:-1]])\n        np.random.shuffle(customers)\n\n        # Create new routes with weighted reinsertion (distance + makespan)\n        current_route = [0]\n        current_load = 0.0\n        temp_solution = []\n\n        for customer in customers:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                current_route.append(0)\n                temp_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            temp_solution.append(np.array(current_route))\n\n        # Multi-step rebalancing phase\n        if len(temp_solution) > 1:\n            # Calculate potential improvements for each customer\n            improvements = []\n            for i, route in enumerate(temp_solution):\n                for j, customer in enumerate(route[1:-1]):\n                    # Calculate distance savings if moved to another route\n                    prev_node = route[j]\n                    next_node = route[j + 2] if j + 2 < len(route) else 0\n                    current_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n                    # Find best alternative route\n                    best_dist = float('inf')\n                    best_route_idx = -1\n                    for k, alt_route in enumerate(temp_solution):\n                        if k == i:\n                            continue\n                        # Check if adding to this route is feasible\n                        if sum(demand[alt_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate insertion cost\n                            for l in range(len(alt_route) - 1):\n                                insert_dist = (distance_matrix[alt_route[l], customer] +\n                                              distance_matrix[customer, alt_route[l + 1]] -\n                                              distance_matrix[alt_route[l], alt_route[l + 1]])\n                                if insert_dist < best_dist:\n                                    best_dist = insert_dist\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        improvements.append((i, j, best_route_idx, current_dist - best_dist))\n\n            # Sort improvements by potential savings (distance + makespan)\n            improvements.sort(key=lambda x: x[3], reverse=True)\n\n            # Apply the best improvements\n            for i, j, best_route_idx, _ in improvements[:min(3, len(improvements))]:\n                route = temp_solution[i]\n                customer = route[j + 1]\n\n                # Remove from current route\n                route = np.concatenate([route[:j + 1], route[j + 2:]])\n                if len(route) == 1:\n                    del temp_solution[i]\n                else:\n                    temp_solution[i] = route\n\n                # Insert into best alternative route\n                alt_route = temp_solution[best_route_idx]\n                best_pos = 0\n                best_insert_cost = float('inf')\n\n                # Find best insertion position\n                for k in range(len(alt_route) - 1):\n                    insert_cost = (distance_matrix[alt_route[k], customer] +\n                                 distance_matrix[customer, alt_route[k + 1]] -\n                                 distance_matrix[alt_route[k], alt_route[k + 1]])\n                    if insert_cost < best_insert_cost:\n                        best_insert_cost = insert_cost\n                        best_pos = k + 1\n\n                # Insert customer\n                alt_route = np.insert(alt_route, best_pos, customer)\n                temp_solution[best_route_idx] = alt_route\n\n        # Chain segment swap operator\n        if len(temp_solution) >= 2:\n            # Select two routes to swap segments\n            route1_idx, route2_idx = random.sample(range(len(temp_solution)), 2)\n            route1 = temp_solution[route1_idx]\n            route2 = temp_solution[route2_idx]\n\n            # Split both routes\n            split_pos1 = random.randint(1, len(route1) - 2)\n            split_pos2 = random.randint(1, len(route2) - 2)\n\n            # Swap segments\n            seg1 = route1[:split_pos1 + 1]\n            seg2 = route2[:split_pos2 + 1]\n            new_route1 = np.concatenate([seg2, route1[split_pos1:]])\n            new_route2 = np.concatenate([seg1, route2[split_pos2:]])\n\n            # Check feasibility\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n                temp_solution[route1_idx] = new_route1\n                temp_solution[route2_idx] = new_route2\n\n        # Validate and update solution\n        if all(sum(demand[route[1:-1]]) <= capacity for route in temp_solution):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6795354148322328,
            0.1195138692855835
        ],
        "raw_score": [
            58.496152354334,
            7.687355918883644
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-aware selection with a multi-step hybrid operator: it first merges underutilized routes to reduce makespan, then performs demand-aware segment relinking between routes by exchanging high-distance segments, and finally applies capacity-preserving segment inversion in the longest route to optimize the distance-makespan tradeoff. The selection prioritizes makespan (60%) over distance (40%) and focuses on routes with low demand and short distances for merging, while ensuring capacity constraints are respected throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    normalized_scores = np.array([(obj[0] / max(o[0] for o in [x[1] for x in archive]),\n                                 obj[1] / max(o[1] for o in [x[1] for x in archive]))\n                                for obj in [x[1] for x in archive]])\n    weights = np.array([0.4, 0.6])  # Slightly more emphasis on makespan\n    scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Merge underutilized routes\n    if len(new_solution) >= 2:\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find routes with low demand and short distance (potential for merging)\n        candidate_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if (route_demands[i] + route_demands[j] <= capacity * 0.8 and  # Leave some capacity slack\n                    route_distances[i] < np.mean(route_distances) and\n                    route_distances[j] < np.mean(route_distances)):\n                    candidate_pairs.append((i, j))\n\n        if candidate_pairs:\n            # Select the pair with the highest combined distance reduction potential\n            i, j = min(candidate_pairs, key=lambda x: route_distances[x[0]] + route_distances[x[1]])\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Step 2: Demand-aware segment relinking\n    if len(new_solution) >= 2:\n        # Calculate route characteristics\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n        # Find high-distance segments in each route\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            # Identify the longest segment in terms of distance\n            max_segment_distance = -1\n            best_segment = None\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    segment_distance = sum(distance_matrix[route[k]][route[k+1]] for k in range(i, j))\n                    if segment_distance > max_segment_distance:\n                        max_segment_distance = segment_distance\n                        best_segment = (i, j)\n\n            if best_segment:\n                i, j = best_segment\n                segment = route[i:j+1]\n                segment_demand = sum(demand[segment])\n\n                # Find compatible routes to exchange with\n                compatible_routes = []\n                for k in range(len(new_solution)):\n                    if k == route_idx:\n                        continue\n                    if sum(demand[new_solution[k][1:-1]]) + segment_demand <= capacity:\n                        compatible_routes.append(k)\n\n                if compatible_routes:\n                    # Select the route that would benefit most from the exchange\n                    best_route = min(compatible_routes, key=lambda k: sum(distance_matrix[new_solution[k][l]][new_solution[k][l+1]] for l in range(len(new_solution[k])-1)))\n                    target_route = new_solution[best_route]\n\n                    # Find insertion point in target route\n                    best_insertion = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(target_route)):\n                        insertion_distance = distance_matrix[target_route[pos-1]][segment[0]] + \\\n                                           distance_matrix[segment[-1]][target_route[pos]] - \\\n                                           distance_matrix[target_route[pos-1]][target_route[pos]]\n                        if insertion_distance < min_increase:\n                            min_increase = insertion_distance\n                            best_insertion = pos\n\n                    # Perform the exchange\n                    new_target_route = np.concatenate([target_route[:best_insertion], segment, target_route[best_insertion:]])\n                    new_solution[best_route] = new_target_route\n                    new_solution[route_idx] = np.concatenate([route[:i], route[j+1:]])\n\n    # Step 3: Capacity-preserving segment inversion\n    if len(new_solution) > 0:\n        route_distances = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_distances)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:\n            # Find the segment with the most potential for distance reduction\n            max_potential = -1\n            best_segment = None\n            for i in range(1, len(longest_route)-2):\n                for j in range(i+1, len(longest_route)-1):\n                    original_distance = sum(distance_matrix[longest_route[k]][longest_route[k+1]] for k in range(i, j+1))\n                    reversed_distance = sum(distance_matrix[longest_route[k+1]][longest_route[k]] for k in range(i, j))\n                    potential = original_distance - reversed_distance\n                    if potential > max_potential and sum(demand[longest_route[i:j+1]]) <= capacity:\n                        max_potential = potential\n                        best_segment = (i, j)\n\n            if best_segment:\n                i, j = best_segment\n                reversed_segment = longest_route[i:j+1][::-1]\n                new_route = np.concatenate([longest_route[:i], reversed_segment, longest_route[j+1:]])\n                new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8699461803648509,
            5.810759276151657
        ],
        "raw_score": [
            54.938909175611954,
            6.801893023072205
        ]
    }
]