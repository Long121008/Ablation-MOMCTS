[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm employs a multi-phase hybrid approach that first selects high-crowding solutions from the archive, then alternates between angle-based route reshuffling for makespan optimization and demand-aware customer redistribution for distance optimization, while ensuring feasibility through capacity checks and route splitting. It prioritizes spatial clustering and demand balancing, dynamically balancing objectives through probabilistic phase activation, and maintains solution quality by cleaning up empty routes and final angle-based optimization. The algorithm's critical design ideas are the integration of angle-based sorting with demand awareness, spatial proximity-based route selection, and capacity-sensitive route splitting, all while avoiding standard 2-opt by using novel hybrid transformations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Angle-based makespan optimization with demand awareness\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[route[1:-1]]\n            customer_demands = demand[route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            # Sort by angle then by demand to balance makespan and capacity\n            sorted_indices = np.lexsort((customer_demands, angles))\n            sorted_route = route[1:-1][sorted_indices]\n            # Split into multiple routes if capacity constraint is violated\n            current_demand = 0\n            split_routes = []\n            current_route = [0]\n            for i in sorted_indices:\n                if current_demand + demand[route[1:-1][i]] <= capacity:\n                    current_route.append(route[1:-1][i])\n                    current_demand += demand[route[1:-1][i]]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, route[1:-1][i]]\n                    current_demand = demand[route[1:-1][i]]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n            # Replace original route with split routes\n            new_solution.pop(route_idx)\n            for r in split_routes:\n                if len(r) > 2:\n                    new_solution.append(r)\n\n    # Phase 2: Demand-aware distance optimization with spatial awareness\n    if len(new_solution) > 1 and random.random() < 0.7:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        # Find the closest route in terms of spatial proximity\n        closest_dist = float('inf')\n        closest_route_idx = -1\n        for i in range(len(new_solution)):\n            if i != route1_idx:\n                dist = np.linalg.norm(coords[new_solution[i][1]] - coords[route1[1]])\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_route_idx = i\n        if closest_route_idx != -1:\n            route2 = new_solution[closest_route_idx]\n            # Try to move customers between routes while balancing demands\n            route1_demand = np.sum(demand[route1[1:-1]])\n            route2_demand = np.sum(demand[route2[1:-1]])\n            for i in range(1, len(route1)-1):\n                if demand[route1[i]] <= capacity - route2_demand:\n                    # Find best insertion position in route2\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(route2)):\n                        dist_change = (distance_matrix[route2[pos-1]][route1[i]] + distance_matrix[route1[i]][route2[pos]] -\n                                     distance_matrix[route2[pos-1]][route2[pos]] +\n                                     distance_matrix[route1[i-1]][route1[i+1]] -\n                                     distance_matrix[route1[i-1]][route1[i]] -\n                                     distance_matrix[route1[i]][route1[i+1]])\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n                    if best_pos != -1:\n                        # Perform the move\n                        route2 = np.insert(route2, best_pos, route1[i])\n                        route1 = np.delete(route1, i)\n                        new_solution[route1_idx] = route1\n                        new_solution[closest_route_idx] = route2\n                        break\n\n    # Phase 3: Capacity-sensitive route splitting\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Find longest route by number of customers\n        route_lengths = [len(route) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 5:\n            # Split route into two balanced parts\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n            for i in range(1, len(longest_route)-1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n            if split_pos > 1 and split_pos < len(longest_route)-2:\n                route1 = np.concatenate((longest_route[:split_pos+1], [0]))\n                route2 = np.concatenate(([0], longest_route[split_pos+1:]))\n                new_solution.pop(longest_route_idx)\n                new_solution.append(route1)\n                new_solution.append(route2)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 4: Final optimization with angle-based sorting\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            sorted_indices = np.argsort(angles)\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: Adaptive angle-demand hybrids, crowding-distance prioritization, geometric demand clustering, capacity-aware merges\n- **Advice**: Alternate between angle-based route reshaping (for makespan) and demand-weighted customer merges (for distance), always check feasibility\n- **Avoid**: Static operator sequences, brute-force swaps, ignoring spatial constraints\n- **Explanation**: Dynamic operator alternation balances objectives while geometric clustering and demand-aware merges ensure feasible, high-quality neighbors\n\n```python\nimport numpy as np\nimport random\n\ndef select_neighbor(archive, demands, vehicle_capacity):\n    # Select high-crowding solution\n    selected_idx = np.argmax([sol[1][2] for sol in archive])\n    selected_sol = archive[selected_idx][0]\n\n    # Hybrid operator: Alternate between angle-based reshuffling and demand-aware merges\n    if random.random() < 0.5:\n        new_sol = angle_based_reshuffle(selected_sol, demands, vehicle_capacity)\n    else:\n        new_sol = demand_aware_merge(selected_sol, demands, vehicle_capacity)\n\n    return new_sol\n\ndef angle_based_reshuffle(routes, demands, vehicle_capacity):\n    # Cluster customers by angle to reduce makespan\n    clustered_routes = []\n    for route in routes:\n        if len(route) > 2:\n            # Sort by angle (simplified)\n            clustered_routes.append(np.sort(route[1:-1]))\n    return clustered_routes\n\ndef demand_aware_merge(routes, demands, vehicle_capacity):\n    # Merge routes if demand allows\n    for i in range(len(routes)):\n        for j in range(i+1, len(routes)):\n            if sum(demands[routes[i]]) + sum(demands[routes[j]]) <= vehicle_capacity:\n                # Merge routes (simplified)\n                pass\n    return routes\n```\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 301,
        "algorithm": "The algorithm combines crowding-distance selection and adaptive local search, prioritizing high-crowding solutions from the archive and alternating between convex hull-based spatial partitioning and capacity-aware route merging, while ensuring feasibility through continuous demand validation and proximity checks. It emphasizes geometric demand balancing and consolidation, dynamically adjusting operator probabilities to balance makespan and distance optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Alternate between spatial clustering and route merging\n    if random.random() < 0.5:\n        # Geometric demand-balanced partitioning\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                customer_coords = coords[route[1:-1]]\n                try:\n                    hull = ConvexHull(customer_coords)\n                    # Split along the longest diagonal of the convex hull\n                    diag_lengths = []\n                    for i in range(len(hull.vertices)):\n                        for j in range(i+1, len(hull.vertices)):\n                            diag_lengths.append((i, j, np.linalg.norm(\n                                customer_coords[hull.vertices[i]] - customer_coords[hull.vertices[j]])))\n                    if diag_lengths:\n                        _, _, _, i, j, _ = max(diag_lengths, key=lambda x: x[2])\n                        # Split customers into two groups\n                        group1 = []\n                        group2 = []\n                        for k in range(len(route[1:-1])):\n                            if (np.linalg.norm(customer_coords[k] - customer_coords[i]) <\n                                np.linalg.norm(customer_coords[k] - customer_coords[j])):\n                                group1.append(route[1:-1][k])\n                            else:\n                                group2.append(route[1:-1][k])\n                        # Check capacity constraints\n                        if (np.sum(demand[group1]) <= capacity and np.sum(demand[group2]) <= capacity):\n                            new_solution[route_idx] = np.concatenate(([0], group1, [0]))\n                            new_solution.insert(route_idx + 1, np.concatenate(([0], group2, [0])))\n                except:\n                    pass\n    else:\n        # Capacity-aware route consolidation\n        if len(new_solution) > 1:\n            # Find two closest routes\n            min_dist = float('inf')\n            route1_idx, route2_idx = -1, -1\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    dist = np.linalg.norm(\n                        coords[new_solution[i][-2]] - coords[new_solution[j][1]])\n                    if dist < min_dist:\n                        min_dist = dist\n                        route1_idx, route2_idx = i, j\n            if route1_idx != -1 and route2_idx != -1:\n                # Check if merging is feasible\n                route1_demand = np.sum(demand[new_solution[route1_idx][1:-1]])\n                route2_demand = np.sum(demand[new_solution[route2_idx][1:-1]])\n                if route1_demand + route2_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate((\n                        new_solution[route1_idx][:-1],\n                        new_solution[route2_idx][1:]))\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.739428414637516,
            7.654493153095245
        ],
        "raw_score": [
            57.45743683651202,
            7.575853237392358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Alternate between spatial clustering and route merging\n    if random.random() < 0.5:\n        # Geometric demand-balanced partitioning\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                customer_coords = coords[route[1:-1]]\n                try:\n                    hull = ConvexHull(customer_coords)\n                    # Split along the longest diagonal of the convex hull\n                    diag_lengths = []\n                    for i in range(len(hull.vertices)):\n                        for j in range(i+1, len(hull.vertices)):\n                            diag_lengths.append((i, j, np.linalg.norm(\n                                customer_coords[hull.vertices[i]] - customer_coords[hull.vertices[j]])))\n                    if diag_lengths:\n                        _, _, _, i, j, _ = max(diag_lengths, key=lambda x: x[2])\n                        # Split customers into two groups\n                        group1 = []\n                        group2 = []\n                        for k in range(len(route[1:-1])):\n                            if (np.linalg.norm(customer_coords[k] - customer_coords[i]) <\n                                np.linalg.norm(customer_coords[k] - customer_coords[j])):\n                                group1.append(route[1:-1][k])\n                            else:\n                                group2.append(route[1:-1][k])\n                        # Check capacity constraints\n                        if (np.sum(demand[group1]) <= capacity and np.sum(demand[group2]) <= capacity):\n                            new_solution[route_idx] = np.concatenate(([0], group1, [0]))\n                            new_solution.insert(route_idx + 1, np.concatenate(([0], group2, [0])))\n                except:\n                    pass\n    else:\n        # Capacity-aware route consolidation\n        if len(new_solution) > 1:\n            # Find two closest routes\n            min_dist = float('inf')\n            route1_idx, route2_idx = -1, -1\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    dist = np.linalg.norm(\n                        coords[new_solution[i][-2]] - coords[new_solution[j][1]])\n                    if dist < min_dist:\n                        min_dist = dist\n                        route1_idx, route2_idx = i, j\n            if route1_idx != -1 and route2_idx != -1:\n                # Check if merging is feasible\n                route1_demand = np.sum(demand[new_solution[route1_idx][1:-1]])\n                route2_demand = np.sum(demand[new_solution[route2_idx][1:-1]])\n                if route1_demand + route2_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate((\n                        new_solution[route1_idx][:-1],\n                        new_solution[route2_idx][1:]))\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm employs a multi-phase hybrid approach that first selects high-crowding solutions from the archive, then alternates between angle-based route reshuffling for makespan optimization and demand-aware customer redistribution for distance optimization, while ensuring feasibility through capacity checks and route splitting. It prioritizes spatial clustering and demand balancing, dynamically balancing objectives through probabilistic phase activation, and maintains solution quality by cleaning up empty routes and final angle-based optimization. The algorithm's critical design ideas are the integration of angle-based sorting with demand awareness, spatial proximity-based route selection, and capacity-sensitive route splitting, all while avoiding standard 2-opt by using novel hybrid transformations.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Angle-based makespan optimization with demand awareness\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[route[1:-1]]\n            customer_demands = demand[route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            # Sort by angle then by demand to balance makespan and capacity\n            sorted_indices = np.lexsort((customer_demands, angles))\n            sorted_route = route[1:-1][sorted_indices]\n            # Split into multiple routes if capacity constraint is violated\n            current_demand = 0\n            split_routes = []\n            current_route = [0]\n            for i in sorted_indices:\n                if current_demand + demand[route[1:-1][i]] <= capacity:\n                    current_route.append(route[1:-1][i])\n                    current_demand += demand[route[1:-1][i]]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, route[1:-1][i]]\n                    current_demand = demand[route[1:-1][i]]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n            # Replace original route with split routes\n            new_solution.pop(route_idx)\n            for r in split_routes:\n                if len(r) > 2:\n                    new_solution.append(r)\n\n    # Phase 2: Demand-aware distance optimization with spatial awareness\n    if len(new_solution) > 1 and random.random() < 0.7:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        # Find the closest route in terms of spatial proximity\n        closest_dist = float('inf')\n        closest_route_idx = -1\n        for i in range(len(new_solution)):\n            if i != route1_idx:\n                dist = np.linalg.norm(coords[new_solution[i][1]] - coords[route1[1]])\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_route_idx = i\n        if closest_route_idx != -1:\n            route2 = new_solution[closest_route_idx]\n            # Try to move customers between routes while balancing demands\n            route1_demand = np.sum(demand[route1[1:-1]])\n            route2_demand = np.sum(demand[route2[1:-1]])\n            for i in range(1, len(route1)-1):\n                if demand[route1[i]] <= capacity - route2_demand:\n                    # Find best insertion position in route2\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(route2)):\n                        dist_change = (distance_matrix[route2[pos-1]][route1[i]] + distance_matrix[route1[i]][route2[pos]] -\n                                     distance_matrix[route2[pos-1]][route2[pos]] +\n                                     distance_matrix[route1[i-1]][route1[i+1]] -\n                                     distance_matrix[route1[i-1]][route1[i]] -\n                                     distance_matrix[route1[i]][route1[i+1]])\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n                    if best_pos != -1:\n                        # Perform the move\n                        route2 = np.insert(route2, best_pos, route1[i])\n                        route1 = np.delete(route1, i)\n                        new_solution[route1_idx] = route1\n                        new_solution[closest_route_idx] = route2\n                        break\n\n    # Phase 3: Capacity-sensitive route splitting\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Find longest route by number of customers\n        route_lengths = [len(route) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 5:\n            # Split route into two balanced parts\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n            for i in range(1, len(longest_route)-1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n            if split_pos > 1 and split_pos < len(longest_route)-2:\n                route1 = np.concatenate((longest_route[:split_pos+1], [0]))\n                route2 = np.concatenate(([0], longest_route[split_pos+1:]))\n                new_solution.pop(longest_route_idx)\n                new_solution.append(route1)\n                new_solution.append(route2)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 4: Final optimization with angle-based sorting\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            sorted_indices = np.argsort(angles)\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 302,
        "algorithm": "The algorithm selects diverse solutions from the archive based on objective diversity, then applies a multi-phase local search: first merging small routes when capacity allows, then redistributing customers to balance demands, followed by spatial-constrained splitting of dispersed routes, and finally optimizing the longest route by sorting customers by demand. Each phase is probabilistically activated to ensure exploration while maintaining feasibility through capacity checks and demand validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    diversity = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        diversity[sorted_idx[0]] = diversity[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            diversity[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-6)\n\n    selected_idx = np.argmax(diversity)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Capacity-aware route merging\n    if len(new_solution) > 2 and random.random() < 0.5:\n        # Find the smallest and second smallest routes\n        route_lengths = [len(route) for route in new_solution]\n        sorted_routes = np.argsort(route_lengths)\n        small_route = new_solution[sorted_routes[0]]\n        second_small_route = new_solution[sorted_routes[1]]\n\n        # Calculate combined demand\n        combined_demand = np.sum(demand[small_route[1:-1]]) + np.sum(demand[second_small_route[1:-1]])\n\n        if combined_demand <= capacity:\n            # Merge the two smallest routes\n            merged_route = np.concatenate((small_route[:-1], second_small_route[1:]))\n            new_solution.pop(sorted_routes[1])\n            new_solution.pop(sorted_routes[0])\n            new_solution.append(merged_route)\n\n    # Phase 2: Demand-balanced customer redistribution\n    if len(new_solution) > 1 and random.random() < 0.6:\n        # Select two routes with significant demand imbalance\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        max_idx = np.argmax(route_demands)\n        min_idx = np.argmin(route_demands)\n\n        if route_demands[max_idx] > 1.2 * route_demands[min_idx]:\n            max_route = new_solution[max_idx]\n            min_route = new_solution[min_idx]\n\n            # Try to move customers from max to min route\n            for i in range(1, len(max_route)-1):\n                if demand[max_route[i]] <= capacity - route_demands[min_idx]:\n                    # Find best insertion position in min route\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(min_route)):\n                        dist_change = (distance_matrix[min_route[pos-1]][max_route[i]] +\n                                     distance_matrix[max_route[i]][min_route[pos]] -\n                                     distance_matrix[min_route[pos-1]][min_route[pos]])\n\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        min_route = np.insert(min_route, best_pos, max_route[i])\n                        max_route = np.delete(max_route, i)\n                        new_solution[max_idx] = max_route\n                        new_solution[min_idx] = min_route\n                        break\n\n    # Phase 3: Spatial-constrained route optimization\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Select a route with high spatial dispersion\n        route_dispersions = []\n        for route in new_solution:\n            if len(route) > 3:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                dispersion = np.mean(np.linalg.norm(route_coords - centroid, axis=1))\n                route_dispersions.append(dispersion)\n            else:\n                route_dispersions.append(0)\n\n        target_idx = np.argmax(route_dispersions)\n        target_route = new_solution[target_idx]\n\n        if len(target_route) > 4:\n            # Find closest customer to depot\n            depot_coords = coords[0]\n            customer_coords = coords[target_route[1:-1]]\n            distances_to_depot = np.linalg.norm(customer_coords - depot_coords, axis=1)\n            closest_customer_idx = np.argmin(distances_to_depot)\n\n            # Split route at this customer\n            split_pos = closest_customer_idx + 1  # +1 because route starts with 0\n\n            if split_pos > 1 and split_pos < len(target_route)-2:\n                route1 = np.concatenate((target_route[:split_pos+1], [0]))\n                route2 = np.concatenate(([0], target_route[split_pos+1:]))\n\n                # Check capacity constraints\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution.pop(target_idx)\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 4: Final optimization with demand-aware sorting\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:\n            # Sort customers by demand (highest first) to balance capacity usage\n            customer_indices = longest_route[1:-1]\n            customer_demands = demand[customer_indices]\n            sorted_indices = np.argsort(-customer_demands)\n            sorted_route = customer_indices[sorted_indices]\n\n            # Check if the sorted route is feasible\n            current_demand = 0\n            is_feasible = True\n            for i in sorted_indices:\n                if current_demand + demand[i] > capacity:\n                    is_feasible = False\n                    break\n                current_demand += demand[i]\n\n            if is_feasible:\n                new_solution[longest_route_idx] = np.concatenate(([0], sorted_route, [0]))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7477425286762831,
            8.745203226804733
        ],
        "raw_score": [
            56.18418456146232,
            7.292711740666277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    diversity = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        diversity[sorted_idx[0]] = diversity[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            diversity[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-6)\n\n    selected_idx = np.argmax(diversity)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Capacity-aware route merging\n    if len(new_solution) > 2 and random.random() < 0.5:\n        # Find the smallest and second smallest routes\n        route_lengths = [len(route) for route in new_solution]\n        sorted_routes = np.argsort(route_lengths)\n        small_route = new_solution[sorted_routes[0]]\n        second_small_route = new_solution[sorted_routes[1]]\n\n        # Calculate combined demand\n        combined_demand = np.sum(demand[small_route[1:-1]]) + np.sum(demand[second_small_route[1:-1]])\n\n        if combined_demand <= capacity:\n            # Merge the two smallest routes\n            merged_route = np.concatenate((small_route[:-1], second_small_route[1:]))\n            new_solution.pop(sorted_routes[1])\n            new_solution.pop(sorted_routes[0])\n            new_solution.append(merged_route)\n\n    # Phase 2: Demand-balanced customer redistribution\n    if len(new_solution) > 1 and random.random() < 0.6:\n        # Select two routes with significant demand imbalance\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        max_idx = np.argmax(route_demands)\n        min_idx = np.argmin(route_demands)\n\n        if route_demands[max_idx] > 1.2 * route_demands[min_idx]:\n            max_route = new_solution[max_idx]\n            min_route = new_solution[min_idx]\n\n            # Try to move customers from max to min route\n            for i in range(1, len(max_route)-1):\n                if demand[max_route[i]] <= capacity - route_demands[min_idx]:\n                    # Find best insertion position in min route\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(min_route)):\n                        dist_change = (distance_matrix[min_route[pos-1]][max_route[i]] +\n                                     distance_matrix[max_route[i]][min_route[pos]] -\n                                     distance_matrix[min_route[pos-1]][min_route[pos]])\n\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        # Perform the move\n                        min_route = np.insert(min_route, best_pos, max_route[i])\n                        max_route = np.delete(max_route, i)\n                        new_solution[max_idx] = max_route\n                        new_solution[min_idx] = min_route\n                        break\n\n    # Phase 3: Spatial-constrained route optimization\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Select a route with high spatial dispersion\n        route_dispersions = []\n        for route in new_solution:\n            if len(route) > 3:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                dispersion = np.mean(np.linalg.norm(route_coords - centroid, axis=1))\n                route_dispersions.append(dispersion)\n            else:\n                route_dispersions.append(0)\n\n        target_idx = np.argmax(route_dispersions)\n        target_route = new_solution[target_idx]\n\n        if len(target_route) > 4:\n            # Find closest customer to depot\n            depot_coords = coords[0]\n            customer_coords = coords[target_route[1:-1]]\n            distances_to_depot = np.linalg.norm(customer_coords - depot_coords, axis=1)\n            closest_customer_idx = np.argmin(distances_to_depot)\n\n            # Split route at this customer\n            split_pos = closest_customer_idx + 1  # +1 because route starts with 0\n\n            if split_pos > 1 and split_pos < len(target_route)-2:\n                route1 = np.concatenate((target_route[:split_pos+1], [0]))\n                route2 = np.concatenate(([0], target_route[split_pos+1:]))\n\n                # Check capacity constraints\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution.pop(target_idx)\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 4: Final optimization with demand-aware sorting\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 4:\n            # Sort customers by demand (highest first) to balance capacity usage\n            customer_indices = longest_route[1:-1]\n            customer_demands = demand[customer_indices]\n            sorted_indices = np.argsort(-customer_demands)\n            sorted_route = customer_indices[sorted_indices]\n\n            # Check if the sorted route is feasible\n            current_demand = 0\n            is_feasible = True\n            for i in sorted_indices:\n                if current_demand + demand[i] > capacity:\n                    is_feasible = False\n                    break\n                current_demand += demand[i]\n\n            if is_feasible:\n                new_solution[longest_route_idx] = np.concatenate(([0], sorted_route, [0]))\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm employs a multi-phase hybrid approach that first selects high-crowding solutions from the archive, then alternates between angle-based route reshuffling for makespan optimization and demand-aware customer redistribution for distance optimization, while ensuring feasibility through capacity checks and route splitting. It prioritizes spatial clustering and demand balancing, dynamically balancing objectives through probabilistic phase activation, and maintains solution quality by cleaning up empty routes and final angle-based optimization. The algorithm's critical design ideas are the integration of angle-based sorting with demand awareness, spatial proximity-based route selection, and capacity-sensitive route splitting, all while avoiding standard 2-opt by using novel hybrid transformations.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Angle-based makespan optimization with demand awareness\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[route[1:-1]]\n            customer_demands = demand[route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            # Sort by angle then by demand to balance makespan and capacity\n            sorted_indices = np.lexsort((customer_demands, angles))\n            sorted_route = route[1:-1][sorted_indices]\n            # Split into multiple routes if capacity constraint is violated\n            current_demand = 0\n            split_routes = []\n            current_route = [0]\n            for i in sorted_indices:\n                if current_demand + demand[route[1:-1][i]] <= capacity:\n                    current_route.append(route[1:-1][i])\n                    current_demand += demand[route[1:-1][i]]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, route[1:-1][i]]\n                    current_demand = demand[route[1:-1][i]]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n            # Replace original route with split routes\n            new_solution.pop(route_idx)\n            for r in split_routes:\n                if len(r) > 2:\n                    new_solution.append(r)\n\n    # Phase 2: Demand-aware distance optimization with spatial awareness\n    if len(new_solution) > 1 and random.random() < 0.7:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        # Find the closest route in terms of spatial proximity\n        closest_dist = float('inf')\n        closest_route_idx = -1\n        for i in range(len(new_solution)):\n            if i != route1_idx:\n                dist = np.linalg.norm(coords[new_solution[i][1]] - coords[route1[1]])\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_route_idx = i\n        if closest_route_idx != -1:\n            route2 = new_solution[closest_route_idx]\n            # Try to move customers between routes while balancing demands\n            route1_demand = np.sum(demand[route1[1:-1]])\n            route2_demand = np.sum(demand[route2[1:-1]])\n            for i in range(1, len(route1)-1):\n                if demand[route1[i]] <= capacity - route2_demand:\n                    # Find best insertion position in route2\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(route2)):\n                        dist_change = (distance_matrix[route2[pos-1]][route1[i]] + distance_matrix[route1[i]][route2[pos]] -\n                                     distance_matrix[route2[pos-1]][route2[pos]] +\n                                     distance_matrix[route1[i-1]][route1[i+1]] -\n                                     distance_matrix[route1[i-1]][route1[i]] -\n                                     distance_matrix[route1[i]][route1[i+1]])\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n                    if best_pos != -1:\n                        # Perform the move\n                        route2 = np.insert(route2, best_pos, route1[i])\n                        route1 = np.delete(route1, i)\n                        new_solution[route1_idx] = route1\n                        new_solution[closest_route_idx] = route2\n                        break\n\n    # Phase 3: Capacity-sensitive route splitting\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Find longest route by number of customers\n        route_lengths = [len(route) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 5:\n            # Split route into two balanced parts\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n            for i in range(1, len(longest_route)-1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n            if split_pos > 1 and split_pos < len(longest_route)-2:\n                route1 = np.concatenate((longest_route[:split_pos+1], [0]))\n                route2 = np.concatenate(([0], longest_route[split_pos+1:]))\n                new_solution.pop(longest_route_idx)\n                new_solution.append(route1)\n                new_solution.append(route2)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 4: Final optimization with angle-based sorting\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            sorted_indices = np.argsort(angles)\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 303,
        "algorithm": "The algorithm employs a multi-phase hybrid approach that selectively applies demand-weighted spatial clustering, angle-based route balancing, and capacity-aware merging to improve both total distance and makespan, prioritizing solutions with high crowding in the archive while ensuring feasibility through capacity checks. It alternates between spatial grouping and angular sorting phases with adaptive activation probabilities, balancing demand and distance considerations in route optimization. Key variables like demand weights and angle similarities guide the transformations while maintaining vehicle capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-weighted spatial clustering for distance optimization\n    if len(new_solution) > 1 and random.random() < 0.7:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[route[1:-1]]\n            customer_demands = demand[route[1:-1]]\n            # Calculate weighted distances to depot\n            weights = customer_demands / np.sum(customer_demands)\n            weighted_distances = np.linalg.norm(customer_coords - depot_coords, axis=1)\n            weighted_distances = weighted_distances * weights\n            # Sort by weighted distance to form clusters\n            sorted_indices = np.argsort(weighted_distances)\n            sorted_route = route[1:-1][sorted_indices]\n            # Split into multiple routes with demand balancing\n            current_demand = 0\n            split_routes = []\n            current_route = [0]\n            for i in sorted_indices:\n                if current_demand + demand[route[1:-1][i]] <= capacity * 0.9:\n                    current_route.append(route[1:-1][i])\n                    current_demand += demand[route[1:-1][i]]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, route[1:-1][i]]\n                    current_demand = demand[route[1:-1][i]]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n            # Replace original route with split routes\n            new_solution.pop(route_idx)\n            for r in split_routes:\n                if len(r) > 2:\n                    new_solution.append(r)\n\n    # Phase 2: Angle-based route balancing with demand-aware merging\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        # Find the route with most similar angle distribution\n        depot_coords = coords[0]\n        route1_angles = np.arctan2(coords[route1[1:-1],1] - depot_coords[1], coords[route1[1:-1],0] - depot_coords[0])\n        angle_similarity = -1\n        most_similar_idx = -1\n        for i in range(len(new_solution)):\n            if i != route1_idx and len(new_solution[i]) > 2:\n                route2_angles = np.arctan2(coords[new_solution[i][1:-1],1] - depot_coords[1], coords[new_solution[i][1:-1],0] - depot_coords[0])\n                # Calculate angle similarity using circular correlation\n                angle_diff = np.abs(np.subtract.outer(route1_angles, route2_angles))\n                min_angle_diff = np.minimum(angle_diff, 2*np.pi - angle_diff)\n                similarity = -np.sum(min_angle_diff)\n                if similarity > angle_similarity:\n                    angle_similarity = similarity\n                    most_similar_idx = i\n        if most_similar_idx != -1:\n            route2 = new_solution[most_similar_idx]\n            # Try to merge routes if capacity allows\n            combined_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by angle order\n                all_customers = np.concatenate((route1[1:-1], route2[1:-1]))\n                all_angles = np.arctan2(coords[all_customers,1] - depot_coords[1], coords[all_customers,0] - depot_coords[0])\n                sorted_indices = np.argsort(all_angles)\n                sorted_customers = all_customers[sorted_indices]\n                # Create new merged route\n                merged_route = np.concatenate(([0], sorted_customers, [0]))\n                new_solution.pop(max(route1_idx, most_similar_idx))\n                new_solution.pop(min(route1_idx, most_similar_idx))\n                new_solution.append(merged_route)\n\n    # Phase 3: Capacity-aware route merging with distance improvement\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Find two routes with compatible demands\n        route_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                demand_i = np.sum(demand[new_solution[i][1:-1]])\n                demand_j = np.sum(demand[new_solution[j][1:-1]])\n                if demand_i + demand_j <= capacity:\n                    route_pairs.append((i, j))\n        if route_pairs:\n            pair_idx = random.choice(route_pairs)\n            route1 = new_solution[pair_idx[0]]\n            route2 = new_solution[pair_idx[1]]\n            # Calculate potential distance improvement\n            original_dist = (np.sum(distance_matrix[route1[:-1], route1[1:]]) +\n                            np.sum(distance_matrix[route2[:-1], route2[1:]]))\n            # Try different merge points\n            best_merge = None\n            best_dist = float('inf')\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    # Create merged route\n                    merged = np.concatenate((route1[:i], route2[j:], [0]))\n                    # Check if route is valid\n                    if np.sum(demand[merged[1:-1]]) <= capacity:\n                        current_dist = np.sum(distance_matrix[merged[:-1], merged[1:]])\n                        if current_dist < best_dist:\n                            best_dist = current_dist\n                            best_merge = merged\n            if best_merge is not None and best_dist < original_dist:\n                new_solution.pop(max(pair_idx[0], pair_idx[1]))\n                new_solution.pop(min(pair_idx[0], pair_idx[1]))\n                new_solution.append(best_merge)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 4: Final optimization with demand-weighted angle sorting\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            customer_demands = demand[longest_route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            # Weight angles by demand to balance both objectives\n            angle_weights = customer_demands / np.sum(customer_demands)\n            weighted_angles = angles * angle_weights\n            sorted_indices = np.argsort(weighted_angles)\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.620422959109262,
            3.208883434534073
        ],
        "raw_score": [
            51.99192527088234,
            6.310220072771951
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-weighted spatial clustering for distance optimization\n    if len(new_solution) > 1 and random.random() < 0.7:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[route[1:-1]]\n            customer_demands = demand[route[1:-1]]\n            # Calculate weighted distances to depot\n            weights = customer_demands / np.sum(customer_demands)\n            weighted_distances = np.linalg.norm(customer_coords - depot_coords, axis=1)\n            weighted_distances = weighted_distances * weights\n            # Sort by weighted distance to form clusters\n            sorted_indices = np.argsort(weighted_distances)\n            sorted_route = route[1:-1][sorted_indices]\n            # Split into multiple routes with demand balancing\n            current_demand = 0\n            split_routes = []\n            current_route = [0]\n            for i in sorted_indices:\n                if current_demand + demand[route[1:-1][i]] <= capacity * 0.9:\n                    current_route.append(route[1:-1][i])\n                    current_demand += demand[route[1:-1][i]]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, route[1:-1][i]]\n                    current_demand = demand[route[1:-1][i]]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n            # Replace original route with split routes\n            new_solution.pop(route_idx)\n            for r in split_routes:\n                if len(r) > 2:\n                    new_solution.append(r)\n\n    # Phase 2: Angle-based route balancing with demand-aware merging\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        # Find the route with most similar angle distribution\n        depot_coords = coords[0]\n        route1_angles = np.arctan2(coords[route1[1:-1],1] - depot_coords[1], coords[route1[1:-1],0] - depot_coords[0])\n        angle_similarity = -1\n        most_similar_idx = -1\n        for i in range(len(new_solution)):\n            if i != route1_idx and len(new_solution[i]) > 2:\n                route2_angles = np.arctan2(coords[new_solution[i][1:-1],1] - depot_coords[1], coords[new_solution[i][1:-1],0] - depot_coords[0])\n                # Calculate angle similarity using circular correlation\n                angle_diff = np.abs(np.subtract.outer(route1_angles, route2_angles))\n                min_angle_diff = np.minimum(angle_diff, 2*np.pi - angle_diff)\n                similarity = -np.sum(min_angle_diff)\n                if similarity > angle_similarity:\n                    angle_similarity = similarity\n                    most_similar_idx = i\n        if most_similar_idx != -1:\n            route2 = new_solution[most_similar_idx]\n            # Try to merge routes if capacity allows\n            combined_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by angle order\n                all_customers = np.concatenate((route1[1:-1], route2[1:-1]))\n                all_angles = np.arctan2(coords[all_customers,1] - depot_coords[1], coords[all_customers,0] - depot_coords[0])\n                sorted_indices = np.argsort(all_angles)\n                sorted_customers = all_customers[sorted_indices]\n                # Create new merged route\n                merged_route = np.concatenate(([0], sorted_customers, [0]))\n                new_solution.pop(max(route1_idx, most_similar_idx))\n                new_solution.pop(min(route1_idx, most_similar_idx))\n                new_solution.append(merged_route)\n\n    # Phase 3: Capacity-aware route merging with distance improvement\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Find two routes with compatible demands\n        route_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                demand_i = np.sum(demand[new_solution[i][1:-1]])\n                demand_j = np.sum(demand[new_solution[j][1:-1]])\n                if demand_i + demand_j <= capacity:\n                    route_pairs.append((i, j))\n        if route_pairs:\n            pair_idx = random.choice(route_pairs)\n            route1 = new_solution[pair_idx[0]]\n            route2 = new_solution[pair_idx[1]]\n            # Calculate potential distance improvement\n            original_dist = (np.sum(distance_matrix[route1[:-1], route1[1:]]) +\n                            np.sum(distance_matrix[route2[:-1], route2[1:]]))\n            # Try different merge points\n            best_merge = None\n            best_dist = float('inf')\n            for i in range(1, len(route1)):\n                for j in range(1, len(route2)):\n                    # Create merged route\n                    merged = np.concatenate((route1[:i], route2[j:], [0]))\n                    # Check if route is valid\n                    if np.sum(demand[merged[1:-1]]) <= capacity:\n                        current_dist = np.sum(distance_matrix[merged[:-1], merged[1:]])\n                        if current_dist < best_dist:\n                            best_dist = current_dist\n                            best_merge = merged\n            if best_merge is not None and best_dist < original_dist:\n                new_solution.pop(max(pair_idx[0], pair_idx[1]))\n                new_solution.pop(min(pair_idx[0], pair_idx[1]))\n                new_solution.append(best_merge)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 4: Final optimization with demand-weighted angle sorting\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            customer_demands = demand[longest_route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            # Weight angles by demand to balance both objectives\n            angle_weights = customer_demands / np.sum(customer_demands)\n            weighted_angles = angles * angle_weights\n            sorted_indices = np.argsort(weighted_angles)\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n            I have 7 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm employs a multi-phase hybrid approach that first selects high-crowding solutions from the archive, then alternates between angle-based route reshuffling for makespan optimization and demand-aware customer redistribution for distance optimization, while ensuring feasibility through capacity checks and route splitting. It prioritizes spatial clustering and demand balancing, dynamically balancing objectives through probabilistic phase activation, and maintains solution quality by cleaning up empty routes and final angle-based optimization. The algorithm's critical design ideas are the integration of angle-based sorting with demand awareness, spatial proximity-based route selection, and capacity-sensitive route splitting, all while avoiding standard 2-opt by using novel hybrid transformations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Angle-based makespan optimization with demand awareness\n    if len(new_solution) > 1 and random.random() < 0.6:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[route[1:-1]]\n            customer_demands = demand[route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            # Sort by angle then by demand to balance makespan and capacity\n            sorted_indices = np.lexsort((customer_demands, angles))\n            sorted_route = route[1:-1][sorted_indices]\n            # Split into multiple routes if capacity constraint is violated\n            current_demand = 0\n            split_routes = []\n            current_route = [0]\n            for i in sorted_indices:\n                if current_demand + demand[route[1:-1][i]] <= capacity:\n                    current_route.append(route[1:-1][i])\n                    current_demand += demand[route[1:-1][i]]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, route[1:-1][i]]\n                    current_demand = demand[route[1:-1][i]]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n            # Replace original route with split routes\n            new_solution.pop(route_idx)\n            for r in split_routes:\n                if len(r) > 2:\n                    new_solution.append(r)\n\n    # Phase 2: Demand-aware distance optimization with spatial awareness\n    if len(new_solution) > 1 and random.random() < 0.7:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route1 = new_solution[route1_idx]\n        # Find the closest route in terms of spatial proximity\n        closest_dist = float('inf')\n        closest_route_idx = -1\n        for i in range(len(new_solution)):\n            if i != route1_idx:\n                dist = np.linalg.norm(coords[new_solution[i][1]] - coords[route1[1]])\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_route_idx = i\n        if closest_route_idx != -1:\n            route2 = new_solution[closest_route_idx]\n            # Try to move customers between routes while balancing demands\n            route1_demand = np.sum(demand[route1[1:-1]])\n            route2_demand = np.sum(demand[route2[1:-1]])\n            for i in range(1, len(route1)-1):\n                if demand[route1[i]] <= capacity - route2_demand:\n                    # Find best insertion position in route2\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(route2)):\n                        dist_change = (distance_matrix[route2[pos-1]][route1[i]] + distance_matrix[route1[i]][route2[pos]] -\n                                     distance_matrix[route2[pos-1]][route2[pos]] +\n                                     distance_matrix[route1[i-1]][route1[i+1]] -\n                                     distance_matrix[route1[i-1]][route1[i]] -\n                                     distance_matrix[route1[i]][route1[i+1]])\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n                    if best_pos != -1:\n                        # Perform the move\n                        route2 = np.insert(route2, best_pos, route1[i])\n                        route1 = np.delete(route1, i)\n                        new_solution[route1_idx] = route1\n                        new_solution[closest_route_idx] = route2\n                        break\n\n    # Phase 3: Capacity-sensitive route splitting\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Find longest route by number of customers\n        route_lengths = [len(route) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 5:\n            # Split route into two balanced parts\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n            for i in range(1, len(longest_route)-1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n            if split_pos > 1 and split_pos < len(longest_route)-2:\n                route1 = np.concatenate((longest_route[:split_pos+1], [0]))\n                route2 = np.concatenate(([0], longest_route[split_pos+1:]))\n                new_solution.pop(longest_route_idx)\n                new_solution.append(route1)\n                new_solution.append(route2)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Phase 4: Final optimization with angle-based sorting\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            sorted_indices = np.argsort(angles)\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a diverse solution from the archive based on normalized objective values and diversity metrics, then applies a hybrid local search combining route merging with demand-balanced customer reallocation while ensuring feasibility through capacity checks, followed by 2-opt optimization. It prioritizes solutions with high diversity in objective values and focuses on merging feasible routes or balancing demands between routes before performing standard 2-opt improvements. The selection process emphasizes exploration of less-explored regions of the Pareto front, while the local search intelligently combines high-level transformations with fine-grained optimization.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 2:\n        # Calculate normalized objective values\n        distances = [sol[1][0] for sol in archive]\n        makespans = [sol[1][1] for sol in archive]\n        norm_dist = [(d - min(distances)) / (max(distances) - min(distances)) for d in distances]\n        norm_makespan = [(m - min(makespans)) / (max(makespans) - min(makespans)) for m in makespans]\n\n        # Calculate diversity score (distance from average)\n        diversity_scores = []\n        avg_dist = sum(norm_dist) / len(norm_dist)\n        avg_makespan = sum(norm_makespan) / len(norm_makespan)\n        for i in range(len(archive)):\n            diversity = abs(norm_dist[i] - avg_dist) + abs(norm_makespan[i] - avg_makespan)\n            diversity_scores.append(diversity)\n\n        # Select solution with highest diversity score\n        selected_idx = max(range(len(archive)), key=lambda i: diversity_scores[i])\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator: Route merging with demand balancing\n    if len(new_solution) > 1:\n        # Select two routes for potential merging\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        while route2_idx == route1_idx and len(new_solution) > 1:\n            route2_idx = random.randint(0, len(new_solution) - 1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Calculate route demands\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        # Check if merging is feasible\n        if demand1 + demand2 <= capacity:\n            # Merge routes\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution.remove(route1)\n            new_solution.remove(route2)\n            new_solution.append(merged_route)\n        else:\n            # Perform demand-balanced customer reallocation\n            # Find customers that can be moved between routes\n            candidates1 = route1[1:-1]\n            candidates2 = route2[1:-1]\n\n            for cust1 in candidates1:\n                for cust2 in candidates2:\n                    # Check if swapping these customers would balance demands\n                    new_demand1 = demand1 - demand[cust1] + demand[cust2]\n                    new_demand2 = demand2 - demand[cust2] + demand[cust1]\n\n                    if new_demand1 <= capacity and new_demand2 <= capacity:\n                        # Perform the swap\n                        route1 = np.delete(route1, np.where(route1 == cust1))\n                        route1 = np.insert(route1, -1, cust2)\n                        route2 = np.delete(route2, np.where(route2 == cust2))\n                        route2 = np.insert(route2, -1, cust1)\n\n                        # Update solution\n                        new_solution[route1_idx] = route1\n                        new_solution[route2_idx] = route2\n                        break\n                else:\n                    continue\n                break\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Apply 2-opt local search for further improvement\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only optimize routes with sufficient customers\n            improved = True\n            while improved:\n                improved = False\n                for j in range(1, len(route)-2):\n                    for k in range(j+1, len(route)-1):\n                        # Calculate current and new distances\n                        a, b, c, d = route[j-1], route[j], route[k], route[k+1]\n                        current_dist = distance_matrix[a][b] + distance_matrix[c][d]\n                        new_dist = distance_matrix[a][c] + distance_matrix[b][d]\n\n                        if new_dist < current_dist:\n                            # Reverse the segment between j and k\n                            route[j:k+1] = route[j:k+1][::-1]\n                            improved = True\n                            break\n                    if improved:\n                        break\n                new_solution[i] = route\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive based on crowding distance (prioritizing solutions in less explored regions of the Pareto front), then applies one of two hybrid local search operators: angle-based spatial clustering (grouping customers by angular position relative to the depot to reduce makespan) or demand-aware swaps (balancing route loads between pairs of routes to minimize total distance). It alternates between these operators randomly, ensuring feasibility through capacity checks and dynamic route reconstruction. The solution is cleaned to remove empty routes before returning.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(0)\n        else:\n            dist = (archive[i+1][1][0] - archive[i-1][1][0]) + (archive[i+1][1][1] - archive[i-1][1][1])\n            crowding_distances.append(dist)\n    selected_idx = max(range(len(archive)), key=lambda i: crowding_distances[i])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Dynamic operator alternation\n    operator = random.choice(['angle_cluster', 'demand_swap'])\n\n    if operator == 'angle_cluster':\n        # Angle-based spatial clustering\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n\n        if len(all_customers) > 0:\n            # Cluster customers based on angle with depot\n            depot_coords = coords[0]\n            angles = []\n            for customer in all_customers:\n                vec = coords[customer] - depot_coords\n                angle = np.arctan2(vec[1], vec[0])\n                angles.append((customer, angle))\n\n            # Sort by angle and split into clusters\n            angles.sort(key=lambda x: x[1])\n            cluster_size = max(2, len(angles) // (len(new_solution) + 1))\n            clusters = [angles[i:i+cluster_size] for i in range(0, len(angles), cluster_size)]\n\n            # Create new routes from clusters\n            new_routes = []\n            for cluster in clusters:\n                route = [0]\n                current_demand = 0\n                for customer, _ in cluster:\n                    if current_demand + demand[customer] <= capacity:\n                        route.append(customer)\n                        current_demand += demand[customer]\n                route.append(0)\n                if len(route) > 2:\n                    new_routes.append(np.array(route))\n\n            if len(new_routes) > 0:\n                new_solution = new_routes\n\n    elif operator == 'demand_swap':\n        # Demand-aware swaps between routes\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route2_idx = random.randint(0, len(new_solution) - 1)\n            while route2_idx == route1_idx and len(new_solution) > 1:\n                route2_idx = random.randint(0, len(new_solution) - 1)\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Find best swap pair\n                best_swap = None\n                best_balance = float('inf')\n\n                for i in range(1, len(route1) - 1):\n                    for j in range(1, len(route2) - 1):\n                        # Check capacity constraints\n                        new_demand1 = np.sum(demand[route1[1:-1]]) - demand[route1[i]] + demand[route2[j]]\n                        new_demand2 = np.sum(demand[route2[1:-1]]) - demand[route2[j]] + demand[route1[i]]\n\n                        if new_demand1 <= capacity and new_demand2 <= capacity:\n                            # Calculate balance improvement\n                            current_balance = abs(np.sum(demand[route1[1:-1]]) - np.sum(demand[route2[1:-1]]))\n                            new_balance = abs(new_demand1 - new_demand2)\n\n                            if new_balance < current_balance and new_balance < best_balance:\n                                best_balance = new_balance\n                                best_swap = (i, j)\n\n                if best_swap:\n                    i, j = best_swap\n                    # Perform the swap\n                    route1[i], route2[j] = route2[j], route1[i]\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing lower makespan 70% and total distance 30%) and applies a hybrid local search combining route merging (when feasible), demand-balanced customer insertions (to balance route loads), and adaptive route reversal (to reduce the longest route length). It ensures feasibility by checking vehicle capacity constraints at each step and intelligently falls back to alternative improvements when standard moves fail.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.3, 0.7)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to merge with the most compatible route\n            min_increase = float('inf')\n            best_merge = None\n\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[other_route[1:-1]])\n\n                    if combined_demand <= capacity:\n                        # Calculate potential distance increase\n                        dist_increase = (distance_matrix[route[-2]][other_route[1]] +\n                                        distance_matrix[other_route[-2]][route[1]] -\n                                        distance_matrix[route[-2]][0] -\n                                        distance_matrix[other_route[-2]][0])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_merge = other_route_idx\n\n            if best_merge is not None:\n                other_route = new_solution[best_merge]\n                merged_route = np.concatenate((route[1:-1], other_route[1:-1], [0]))\n                new_solution[route_idx] = merged_route\n                del new_solution[best_merge]\n            else:\n                # Step 2: Try demand-balanced insertion\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route = None\n                best_balance = float('inf')\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        new_demand = np.sum(demand[other_route[1:-1]]) + demand[customer]\n\n                        if new_demand <= capacity:\n                            current_balance = abs(np.sum(demand[route[1:-1]]) - demand[customer] -\n                                                np.sum(demand[other_route[1:-1]]) - demand[customer])\n\n                            if current_balance < best_balance:\n                                best_balance = current_balance\n                                best_route = other_route_idx\n\n                if best_route is not None:\n                    other_route = new_solution[best_route]\n                    other_route = np.insert(other_route, -1, customer)\n                    route = np.delete(route, customer_pos)\n\n                    new_solution[route_idx] = route\n                    new_solution[best_route] = other_route\n                else:\n                    # Step 3: Try adaptive route reversal\n                    if len(route) > 5:\n                        reverse_pos = random.randint(2, len(route) - 3)\n                        reversed_segment = route[reverse_pos:-1][::-1]\n\n                        if np.sum(demand[reversed_segment]) <= capacity:\n                            new_route = np.concatenate((route[:reverse_pos], reversed_segment, [0]))\n                            new_solution[route_idx] = new_route\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions from the archive with a weighted preference for lower total distance (50%) over makespan (50%), then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-adaptive swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations when standard improvements fail, always enforcing capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.5, 0.5)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to split the route into two\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 2: If splitting fails, try to relocate a customer to another route\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_pos)\n\n                            new_solution[route_idx] = route\n                            new_solution[other_route_idx] = other_route\n                            break\n                else:\n                    # Step 3: If relocation fails, try a capacity-adaptive swap\n                    for i in range(1, len(route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[route[1:-1]]) + demand[route[i]]):\n                                        old_dist = (distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][other_route[j]] + distance_matrix[other_route[j]][other_route[j+1]])\n                                        new_dist = (distance_matrix[route[i-1]][other_route[j]] + distance_matrix[other_route[j]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][route[i]] + distance_matrix[route[i]][other_route[j+1]])\n\n                                        if new_dist < old_dist:\n                                            route[i], other_route[j] = other_route[j], route[i]\n                                            new_solution[route_idx] = route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm prioritizes solutions with lower makespan (70% weight) over total distance (30% weight) and applies a hybrid local search combining route merging, intelligent customer insertion, and distance-aware swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations (merge, insert, swap) when standard improvements fail, and always checks capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.3, 0.7)  # Prefer solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge or modify\n        route_idx1, route_idx2 = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_idx1], new_solution[route_idx2]\n\n        # Step 2: Try to merge the two routes (if feasible)\n        merged_route = np.concatenate((route1[:-1], route2[1:]))\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution[route_idx1] = merged_route\n            new_solution.pop(route_idx2)\n        else:\n            # Step 3: If merging fails, try to insert a customer from one route to the other\n            if len(route1) > 3 and len(route2) > 2:\n                customer_pos = random.randint(1, len(route1) - 2)\n                customer = route1[customer_pos]\n\n                if np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                    route2 = np.insert(route2, -1, customer)\n                    route1 = np.delete(route1, customer_pos)\n\n                    new_solution[route_idx1] = route1\n                    new_solution[route_idx2] = route2\n                else:\n                    # Step 4: If insertion fails, try a distance-aware swap between two routes\n                    for i in range(1, len(route1) - 1):\n                        for j in range(1, len(route2) - 1):\n                            if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                                demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                                # Calculate distance change\n                                old_dist = (distance_matrix[route1[i-1]][route1[i]] + distance_matrix[route1[i]][route1[i+1]] +\n                                           distance_matrix[route2[j-1]][route2[j]] + distance_matrix[route2[j]][route2[j+1]])\n                                new_dist = (distance_matrix[route1[i-1]][route2[j]] + distance_matrix[route2[j]][route1[i+1]] +\n                                           distance_matrix[route2[j-1]][route1[i]] + distance_matrix[route1[i]][route2[j+1]])\n\n                                if new_dist < old_dist:\n                                    route1[i], route2[j] = route2[j], route1[i]\n                                    new_solution[route_idx1] = route1\n                                    new_solution[route_idx2] = route2\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: Adaptive angle-demand hybrids, crowding-distance prioritization, geometric demand clustering, capacity-aware merges\n- **Advice**: Alternate between angle-based route reshaping (for makespan) and demand-weighted customer merges (for distance), always check feasibility\n- **Avoid**: Static operator sequences, brute-force swaps, ignoring spatial constraints\n- **Explanation**: Dynamic operator alternation balances objectives while geometric clustering and demand-aware merges ensure feasible, high-quality neighbors\n\n```python\nimport numpy as np\nimport random\n\ndef select_neighbor(archive, demands, vehicle_capacity):\n    # Select high-crowding solution\n    selected_idx = np.argmax([sol[1][2] for sol in archive])\n    selected_sol = archive[selected_idx][0]\n\n    # Hybrid operator: Alternate between angle-based reshuffling and demand-aware merges\n    if random.random() < 0.5:\n        new_sol = angle_based_reshuffle(selected_sol, demands, vehicle_capacity)\n    else:\n        new_sol = demand_aware_merge(selected_sol, demands, vehicle_capacity)\n\n    return new_sol\n\ndef angle_based_reshuffle(routes, demands, vehicle_capacity):\n    # Cluster customers by angle to reduce makespan\n    clustered_routes = []\n    for route in routes:\n        if len(route) > 2:\n            # Sort by angle (simplified)\n            clustered_routes.append(np.sort(route[1:-1]))\n    return clustered_routes\n\ndef demand_aware_merge(routes, demands, vehicle_capacity):\n    # Merge routes if demand allows\n    for i in range(len(routes)):\n        for j in range(i+1, len(routes)):\n            if sum(demands[routes[i]]) + sum(demands[routes[j]]) <= vehicle_capacity:\n                # Merge routes (simplified)\n                pass\n    return routes\n```\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 304,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Adaptive angle-demand hybrid operator\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Angle-based spatial clustering for makespan optimization\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[route[1:-1]]\n            customer_demands = demand[route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            # Sort by angle then by demand ratio (demand/distance)\n            distances = np.linalg.norm(customer_coords - depot_coords, axis=1)\n            demand_ratios = customer_demands / (distances + 1e-8)\n            sorted_indices = np.lexsort((demand_ratios, angles))\n            sorted_route = route[1:-1][sorted_indices]\n\n            # Split into multiple routes if capacity constraint is violated\n            current_demand = 0\n            split_routes = []\n            current_route = [0]\n            for i in sorted_indices:\n                if current_demand + demand[route[1:-1][i]] <= capacity:\n                    current_route.append(route[1:-1][i])\n                    current_demand += demand[route[1:-1][i]]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, route[1:-1][i]]\n                    current_demand = demand[route[1:-1][i]]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n\n            # Replace original route with split routes\n            new_solution.pop(route_idx)\n            for r in split_routes:\n                if len(r) > 2:\n                    new_solution.append(r)\n\n    # Step 3: Geometric demand clustering for distance optimization\n    if len(new_solution) > 1 and random.random() < 0.6:\n        # Find the most spatially clustered route\n        max_cluster_score = -1\n        best_route_idx = -1\n        for i, route in enumerate(new_solution):\n            if len(route) > 4:\n                customer_coords = coords[route[1:-1]]\n                # Calculate centroid\n                centroid = np.mean(customer_coords, axis=0)\n                # Calculate average distance to centroid\n                avg_dist = np.mean(np.linalg.norm(customer_coords - centroid, axis=1))\n                cluster_score = len(route) / (avg_dist + 1e-8)\n                if cluster_score > max_cluster_score:\n                    max_cluster_score = cluster_score\n                    best_route_idx = i\n\n        if best_route_idx != -1:\n            route = new_solution[best_route_idx]\n            # Try to merge with closest compatible route\n            closest_dist = float('inf')\n            closest_route_idx = -1\n            for i in range(len(new_solution)):\n                if i != best_route_idx:\n                    dist = np.linalg.norm(coords[new_solution[i][1]] - coords[route[1]])\n                    if dist < closest_dist:\n                        closest_dist = dist\n                        closest_route_idx = i\n\n            if closest_route_idx != -1:\n                other_route = new_solution[closest_route_idx]\n                if np.sum(demand[route[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate((route[:-1], other_route[1:]))\n                    new_solution.pop(best_route_idx)\n                    if closest_route_idx > best_route_idx:\n                        new_solution.pop(closest_route_idx - 1)\n                    else:\n                        new_solution.pop(closest_route_idx)\n                    new_solution.append(merged_route)\n                else:\n                    # Perform demand-aware customer transfer\n                    route_demand = np.sum(demand[route[1:-1]])\n                    other_route_demand = np.sum(demand[other_route[1:-1]])\n                    for i in range(1, len(route)-1):\n                        if demand[route[i]] <= capacity - other_route_demand:\n                            # Find best insertion position in other route\n                            best_pos = -1\n                            best_dist_change = 0\n                            for pos in range(1, len(other_route)):\n                                dist_change = (distance_matrix[other_route[pos-1]][route[i]] + distance_matrix[route[i]][other_route[pos]] -\n                                             distance_matrix[other_route[pos-1]][other_route[pos]] +\n                                             distance_matrix[route[i-1]][route[i+1]] -\n                                             distance_matrix[route[i-1]][route[i]] -\n                                             distance_matrix[route[i]][route[i+1]])\n                                if dist_change < best_dist_change:\n                                    best_dist_change = dist_change\n                                    best_pos = pos\n                            if best_pos != -1:\n                                # Perform the transfer\n                                other_route = np.insert(other_route, best_pos, route[i])\n                                route = np.delete(route, i)\n                                new_solution[best_route_idx] = route\n                                new_solution[closest_route_idx] = other_route\n                                break\n\n    # Step 4: Capacity-aware route splitting\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Find longest route by number of customers\n        route_lengths = [len(route) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 5:\n            # Split route into two balanced parts\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n            for i in range(1, len(longest_route)-1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n            if split_pos > 1 and split_pos < len(longest_route)-2:\n                route1 = np.concatenate((longest_route[:split_pos+1], [0]))\n                route2 = np.concatenate(([0], longest_route[split_pos+1:]))\n                new_solution.pop(longest_route_idx)\n                new_solution.append(route1)\n                new_solution.append(route2)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Final optimization with angle-based sorting for makespan reduction\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            sorted_indices = np.argsort(angles)\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n",
        "metric_score": [
            -0.44911696621343306,
            4.373559951782227
        ],
        "raw_score": [
            40.22758064181929,
            3.90422316746233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Adaptive angle-demand hybrid operator\n    if len(new_solution) > 1 and random.random() < 0.7:\n        # Angle-based spatial clustering for makespan optimization\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[route[1:-1]]\n            customer_demands = demand[route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            # Sort by angle then by demand ratio (demand/distance)\n            distances = np.linalg.norm(customer_coords - depot_coords, axis=1)\n            demand_ratios = customer_demands / (distances + 1e-8)\n            sorted_indices = np.lexsort((demand_ratios, angles))\n            sorted_route = route[1:-1][sorted_indices]\n\n            # Split into multiple routes if capacity constraint is violated\n            current_demand = 0\n            split_routes = []\n            current_route = [0]\n            for i in sorted_indices:\n                if current_demand + demand[route[1:-1][i]] <= capacity:\n                    current_route.append(route[1:-1][i])\n                    current_demand += demand[route[1:-1][i]]\n                else:\n                    current_route.append(0)\n                    split_routes.append(np.array(current_route))\n                    current_route = [0, route[1:-1][i]]\n                    current_demand = demand[route[1:-1][i]]\n            current_route.append(0)\n            split_routes.append(np.array(current_route))\n\n            # Replace original route with split routes\n            new_solution.pop(route_idx)\n            for r in split_routes:\n                if len(r) > 2:\n                    new_solution.append(r)\n\n    # Step 3: Geometric demand clustering for distance optimization\n    if len(new_solution) > 1 and random.random() < 0.6:\n        # Find the most spatially clustered route\n        max_cluster_score = -1\n        best_route_idx = -1\n        for i, route in enumerate(new_solution):\n            if len(route) > 4:\n                customer_coords = coords[route[1:-1]]\n                # Calculate centroid\n                centroid = np.mean(customer_coords, axis=0)\n                # Calculate average distance to centroid\n                avg_dist = np.mean(np.linalg.norm(customer_coords - centroid, axis=1))\n                cluster_score = len(route) / (avg_dist + 1e-8)\n                if cluster_score > max_cluster_score:\n                    max_cluster_score = cluster_score\n                    best_route_idx = i\n\n        if best_route_idx != -1:\n            route = new_solution[best_route_idx]\n            # Try to merge with closest compatible route\n            closest_dist = float('inf')\n            closest_route_idx = -1\n            for i in range(len(new_solution)):\n                if i != best_route_idx:\n                    dist = np.linalg.norm(coords[new_solution[i][1]] - coords[route[1]])\n                    if dist < closest_dist:\n                        closest_dist = dist\n                        closest_route_idx = i\n\n            if closest_route_idx != -1:\n                other_route = new_solution[closest_route_idx]\n                if np.sum(demand[route[1:-1]]) + np.sum(demand[other_route[1:-1]]) <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate((route[:-1], other_route[1:]))\n                    new_solution.pop(best_route_idx)\n                    if closest_route_idx > best_route_idx:\n                        new_solution.pop(closest_route_idx - 1)\n                    else:\n                        new_solution.pop(closest_route_idx)\n                    new_solution.append(merged_route)\n                else:\n                    # Perform demand-aware customer transfer\n                    route_demand = np.sum(demand[route[1:-1]])\n                    other_route_demand = np.sum(demand[other_route[1:-1]])\n                    for i in range(1, len(route)-1):\n                        if demand[route[i]] <= capacity - other_route_demand:\n                            # Find best insertion position in other route\n                            best_pos = -1\n                            best_dist_change = 0\n                            for pos in range(1, len(other_route)):\n                                dist_change = (distance_matrix[other_route[pos-1]][route[i]] + distance_matrix[route[i]][other_route[pos]] -\n                                             distance_matrix[other_route[pos-1]][other_route[pos]] +\n                                             distance_matrix[route[i-1]][route[i+1]] -\n                                             distance_matrix[route[i-1]][route[i]] -\n                                             distance_matrix[route[i]][route[i+1]])\n                                if dist_change < best_dist_change:\n                                    best_dist_change = dist_change\n                                    best_pos = pos\n                            if best_pos != -1:\n                                # Perform the transfer\n                                other_route = np.insert(other_route, best_pos, route[i])\n                                route = np.delete(route, i)\n                                new_solution[best_route_idx] = route\n                                new_solution[closest_route_idx] = other_route\n                                break\n\n    # Step 4: Capacity-aware route splitting\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Find longest route by number of customers\n        route_lengths = [len(route) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 5:\n            # Split route into two balanced parts\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand / 2\n            current_demand = 0\n            split_pos = 1\n            for i in range(1, len(longest_route)-1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n            if split_pos > 1 and split_pos < len(longest_route)-2:\n                route1 = np.concatenate((longest_route[:split_pos+1], [0]))\n                route2 = np.concatenate(([0], longest_route[split_pos+1:]))\n                new_solution.pop(longest_route_idx)\n                new_solution.append(route1)\n                new_solution.append(route2)\n\n    # Clean up empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Final optimization with angle-based sorting for makespan reduction\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Select route with largest makespan\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n            sorted_indices = np.argsort(angles)\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n        I have 6 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest makespan from the archive, then reconstructs routes by prioritizing high-demand customers (sorted in descending order) and reinserting them into new routes while respecting vehicle capacity constraints. This strategy aims to balance capacity utilization and reduce makespan by focusing on customers with larger demands first. The overall structure involves route fragmentation and a demand-weighted reinsertion heuristic.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    all_customers = []\n\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n\n    # Sort customers by demand in descending order to prioritize high-demand customers\n    all_customers.sort(key=lambda x: -demand[x])\n\n    current_route = [0]\n    current_load = 0\n\n    for customer in all_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with a weighted preference (70% distance, 30% makespan) and applies a hybrid local search that first tries to split the longest route, then performs demand-aware relocations, and finally attempts capacity-balancing swaps to improve both objectives while maintaining feasibility. It prioritizes reducing the longest routes and intelligently handles failed operations by exploring alternative transformations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Identify the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        # Step 1: Try to split the longest route into two\n        if len(longest_route) > 4:\n            for split_pos in range(2, len(longest_route) - 2):\n                first_part = longest_route[:split_pos + 1]\n                second_part = np.concatenate(([0], longest_route[split_pos:]))\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = first_part\n                    new_solution.insert(longest_route_idx + 1, second_part)\n                    break\n            else:\n                # Step 2: Try demand-aware relocation\n                for i in range(1, len(longest_route) - 1):\n                    for other_route_idx in range(len(new_solution)):\n                        if other_route_idx != longest_route_idx:\n                            other_route = new_solution[other_route_idx]\n                            for j in range(1, len(other_route)):\n                                if np.sum(demand[other_route[1:-1]]) + demand[longest_route[i]] <= capacity:\n                                    old_dist = (distance_matrix[longest_route[i-1]][longest_route[i]] +\n                                                distance_matrix[longest_route[i]][longest_route[i+1]] +\n                                                distance_matrix[other_route[j-1]][other_route[j]])\n                                    new_dist = (distance_matrix[longest_route[i-1]][longest_route[i+1]] +\n                                                distance_matrix[other_route[j-1]][longest_route[i]] +\n                                                distance_matrix[longest_route[i]][other_route[j]])\n\n                                    if new_dist < old_dist:\n                                        customer = longest_route[i]\n                                        other_route = np.insert(other_route, j, customer)\n                                        longest_route = np.delete(longest_route, i)\n                                        new_solution[longest_route_idx] = longest_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                            else:\n                                continue\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    # Step 3: Try capacity-balancing swap\n                    for i in range(1, len(longest_route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != longest_route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[longest_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[longest_route[1:-1]]) + demand[longest_route[i]]):\n                                        longest_load = np.sum(demand[longest_route[1:-1]])\n                                        other_load = np.sum(demand[other_route[1:-1]])\n\n                                        if (abs((longest_load - demand[longest_route[i]] + demand[other_route[j]]) -\n                                               (other_load - demand[other_route[j]] + demand[longest_route[i]])) <\n                                            abs(longest_load - other_load)):\n                                            longest_route[i], other_route[j] = other_route[j], longest_route[i]\n                                            new_solution[longest_route_idx] = longest_route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        objectives = np.array([sol[1] for sol in archive])\n        crowding_dist = np.zeros(len(archive))\n\n        for obj_idx in range(2):\n            sorted_idx = np.argsort(objectives[:, obj_idx])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Apply hybrid operator based on random selection\n    if len(new_solution) > 1:\n        if random.random() < 0.5:\n            # Angle-based reshuffling for makespan optimization\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n        else:\n            # Demand-aware swap for distance optimization\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            for i in range(1, len(route1)-1):\n                if demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]):\n                    best_pos = -1\n                    best_dist_change = 0\n\n                    for pos in range(1, len(route2)):\n                        dist_change = (distance_matrix[route2[pos-1]][route1[i]] + distance_matrix[route1[i]][route2[pos]] -\n                                     distance_matrix[route2[pos-1]][route2[pos]] +\n                                     distance_matrix[route1[i-1]][route1[i+1]] -\n                                     distance_matrix[route1[i-1]][route1[i]] -\n                                     distance_matrix[route1[i]][route1[i+1]])\n\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n\n                    if best_pos != -1:\n                        route2 = np.insert(route2, best_pos, route1[i])\n                        route1 = np.delete(route1, i)\n                        new_solution[route1_idx] = route1\n                        new_solution[route2_idx] = route2\n                        break\n\n        # Step 3: Fallback mechanism - aggressive route balancing\n        if random.random() < 0.3:\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 4:\n                total_demand = np.sum(demand[longest_route[1:-1]])\n                target_demand = total_demand * 0.6\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(longest_route)-1):\n                    current_demand += demand[longest_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                first_part = longest_route[:split_pos+1]\n                second_part = longest_route[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = first_part\n                    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Step 4: Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Step 5: Apply additional improvement - spatial clustering with demand consideration\n    if len(new_solution) > 1 and random.random() < 0.4:\n        # Find the route with most customers\n        route_lengths = [len(route) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 5:\n            # Cluster customers by both angle and demand\n            depot_coords = coords[0]\n            customer_coords = coords[longest_route[1:-1]]\n            customer_demands = demand[longest_route[1:-1]]\n\n            # Calculate angles\n            angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n\n            # Sort by angle first, then by demand\n            sorted_indices = np.lexsort((customer_demands, angles))\n            sorted_route = longest_route[1:-1][sorted_indices]\n            sorted_route = np.concatenate(([0], sorted_route, [0]))\n\n            if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = sorted_route\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using crowding distance to balance exploration and exploitation, then applies either angle-based spatial clustering (for makespan optimization) or demand-weighted geometric swaps (for distance optimization), while probabilistically splitting the longest route to further reduce makespan. It ensures feasibility by checking capacity constraints and only making valid moves.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sol[1] for sol in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        if random.random() < 0.5:\n            # Angle-based spatial clustering for makespan optimization\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n        else:\n            # Demand-weighted geometric swap for distance optimization\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            for i in range(1, len(route1)-1):\n                if demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]):\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(route2)):\n                        dist_change = (distance_matrix[route2[pos-1]][route1[i]] + distance_matrix[route1[i]][route2[pos]] -\n                                     distance_matrix[route2[pos-1]][route2[pos]] +\n                                     distance_matrix[route1[i-1]][route1[i+1]] -\n                                     distance_matrix[route1[i-1]][route1[i]] -\n                                     distance_matrix[route1[i]][route1[i+1]])\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n                    if best_pos != -1:\n                        route2 = np.insert(route2, best_pos, route1[i])\n                        route1 = np.delete(route1, i)\n                        new_solution[route1_idx] = route1\n                        new_solution[route2_idx] = route2\n                        break\n\n    # Probabilistic route splitting for makespan reduction\n    if random.random() < 0.3 and len(new_solution) > 1:\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: np.sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 4:\n            split_pos = len(longest_route) // 2\n            first_part = longest_route[:split_pos+1]\n            second_part = longest_route[split_pos:]\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = first_part\n                new_solution.insert(longest_route_idx + 1, second_part)\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the ultra-concise reflection (\u2264100 words):\n\n- **Keywords**: Adaptive angle-demand hybrids, crowding-distance prioritization, geometric demand clustering, capacity-aware merges\n- **Advice**: Alternate between angle-based route reshaping (for makespan) and demand-weighted customer merges (for distance), always check feasibility\n- **Avoid**: Static operator sequences, brute-force swaps, ignoring spatial constraints\n- **Explanation**: Dynamic operator alternation balances objectives while geometric clustering and demand-aware merges ensure feasible, high-quality neighbors\n\n**Final Code**:\n```python\nimport numpy as np\nimport random\n\ndef select_neighbor(archive, demands, vehicle_capacity):\n    # Select high-crowding solution\n    selected_idx = np.argmax([sol[1][2] for sol in archive])\n    selected_sol = archive[selected_idx][0]\n\n    # Hybrid operator: Alternate between angle-based reshuffling and demand-aware merges\n    if random.random() < 0.5:\n        new_sol = angle_based_reshuffle(selected_sol, demands, vehicle_capacity)\n    else:\n        new_sol = demand_aware_merge(selected_sol, demands, vehicle_capacity)\n\n    return new_sol\n\ndef angle_based_reshuffle(routes, demands, vehicle_capacity):\n    # Cluster customers by angle to reduce makespan\n    clustered_routes = []\n    for route in routes:\n        if len(route) > 2:\n            # Sort by angle (simplified)\n            clustered_routes.append(np.sort(route[1:-1]))\n    return clustered_routes\n\ndef demand_aware_merge(routes, demands, vehicle_capacity):\n    # Merge routes if demand allows\n    for i in range(len(routes)):\n        for j in range(i+1, len(routes)):\n            if sum(demands[routes[i]]) + sum(demands[routes[j]]) <= vehicle_capacity:\n                # Merge routes (simplified)\n                pass\n    return routes\n```\n\n*(Word count: ~50)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 305,
        "algorithm": "The algorithm selects a solution from the archive using crowding distance to balance exploration and exploitation, then applies a hybrid local search combining angle-based spatial clustering (prioritized for makespan optimization), demand-weighted geometric swaps (prioritized for distance optimization), and probabilistic route splitting (prioritized for further makespan reduction), ensuring feasibility through capacity checks and spatial constraints. The operator selection is weighted (angle: 0.4, demand: 0.4, split: 0.2), with angle-based clustering and splitting prioritizing makespan reduction, while demand-weighted swaps focus on distance optimization. The algorithm probabilistically splits the longest route to reduce makespan while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Hybrid operator selection\n        operator = random.choices(['angle', 'demand', 'split'], weights=[0.4, 0.4, 0.2])[0]\n\n        if operator == 'angle':\n            # Angle-based spatial clustering for makespan optimization\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n\n        elif operator == 'demand':\n            # Demand-weighted geometric swap for distance optimization\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            for i in range(1, len(route1)-1):\n                if demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]):\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(route2)):\n                        dist_change = (distance_matrix[route2[pos-1]][route1[i]] + distance_matrix[route1[i]][route2[pos]] -\n                                     distance_matrix[route2[pos-1]][route2[pos]] +\n                                     distance_matrix[route1[i-1]][route1[i+1]] -\n                                     distance_matrix[route1[i-1]][route1[i]] -\n                                     distance_matrix[route1[i]][route1[i+1]])\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n                    if best_pos != -1:\n                        route2 = np.insert(route2, best_pos, route1[i])\n                        route1 = np.delete(route1, i)\n                        new_solution[route1_idx] = route1\n                        new_solution[route2_idx] = route2\n                        break\n\n        elif operator == 'split':\n            # Probabilistic route splitting for makespan reduction\n            longest_route_idx = max(range(len(new_solution)), key=lambda i: np.sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n            longest_route = new_solution[longest_route_idx]\n            if len(longest_route) > 4:\n                split_pos = len(longest_route) // 2\n                first_part = longest_route[:split_pos+1]\n                second_part = longest_route[split_pos:]\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = first_part\n                    new_solution.insert(longest_route_idx + 1, second_part)\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7315802243725595,
            0.5349126160144806
        ],
        "raw_score": [
            36.07001340041753,
            4.580718075568704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Hybrid operator selection\n        operator = random.choices(['angle', 'demand', 'split'], weights=[0.4, 0.4, 0.2])[0]\n\n        if operator == 'angle':\n            # Angle-based spatial clustering for makespan optimization\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n\n        elif operator == 'demand':\n            # Demand-weighted geometric swap for distance optimization\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            for i in range(1, len(route1)-1):\n                if demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]):\n                    best_pos = -1\n                    best_dist_change = 0\n                    for pos in range(1, len(route2)):\n                        dist_change = (distance_matrix[route2[pos-1]][route1[i]] + distance_matrix[route1[i]][route2[pos]] -\n                                     distance_matrix[route2[pos-1]][route2[pos]] +\n                                     distance_matrix[route1[i-1]][route1[i+1]] -\n                                     distance_matrix[route1[i-1]][route1[i]] -\n                                     distance_matrix[route1[i]][route1[i+1]])\n                        if dist_change < best_dist_change:\n                            best_dist_change = dist_change\n                            best_pos = pos\n                    if best_pos != -1:\n                        route2 = np.insert(route2, best_pos, route1[i])\n                        route1 = np.delete(route1, i)\n                        new_solution[route1_idx] = route1\n                        new_solution[route2_idx] = route2\n                        break\n\n        elif operator == 'split':\n            # Probabilistic route splitting for makespan reduction\n            longest_route_idx = max(range(len(new_solution)), key=lambda i: np.sum(distance_matrix[new_solution[i][:-1], new_solution[i][1:]]))\n            longest_route = new_solution[longest_route_idx]\n            if len(longest_route) > 4:\n                split_pos = len(longest_route) // 2\n                first_part = longest_route[:split_pos+1]\n                second_part = longest_route[split_pos:]\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = first_part\n                    new_solution.insert(longest_route_idx + 1, second_part)\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "operation": "elitist"
    }
]