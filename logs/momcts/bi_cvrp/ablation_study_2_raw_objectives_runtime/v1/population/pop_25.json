[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7626046040934145,
            0.21666795015335083
        ],
        "raw_score": [
            57.38218004043512,
            7.516075889345629
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive using crowding-distance-aware selection to prioritize diverse solutions, then applies a hybrid local search that alternates between angle-based route reshuffling (for makespan optimization) and demand-aware swaps (for distance optimization), while ensuring feasibility through capacity checks and spatial constraints, with a fallback mechanism for large-scale route restructuring when standard operations fail. The approach balances both objectives by dynamically switching between spatial and demand-based improvements, with higher priority given to spatial clustering for makespan reduction and proximity-based swaps for distance optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([sol[1] for sol in archive])\n        crowding_dist = np.zeros(len(archive))\n\n        for obj_idx in range(2):\n            sorted_idx = np.argsort(objectives[:, obj_idx])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Spatial-geometric route reshuffling (angle-based clustering for makespan)\n        if random.random() < 0.5:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Calculate angles for angle-based clustering\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n\n                # Sort customers by angle\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n\n                # Check capacity constraint\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n\n        # Demand-aware capacity-constrained swaps (spatial proximity for distance)\n        else:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Find spatially close customers from different routes\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check spatial proximity\n                    dist = np.linalg.norm(coords[route1[i]] - coords[route2[j]])\n                    if dist < np.mean(distance_matrix) * 0.5:  # Only consider close pairs\n                        # Check demand compatibility\n                        if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                            demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                            # Perform swap\n                            route1[i], route2[j] = route2[j], route1[i]\n                            new_solution[route1_idx] = route1\n                            new_solution[route2_idx] = route2\n                            break\n                else:\n                    continue\n                break\n\n        # Fallback mechanism for large-scale restructuring\n        if random.random() < 0.2:\n            # Identify long routes\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 5:\n                # Split into two balanced parts\n                split_pos = len(longest_route) // 2\n                part1 = np.concatenate((longest_route[:split_pos], [0]))\n                part2 = np.concatenate(([0], longest_route[split_pos:-1]))\n\n                if (np.sum(demand[part1[1:-1]]) <= capacity and\n                    np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = part1\n                    new_solution.insert(longest_route_idx + 1, part2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9468684497508806,
            1.1366134881973267
        ],
        "raw_score": [
            36.735819564521165,
            4.314131676940484
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest makespan from the archive, then reconstructs routes by prioritizing high-demand customers (sorted in descending order) and reinserting them into new routes while respecting vehicle capacity constraints. This strategy aims to balance capacity utilization and reduce makespan by focusing on customers with larger demands first. The overall structure involves route fragmentation and a demand-weighted reinsertion heuristic.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    all_customers = []\n\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n\n    # Sort customers by demand in descending order to prioritize high-demand customers\n    all_customers.sort(key=lambda x: -demand[x])\n\n    current_route = [0]\n    current_load = 0\n\n    for customer in all_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.816960311744704,
            0.4819713830947876
        ],
        "raw_score": [
            58.1186865918592,
            7.76925883811885
        ]
    },
    {
        "algorithm": "This algorithm selects a solution from the archive using a weighted combination of distance (30%) and makespan (70%), then applies a hybrid local search that includes route merging, demand-balanced splitting, and customer reallocation (triggered 60% of the time) to balance makespan while improving total distance. It prioritizes reducing the longest routes and reallocating customers to better utilize vehicle capacity, ensuring feasibility by strictly enforcing capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.3, 0.7)  # 30% distance, 70% makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Identify routes for targeted operations\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        shortest_route_idx = np.argmin(route_lengths)\n\n        # Step 2: Try route merging if feasible\n        if len(new_solution) > 2:\n            # Select two shortest routes for potential merging\n            route1_idx, route2_idx = sorted(range(len(new_solution)), key=lambda i: len(new_solution[i]))[:2]\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n        # Step 3: Demand-balanced route splitting\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand * 0.6  # Target 60% of demand in first part\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(longest_route) - 1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            first_part = longest_route[:split_pos + 1]\n            second_part = longest_route[split_pos:]\n\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = first_part\n                new_solution.insert(longest_route_idx + 1, second_part)\n\n        # Step 4: Customer reallocation with demand balancing\n        if random.random() < 0.6:  # 60% chance to try reallocation\n            # Find route with most excess capacity\n            route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            excess_capacities = [capacity - d for d in route_demands]\n            donor_idx = np.argmax(excess_capacities)\n\n            if excess_capacities[donor_idx] > 0:\n                donor_route = new_solution[donor_idx]\n                # Find customers that can be moved to other routes\n                for i in reversed(range(1, len(donor_route) - 1)):\n                    customer = donor_route[i]\n                    if demand[customer] <= excess_capacities[donor_idx]:\n                        # Find best route to insert this customer\n                        best_route = -1\n                        best_pos = -1\n                        best_improvement = 0\n\n                        for r in range(len(new_solution)):\n                            if r == donor_idx:\n                                continue\n                            route = new_solution[r]\n                            if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                                continue\n\n                            for pos in range(1, len(route)):\n                                # Calculate potential improvement\n                                improvement = (distance_matrix[route[pos-1]][customer] + distance_matrix[customer][route[pos]] -\n                                             distance_matrix[route[pos-1]][route[pos]] +\n                                             distance_matrix[donor_route[i-1]][donor_route[i+1]] -\n                                             distance_matrix[donor_route[i-1]][customer] -\n                                             distance_matrix[customer][donor_route[i+1]])\n\n                                if improvement < best_improvement:\n                                    best_improvement = improvement\n                                    best_route = r\n                                    best_pos = pos\n\n                        if best_route != -1:\n                            # Perform the move\n                            route = new_solution[best_route]\n                            route = np.insert(route, best_pos, customer)\n                            new_solution[best_route] = route\n                            donor_route = np.delete(donor_route, i)\n                            new_solution[donor_idx] = donor_route\n                            break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.8248165757709953,
            0.7335710227489471
        ],
        "raw_score": [
            58.64121823162057,
            7.814322992703525
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive with a weighted preference for lower total distance (50%) over makespan (50%), then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-adaptive swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations when standard improvements fail, always enforcing capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.5, 0.5)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to split the route into two\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 2: If splitting fails, try to relocate a customer to another route\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_pos)\n\n                            new_solution[route_idx] = route\n                            new_solution[other_route_idx] = other_route\n                            break\n                else:\n                    # Step 3: If relocation fails, try a capacity-adaptive swap\n                    for i in range(1, len(route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[route[1:-1]]) + demand[route[i]]):\n                                        old_dist = (distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][other_route[j]] + distance_matrix[other_route[j]][other_route[j+1]])\n                                        new_dist = (distance_matrix[route[i-1]][other_route[j]] + distance_matrix[other_route[j]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][route[i]] + distance_matrix[route[i]][other_route[j+1]])\n\n                                        if new_dist < old_dist:\n                                            route[i], other_route[j] = other_route[j], route[i]\n                                            new_solution[route_idx] = route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7039234633235187,
            0.1366652548313141
        ],
        "raw_score": [
            58.0593097506559,
            7.644695851627934
        ]
    },
    {
        "algorithm": "The algorithm selects a Pareto-optimal solution from the archive using dominance scores, then applies a three-step hybrid local search: first redistributing customers via demand-aware k-means clustering, second merging/splitting routes to balance capacity and distance, and finally optimizing with demand-weighted segment reversals prioritizing high-demand customers while maintaining feasibility. The method intelligently balances the bi-objective trade-off by emphasizing demand-sensitive operations and capacity-constrained transformations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate dominance scores\n        dominance = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                       (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                        dominance[i] += 1\n\n        # Select solution with highest dominance score (most Pareto-optimal)\n        selected_idx = np.argmax(dominance)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Demand-aware k-means clustering for route redistribution\n    all_customers = np.concatenate([route[1:-1] for route in new_solution])\n    if len(all_customers) > 0:\n        # Calculate demand-weighted centroids\n        customer_coords = coords[all_customers]\n        customer_demands = demand[all_customers]\n\n        # Initialize clusters with current routes\n        clusters = [route[1:-1] for route in new_solution]\n        cluster_centroids = np.array([np.mean(coords[cluster], axis=0) for cluster in clusters])\n\n        # Iterative refinement\n        for _ in range(3):  # Fixed number of iterations\n            new_clusters = [[] for _ in range(len(clusters))]\n\n            for i, customer in enumerate(all_customers):\n                # Calculate demand-weighted distance to centroids\n                distances = np.linalg.norm(customer_coords[i] - cluster_centroids, axis=1)\n                weighted_distances = distances * (1 + 0.5 * customer_demands[i]/capacity)  # Higher demand affects more\n                closest_cluster = np.argmin(weighted_distances)\n                new_clusters[closest_cluster].append(customer)\n\n            # Update centroids\n            for i in range(len(clusters)):\n                if len(new_clusters[i]) > 0:\n                    cluster_centroids[i] = np.mean(coords[new_clusters[i]], axis=0)\n                else:\n                    # Handle empty clusters by merging with closest non-empty\n                    non_empty = [j for j in range(len(new_clusters)) if len(new_clusters[j]) > 0]\n                    if non_empty:\n                        closest = np.argmin(np.linalg.norm(cluster_centroids[i] - cluster_centroids[non_empty], axis=1))\n                        new_clusters[non_empty[closest]].extend(new_clusters[i])\n                        new_clusters[i] = []\n                        cluster_centroids[i] = cluster_centroids[non_empty[closest]]\n\n            clusters = new_clusters\n\n        # Reconstruct solution from clusters\n        new_solution = []\n        for cluster in clusters:\n            if len(cluster) > 0:\n                # Sort customers by angle from depot to create feasible route\n                depot_coord = coords[0]\n                cluster_coords = coords[cluster]\n                angles = np.arctan2(cluster_coords[:,1] - depot_coord[1], cluster_coords[:,0] - depot_coord[0])\n                sorted_indices = np.argsort(angles)\n                sorted_customers = np.array(cluster)[sorted_indices]\n\n                # Check capacity constraint\n                if sum(demand[sorted_customers]) <= capacity:\n                    new_solution.append(np.concatenate([[0], sorted_customers, [0]]))\n\n    # Step 2: Capacity-constrained route merging/splitting\n    if len(new_solution) > 1:\n        # Find two most compatible routes (smallest distance between them)\n        min_dist = float('inf')\n        merge_pair = (0, 1)\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                # Distance between last customer of route i and first customer of route j\n                last_i = new_solution[i][-2]\n                first_j = new_solution[j][1]\n                dist = distance_matrix[last_i][first_j]\n\n                if dist < min_dist:\n                    min_dist = dist\n                    merge_pair = (i, j)\n\n        # Check if merging is feasible\n        merged_demand = sum(demand[new_solution[merge_pair[0]][1:-1]]) + sum(demand[new_solution[merge_pair[1]][1:-1]])\n        if merged_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([new_solution[merge_pair[0]][:-1], new_solution[merge_pair[1]][1:]])\n            new_solution[merge_pair[0]] = merged_route\n            del new_solution[merge_pair[1]]\n        else:\n            # Try splitting instead\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                customers = route[1:-1]\n                if len(customers) > 2:  # Need at least 3 customers to split (2 segments)\n                    # Find best split point that minimizes demand imbalance\n                    cumulative_demand = np.cumsum(demand[customers])\n                    total_demand = cumulative_demand[-1]\n                    split_pos = np.argmin(np.abs(cumulative_demand - total_demand/2))\n\n                    # Create two new routes\n                    route1 = np.concatenate([[0], customers[:split_pos+1], [0]])\n                    route2 = np.concatenate([[0], customers[split_pos+1:], [0]])\n\n                    # Check feasibility\n                    if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                        new_solution[route_idx] = route1\n                        new_solution.insert(route_idx+1, route2)\n                        break\n\n    # Step 3: Demand-weighted segment reversal\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) >= 2:\n            # Calculate demand weights\n            weights = demand[customers] / capacity\n            weighted_distances = np.zeros(len(customers)-1)\n\n            for i in range(len(customers)-1):\n                # Calculate distance between consecutive customers\n                weighted_distances[i] = distance_matrix[customers[i]][customers[i+1]] * (weights[i] + weights[i+1])\n\n            # Find segment with highest weighted distance (most improvement potential)\n            segment_start = np.argmax(weighted_distances)\n            segment_end = segment_start + 1\n\n            # Reverse the segment\n            new_segment = np.concatenate([customers[:segment_start],\n                                         customers[segment_start:segment_end+1][::-1],\n                                         customers[segment_end+1:]])\n\n            # Verify capacity constraint\n            if sum(demand[new_segment]) <= capacity:\n                route[1:-1] = new_segment\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8587460936517386,
            10.895758479833603
        ],
        "raw_score": [
            58.170068167260425,
            7.6011116159330445
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a promising solution from the archive based on trade-off ratios, then applies a two-phase transformation: first partitioning customers into angular sectors to optimize makespan, followed by demand-aware route consolidation to refine distance, while always maintaining feasibility through capacity checks. The method prioritizes spatial clustering in Phase 1 and demand balancing in Phase 2, with iterative merging decisions based on distance improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    trade_off_ratios = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(trade_off_ratios)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Angular sector partitioning for makespan optimization\n    if len(new_solution) > 1:\n        # Calculate angular sectors for all customers\n        depot_coords = coords[0]\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n        angles = np.arctan2(coords[all_customers, 1] - depot_coords[1],\n                          coords[all_customers, 0] - depot_coords[0])\n\n        # Sort customers by angle\n        sorted_indices = np.argsort(angles)\n        sorted_customers = np.array(all_customers)[sorted_indices]\n\n        # Create new routes by splitting into angular sectors\n        num_sectors = min(len(new_solution), len(sorted_customers))\n        sector_size = len(sorted_customers) // num_sectors\n        new_routes = []\n\n        for i in range(num_sectors):\n            start = i * sector_size\n            end = (i + 1) * sector_size if i < num_sectors - 1 else len(sorted_customers)\n            sector_customers = sorted_customers[start:end]\n\n            if len(sector_customers) > 0 and np.sum(demand[sector_customers]) <= capacity:\n                new_route = np.concatenate(([0], sector_customers, [0]))\n                new_routes.append(new_route)\n\n        if len(new_routes) > 1:\n            new_solution = new_routes\n\n    # Phase 2: Demand-aware route consolidation for distance optimization\n    if len(new_solution) > 2:\n        # Calculate route demands and sort by demand\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_routes = sorted(zip(new_solution, route_demands), key=lambda x: x[1])\n        new_solution = [route for route, _ in sorted_routes]\n\n        # Try to merge routes with similar demands\n        merged = True\n        while merged and len(new_solution) > 1:\n            merged = False\n            for i in range(len(new_solution) - 1):\n                if i >= len(new_solution) - 1:\n                    break\n\n                route1, route2 = new_solution[i], new_solution[i+1]\n                demand1, demand2 = sum(demand[route1[1:-1]]), sum(demand[route2[1:-1]])\n\n                if demand1 + demand2 <= capacity:\n                    # Calculate distance improvement\n                    old_dist = (sum(distance_matrix[route1[j], route1[j+1]] for j in range(len(route1)-1)) +\n                               sum(distance_matrix[route2[j], route2[j+1]] for j in range(len(route2)-1)))\n                    new_route = np.concatenate((route1[:-1], route2[1:]))\n                    new_dist = sum(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route)-1))\n\n                    if new_dist < old_dist:\n                        new_solution = new_solution[:i] + [new_route] + new_solution[i+2:]\n                        merged = True\n                        break\n\n    # Ensure all routes are feasible\n    new_solution = [route for route in new_solution if len(route) > 2 and sum(demand[route[1:-1]]) <= capacity]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7595065660994974,
            0.5461699068546295
        ],
        "raw_score": [
            58.245267990149785,
            7.6260714424962135
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and a novel \"route reshuffling\" operator to balance the two objectives while ensuring feasibility. It intelligently selects customers for reinsertion and reshuffles routes to reduce makespan differences, focusing on capacity constraints and objective trade-offs. The process ensures feasibility at each step while targeting both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route merging (if possible) to reduce makespan\n    if len(selected_solution) > 1:\n        merged_routes = []\n        for route in selected_solution:\n            if not merged_routes or np.sum(demand[route[1:-1]]) + np.sum(demand[merged_routes[-1][1:-1]]) <= capacity:\n                if merged_routes:\n                    merged_route = np.concatenate((merged_routes[-1][:-1], route[1:]))\n                    merged_routes[-1] = merged_route\n                else:\n                    merged_routes.append(route)\n            else:\n                merged_routes.append(route)\n        selected_solution = merged_routes\n\n    # Step 2: Customer reinsertion with capacity constraints\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        candidates = route[1:-1]\n        if len(candidates) == 0:\n            new_solution.append(route)\n            continue\n\n        removed_customer = np.random.choice(candidates)\n        remaining_route = route[route != removed_customer]\n\n        # Find best insertion position in existing routes\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, r in enumerate(new_solution):\n            for pos in range(1, len(r)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate((r[1:pos], [removed_customer], r[pos:-1]))]) <= capacity:\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[r[pos-1], removed_customer] +\n                                   distance_matrix[removed_customer, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insertion = (i, pos)\n\n        if best_insertion:\n            i, pos = best_insertion\n            new_route = np.concatenate((new_solution[i][:pos], [removed_customer], new_solution[i][pos:]))\n            new_solution[i] = new_route\n        else:\n            # If no valid insertion found, create new route\n            new_solution.append(np.array([0, removed_customer, 0]))\n\n    # Step 3: Route reshuffling (novel operator) to balance objectives\n    if len(new_solution) > 1:\n        # Select two routes to reshuffle\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Find best split points for both routes\n        best_split = None\n        min_diff = float('inf')\n\n        for split1 in range(1, len(new_solution[idx1])-1):\n            for split2 in range(1, len(new_solution[idx2])-1):\n                # Check capacity constraints for both new routes\n                if (np.sum(demand[new_solution[idx1][1:split1]]) <= capacity and\n                    np.sum(demand[new_solution[idx1][split1:-1]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][1:split2]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][split2:-1]]) <= capacity):\n\n                    # Calculate makespan difference after reshuffling\n                    current_makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n                    new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n                    new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n                    new_makespan1 = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                    new_makespan2 = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n\n                    diff = abs(new_makespan1 - new_makespan2)\n                    if diff < min_diff:\n                        min_diff = diff\n                        best_split = (split1, split2)\n\n        if best_split:\n            split1, split2 = best_split\n            new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n            new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n            new_solution[idx1] = new_route1\n            new_solution[idx2] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8234625192972875,
            2.7163036167621613
        ],
        "raw_score": [
            58.1689844298665,
            7.7370092861205855
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding-distance-aware selection, then applies a hybrid local search combining angle-based route reshuffling (prioritizing makespan optimization) and demand-aware swaps (focusing on distance optimization), with dynamic alternation between these operations to balance both objectives while ensuring feasibility through capacity checks and spatial constraints. The method includes a fallback mechanism for large-scale restructuring by splitting long routes when beneficial.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        objectives = np.array([sol[1] for sol in archive])\n        crowding_dist = np.zeros(len(archive))\n\n        for obj_idx in range(2):\n            sorted_idx = np.argsort(objectives[:, obj_idx])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 2: Hybrid local search\n    if len(new_solution) > 1:\n        # Operator 1: Angle-based reshuffling (makespan optimization)\n        if random.random() < 0.5:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Calculate angles for angle-based clustering\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n\n                # Sort customers by angle\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n\n                # Check capacity constraint\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n\n        # Operator 2: Demand-aware swaps (distance optimization)\n        else:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Find spatially close customers from different routes\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check spatial proximity\n                    dist = np.linalg.norm(coords[route1[i]] - coords[route2[j]])\n                    if dist < np.mean(distance_matrix) * 0.5:  # Only consider close pairs\n                        # Check demand compatibility\n                        if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                            demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                            # Perform swap\n                            route1[i], route2[j] = route2[j], route1[i]\n                            new_solution[route1_idx] = route1\n                            new_solution[route2_idx] = route2\n                            break\n                else:\n                    continue\n                break\n\n        # Fallback mechanism for large-scale restructuring\n        if random.random() < 0.2:\n            # Identify long routes\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 5:\n                # Split into two balanced parts\n                split_pos = len(longest_route) // 2\n                part1 = np.concatenate((longest_route[:split_pos], [0]))\n                part2 = np.concatenate(([0], longest_route[split_pos:-1]))\n\n                if (np.sum(demand[part1[1:-1]]) <= capacity and\n                    np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = part1\n                    new_solution.insert(longest_route_idx + 1, part2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.810596423728601,
            0.908486396074295
        ],
        "raw_score": [
            38.519120943490805,
            4.843382741324403
        ]
    }
]