[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and a novel \"route reshuffling\" operator to balance the two objectives while ensuring feasibility. It intelligently selects customers for reinsertion and reshuffles routes to reduce makespan differences, focusing on capacity constraints and objective trade-offs. The process ensures feasibility at each step while targeting both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route merging (if possible) to reduce makespan\n    if len(selected_solution) > 1:\n        merged_routes = []\n        for route in selected_solution:\n            if not merged_routes or np.sum(demand[route[1:-1]]) + np.sum(demand[merged_routes[-1][1:-1]]) <= capacity:\n                if merged_routes:\n                    merged_route = np.concatenate((merged_routes[-1][:-1], route[1:]))\n                    merged_routes[-1] = merged_route\n                else:\n                    merged_routes.append(route)\n            else:\n                merged_routes.append(route)\n        selected_solution = merged_routes\n\n    # Step 2: Customer reinsertion with capacity constraints\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        candidates = route[1:-1]\n        if len(candidates) == 0:\n            new_solution.append(route)\n            continue\n\n        removed_customer = np.random.choice(candidates)\n        remaining_route = route[route != removed_customer]\n\n        # Find best insertion position in existing routes\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, r in enumerate(new_solution):\n            for pos in range(1, len(r)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate((r[1:pos], [removed_customer], r[pos:-1]))]) <= capacity:\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[r[pos-1], removed_customer] +\n                                   distance_matrix[removed_customer, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insertion = (i, pos)\n\n        if best_insertion:\n            i, pos = best_insertion\n            new_route = np.concatenate((new_solution[i][:pos], [removed_customer], new_solution[i][pos:]))\n            new_solution[i] = new_route\n        else:\n            # If no valid insertion found, create new route\n            new_solution.append(np.array([0, removed_customer, 0]))\n\n    # Step 3: Route reshuffling (novel operator) to balance objectives\n    if len(new_solution) > 1:\n        # Select two routes to reshuffle\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Find best split points for both routes\n        best_split = None\n        min_diff = float('inf')\n\n        for split1 in range(1, len(new_solution[idx1])-1):\n            for split2 in range(1, len(new_solution[idx2])-1):\n                # Check capacity constraints for both new routes\n                if (np.sum(demand[new_solution[idx1][1:split1]]) <= capacity and\n                    np.sum(demand[new_solution[idx1][split1:-1]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][1:split2]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][split2:-1]]) <= capacity):\n\n                    # Calculate makespan difference after reshuffling\n                    current_makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n                    new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n                    new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n                    new_makespan1 = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                    new_makespan2 = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n\n                    diff = abs(new_makespan1 - new_makespan2)\n                    if diff < min_diff:\n                        min_diff = diff\n                        best_split = (split1, split2)\n\n        if best_split:\n            split1, split2 = best_split\n            new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n            new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n            new_solution[idx1] = new_route1\n            new_solution[idx2] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8234625192972875,
            2.7163036167621613
        ],
        "raw_score": [
            58.1689844298665,
            7.7370092861205855
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (prioritizing makespan over distance) and applies a hybrid local search combining route splitting (for demand imbalance), customer relocation (to balance makespan), and demand-aware reshuffling (to swap route segments while maintaining capacity constraints). It focuses on reducing makespan by 10% and demand imbalance by 20% of capacity thresholds, ensuring feasibility through rigorous demand checks. The weighted selection (0.4 distance, 0.6 makespan) balances exploration of diverse solutions while the hybrid operators target both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Balance between distance and makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Try to split a route with high demand imbalance\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    second_part_demand = total_demand - first_part_demand\n                    if abs(first_part_demand - second_part_demand) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Relocate customers to balance makespan\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        longest_route = np.argmax(makespans)\n        shortest_route = np.argmin(makespans)\n\n        if makespans[longest_route] - makespans[shortest_route] > 0.1 * np.mean(makespans):\n            for customer_pos in range(1, len(new_solution[longest_route])-1):\n                customer = new_solution[longest_route][customer_pos]\n                if (np.sum(demand[new_solution[shortest_route][1:-1]]) + demand[customer] <= capacity and\n                    len(new_solution[shortest_route]) < len(new_solution[longest_route])):\n                    # Calculate potential makespan improvement\n                    old_dist = (distance_matrix[new_solution[longest_route][customer_pos-1], customer] +\n                               distance_matrix[customer, new_solution[longest_route][customer_pos+1]] -\n                               distance_matrix[new_solution[longest_route][customer_pos-1], new_solution[longest_route][customer_pos+1]])\n                    new_dist = (distance_matrix[new_solution[shortest_route][-2], customer] +\n                               distance_matrix[customer, 0] -\n                               distance_matrix[new_solution[shortest_route][-2], 0])\n                    if old_dist > new_dist:\n                        new_solution[shortest_route] = np.concatenate((new_solution[shortest_route][:-1], [customer], [0]))\n                        new_solution[longest_route] = np.concatenate((new_solution[longest_route][:customer_pos], new_solution[longest_route][customer_pos+1:]))\n                        break\n\n        # Step 3: Demand-aware reshuffling\n        if len(new_solution) > 2:\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n            demand1, demand2 = np.sum(demand[route1[1:-1]]), np.sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > 0.2 * capacity:\n                for split1 in range(1, len(route1)-1):\n                    for split2 in range(1, len(route2)-1):\n                        part1 = route1[1:split1]\n                        part2 = route2[1:split2]\n                        new_demand1 = demand1 - np.sum(demand[part1]) + np.sum(demand[part2])\n                        new_demand2 = demand2 - np.sum(demand[part2]) + np.sum(demand[part1])\n                        if (new_demand1 <= capacity and new_demand2 <= capacity and\n                            abs(new_demand1 - new_demand2) < abs(demand1 - demand2)):\n                            new_route1 = np.concatenate(([0], part1, route2[split2:-1], route1[split1:-1], [0]))\n                            new_route2 = np.concatenate(([0], part2, route1[split1:-1], route2[split2:-1], [0]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                    else:\n                        continue\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7904515528208966,
            0.8658688962459564
        ],
        "raw_score": [
            58.1234035683554,
            7.636296895092969
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7626046040934145,
            0.21666795015335083
        ],
        "raw_score": [
            57.38218004043512,
            7.516075889345629
        ]
    },
    {
        "algorithm": "This algorithm selects a solution from the archive based on a weighted combination of distance and makespan objectives, then applies a hybrid local search combining route reshaping (with demand-aware segment relocation), demand-aware customer reallocation (using spatial clustering), and route merging (for balanced demand pairs) to improve both objectives while maintaining feasibility. The method prioritizes distance reduction (60% weight) over balanced routes (40%) in reshaping and considers spatial proximity (50%) alongside distance in customer insertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])  # More weight on distance\n    selected_idx = min(len(archive) // 3, len(archive) - 1)  # Select a better solution\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route reshaping with demand consideration\n    if len(new_solution) > 1:\n        route_idx = random.choice(range(len(new_solution)))\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Select a segment based on demand density\n            demands = demand[selected_route[1:-1]]\n            segment_length = min(3, len(selected_route) - 2)\n            segment_start = random.randint(1, len(selected_route) - 1 - segment_length)\n            segment_end = segment_start + segment_length\n            removed_segment = selected_route[segment_start:segment_end]\n\n            # Calculate demand of the segment\n            segment_demand = sum(demands[segment_start - 1:segment_end - 1])\n\n            # Find best insertion point considering both distance and demand balance\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(selected_route) - 1):\n                if i not in range(segment_start - 1, segment_end):\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[selected_route[i], removed_segment[0]] +\n                                   distance_matrix[removed_segment[-1], selected_route[i+1]] -\n                                   distance_matrix[selected_route[i], selected_route[i+1]])\n\n                    # Calculate demand balance improvement\n                    current_demand = sum(demand[selected_route[1:-1]])\n                    new_demand = current_demand - segment_demand\n                    balance_score = abs(new_demand - capacity / 2)  # Prefer balanced routes\n\n                    # Combined score\n                    score = 0.6 * dist_increase + 0.4 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(selected_route, best_pos, removed_segment)\n                new_solution[route_idx] = new_route\n\n    # Demand-aware customer reallocation with spatial clustering\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Cluster customers based on spatial proximity and demand\n        clusters = []\n        for customer in unassigned_customers:\n            assigned = False\n            for cluster in clusters:\n                # Check if customer is close to any member of the cluster\n                for member in cluster:\n                    if distance_matrix[customer, member] < 1.5 * np.mean(distance_matrix):\n                        cluster.append(customer)\n                        assigned = True\n                        break\n                if assigned:\n                    break\n            if not assigned:\n                clusters.append([customer])\n\n        for cluster in clusters:\n            # Sort customers in cluster by demand (descending)\n            cluster.sort(key=lambda x: -demand[x])\n\n            for customer in cluster:\n                best_route = -1\n                best_pos = -1\n                best_score = float('inf')\n\n                for route_idx in range(len(new_solution)):\n                    route = new_solution[route_idx]\n                    current_demand = sum(demand[route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        for i in range(len(route) - 1):\n                            # Calculate distance increase\n                            dist_increase = (distance_matrix[route[i], customer] +\n                                           distance_matrix[customer, route[i+1]] -\n                                           distance_matrix[route[i], route[i+1]])\n\n                            # Calculate spatial proximity to existing customers\n                            spatial_score = np.mean([distance_matrix[customer, c] for c in route[1:-1]])\n\n                            # Combined score\n                            score = 0.5 * dist_increase + 0.5 * spatial_score\n\n                            if score < best_score:\n                                best_score = score\n                                best_route = route_idx\n                                best_pos = i + 1\n\n                if best_route != -1:\n                    new_route = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[best_route] = new_route\n\n    # Route merging to reduce makespan\n    if len(new_solution) > 2:\n        # Find two routes with similar demands\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        min_diff = float('inf')\n        merge_pair = (-1, -1)\n\n        for i in range(len(new_solution)):\n            for j in range(i + 1, len(new_solution)):\n                diff = abs(route_demands[i] - route_demands[j])\n                if diff < min_diff and route_demands[i] + route_demands[j] <= capacity:\n                    min_diff = diff\n                    merge_pair = (i, j)\n\n        if merge_pair != (-1, -1):\n            route1, route2 = new_solution[merge_pair[0]], new_solution[merge_pair[1]]\n\n            # Calculate best merge point\n            best_pos = -1\n            best_increase = float('inf')\n\n            for i in range(len(route1) - 1):\n                for j in range(len(route2) - 1):\n                    # Calculate distance increase for merging at these points\n                    dist_increase = (distance_matrix[route1[i], route2[1]] +\n                                   distance_matrix[route2[-2], route1[i+1]] -\n                                   distance_matrix[route1[i], route1[i+1]] -\n                                   distance_matrix[route2[-2], route2[-1]])\n\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = (i, j)\n\n            if best_pos != -1:\n                # Merge the routes\n                merged_route = np.concatenate([\n                    route1[:best_pos[0] + 1],\n                    route2[1:-1],\n                    route1[best_pos[0] + 1:]\n                ])\n                new_solution = [route for idx, route in enumerate(new_solution)\n                              if idx not in merge_pair] + [merged_route]\n\n    # Ensure the solution remains feasible\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7688276850363361,
            0.5797156393527985
        ],
        "raw_score": [
            57.84734696647112,
            7.624469138800522
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive with a weighted preference for lower total distance (50%) over makespan (50%), then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-adaptive swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations when standard improvements fail, always enforcing capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.5, 0.5)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to split the route into two\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 2: If splitting fails, try to relocate a customer to another route\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_pos)\n\n                            new_solution[route_idx] = route\n                            new_solution[other_route_idx] = other_route\n                            break\n                else:\n                    # Step 3: If relocation fails, try a capacity-adaptive swap\n                    for i in range(1, len(route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[route[1:-1]]) + demand[route[i]]):\n                                        old_dist = (distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][other_route[j]] + distance_matrix[other_route[j]][other_route[j+1]])\n                                        new_dist = (distance_matrix[route[i-1]][other_route[j]] + distance_matrix[other_route[j]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][route[i]] + distance_matrix[route[i]][other_route[j+1]])\n\n                                        if new_dist < old_dist:\n                                            route[i], other_route[j] = other_route[j], route[i]\n                                            new_solution[route_idx] = route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7039234633235187,
            0.1366652548313141
        ],
        "raw_score": [
            58.0593097506559,
            7.644695851627934
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the best total distance from the archive and applies a hybrid local search combining route splitting (based on demand imbalance), a novel cluster-based 2-opt (optimizing spatial proximity), and demand-based customer relocation between routes (balancing vehicle loads). It prioritizes reducing makespan by splitting overloaded routes and improving total distance through spatial-aware optimizations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route Splitting based on demand imbalance\n    if len(new_solution) > 0:\n        # Find the route with the highest demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        target_route_idx = np.argmax(demands)\n        target_route = new_solution[target_route_idx]\n\n        # Find the customer with the highest demand in this route\n        customers = target_route[1:-1]\n        if len(customers) > 0:\n            customer_demands = [(c, demand[c]) for c in customers]\n            customer_demands.sort(key=lambda x: -x[1])\n            split_customer = customer_demands[0][0]\n\n            # Split the route at this customer\n            split_idx = np.where(target_route == split_customer)[0][0]\n            new_route1 = np.concatenate([target_route[:split_idx+1], [0]])\n            new_route2 = np.concatenate([[0], target_route[split_idx:]])\n\n            # Replace the original route with the two new routes\n            new_solution.pop(target_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    # Step 2: Cluster-based 2-opt (considering spatial proximity)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depots\n\n        if len(route) >= 2:\n            # Find two customers that are close in space but not necessarily adjacent\n            customer_coords = coords[route]\n            distances = np.linalg.norm(customer_coords[:, np.newaxis, :] - customer_coords[np.newaxis, :, :], axis=2)\n            np.fill_diagonal(distances, np.inf)\n            i, j = np.unravel_index(np.argmin(distances), distances.shape)\n\n            # Ensure i < j for proper segment reversal\n            if i > j:\n                i, j = j, i\n\n            # Reverse the segment between i and j\n            new_segment = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Step 3: Demand-based customer relocation between routes\n    if len(new_solution) > 1:\n        # Find the two most imbalanced routes\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = np.argsort(demands)\n        source_route_idx = sorted_indices[-1]  # Most loaded route\n        target_route_idx = sorted_indices[0]  # Least loaded route\n\n        source_route = new_solution[source_route_idx]\n        target_route = new_solution[target_route_idx]\n\n        # Find the customer with the highest demand in the source route\n        customers = source_route[1:-1]\n        if len(customers) > 0:\n            customer_demands = [(c, demand[c]) for c in customers]\n            customer_demands.sort(key=lambda x: -x[1])\n            customer_to_move = customer_demands[0][0]\n\n            # Check if moving this customer to the target route is feasible\n            source_demand = sum(demand[source_route[1:-1]])\n            target_demand = sum(demand[target_route[1:-1]])\n            if target_demand + demand[customer_to_move] <= capacity:\n                # Remove customer from source route\n                mask = source_route != customer_to_move\n                new_source_route = source_route[mask]\n\n                # Insert customer into target route at the best position\n                best_pos = -1\n                best_increase = float('inf')\n\n                for i in range(len(target_route) - 1):\n                    dist_increase = (distance_matrix[target_route[i], customer_to_move] +\n                                    distance_matrix[customer_to_move, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = i + 1\n\n                if best_pos != -1:\n                    new_target_route = np.insert(target_route, best_pos, customer_to_move)\n                    new_solution[source_route_idx] = new_source_route\n                    new_solution[target_route_idx] = new_target_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7196664685669433,
            0.6482102572917938
        ],
        "raw_score": [
            57.69770042862447,
            7.714377659263765
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (top 1/3 by objective product), then applies a hybrid local search alternating between demand-aware relocation (prioritizing makespan balance), capacity-constrained segment swaps (for distance optimization), and route merging/splitting (to optimize both objectives). It dynamically adjusts operator weights based on success, reverting to the original solution if capacity constraints are violated. The method prioritizes high-demand customers for relocation and balances demands during splits, while segment swaps focus on distance reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] * x[1][1])  # Sort by product of objectives (trade-off)\n    selected_idx = min(len(archive) // 3, len(archive) - 1)  # Select from top 1/3 solutions\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with dynamic operator selection\n    operators = ['relocation', 'segment_swap', 'merge_split']\n    operator_weights = [0.4, 0.4, 0.2]  # Initial weights\n\n    for _ in range(3):  # Apply multiple operators\n        # Select operator based on weights\n        operator = random.choices(operators, weights=operator_weights, k=1)[0]\n\n        if operator == 'relocation' and len(new_solution) > 1:\n            # Demand-aware customer relocation to balance makespan\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            customers = route[1:-1]\n\n            if len(customers) > 1:\n                # Find customer with highest demand\n                customer = max(customers, key=lambda x: demand[x])\n                pos = np.where(route == customer)[0][0]\n\n                # Try to move to another route\n                for other_idx in range(len(new_solution)):\n                    if other_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_idx]\n                    current_demand = sum(demand[other_route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        # Find best insertion position\n                        best_pos = -1\n                        best_increase = float('inf')\n\n                        for i in range(len(other_route) - 1):\n                            dist_increase = (distance_matrix[other_route[i], customer] +\n                                           distance_matrix[customer, other_route[i+1]] -\n                                           distance_matrix[other_route[i], other_route[i+1]])\n                            if dist_increase < best_increase:\n                                best_increase = dist_increase\n                                best_pos = i + 1\n\n                        if best_pos != -1:\n                            # Perform relocation\n                            new_route = np.insert(other_route, best_pos, customer)\n                            new_solution[other_idx] = new_route\n                            new_solution[route_idx] = np.delete(route, pos)\n                            operator_weights = [0.5, 0.3, 0.2]  # Increase relocation weight\n                            break\n\n        elif operator == 'segment_swap' and len(new_solution) > 1:\n            # Capacity-constrained segment swap for distance optimization\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Select two segments\n                split1 = random.randint(1, len(route) - 3)\n                split2 = random.randint(split1 + 1, len(route) - 2)\n                segment1 = route[split1:split2]\n                segment2 = route[split2:]\n\n                # Check capacity constraints\n                demand1 = sum(demand[segment1])\n                demand2 = sum(demand[segment2])\n\n                if demand1 + demand2 <= capacity:\n                    # Swap segments\n                    new_route = np.concatenate([route[:split1], segment2, segment1, route[:split1]])\n                    new_solution[route_idx] = new_route\n                    operator_weights = [0.3, 0.5, 0.2]  # Increase segment swap weight\n\n        elif operator == 'merge_split':\n            # Route merging/splitting for both objectives\n            if len(new_solution) > 1:\n                # Try to merge two routes\n                route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution.pop(max(route1_idx, route2_idx))\n                    new_solution.pop(min(route1_idx, route2_idx))\n                    new_solution.append(merged_route)\n                    operator_weights = [0.3, 0.2, 0.5]  # Increase merge/split weight\n            else:\n                # Try to split a long route\n                for route_idx in range(len(new_solution)):\n                    route = new_solution[route_idx]\n                    if len(route) > 6:  # Arbitrary threshold for \"long\" route\n                        # Find best split point\n                        best_split = -1\n                        best_balance = float('inf')\n\n                        for i in range(2, len(route) - 2):\n                            demand1 = sum(demand[route[1:i]])\n                            demand2 = sum(demand[route[i:-1]])\n                            balance = abs(demand1 - demand2)\n\n                            if balance < best_balance and demand1 <= capacity and demand2 <= capacity:\n                                best_balance = balance\n                                best_split = i\n\n                        if best_split != -1:\n                            # Split route\n                            new_route1 = np.concatenate([[0], route[1:best_split], [0]])\n                            new_route2 = np.concatenate([[0], route[best_split:-1], [0]])\n                            new_solution[route_idx] = new_route1\n                            new_solution.insert(route_idx + 1, new_route2)\n                            operator_weights = [0.3, 0.2, 0.5]  # Increase merge/split weight\n                            break\n\n    # Final feasibility check\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution  # Revert to original if infeasible\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7370865569403737,
            1.2501406967639923
        ],
        "raw_score": [
            50.02551667656539,
            6.201089234807016
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.5, 0.5) if len(archive) > 5 else (0.3, 0.7)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Adaptive operator selection\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        longest_route = np.argmax(makespans)\n        shortest_route = np.argmin(makespans)\n\n        if makespans[longest_route] - makespans[shortest_route] > 0.1 * np.mean(makespans):\n            # Demand-balanced reshuffling\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    if abs(first_part_demand - (total_demand - first_part_demand)) > 0.2 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n        else:\n            # Capacity-aware segment swaps\n            for i in range(len(new_solution)):\n                for j in range(i+1, len(new_solution)):\n                    route1, route2 = new_solution[i], new_solution[j]\n                    for pos1 in range(1, len(route1)-1):\n                        for pos2 in range(1, len(route2)-1):\n                            if (demand[route1[pos1]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[pos2]] and\n                                demand[route2[pos2]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[pos1]]):\n                                # Check distance improvement\n                                old_dist = (distance_matrix[route1[pos1-1], route1[pos1]] +\n                                           distance_matrix[route1[pos1], route1[pos1+1]] +\n                                           distance_matrix[route2[pos2-1], route2[pos2]] +\n                                           distance_matrix[route2[pos2], route2[pos2+1]])\n                                new_dist = (distance_matrix[route1[pos1-1], route2[pos2]] +\n                                           distance_matrix[route2[pos2], route1[pos1+1]] +\n                                           distance_matrix[route2[pos2-1], route1[pos1]] +\n                                           distance_matrix[route1[pos1], route2[pos2+1]])\n                                if new_dist < old_dist:\n                                    # Perform swap\n                                    route1[pos1], route2[pos2] = route2[pos2], route1[pos1]\n                                    new_solution[i] = route1\n                                    new_solution[j] = route2\n                                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Final feasibility check\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7198371873822134,
            0.8180724084377289
        ],
        "raw_score": [
            57.85577185393448,
            7.805199245107794
        ]
    },
    {
        "algorithm": "The algorithm dynamically alternates between distance-focused and makespan-focused selection from the archive, then applies a hybrid local search combining demand-aware route splitting, capacity-constrained segment swaps, and adaptive customer reinsertion, prioritizing solutions with balanced objectives while ensuring feasibility through incremental validation. It alternates between prioritizing total distance (first two iterations) and makespan (next two iterations) during selection, and uses a multi-step local search that first splits long routes with unbalanced demands, then performs segment swaps between routes to improve both distance and makespan, followed by adaptive customer reinsertion to further optimize the solution structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    iteration = len(archive) % 4\n    if iteration < 2:\n        weights = (0.8, 0.2)  # Distance-focused\n    else:\n        weights = (0.2, 0.8)  # Makespan-focused\n\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Demand-aware route splitting with makespan improvement\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        max_makespan = max(makespans)\n\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3 and makespans[route_idx] > 0.9 * max_makespan:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    if abs(first_part_demand - (total_demand - first_part_demand)) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Capacity-constrained segment swaps\n        for _ in range(2):  # Try multiple swaps\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n\n            for split1 in range(1, len(route1)-1):\n                for split2 in range(1, len(route2)-1):\n                    part1 = route1[1:split1]\n                    part2 = route2[1:split2]\n                    if (np.sum(demand[part1]) <= capacity - np.sum(demand[route2[1:-1]]) + np.sum(demand[part2]) and\n                        np.sum(demand[part2]) <= capacity - np.sum(demand[route1[1:-1]]) + np.sum(demand[part1])):\n                        # Calculate makespan improvement potential\n                        old_dist = (distance_matrix[route1[split1-1], route1[split1]] +\n                                   distance_matrix[route2[split2-1], route2[split2]])\n                        new_dist = (distance_matrix[route1[split1-1], route2[split2]] +\n                                   distance_matrix[route2[split2-1], route1[split1]])\n                        if new_dist < old_dist:\n                            new_route1 = np.concatenate((route1[:split1], route2[split2:-1], route1[split1:]))\n                            new_route2 = np.concatenate((route2[:split2], route1[split1:-1], route2[split2:]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                else:\n                    continue\n                break\n\n        # Step 3: Adaptive customer reinsertion\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                candidate_pos = random.randint(1, len(route)-2)\n                customer = route[candidate_pos]\n\n                # Try reinserting into other routes\n                for other_idx in range(len(new_solution)):\n                    if other_idx != route_idx:\n                        other_route = new_solution[other_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate potential improvement\n                            old_dist = (distance_matrix[route[candidate_pos-1], customer] +\n                                      distance_matrix[customer, route[candidate_pos+1]] -\n                                      distance_matrix[route[candidate_pos-1], route[candidate_pos+1]])\n                            new_dist = (distance_matrix[other_route[-2], customer] +\n                                      distance_matrix[customer, 0] -\n                                      distance_matrix[other_route[-2], 0])\n                            if new_dist < old_dist:\n                                new_solution[other_idx] = np.concatenate((other_route[:-1], [customer], [0]))\n                                new_solution[route_idx] = np.concatenate((route[:candidate_pos], route[candidate_pos+1:]))\n                                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.732739139460205,
            3.2730793952941895
        ],
        "raw_score": [
            58.31340533238172,
            7.84913809031286
        ]
    }
]