[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (prioritizing lower makespan and total distance) and applies a hybrid local search combining route merging, customer reinsertion with capacity checks, and a novel \"route reshuffling\" operator to balance the two objectives while ensuring feasibility. It intelligently selects customers for reinsertion and reshuffles routes to reduce makespan differences, focusing on capacity constraints and objective trade-offs. The process ensures feasibility at each step while targeting both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n\n    # Step 1: Route merging (if possible) to reduce makespan\n    if len(selected_solution) > 1:\n        merged_routes = []\n        for route in selected_solution:\n            if not merged_routes or np.sum(demand[route[1:-1]]) + np.sum(demand[merged_routes[-1][1:-1]]) <= capacity:\n                if merged_routes:\n                    merged_route = np.concatenate((merged_routes[-1][:-1], route[1:]))\n                    merged_routes[-1] = merged_route\n                else:\n                    merged_routes.append(route)\n            else:\n                merged_routes.append(route)\n        selected_solution = merged_routes\n\n    # Step 2: Customer reinsertion with capacity constraints\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route)\n            continue\n\n        # Remove a random customer (not depot) and reinsert elsewhere\n        candidates = route[1:-1]\n        if len(candidates) == 0:\n            new_solution.append(route)\n            continue\n\n        removed_customer = np.random.choice(candidates)\n        remaining_route = route[route != removed_customer]\n\n        # Find best insertion position in existing routes\n        best_insertion = None\n        min_increase = float('inf')\n\n        for i, r in enumerate(new_solution):\n            for pos in range(1, len(r)):\n                # Check capacity constraint\n                if np.sum(demand[np.concatenate((r[1:pos], [removed_customer], r[pos:-1]))]) <= capacity:\n                    # Calculate distance increase\n                    dist_increase = (distance_matrix[r[pos-1], removed_customer] +\n                                   distance_matrix[removed_customer, r[pos]] -\n                                   distance_matrix[r[pos-1], r[pos]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_insertion = (i, pos)\n\n        if best_insertion:\n            i, pos = best_insertion\n            new_route = np.concatenate((new_solution[i][:pos], [removed_customer], new_solution[i][pos:]))\n            new_solution[i] = new_route\n        else:\n            # If no valid insertion found, create new route\n            new_solution.append(np.array([0, removed_customer, 0]))\n\n    # Step 3: Route reshuffling (novel operator) to balance objectives\n    if len(new_solution) > 1:\n        # Select two routes to reshuffle\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Find best split points for both routes\n        best_split = None\n        min_diff = float('inf')\n\n        for split1 in range(1, len(new_solution[idx1])-1):\n            for split2 in range(1, len(new_solution[idx2])-1):\n                # Check capacity constraints for both new routes\n                if (np.sum(demand[new_solution[idx1][1:split1]]) <= capacity and\n                    np.sum(demand[new_solution[idx1][split1:-1]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][1:split2]]) <= capacity and\n                    np.sum(demand[new_solution[idx2][split2:-1]]) <= capacity):\n\n                    # Calculate makespan difference after reshuffling\n                    current_makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n                    new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n                    new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n                    new_makespan1 = sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1))\n                    new_makespan2 = sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1))\n\n                    diff = abs(new_makespan1 - new_makespan2)\n                    if diff < min_diff:\n                        min_diff = diff\n                        best_split = (split1, split2)\n\n        if best_split:\n            split1, split2 = best_split\n            new_route1 = np.concatenate((new_solution[idx1][:split1], new_solution[idx2][split2:-1], new_solution[idx1][split1:]))\n            new_route2 = np.concatenate((new_solution[idx2][:split2], new_solution[idx1][split1:-1], new_solution[idx2][split2:]))\n            new_solution[idx1] = new_route1\n            new_solution[idx2] = new_route2\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8234625192972875,
            2.7163036167621613
        ],
        "raw_score": [
            58.1689844298665,
            7.7370092861205855
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (prioritizing makespan over distance) and applies a hybrid local search combining route splitting (for demand imbalance), customer relocation (to balance makespan), and demand-aware reshuffling (to swap route segments while maintaining capacity constraints). It focuses on reducing makespan by 10% and demand imbalance by 20% of capacity thresholds, ensuring feasibility through rigorous demand checks. The weighted selection (0.4 distance, 0.6 makespan) balances exploration of diverse solutions while the hybrid operators target both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Balance between distance and makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Try to split a route with high demand imbalance\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    second_part_demand = total_demand - first_part_demand\n                    if abs(first_part_demand - second_part_demand) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Relocate customers to balance makespan\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        longest_route = np.argmax(makespans)\n        shortest_route = np.argmin(makespans)\n\n        if makespans[longest_route] - makespans[shortest_route] > 0.1 * np.mean(makespans):\n            for customer_pos in range(1, len(new_solution[longest_route])-1):\n                customer = new_solution[longest_route][customer_pos]\n                if (np.sum(demand[new_solution[shortest_route][1:-1]]) + demand[customer] <= capacity and\n                    len(new_solution[shortest_route]) < len(new_solution[longest_route])):\n                    # Calculate potential makespan improvement\n                    old_dist = (distance_matrix[new_solution[longest_route][customer_pos-1], customer] +\n                               distance_matrix[customer, new_solution[longest_route][customer_pos+1]] -\n                               distance_matrix[new_solution[longest_route][customer_pos-1], new_solution[longest_route][customer_pos+1]])\n                    new_dist = (distance_matrix[new_solution[shortest_route][-2], customer] +\n                               distance_matrix[customer, 0] -\n                               distance_matrix[new_solution[shortest_route][-2], 0])\n                    if old_dist > new_dist:\n                        new_solution[shortest_route] = np.concatenate((new_solution[shortest_route][:-1], [customer], [0]))\n                        new_solution[longest_route] = np.concatenate((new_solution[longest_route][:customer_pos], new_solution[longest_route][customer_pos+1:]))\n                        break\n\n        # Step 3: Demand-aware reshuffling\n        if len(new_solution) > 2:\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n            demand1, demand2 = np.sum(demand[route1[1:-1]]), np.sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > 0.2 * capacity:\n                for split1 in range(1, len(route1)-1):\n                    for split2 in range(1, len(route2)-1):\n                        part1 = route1[1:split1]\n                        part2 = route2[1:split2]\n                        new_demand1 = demand1 - np.sum(demand[part1]) + np.sum(demand[part2])\n                        new_demand2 = demand2 - np.sum(demand[part2]) + np.sum(demand[part1])\n                        if (new_demand1 <= capacity and new_demand2 <= capacity and\n                            abs(new_demand1 - new_demand2) < abs(demand1 - demand2)):\n                            new_route1 = np.concatenate(([0], part1, route2[split2:-1], route1[split1:-1], [0]))\n                            new_route2 = np.concatenate(([0], part2, route1[split1:-1], route2[split2:-1], [0]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                    else:\n                        continue\n                    break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7904515528208966,
            0.8658688962459564
        ],
        "raw_score": [
            58.1234035683554,
            7.636296895092969
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the best makespan from the archive and applies a hybrid local search combining route merging, 2-opt, and demand-based customer reinsertion to reduce both total distance and makespan while ensuring feasibility. It prioritizes high-demand customers and route merging when feasible, followed by 2-opt for local optimization, and finally reinserts unassigned customers into the longest route to balance makespan. The solution ensures capacity constraints are never violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Apply hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes to merge (if feasible)\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible in terms of capacity\n        total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes (excluding depots)\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Step 2: Apply 2-opt on a randomly selected route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depots\n        if len(route) >= 2:\n            i, j = sorted(random.sample(range(len(route)), 2))\n            # Reverse the segment between i and j\n            new_segment = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Step 3: Reinsert high-demand customers to balance routes\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Find the route with the highest makespan\n        makespans = [sum(distance_matrix[np.concatenate([route[:-1], route[1:]])]) for route in new_solution]\n        target_route_idx = np.argmax(makespans)\n        target_route = new_solution[target_route_idx]\n\n        # Try to insert unassigned customers with highest demand first\n        unassigned_customers.sort(key=lambda x: -demand[x])\n        for customer in unassigned_customers:\n            best_pos = -1\n            best_increase = float('inf')\n\n            # Find the best insertion position in the target route\n            for i in range(len(target_route) - 1):\n                # Check capacity constraint\n                current_demand = sum(demand[target_route[1:-1]])\n                if current_demand + demand[customer] <= capacity:\n                    # Calculate the increase in distance\n                    dist_increase = (distance_matrix[target_route[i], customer] +\n                                    distance_matrix[customer, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(target_route, best_pos, customer)\n                new_solution[target_route_idx] = new_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.2571794216643792,
            0.4204300045967102
        ],
        "raw_score": [
            31.856981161376098,
            3.5915282607247287
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined total distance and makespan from the archive, then applies a hybrid local search that fragments routes, shuffles customers, and rebuilds routes while respecting capacity constraints, prioritizing the most promising solutions for improvement. The key design ideas are: (1) intelligent solution selection based on aggregated objective values, and (2) a capacity-aware route reconstruction strategy that ensures feasibility while introducing randomness for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: route fragmentation + customer reinsertion\n    new_solution = []\n    all_customers = []\n\n    # Collect all customers from all routes\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])  # Exclude depot\n\n    # Shuffle customers for randomness\n    random.shuffle(all_customers)\n\n    # Rebuild routes with capacity checks\n    current_route = [0]\n    current_load = 0\n\n    for customer in all_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # If no routes were created (edge case), return original\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6697742146086336,
            0.45303669571876526
        ],
        "raw_score": [
            51.746525783600006,
            6.140857876814449
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the best total distance from the archive and applies a hybrid local search combining route splitting (based on demand imbalance), a novel cluster-based 2-opt (optimizing spatial proximity), and demand-based customer relocation between routes (balancing vehicle loads). It prioritizes reducing makespan by splitting overloaded routes and improving total distance through spatial-aware optimizations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][0])\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Route Splitting based on demand imbalance\n    if len(new_solution) > 0:\n        # Find the route with the highest demand\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        target_route_idx = np.argmax(demands)\n        target_route = new_solution[target_route_idx]\n\n        # Find the customer with the highest demand in this route\n        customers = target_route[1:-1]\n        if len(customers) > 0:\n            customer_demands = [(c, demand[c]) for c in customers]\n            customer_demands.sort(key=lambda x: -x[1])\n            split_customer = customer_demands[0][0]\n\n            # Split the route at this customer\n            split_idx = np.where(target_route == split_customer)[0][0]\n            new_route1 = np.concatenate([target_route[:split_idx+1], [0]])\n            new_route2 = np.concatenate([[0], target_route[split_idx:]])\n\n            # Replace the original route with the two new routes\n            new_solution.pop(target_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    # Step 2: Cluster-based 2-opt (considering spatial proximity)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx][1:-1]  # Exclude depots\n\n        if len(route) >= 2:\n            # Find two customers that are close in space but not necessarily adjacent\n            customer_coords = coords[route]\n            distances = np.linalg.norm(customer_coords[:, np.newaxis, :] - customer_coords[np.newaxis, :, :], axis=2)\n            np.fill_diagonal(distances, np.inf)\n            i, j = np.unravel_index(np.argmin(distances), distances.shape)\n\n            # Ensure i < j for proper segment reversal\n            if i > j:\n                i, j = j, i\n\n            # Reverse the segment between i and j\n            new_segment = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n            new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Step 3: Demand-based customer relocation between routes\n    if len(new_solution) > 1:\n        # Find the two most imbalanced routes\n        demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_indices = np.argsort(demands)\n        source_route_idx = sorted_indices[-1]  # Most loaded route\n        target_route_idx = sorted_indices[0]  # Least loaded route\n\n        source_route = new_solution[source_route_idx]\n        target_route = new_solution[target_route_idx]\n\n        # Find the customer with the highest demand in the source route\n        customers = source_route[1:-1]\n        if len(customers) > 0:\n            customer_demands = [(c, demand[c]) for c in customers]\n            customer_demands.sort(key=lambda x: -x[1])\n            customer_to_move = customer_demands[0][0]\n\n            # Check if moving this customer to the target route is feasible\n            source_demand = sum(demand[source_route[1:-1]])\n            target_demand = sum(demand[target_route[1:-1]])\n            if target_demand + demand[customer_to_move] <= capacity:\n                # Remove customer from source route\n                mask = source_route != customer_to_move\n                new_source_route = source_route[mask]\n\n                # Insert customer into target route at the best position\n                best_pos = -1\n                best_increase = float('inf')\n\n                for i in range(len(target_route) - 1):\n                    dist_increase = (distance_matrix[target_route[i], customer_to_move] +\n                                    distance_matrix[customer_to_move, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n                    if dist_increase < best_increase:\n                        best_increase = dist_increase\n                        best_pos = i + 1\n\n                if best_pos != -1:\n                    new_target_route = np.insert(target_route, best_pos, customer_to_move)\n                    new_solution[source_route_idx] = new_source_route\n                    new_solution[target_route_idx] = new_target_route\n\n    # Ensure all routes are feasible\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7196664685669433,
            0.6482102572917938
        ],
        "raw_score": [
            57.69770042862447,
            7.714377659263765
        ]
    },
    {
        "algorithm": "The algorithm dynamically alternates between distance-focused and makespan-focused selection from the archive, then applies a hybrid local search combining demand-aware route splitting, capacity-constrained segment swaps, and adaptive customer reinsertion, prioritizing solutions with balanced objectives while ensuring feasibility through incremental validation. It alternates between prioritizing total distance (first two iterations) and makespan (next two iterations) during selection, and uses a multi-step local search that first splits long routes with unbalanced demands, then performs segment swaps between routes to improve both distance and makespan, followed by adaptive customer reinsertion to further optimize the solution structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    iteration = len(archive) % 4\n    if iteration < 2:\n        weights = (0.8, 0.2)  # Distance-focused\n    else:\n        weights = (0.2, 0.8)  # Makespan-focused\n\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Demand-aware route splitting with makespan improvement\n        makespans = [sum(distance_matrix[r[i], r[i+1]] for i in range(len(r)-1)) for r in new_solution]\n        max_makespan = max(makespans)\n\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3 and makespans[route_idx] > 0.9 * max_makespan:\n                total_demand = np.sum(demand[route[1:-1]])\n                for split_pos in range(1, len(route)-1):\n                    first_part_demand = np.sum(demand[route[1:split_pos]])\n                    if abs(first_part_demand - (total_demand - first_part_demand)) > 0.3 * total_demand:\n                        first_part = route[:split_pos+1]\n                        second_part = route[split_pos:]\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            new_solution[route_idx] = first_part\n                            new_solution.insert(route_idx+1, second_part)\n                            break\n\n        # Step 2: Capacity-constrained segment swaps\n        for _ in range(2):  # Try multiple swaps\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[idx1], new_solution[idx2]\n\n            for split1 in range(1, len(route1)-1):\n                for split2 in range(1, len(route2)-1):\n                    part1 = route1[1:split1]\n                    part2 = route2[1:split2]\n                    if (np.sum(demand[part1]) <= capacity - np.sum(demand[route2[1:-1]]) + np.sum(demand[part2]) and\n                        np.sum(demand[part2]) <= capacity - np.sum(demand[route1[1:-1]]) + np.sum(demand[part1])):\n                        # Calculate makespan improvement potential\n                        old_dist = (distance_matrix[route1[split1-1], route1[split1]] +\n                                   distance_matrix[route2[split2-1], route2[split2]])\n                        new_dist = (distance_matrix[route1[split1-1], route2[split2]] +\n                                   distance_matrix[route2[split2-1], route1[split1]])\n                        if new_dist < old_dist:\n                            new_route1 = np.concatenate((route1[:split1], route2[split2:-1], route1[split1:]))\n                            new_route2 = np.concatenate((route2[:split2], route1[split1:-1], route2[split2:]))\n                            new_solution[idx1] = new_route1\n                            new_solution[idx2] = new_route2\n                            break\n                else:\n                    continue\n                break\n\n        # Step 3: Adaptive customer reinsertion\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                candidate_pos = random.randint(1, len(route)-2)\n                customer = route[candidate_pos]\n\n                # Try reinserting into other routes\n                for other_idx in range(len(new_solution)):\n                    if other_idx != route_idx:\n                        other_route = new_solution[other_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate potential improvement\n                            old_dist = (distance_matrix[route[candidate_pos-1], customer] +\n                                      distance_matrix[customer, route[candidate_pos+1]] -\n                                      distance_matrix[route[candidate_pos-1], route[candidate_pos+1]])\n                            new_dist = (distance_matrix[other_route[-2], customer] +\n                                      distance_matrix[customer, 0] -\n                                      distance_matrix[other_route[-2], 0])\n                            if new_dist < old_dist:\n                                new_solution[other_idx] = np.concatenate((other_route[:-1], [customer], [0]))\n                                new_solution[route_idx] = np.concatenate((route[:candidate_pos], route[candidate_pos+1:]))\n                                break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.732739139460205,
            3.2730793952941895
        ],
        "raw_score": [
            58.31340533238172,
            7.84913809031286
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = len(archive) // 2  # Select a middle solution to promote diversity\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route reshaping: dynamically reshape a route by removing and reinserting segments\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:  # Ensure the route has enough customers to reshape\n            # Randomly select a segment to remove and reinsert\n            start_pos = random.randint(1, len(selected_route) - 3)\n            end_pos = random.randint(start_pos + 1, len(selected_route) - 2)\n            removed_segment = selected_route[start_pos:end_pos + 1]\n            remaining_route = np.concatenate([selected_route[:start_pos], selected_route[end_pos + 1:]])\n\n            # Try to reinsert the segment into a different position in the same route\n            best_pos = -1\n            best_increase = float('inf')\n\n            for i in range(len(remaining_route) - 1):\n                # Calculate the increase in distance\n                dist_increase = (distance_matrix[remaining_route[i], removed_segment[0]] +\n                                distance_matrix[removed_segment[-1], remaining_route[i+1]] -\n                                distance_matrix[remaining_route[i], remaining_route[i+1]])\n                if dist_increase < best_increase:\n                    best_increase = dist_increase\n                    best_pos = i + 1\n\n            if best_pos != -1:\n                new_route = np.insert(remaining_route, best_pos, removed_segment)\n                new_solution[route_idx] = new_route\n\n    # Demand-aware customer reallocation: reassign customers based on demand and spatial proximity\n    all_customers = set()\n    for route in new_solution:\n        all_customers.update(route[1:-1])\n    unassigned_customers = [c for c in range(1, len(demand)) if c not in all_customers]\n\n    if unassigned_customers:\n        # Sort customers by demand in descending order\n        unassigned_customers.sort(key=lambda x: -demand[x])\n\n        for customer in unassigned_customers:\n            best_route = -1\n            best_pos = -1\n            best_increase = float('inf')\n\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                current_demand = sum(demand[route[1:-1]])\n\n                if current_demand + demand[customer] <= capacity:\n                    for i in range(len(route) - 1):\n                        # Calculate the increase in distance\n                        dist_increase = (distance_matrix[route[i], customer] +\n                                        distance_matrix[customer, route[i+1]] -\n                                        distance_matrix[route[i], route[i+1]])\n                        if dist_increase < best_increase:\n                            best_increase = dist_increase\n                            best_route = route_idx\n                            best_pos = i + 1\n\n            if best_route != -1:\n                new_route = np.insert(new_solution[best_route], best_pos, customer)\n                new_solution[best_route] = new_route\n\n    # Ensure the solution remains feasible\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5508758633378769,
            0.6243339776992798
        ],
        "raw_score": [
            49.4207769627197,
            6.346335107487226
        ]
    },
    {
        "algorithm": "The algorithm implements a three-phase local search strategy for the Bi-CVRP, prioritizing balanced solutions (Phase 1), distance optimization (Phase 2), and novel route fusion (Phase 3). It dynamically selects customers to relocate between routes based on demand compatibility and spatial proximity, with a focus on reducing makespan and total distance while ensuring capacity constraints. The route fusion operator merges underutilized routes to improve solution quality, with careful validation of feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))  # Select solution with most balanced objectives\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Demand-aware route reshaping (focus on makespan)\n    if len(new_solution) > 1:\n        # Select the longest route (potential makespan bottleneck)\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        route_idx = np.argmax(route_lengths)\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Identify customers that could reduce route length when relocated\n            for i in range(1, len(selected_route) - 1):\n                customer = selected_route[i]\n                # Find the best insertion position in any other route\n                best_route = -1\n                best_pos = -1\n                best_improvement = 0\n\n                for r in range(len(new_solution)):\n                    if r == route_idx:\n                        continue\n                    other_route = new_solution[r]\n                    current_demand = sum(demand[other_route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        for j in range(len(other_route) - 1):\n                            # Calculate potential improvement in distance\n                            improvement = (distance_matrix[other_route[j], customer] +\n                                          distance_matrix[customer, other_route[j+1]] -\n                                          distance_matrix[other_route[j], other_route[j+1]])\n\n                            if improvement < best_improvement:\n                                best_improvement = improvement\n                                best_route = r\n                                best_pos = j + 1\n\n                if best_route != -1:\n                    # Perform the move\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[route_idx] = np.delete(selected_route, i)\n                    break  # Only move one customer at a time\n\n    # Phase 2: Spatial-aware customer reallocation (focus on distance)\n    if len(new_solution) > 1:\n        # Select a random route to potentially improve\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            # Find the customer whose removal would most reduce route length\n            best_customer = -1\n            best_reduction = 0\n\n            for i in range(1, len(selected_route) - 1):\n                customer = selected_route[i]\n                reduction = (distance_matrix[selected_route[i-1], selected_route[i+1]] -\n                            distance_matrix[selected_route[i-1], customer] -\n                            distance_matrix[customer, selected_route[i+1]])\n\n                if reduction > best_reduction:\n                    best_reduction = reduction\n                    best_customer = i\n\n            if best_customer != -1:\n                customer = selected_route[best_customer]\n                # Try to reinsert this customer into another route\n                best_route = -1\n                best_pos = -1\n                best_improvement = 0\n\n                for r in range(len(new_solution)):\n                    if r == route_idx:\n                        continue\n                    other_route = new_solution[r]\n                    current_demand = sum(demand[other_route[1:-1]])\n\n                    if current_demand + demand[customer] <= capacity:\n                        for j in range(len(other_route) - 1):\n                            # Calculate potential improvement in distance\n                            improvement = (distance_matrix[other_route[j], customer] +\n                                          distance_matrix[customer, other_route[j+1]] -\n                                          distance_matrix[other_route[j], other_route[j+1]])\n\n                            if improvement < best_improvement:\n                                best_improvement = improvement\n                                best_route = r\n                                best_pos = j + 1\n\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[route_idx] = np.delete(selected_route, best_customer)\n\n    # Phase 3: Route fusion (novel operator)\n    if len(new_solution) > 2:\n        # Identify the two most underutilized routes\n        utilization = [sum(demand[route[1:-1]]) / capacity for route in new_solution]\n        sorted_indices = sorted(range(len(utilization)), key=lambda i: utilization[i])\n\n        for i in range(min(2, len(sorted_indices))):\n            route_idx = sorted_indices[i]\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Try to merge this route with another\n                for other_idx in range(len(new_solution)):\n                    if other_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_idx]\n\n                    # Check if merging is feasible\n                    if sum(demand[route[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                        # Calculate the best merge point\n                        best_pos = -1\n                        best_distance = float('inf')\n\n                        for j in range(len(other_route) - 1):\n                            # Calculate the distance of the merged route\n                            merged_route = np.concatenate([\n                                other_route[:j+1],\n                                route[1:-1],\n                                other_route[j+1:]\n                            ])\n                            dist = np.sum(distance_matrix[merged_route[:-1], merged_route[1:]])\n\n                            if dist < best_distance:\n                                best_distance = dist\n                                best_pos = j\n\n                        if best_pos != -1:\n                            # Perform the merge\n                            merged_route = np.concatenate([\n                                other_route[:best_pos+1],\n                                route[1:-1],\n                                other_route[best_pos+1:]\n                            ])\n                            new_solution[other_idx] = merged_route\n                            del new_solution[route_idx]\n                            break\n\n    # Ensure the solution remains feasible\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7212838099716907,
            9.712263315916061
        ],
        "raw_score": [
            55.29715789056763,
            7.465192311468993
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on objective diversity (prioritizing distance or makespan improvement), then applies a hybrid local search combining route merging (for makespan reduction), demand-balancing relocations, and spatial clustering optimizations, with operator selection based on current solution characteristics (e.g., high makespan or demand imbalance), while ensuring feasibility through capacity checks and rigorous acceptance criteria.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity metrics\n        distances = np.array([sol[1][0] for sol in archive])\n        makespans = np.array([sol[1][1] for sol in archive])\n        dist_std = np.std(distances)\n        makespan_std = np.std(makespans)\n\n        # Weight selection based on diversity\n        if dist_std > makespan_std:\n            weights = (0.6, 0.4)  # Prefer distance improvement\n        else:\n            weights = (0.4, 0.6)  # Prefer makespan improvement\n\n        selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search with dynamic operator selection\n    if len(new_solution) > 1:\n        # Determine which operator to apply based on current solution characteristics\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        avg_length = np.mean(route_lengths)\n        max_length = max(route_lengths)\n\n        # Operator selection criteria\n        if max_length > 1.5 * avg_length:  # Makespan is problematic\n            operator = \"merge\"\n        elif any(sum(demand[route[1:-1]]) > 0.8 * capacity for route in new_solution):  # Demand imbalance\n            operator = \"relocate\"\n        else:  # Default to spatial optimization\n            operator = \"cluster\"\n\n        # Apply selected operator\n        if operator == \"merge\":\n            # Merge two routes to reduce makespan\n            route_idx1, route_idx2 = sorted(random.sample(range(len(new_solution)), 2), key=lambda i: len(new_solution[i]))\n            route1 = new_solution[route_idx1]\n            route2 = new_solution[route_idx2]\n\n            # Check capacity feasibility\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Find best merge point to minimize distance increase\n                best_merge = None\n                best_increase = float('inf')\n\n                for i in range(1, len(route1)):\n                    for j in range(1, len(route2)):\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[route1[i-1], route2[j]] +\n                                        distance_matrix[route2[j-1], route1[i]] -\n                                        distance_matrix[route1[i-1], route1[i]] -\n                                        distance_matrix[route2[j-1], route2[j]])\n\n                        if dist_increase < best_increase:\n                            best_increase = dist_increase\n                            best_merge = (i, j)\n\n                if best_merge:\n                    i, j = best_merge\n                    merged_route = np.concatenate([route1[:i], route2[j:], route2[:j], route1[i:]])\n                    new_solution[route_idx1] = merged_route\n                    new_solution.pop(route_idx2)\n\n        elif operator == \"relocate\":\n            # Relocate customers between routes to balance demand\n            demands = [sum(demand[route[1:-1]]) for route in new_solution]\n            sorted_indices = np.argsort(demands)\n            source_route_idx = sorted_indices[-1]  # Most loaded route\n            target_route_idx = sorted_indices[0]  # Least loaded route\n\n            source_route = new_solution[source_route_idx]\n            target_route = new_solution[target_route_idx]\n\n            # Find best customer to move\n            best_customer = None\n            best_improvement = 0\n\n            for c in source_route[1:-1]:\n                # Check if moving this customer improves both objectives\n                source_demand = sum(demand[source_route[1:-1]])\n                target_demand = sum(demand[target_route[1:-1]])\n\n                if target_demand + demand[c] <= capacity:\n                    # Calculate potential distance improvement\n                    # Find best insertion position in target route\n                    best_pos = -1\n                    best_dist_increase = float('inf')\n\n                    for i in range(len(target_route) - 1):\n                        dist_increase = (distance_matrix[target_route[i], c] +\n                                        distance_matrix[c, target_route[i+1]] -\n                                        distance_matrix[target_route[i], target_route[i+1]])\n\n                        if dist_increase < best_dist_increase:\n                            best_dist_increase = dist_increase\n                            best_pos = i + 1\n\n                    if best_pos != -1:\n                        # Calculate makespan improvement\n                        original_makespan = max(sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution)\n\n                        # Create temporary solution\n                        temp_solution = [route.copy() for route in new_solution]\n                        temp_source = temp_solution[source_route_idx]\n                        temp_target = temp_solution[target_route_idx]\n\n                        # Remove customer from source\n                        mask = temp_source != c\n                        temp_source = temp_source[mask]\n\n                        # Add customer to target\n                        temp_target = np.insert(temp_target, best_pos, c)\n\n                        # Update routes\n                        temp_solution[source_route_idx] = temp_source\n                        temp_solution[target_route_idx] = temp_target\n\n                        # Calculate new makespan\n                        new_makespan = max(sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in temp_solution)\n\n                        # Calculate improvement (negative means better)\n                        improvement = (best_dist_increase + (original_makespan - new_makespan)) / 2\n\n                        if improvement < best_improvement:\n                            best_improvement = improvement\n                            best_customer = c\n\n            if best_customer is not None:\n                # Perform the relocation\n                c = best_customer\n                source_route = new_solution[source_route_idx]\n                target_route = new_solution[target_route_idx]\n\n                # Remove customer from source\n                mask = source_route != c\n                source_route = source_route[mask]\n\n                # Find best insertion position\n                best_pos = -1\n                best_dist_increase = float('inf')\n\n                for i in range(len(target_route) - 1):\n                    dist_increase = (distance_matrix[target_route[i], c] +\n                                    distance_matrix[c, target_route[i+1]] -\n                                    distance_matrix[target_route[i], target_route[i+1]])\n\n                    if dist_increase < best_dist_increase:\n                        best_dist_increase = dist_increase\n                        best_pos = i + 1\n\n                if best_pos != -1:\n                    target_route = np.insert(target_route, best_pos, c)\n\n                # Update routes\n                new_solution[source_route_idx] = source_route\n                new_solution[target_route_idx] = target_route\n\n        else:  # cluster operator\n            # Spatial clustering optimization\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx][1:-1]  # Exclude depots\n\n            if len(route) >= 2:\n                # Find two customers that are close in space but not necessarily adjacent\n                customer_coords = coords[route]\n                distances = np.linalg.norm(customer_coords[:, np.newaxis, :] - customer_coords[np.newaxis, :, :], axis=2)\n                np.fill_diagonal(distances, np.inf)\n\n                # Find the closest pair\n                i, j = np.unravel_index(np.argmin(distances), distances.shape)\n\n                # Ensure i < j for proper segment reversal\n                if i > j:\n                    i, j = j, i\n\n                # Check if reversing this segment improves both objectives\n                original_distance = sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                original_segment = sum(distance_matrix[route[k], route[k+1]] for k in range(i, j))\n\n                # Calculate new segment distance\n                new_segment = route[i:j+1][::-1]\n                new_distance = sum(distance_matrix[new_segment[k], new_segment[k+1]] for k in range(len(new_segment)-1))\n\n                # Calculate potential makespan change\n                original_makespan = max(sum(distance_matrix[r[k], r[k+1]] for k in range(len(r)-1)) for r in new_solution)\n                current_route_length = sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n                new_route_length = current_route_length - original_segment + new_distance\n\n                # Only accept if both objectives don't worsen\n                if new_route_length <= current_route_length and new_route_length <= original_makespan:\n                    new_segment = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n                    new_solution[route_idx] = np.concatenate([[0], new_segment, [0]])\n\n    # Remove empty routes and ensure feasibility\n    new_solution = [route for route in new_solution if len(route) > 2]\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated infeasible solution!\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5480909763070547,
            10.581055253744125
        ],
        "raw_score": [
            54.42076111276464,
            6.686727397347566
        ]
    }
]