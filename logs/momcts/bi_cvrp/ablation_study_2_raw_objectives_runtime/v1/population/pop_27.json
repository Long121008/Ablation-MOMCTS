[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objectives (prioritizing total distance), then applies a hybrid local search that combines route splitting, customer relocation, and capacity-aware swaps to generate a feasible neighbor solution while ensuring vehicle capacity constraints are met. The method intelligently alternates between these operations when standard improvements fail, aiming to balance both objectives in the Bi-CVRP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.7, 0.3)  # Prefer solutions with lower total distance\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, customer relocation, and capacity-aware swaps\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split or modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two (if feasible)\n        if len(selected_route) > 3:  # Ensure the route has enough customers to split\n            split_pos = random.randint(1, len(selected_route) - 2)\n            first_part = selected_route[:split_pos + 1]\n            second_part = selected_route[split_pos:]\n\n            # Check capacity feasibility for both parts\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n            else:\n                # Step 3: If splitting fails, try to relocate a customer to another route\n                if len(new_solution) > 1:\n                    other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                    other_route = new_solution[other_route_idx]\n                    customer_pos = random.randint(1, len(selected_route) - 2)\n                    customer = selected_route[customer_pos]\n\n                    # Check if adding the customer to the other route is feasible\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        other_route.insert(-1, customer)\n                        selected_route = np.delete(selected_route, customer_pos)\n\n                        # Update the routes\n                        new_solution[route_idx] = selected_route\n                        new_solution[other_route_idx] = other_route\n                    else:\n                        # Step 4: If relocation fails, try a capacity-aware swap between two routes\n                        if len(new_solution) > 1:\n                            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n                            other_route = new_solution[other_route_idx]\n\n                            # Find customers to swap (ensuring capacity constraints)\n                            for i in range(1, len(selected_route) - 1):\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[selected_route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[selected_route[1:-1]]) + demand[selected_route[i]]):\n                                        # Perform the swap\n                                        selected_route[i], other_route[j] = other_route[j], selected_route[i]\n                                        new_solution[route_idx] = selected_route\n                                        new_solution[other_route_idx] = other_route\n                                        break\n                                else:\n                                    continue\n                                break\n\n    # Ensure the solution remains feasible (remove empty routes)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736366851811576,
            0.10219168663024902
        ],
        "raw_score": [
            57.98495804987505,
            7.682986512791148
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower makespan (weighted 0.6 vs. 0.4 for total distance), then applies a hybrid local search combining route splitting, demand-balanced reallocation, and angle-aware edge swaps to improve both objectives while ensuring feasibility. It first attempts to split routes at balanced demand points, then uses geometric angle analysis to guide customer swaps, and finally removes empty routes. The approach balances exploration of route structure with geometric intuition to improve efficiency and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.4, 0.6)  # Prioritize solutions with lower makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to potentially split\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        # Step 2: Try to split the route into two balanced routes\n        if len(selected_route) > 4:\n            split_pos = len(selected_route) // 2\n            route1 = selected_route[:split_pos + 1]\n            route2 = selected_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 3: If splitting fails, try reallocating customers based on demand balance\n                total_demand = np.sum(demand[selected_route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(selected_route) - 1):\n                    current_demand += demand[selected_route[i]]\n                    if current_demand >= target_demand:\n                        split_pos = i\n                        break\n\n                route1 = selected_route[:split_pos + 1]\n                route2 = selected_route[split_pos:]\n\n                if (np.sum(demand[route1[1:-1]]) <= capacity and\n                    np.sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                else:\n                    # Step 4: If reallocation fails, try angle-aware edge swaps\n                    for i in range(1, len(selected_route) - 1):\n                        for j in range(i + 1, len(selected_route) - 1):\n                            # Calculate angle between edges\n                            vec1 = coords[selected_route[i]] - coords[selected_route[i-1]]\n                            vec2 = coords[selected_route[j]] - coords[selected_route[i-1]]\n                            angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2)))\n\n                            if angle > np.pi / 2:  # If angle is obtuse, swap might reduce distance\n                                # Check capacity constraints\n                                if (demand[selected_route[i]] <= capacity - np.sum(demand[selected_route[1:i]]) + demand[selected_route[j]] and\n                                    demand[selected_route[j]] <= capacity - np.sum(demand[selected_route[i+1:j]]) + demand[selected_route[i]]):\n                                    selected_route[i], selected_route[j] = selected_route[j], selected_route[i]\n                                    new_solution[route_idx] = selected_route\n                                    break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7626046040934145,
            0.21666795015335083
        ],
        "raw_score": [
            57.38218004043512,
            7.516075889345629
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive using crowding-distance-aware selection to prioritize diverse solutions, then applies a hybrid local search that alternates between angle-based route reshuffling (for makespan optimization) and demand-aware swaps (for distance optimization), while ensuring feasibility through capacity checks and spatial constraints, with a fallback mechanism for large-scale route restructuring when standard operations fail. The approach balances both objectives by dynamically switching between spatial and demand-based improvements, with higher priority given to spatial clustering for makespan reduction and proximity-based swaps for distance optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([sol[1] for sol in archive])\n        crowding_dist = np.zeros(len(archive))\n\n        for obj_idx in range(2):\n            sorted_idx = np.argsort(objectives[:, obj_idx])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Spatial-geometric route reshuffling (angle-based clustering for makespan)\n        if random.random() < 0.5:\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Calculate angles for angle-based clustering\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n\n                # Sort customers by angle\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n\n                # Check capacity constraint\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n\n        # Demand-aware capacity-constrained swaps (spatial proximity for distance)\n        else:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Find spatially close customers from different routes\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    # Check spatial proximity\n                    dist = np.linalg.norm(coords[route1[i]] - coords[route2[j]])\n                    if dist < np.mean(distance_matrix) * 0.5:  # Only consider close pairs\n                        # Check demand compatibility\n                        if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                            demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                            # Perform swap\n                            route1[i], route2[j] = route2[j], route1[i]\n                            new_solution[route1_idx] = route1\n                            new_solution[route2_idx] = route2\n                            break\n                else:\n                    continue\n                break\n\n        # Fallback mechanism for large-scale restructuring\n        if random.random() < 0.2:\n            # Identify long routes\n            route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n            longest_route_idx = np.argmax(route_lengths)\n            longest_route = new_solution[longest_route_idx]\n\n            if len(longest_route) > 5:\n                # Split into two balanced parts\n                split_pos = len(longest_route) // 2\n                part1 = np.concatenate((longest_route[:split_pos], [0]))\n                part2 = np.concatenate(([0], longest_route[split_pos:-1]))\n\n                if (np.sum(demand[part1[1:-1]]) <= capacity and\n                    np.sum(demand[part2[1:-1]]) <= capacity):\n                    new_solution[longest_route_idx] = part1\n                    new_solution.insert(longest_route_idx + 1, part2)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9468684497508806,
            1.1366134881973267
        ],
        "raw_score": [
            36.735819564521165,
            4.314131676940484
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest makespan from the archive, then reconstructs routes by prioritizing high-demand customers (sorted in descending order) and reinserting them into new routes while respecting vehicle capacity constraints. This strategy aims to balance capacity utilization and reduce makespan by focusing on customers with larger demands first. The overall structure involves route fragmentation and a demand-weighted reinsertion heuristic.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1], reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    new_solution = []\n    all_customers = []\n\n    for route in selected_solution:\n        all_customers.extend(route[1:-1])\n\n    # Sort customers by demand in descending order to prioritize high-demand customers\n    all_customers.sort(key=lambda x: -demand[x])\n\n    current_route = [0]\n    current_load = 0\n\n    for customer in all_customers:\n        if current_load + demand[customer] <= capacity:\n            current_route.append(customer)\n            current_load += demand[customer]\n        else:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n            current_route = [0, customer]\n            current_load = demand[customer]\n\n    if len(current_route) > 1:\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.816960311744704,
            0.4819713830947876
        ],
        "raw_score": [
            58.1186865918592,
            7.76925883811885
        ]
    },
    {
        "algorithm": "This algorithm selects a solution from the archive using a weighted combination of distance (30%) and makespan (70%), then applies a hybrid local search that includes route merging, demand-balanced splitting, and customer reallocation (triggered 60% of the time) to balance makespan while improving total distance. It prioritizes reducing the longest routes and reallocating customers to better utilize vehicle capacity, ensuring feasibility by strictly enforcing capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.3, 0.7)  # 30% distance, 70% makespan\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Identify routes for targeted operations\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        shortest_route_idx = np.argmin(route_lengths)\n\n        # Step 2: Try route merging if feasible\n        if len(new_solution) > 2:\n            # Select two shortest routes for potential merging\n            route1_idx, route2_idx = sorted(range(len(new_solution)), key=lambda i: len(new_solution[i]))[:2]\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n        # Step 3: Demand-balanced route splitting\n        longest_route = new_solution[longest_route_idx]\n        if len(longest_route) > 3:\n            total_demand = np.sum(demand[longest_route[1:-1]])\n            target_demand = total_demand * 0.6  # Target 60% of demand in first part\n            current_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(longest_route) - 1):\n                current_demand += demand[longest_route[i]]\n                if current_demand >= target_demand:\n                    split_pos = i\n                    break\n\n            first_part = longest_route[:split_pos + 1]\n            second_part = longest_route[split_pos:]\n\n            if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                np.sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[longest_route_idx] = first_part\n                new_solution.insert(longest_route_idx + 1, second_part)\n\n        # Step 4: Customer reallocation with demand balancing\n        if random.random() < 0.6:  # 60% chance to try reallocation\n            # Find route with most excess capacity\n            route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n            excess_capacities = [capacity - d for d in route_demands]\n            donor_idx = np.argmax(excess_capacities)\n\n            if excess_capacities[donor_idx] > 0:\n                donor_route = new_solution[donor_idx]\n                # Find customers that can be moved to other routes\n                for i in reversed(range(1, len(donor_route) - 1)):\n                    customer = donor_route[i]\n                    if demand[customer] <= excess_capacities[donor_idx]:\n                        # Find best route to insert this customer\n                        best_route = -1\n                        best_pos = -1\n                        best_improvement = 0\n\n                        for r in range(len(new_solution)):\n                            if r == donor_idx:\n                                continue\n                            route = new_solution[r]\n                            if np.sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                                continue\n\n                            for pos in range(1, len(route)):\n                                # Calculate potential improvement\n                                improvement = (distance_matrix[route[pos-1]][customer] + distance_matrix[customer][route[pos]] -\n                                             distance_matrix[route[pos-1]][route[pos]] +\n                                             distance_matrix[donor_route[i-1]][donor_route[i+1]] -\n                                             distance_matrix[donor_route[i-1]][customer] -\n                                             distance_matrix[customer][donor_route[i+1]])\n\n                                if improvement < best_improvement:\n                                    best_improvement = improvement\n                                    best_route = r\n                                    best_pos = pos\n\n                        if best_route != -1:\n                            # Perform the move\n                            route = new_solution[best_route]\n                            route = np.insert(route, best_pos, customer)\n                            new_solution[best_route] = route\n                            donor_route = np.delete(donor_route, i)\n                            new_solution[donor_idx] = donor_route\n                            break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.8248165757709953,
            0.7335710227489471
        ],
        "raw_score": [
            58.64121823162057,
            7.814322992703525
        ]
    },
    {
        "algorithm": "The algorithm first selects a solution from the archive with high crowding distance (indicating potential for improvement), then applies a hybrid local search combining demand-weighted route splitting to balance makespan and adaptive angle-based edge insertion to optimize distance while maintaining feasibility. The method prioritizes routes with high demand concentration for splitting and evaluates insertion positions based on angular alignment to minimize detours, dynamically adjusting the search based on route length and capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([s[1] for s in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]\n\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Demand-weighted clustering for makespan balancing\n            demand_weights = demand[route[1:-1]]\n            split_pos = np.argmax(demand_weights) + 1\n\n            route1 = np.concatenate((route[:split_pos+1], [0]))\n            route2 = np.concatenate(([0], route[split_pos+1:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Adaptive angle-based edge insertion\n                for i in range(1, len(route)-1):\n                    best_insertion = None\n                    best_angle = -np.inf\n                    for other_route_idx in range(len(new_solution)):\n                        if other_route_idx != route_idx:\n                            other_route = new_solution[other_route_idx]\n                            for j in range(1, len(other_route)):\n                                if j == len(other_route)-1:\n                                    vec1 = coords[other_route[j]] - coords[other_route[j-1]]\n                                    vec2 = coords[route[i]] - coords[other_route[j-1]]\n                                else:\n                                    vec1 = coords[other_route[j]] - coords[other_route[j-1]]\n                                    vec2 = coords[route[i]] - coords[other_route[j-1]]\n                                angle = np.arccos(np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2) + 1e-10))\n\n                                if angle > best_angle and (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] if j < len(other_route)-1 else True):\n                                    best_angle = angle\n                                    best_insertion = (other_route_idx, j)\n\n                    if best_insertion is not None:\n                        other_route_idx, j = best_insertion\n                        other_route = new_solution[other_route_idx]\n                        if j == len(other_route)-1:\n                            other_route = np.concatenate((other_route[:-1], [route[i]], [0]))\n                        else:\n                            other_route = np.concatenate((other_route[:j+1], [route[i]], other_route[j+1:]))\n                        new_solution[other_route_idx] = other_route\n                        route = np.concatenate((route[:i], route[i+1:]))\n                        new_solution[route_idx] = route\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.8229435262529914,
            0.6118530929088593
        ],
        "raw_score": [
            57.01996069181728,
            7.531724241765126
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([s[1] for s in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]\n\n    selected_idx = np.argmax(crowding)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Alternate between angle-based reshuffling and demand-aware swaps\n        if random.random() < 0.5:\n            # Angle-based reshuffling for makespan optimization\n            route_idx = random.randint(0, len(new_solution)-1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Calculate angles for angle-based clustering\n                depot_coords = coords[0]\n                customer_coords = coords[route[1:-1]]\n                angles = np.arctan2(customer_coords[:,1] - depot_coords[1], customer_coords[:,0] - depot_coords[0])\n\n                # Sort customers by angle\n                sorted_indices = np.argsort(angles)\n                sorted_route = route[1:-1][sorted_indices]\n                sorted_route = np.concatenate(([0], sorted_route, [0]))\n\n                # Check capacity constraint\n                if np.sum(demand[sorted_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = sorted_route\n        else:\n            # Demand-aware swaps for distance optimization\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Find customers with compatible demands\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    if (demand[route1[i]] <= capacity - np.sum(demand[route2[1:-1]]) + demand[route2[j]] and\n                        demand[route2[j]] <= capacity - np.sum(demand[route1[1:-1]]) + demand[route1[i]]):\n                        # Perform swap\n                        route1[i], route2[j] = route2[j], route1[i]\n                        new_solution[route1_idx] = route1\n                        new_solution[route2_idx] = route2\n                        break\n                else:\n                    continue\n                break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8658725488704215,
            1.793966919183731
        ],
        "raw_score": [
            38.328083354733764,
            4.701085612221401
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive with a weighted preference for lower total distance (50%) over makespan (50%), then applies a hybrid local search combining route splitting, demand-aware relocations, and capacity-adaptive swaps to balance both objectives while ensuring feasibility. It intelligently alternates between operations when standard improvements fail, always enforcing capacity constraints. The solution is iteratively refined by randomly selecting promising routes and applying the most effective feasible transformation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = (0.5, 0.5)\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:\n            # Step 1: Try to split the route into two\n            split_pos = random.randint(2, len(route) - 3)\n            route1 = np.concatenate((route[:split_pos], [0]))\n            route2 = np.concatenate(([0], route[split_pos:-1]))\n\n            if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n                new_solution[route_idx] = route1\n                new_solution.insert(route_idx + 1, route2)\n            else:\n                # Step 2: If splitting fails, try to relocate a customer to another route\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != route_idx:\n                        other_route = new_solution[other_route_idx]\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            other_route = np.insert(other_route, -1, customer)\n                            route = np.delete(route, customer_pos)\n\n                            new_solution[route_idx] = route\n                            new_solution[other_route_idx] = other_route\n                            break\n                else:\n                    # Step 3: If relocation fails, try a capacity-adaptive swap\n                    for i in range(1, len(route) - 1):\n                        for other_route_idx in range(len(new_solution)):\n                            if other_route_idx != route_idx:\n                                other_route = new_solution[other_route_idx]\n                                for j in range(1, len(other_route) - 1):\n                                    if (demand[route[i]] <= capacity - np.sum(demand[other_route[1:-1]]) + demand[other_route[j]] and\n                                        demand[other_route[j]] <= capacity - np.sum(demand[route[1:-1]]) + demand[route[i]]):\n                                        old_dist = (distance_matrix[route[i-1]][route[i]] + distance_matrix[route[i]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][other_route[j]] + distance_matrix[other_route[j]][other_route[j+1]])\n                                        new_dist = (distance_matrix[route[i-1]][other_route[j]] + distance_matrix[other_route[j]][route[i+1]] +\n                                                   distance_matrix[other_route[j-1]][route[i]] + distance_matrix[route[i]][other_route[j+1]])\n\n                                        if new_dist < old_dist:\n                                            route[i], other_route[j] = other_route[j], route[i]\n                                            new_solution[route_idx] = route\n                                            new_solution[other_route_idx] = other_route\n                                            break\n                                else:\n                                    continue\n                                break\n                        else:\n                            continue\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7039234633235187,
            0.1366652548313141
        ],
        "raw_score": [
            58.0593097506559,
            7.644695851627934
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a promising solution from the archive based on trade-off ratios, then applies a two-phase transformation: first partitioning customers into angular sectors to optimize makespan, followed by demand-aware route consolidation to refine distance, while always maintaining feasibility through capacity checks. The method prioritizes spatial clustering in Phase 1 and demand balancing in Phase 2, with iterative merging decisions based on distance improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    trade_off_ratios = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(trade_off_ratios)\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Angular sector partitioning for makespan optimization\n    if len(new_solution) > 1:\n        # Calculate angular sectors for all customers\n        depot_coords = coords[0]\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n        angles = np.arctan2(coords[all_customers, 1] - depot_coords[1],\n                          coords[all_customers, 0] - depot_coords[0])\n\n        # Sort customers by angle\n        sorted_indices = np.argsort(angles)\n        sorted_customers = np.array(all_customers)[sorted_indices]\n\n        # Create new routes by splitting into angular sectors\n        num_sectors = min(len(new_solution), len(sorted_customers))\n        sector_size = len(sorted_customers) // num_sectors\n        new_routes = []\n\n        for i in range(num_sectors):\n            start = i * sector_size\n            end = (i + 1) * sector_size if i < num_sectors - 1 else len(sorted_customers)\n            sector_customers = sorted_customers[start:end]\n\n            if len(sector_customers) > 0 and np.sum(demand[sector_customers]) <= capacity:\n                new_route = np.concatenate(([0], sector_customers, [0]))\n                new_routes.append(new_route)\n\n        if len(new_routes) > 1:\n            new_solution = new_routes\n\n    # Phase 2: Demand-aware route consolidation for distance optimization\n    if len(new_solution) > 2:\n        # Calculate route demands and sort by demand\n        route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n        sorted_routes = sorted(zip(new_solution, route_demands), key=lambda x: x[1])\n        new_solution = [route for route, _ in sorted_routes]\n\n        # Try to merge routes with similar demands\n        merged = True\n        while merged and len(new_solution) > 1:\n            merged = False\n            for i in range(len(new_solution) - 1):\n                if i >= len(new_solution) - 1:\n                    break\n\n                route1, route2 = new_solution[i], new_solution[i+1]\n                demand1, demand2 = sum(demand[route1[1:-1]]), sum(demand[route2[1:-1]])\n\n                if demand1 + demand2 <= capacity:\n                    # Calculate distance improvement\n                    old_dist = (sum(distance_matrix[route1[j], route1[j+1]] for j in range(len(route1)-1)) +\n                               sum(distance_matrix[route2[j], route2[j+1]] for j in range(len(route2)-1)))\n                    new_route = np.concatenate((route1[:-1], route2[1:]))\n                    new_dist = sum(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route)-1))\n\n                    if new_dist < old_dist:\n                        new_solution = new_solution[:i] + [new_route] + new_solution[i+2:]\n                        merged = True\n                        break\n\n    # Ensure all routes are feasible\n    new_solution = [route for route in new_solution if len(route) > 2 and sum(demand[route[1:-1]]) <= capacity]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7595065660994974,
            0.5461699068546295
        ],
        "raw_score": [
            58.245267990149785,
            7.6260714424962135
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using weighted crowding distances to prioritize less explored regions, then applies a hybrid local search that alternates between angle-based reshuffling (for makespan reduction), route splitting (for distance reduction), and demand-aware relocation (for balanced demand distribution), with operator probabilities dynamically adjusted based on success rates. All transformations strictly enforce capacity constraints, and the operator sequence adapts to maintain balance between objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        crowding_distances[sorted_idx[0]] = float('inf')\n        crowding_distances[sorted_idx[-1]] = float('inf')\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_idx[i+1], obj_idx] != objectives[sorted_idx[i-1], obj_idx]:\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx])\n\n    # Dynamic weight adjustment based on crowding distance\n    total_crowding = np.sum(crowding_distances)\n    if total_crowding > 0:\n        weights = (0.4 + 0.3 * (crowding_distances / total_crowding),  # Distance weight\n                  0.6 - 0.3 * (crowding_distances / total_crowding))  # Makespan weight\n    else:\n        weights = (0.5, 0.5)\n\n    # Select solution with highest weighted crowding distance\n    selected_idx = max(range(len(archive)), key=lambda i: weights[0][i] * archive[i][1][0] + weights[1][i] * archive[i][1][1])\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Operator selection probabilities based on recent success rates\n        operator_probs = [0.4, 0.3, 0.3]  # Initial probabilities for reshuffling, splitting, relocation\n        operator_success = [0, 0, 0]\n\n        # Try angle-based reshuffling (makespan reduction)\n        if random.random() < operator_probs[0]:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Calculate angles between consecutive points\n                angles = []\n                for i in range(1, len(route)-1):\n                    vec1 = coords[route[i]] - coords[route[i-1]]\n                    vec2 = coords[route[i+1]] - coords[route[i]]\n                    angle = np.arctan2(np.cross(vec1, vec2), np.dot(vec1, vec2))\n                    angles.append(abs(angle))\n\n                # Find segment with largest angle (most \"curved\")\n                if angles:\n                    max_angle_idx = np.argmax(angles) + 1\n                    segment_start = max(2, max_angle_idx - 2)\n                    segment_end = min(len(route)-2, max_angle_idx + 2)\n\n                    # Try to reverse this segment\n                    reversed_segment = route[segment_start:segment_end][::-1]\n                    if np.sum(demand[reversed_segment]) <= capacity:\n                        new_route = np.concatenate((route[:segment_start], reversed_segment, route[segment_end:]))\n                        new_solution[route_idx] = new_route\n                        operator_success[0] += 1\n\n        # Try route splitting (distance reduction)\n        if random.random() < operator_probs[1] and operator_success[0] == 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                # Find split point that minimizes distance increase\n                min_increase = float('inf')\n                best_split = None\n\n                for split_pos in range(2, len(route)-2):\n                    route1 = route[:split_pos+1]\n                    route2 = route[split_pos-1:]\n\n                    if (np.sum(demand[route1[1:-1]]) <= capacity and\n                        np.sum(demand[route2[1:-1]]) <= capacity):\n                        dist_increase = (distance_matrix[route1[-2]][0] + distance_matrix[route2[-2]][0] -\n                                        distance_matrix[route[split_pos-1]][route[split_pos]])\n\n                        if dist_increase < min_increase:\n                            min_increase = dist_increase\n                            best_split = split_pos\n\n                if best_split is not None:\n                    route1 = route[:best_split+1]\n                    route2 = route[best_split-1:]\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    operator_success[1] += 1\n\n        # Try demand-aware relocation (distance reduction)\n        if random.random() < operator_probs[2] and operator_success[0] == 0 and operator_success[1] == 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3 and len(new_solution) > 1:\n                # Find customer that would best balance demands\n                best_balance = float('inf')\n                best_customer = None\n                best_route = None\n\n                for customer_pos in range(1, len(route)-1):\n                    customer = route[customer_pos]\n                    for other_route_idx in range(len(new_solution)):\n                        if other_route_idx != route_idx:\n                            other_route = new_solution[other_route_idx]\n                            if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                                current_balance = abs(np.sum(demand[route[1:-1]]) - demand[customer] -\n                                                    np.sum(demand[other_route[1:-1]]) - demand[customer])\n                                if current_balance < best_balance:\n                                    best_balance = current_balance\n                                    best_customer = (route_idx, customer_pos, other_route_idx)\n\n                if best_customer is not None:\n                    route_idx, customer_pos, other_route_idx = best_customer\n                    route = new_solution[route_idx]\n                    other_route = new_solution[other_route_idx]\n                    customer = route[customer_pos]\n\n                    other_route = np.insert(other_route, -1, customer)\n                    route = np.delete(route, customer_pos)\n\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n                    operator_success[2] += 1\n\n        # Update operator probabilities based on success\n        total_success = sum(operator_success)\n        if total_success > 0:\n            operator_probs = [p * (0.9 + 0.2 * (s / total_success)) for p, s in zip(operator_probs, operator_success)]\n            operator_probs = [p / sum(operator_probs) for p in operator_probs]\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "metric_score": [
            -0.7898756033744234,
            1.178256869316101
        ],
        "raw_score": [
            57.17352419772169,
            7.4983780820744945
        ]
    }
]