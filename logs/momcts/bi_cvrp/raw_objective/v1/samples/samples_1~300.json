[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower total distance and makespan) and applies a hybrid local search combining route splitting/merging with demand-aware customer reinsertion to balance objectives while ensuring feasibility. It first tries to split long routes or merge compatible routes, then optimizes by moving customers from overloaded routes to underutilized ones. The method intelligently balances exploration (random selection) and exploitation (greedy insertion) to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and demand-aware merging\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(longest_route)-2)\n            route1 = longest_route[:split_pos+1]\n            route2 = longest_route[split_pos:-1]\n            route2 = np.concatenate(([0], route2))\n\n            # Check capacity feasibility\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n    else:\n        # Try to merge two routes if possible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is possible (demand constraint)\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Remove the two routes and add the merged one\n                new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Demand-aware insertion: move a customer from a long route to a short route if possible\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            if len(longest_route) > 3:  # Ensure we can remove a customer\n                # Select a customer to move (not depot)\n                customer_to_move = random.choice(longest_route[1:-1])\n\n                # Check if moving this customer to the shortest route is feasible\n                new_shortest_demand = sum(demand[node] for node in shortest_route[1:-1]) + demand[customer_to_move]\n                if new_shortest_demand <= capacity:\n                    # Remove customer from longest route\n                    new_longest_route = np.array([node for node in longest_route if node != customer_to_move])\n\n                    # Find the best insertion position in the shortest route\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(shortest_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[shortest_route[i-1], customer_to_move] +\n                                distance_matrix[customer_to_move, shortest_route[i]] -\n                                distance_matrix[shortest_route[i-1], shortest_route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    # Insert the customer\n                    new_shortest_route = np.insert(shortest_route, best_insert_pos, customer_to_move)\n\n                    # Update the solution\n                    new_solution[longest_idx] = new_longest_route\n                    new_solution[shortest_idx] = new_shortest_route\n\n    return new_solution\n\n",
        "score": [
            52.18096085122906,
            6.258409247957831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and demand-aware merging\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(longest_route)-2)\n            route1 = longest_route[:split_pos+1]\n            route2 = longest_route[split_pos:-1]\n            route2 = np.concatenate(([0], route2))\n\n            # Check capacity feasibility\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n    else:\n        # Try to merge two routes if possible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is possible (demand constraint)\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Remove the two routes and add the merged one\n                new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Demand-aware insertion: move a customer from a long route to a short route if possible\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            if len(longest_route) > 3:  # Ensure we can remove a customer\n                # Select a customer to move (not depot)\n                customer_to_move = random.choice(longest_route[1:-1])\n\n                # Check if moving this customer to the shortest route is feasible\n                new_shortest_demand = sum(demand[node] for node in shortest_route[1:-1]) + demand[customer_to_move]\n                if new_shortest_demand <= capacity:\n                    # Remove customer from longest route\n                    new_longest_route = np.array([node for node in longest_route if node != customer_to_move])\n\n                    # Find the best insertion position in the shortest route\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(shortest_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[shortest_route[i-1], customer_to_move] +\n                                distance_matrix[customer_to_move, shortest_route[i]] -\n                                distance_matrix[shortest_route[i-1], shortest_route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    # Insert the customer\n                    new_shortest_route = np.insert(shortest_route, best_insert_pos, customer_to_move)\n\n                    # Update the solution\n                    new_solution[longest_idx] = new_longest_route\n                    new_solution[shortest_idx] = new_shortest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower total distance and makespan) and applies a hybrid local search combining route splitting/merging with demand-aware customer reinsertion to balance objectives while ensuring feasibility. It first tries to split long routes or merge compatible routes, then optimizes by moving customers from overloaded routes to underutilized ones. The method intelligently balances exploration (random selection) and exploitation (greedy insertion) to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and demand-aware merging\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(longest_route)-2)\n            route1 = longest_route[:split_pos+1]\n            route2 = longest_route[split_pos:-1]\n            route2 = np.concatenate(([0], route2))\n\n            # Check capacity feasibility\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n    else:\n        # Try to merge two routes if possible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is possible (demand constraint)\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Remove the two routes and add the merged one\n                new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Demand-aware insertion: move a customer from a long route to a short route if possible\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            if len(longest_route) > 3:  # Ensure we can remove a customer\n                # Select a customer to move (not depot)\n                customer_to_move = random.choice(longest_route[1:-1])\n\n                # Check if moving this customer to the shortest route is feasible\n                new_shortest_demand = sum(demand[node] for node in shortest_route[1:-1]) + demand[customer_to_move]\n                if new_shortest_demand <= capacity:\n                    # Remove customer from longest route\n                    new_longest_route = np.array([node for node in longest_route if node != customer_to_move])\n\n                    # Find the best insertion position in the shortest route\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(shortest_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[shortest_route[i-1], customer_to_move] +\n                                distance_matrix[customer_to_move, shortest_route[i]] -\n                                distance_matrix[shortest_route[i-1], shortest_route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    # Insert the customer\n                    new_shortest_route = np.insert(shortest_route, best_insert_pos, customer_to_move)\n\n                    # Update the solution\n                    new_solution[longest_idx] = new_longest_route\n                    new_solution[shortest_idx] = new_shortest_route\n\n    return new_solution\n\n",
        "score": [
            52.18096085122906,
            6.258409247957831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and demand-aware merging\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(longest_route)-2)\n            route1 = longest_route[:split_pos+1]\n            route2 = longest_route[split_pos:-1]\n            route2 = np.concatenate(([0], route2))\n\n            # Check capacity feasibility\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n    else:\n        # Try to merge two routes if possible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is possible (demand constraint)\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Remove the two routes and add the merged one\n                new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Demand-aware insertion: move a customer from a long route to a short route if possible\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            if len(longest_route) > 3:  # Ensure we can remove a customer\n                # Select a customer to move (not depot)\n                customer_to_move = random.choice(longest_route[1:-1])\n\n                # Check if moving this customer to the shortest route is feasible\n                new_shortest_demand = sum(demand[node] for node in shortest_route[1:-1]) + demand[customer_to_move]\n                if new_shortest_demand <= capacity:\n                    # Remove customer from longest route\n                    new_longest_route = np.array([node for node in longest_route if node != customer_to_move])\n\n                    # Find the best insertion position in the shortest route\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(shortest_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[shortest_route[i-1], customer_to_move] +\n                                distance_matrix[customer_to_move, shortest_route[i]] -\n                                distance_matrix[shortest_route[i-1], shortest_route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    # Insert the customer\n                    new_shortest_route = np.insert(shortest_route, best_insert_pos, customer_to_move)\n\n                    # Update the solution\n                    new_solution[longest_idx] = new_longest_route\n                    new_solution[shortest_idx] = new_shortest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower total distance and makespan) and applies a hybrid local search combining route splitting/merging with demand-aware customer reinsertion to balance objectives while ensuring feasibility. It first tries to split long routes or merge compatible routes, then optimizes by moving customers from overloaded routes to underutilized ones. The method intelligently balances exploration (random selection) and exploitation (greedy insertion) to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and demand-aware merging\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(longest_route)-2)\n            route1 = longest_route[:split_pos+1]\n            route2 = longest_route[split_pos:-1]\n            route2 = np.concatenate(([0], route2))\n\n            # Check capacity feasibility\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n    else:\n        # Try to merge two routes if possible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is possible (demand constraint)\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Remove the two routes and add the merged one\n                new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Demand-aware insertion: move a customer from a long route to a short route if possible\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            if len(longest_route) > 3:  # Ensure we can remove a customer\n                # Select a customer to move (not depot)\n                customer_to_move = random.choice(longest_route[1:-1])\n\n                # Check if moving this customer to the shortest route is feasible\n                new_shortest_demand = sum(demand[node] for node in shortest_route[1:-1]) + demand[customer_to_move]\n                if new_shortest_demand <= capacity:\n                    # Remove customer from longest route\n                    new_longest_route = np.array([node for node in longest_route if node != customer_to_move])\n\n                    # Find the best insertion position in the shortest route\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(shortest_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[shortest_route[i-1], customer_to_move] +\n                                distance_matrix[customer_to_move, shortest_route[i]] -\n                                distance_matrix[shortest_route[i-1], shortest_route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    # Insert the customer\n                    new_shortest_route = np.insert(shortest_route, best_insert_pos, customer_to_move)\n\n                    # Update the solution\n                    new_solution[longest_idx] = new_longest_route\n                    new_solution[shortest_idx] = new_shortest_route\n\n    return new_solution\n\n",
        "score": [
            52.18096085122906,
            6.258409247957831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting and demand-aware merging\n    if len(new_solution) > 1 and random.random() < 0.5:\n        # Split a long route into two\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 3:  # Ensure we can split\n            split_pos = random.randint(1, len(longest_route)-2)\n            route1 = longest_route[:split_pos+1]\n            route2 = longest_route[split_pos:-1]\n            route2 = np.concatenate(([0], route2))\n\n            # Check capacity feasibility\n            demand1 = sum(demand[node] for node in route1[1:-1])\n            demand2 = sum(demand[node] for node in route2[1:-1])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[longest_route_idx] = route1\n                new_solution.append(route2)\n    else:\n        # Try to merge two routes if possible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is possible (demand constraint)\n            total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Remove the two routes and add the merged one\n                new_solution = [r for i, r in enumerate(new_solution) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n\n    # Demand-aware insertion: move a customer from a long route to a short route if possible\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            if len(longest_route) > 3:  # Ensure we can remove a customer\n                # Select a customer to move (not depot)\n                customer_to_move = random.choice(longest_route[1:-1])\n\n                # Check if moving this customer to the shortest route is feasible\n                new_shortest_demand = sum(demand[node] for node in shortest_route[1:-1]) + demand[customer_to_move]\n                if new_shortest_demand <= capacity:\n                    # Remove customer from longest route\n                    new_longest_route = np.array([node for node in longest_route if node != customer_to_move])\n\n                    # Find the best insertion position in the shortest route\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(shortest_route)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[shortest_route[i-1], customer_to_move] +\n                                distance_matrix[customer_to_move, shortest_route[i]] -\n                                distance_matrix[shortest_route[i-1], shortest_route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    # Insert the customer\n                    new_shortest_route = np.insert(shortest_route, best_insert_pos, customer_to_move)\n\n                    # Update the solution\n                    new_solution[longest_idx] = new_longest_route\n                    new_solution[shortest_idx] = new_shortest_route\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm prioritizes solutions with the lowest makespan from the archive, then applies a hybrid local search combining route merging (when feasible) and customer reallocation to balance demands, followed by a 2-opt improvement on a randomly selected route while ensuring capacity constraints are met. The method intelligently balances exploration (random selection of routes) and exploitation (merging/reallocation) to improve both total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging is not feasible, try reallocating customers between routes\n            for route in [route_i, route_j]:\n                customers = route[1:-1]\n                for customer in customers:\n                    # Try to move this customer to the other route\n                    other_route = route_j if route is route_i else route_i\n                    temp_route = other_route.copy()\n                    temp_route = np.insert(temp_route, -1, customer)\n                    # Check capacity constraint\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        other_route = temp_route\n                        route = np.delete(route, np.where(route == customer)[0][0])\n                        # Update the solution\n                        if route is route_i:\n                            new_solution[i] = route\n                            new_solution[j] = other_route\n                        else:\n                            new_solution[j] = route\n                            new_solution[i] = other_route\n                        break\n\n    # Additional improvement: 2-opt on a random route (with capacity check)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select two random edges to swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n            # Create the new route\n            new_route = np.concatenate([\n                route[:i],\n                route[j:j+1],\n                route[i+1:j],\n                route[i:i+1],\n                route[j+1:]\n            ])\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            39.72620048677433,
            4.184243484262867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging is not feasible, try reallocating customers between routes\n            for route in [route_i, route_j]:\n                customers = route[1:-1]\n                for customer in customers:\n                    # Try to move this customer to the other route\n                    other_route = route_j if route is route_i else route_i\n                    temp_route = other_route.copy()\n                    temp_route = np.insert(temp_route, -1, customer)\n                    # Check capacity constraint\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        other_route = temp_route\n                        route = np.delete(route, np.where(route == customer)[0][0])\n                        # Update the solution\n                        if route is route_i:\n                            new_solution[i] = route\n                            new_solution[j] = other_route\n                        else:\n                            new_solution[j] = route\n                            new_solution[i] = other_route\n                        break\n\n    # Additional improvement: 2-opt on a random route (with capacity check)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select two random edges to swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n            # Create the new route\n            new_route = np.concatenate([\n                route[:i],\n                route[j:j+1],\n                route[i+1:j],\n                route[i:i+1],\n                route[j+1:]\n            ])\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm prioritizes solutions with the lowest makespan from the archive, then applies a hybrid local search combining route merging (when feasible) and customer reallocation to balance demands, followed by a 2-opt improvement on a randomly selected route while ensuring capacity constraints are met. The method intelligently balances exploration (random selection of routes) and exploitation (merging/reallocation) to improve both total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging is not feasible, try reallocating customers between routes\n            for route in [route_i, route_j]:\n                customers = route[1:-1]\n                for customer in customers:\n                    # Try to move this customer to the other route\n                    other_route = route_j if route is route_i else route_i\n                    temp_route = other_route.copy()\n                    temp_route = np.insert(temp_route, -1, customer)\n                    # Check capacity constraint\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        other_route = temp_route\n                        route = np.delete(route, np.where(route == customer)[0][0])\n                        # Update the solution\n                        if route is route_i:\n                            new_solution[i] = route\n                            new_solution[j] = other_route\n                        else:\n                            new_solution[j] = route\n                            new_solution[i] = other_route\n                        break\n\n    # Additional improvement: 2-opt on a random route (with capacity check)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select two random edges to swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n            # Create the new route\n            new_route = np.concatenate([\n                route[:i],\n                route[j:j+1],\n                route[i+1:j],\n                route[i:i+1],\n                route[j+1:]\n            ])\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            39.72620048677433,
            4.184243484262867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging is not feasible, try reallocating customers between routes\n            for route in [route_i, route_j]:\n                customers = route[1:-1]\n                for customer in customers:\n                    # Try to move this customer to the other route\n                    other_route = route_j if route is route_i else route_i\n                    temp_route = other_route.copy()\n                    temp_route = np.insert(temp_route, -1, customer)\n                    # Check capacity constraint\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        other_route = temp_route\n                        route = np.delete(route, np.where(route == customer)[0][0])\n                        # Update the solution\n                        if route is route_i:\n                            new_solution[i] = route\n                            new_solution[j] = other_route\n                        else:\n                            new_solution[j] = route\n                            new_solution[i] = other_route\n                        break\n\n    # Additional improvement: 2-opt on a random route (with capacity check)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select two random edges to swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n            # Create the new route\n            new_route = np.concatenate([\n                route[:i],\n                route[j:j+1],\n                route[i+1:j],\n                route[i:i+1],\n                route[j+1:]\n            ])\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm prioritizes solutions with the lowest makespan from the archive, then applies a hybrid local search combining route merging (when feasible) and customer reallocation to balance demands, followed by a 2-opt improvement on a randomly selected route while ensuring capacity constraints are met. The method intelligently balances exploration (random selection of routes) and exploitation (merging/reallocation) to improve both total distance and makespan.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging is not feasible, try reallocating customers between routes\n            for route in [route_i, route_j]:\n                customers = route[1:-1]\n                for customer in customers:\n                    # Try to move this customer to the other route\n                    other_route = route_j if route is route_i else route_i\n                    temp_route = other_route.copy()\n                    temp_route = np.insert(temp_route, -1, customer)\n                    # Check capacity constraint\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        other_route = temp_route\n                        route = np.delete(route, np.where(route == customer)[0][0])\n                        # Update the solution\n                        if route is route_i:\n                            new_solution[i] = route\n                            new_solution[j] = other_route\n                        else:\n                            new_solution[j] = route\n                            new_solution[i] = other_route\n                        break\n\n    # Additional improvement: 2-opt on a random route (with capacity check)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select two random edges to swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n            # Create the new route\n            new_route = np.concatenate([\n                route[:i],\n                route[j:j+1],\n                route[i+1:j],\n                route[i:i+1],\n                route[j+1:]\n            ])\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            39.72620048677433,
            4.184243484262867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: route merging and customer reallocation\n    if len(new_solution) > 1:\n        # Randomly select two routes for potential merging\n        route_indices = list(range(len(new_solution)))\n        i, j = random.sample(route_indices, 2)\n\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Check if merging these routes is feasible\n        total_demand = sum(demand[route_i[1:-1]]) + sum(demand[route_j[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n        else:\n            # If merging is not feasible, try reallocating customers between routes\n            for route in [route_i, route_j]:\n                customers = route[1:-1]\n                for customer in customers:\n                    # Try to move this customer to the other route\n                    other_route = route_j if route is route_i else route_i\n                    temp_route = other_route.copy()\n                    temp_route = np.insert(temp_route, -1, customer)\n                    # Check capacity constraint\n                    if sum(demand[temp_route[1:-1]]) <= capacity:\n                        other_route = temp_route\n                        route = np.delete(route, np.where(route == customer)[0][0])\n                        # Update the solution\n                        if route is route_i:\n                            new_solution[i] = route\n                            new_solution[j] = other_route\n                        else:\n                            new_solution[j] = route\n                            new_solution[i] = other_route\n                        break\n\n    # Additional improvement: 2-opt on a random route (with capacity check)\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Need at least 4 nodes for 2-opt\n            # Select two random edges to swap\n            i = random.randint(1, len(route) - 3)\n            j = random.randint(i + 1, len(route) - 2)\n            # Create the new route\n            new_route = np.concatenate([\n                route[:i],\n                route[j:j+1],\n                route[i+1:j],\n                route[i:i+1],\n                route[j+1:]\n            ])\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The algorithm selects the best solution from the archive (sorted by total distance and makespan) and applies a hybrid local search combining route merging, splitting, and demand-based node reinsertion. It prioritizes merging feasible routes first, then splits long routes to balance makespan, and finally reinserts nodes to improve overall distance and route balance while ensuring feasibility. The method intelligently balances exploration (random selection) and exploitation (greedy insertion) to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split, merge, and reinsert nodes\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n            # Merge the routes\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n\n            # Reinsert nodes from the merged route to balance makespan\n            for node in merged_route[1:-1]:\n                # Find the best route to reinsert the node\n                best_route_idx = -1\n                best_insert_cost = float('inf')\n                for i, route in enumerate(new_solution):\n                    if sum(demand[node] for node in route[1:-1]) + demand[node] > capacity:\n                        continue\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], node] + distance_matrix[node, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < best_insert_cost:\n                            best_insert_cost = insert_cost\n                            best_route_idx = i\n                            best_pos = j\n\n                if best_route_idx != -1:\n                    # Reinsert the node\n                    new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, node)\n                    merged_route = np.delete(merged_route, np.where(merged_route == node)[0][0])\n                    new_solution[route1_idx] = merged_route\n\n    # If no merge occurred, perform a split\n    if len(new_solution) == 1 and len(new_solution[0]) > 3:\n        # Find the best split point\n        best_split_cost = float('inf')\n        best_split_pos = -1\n        route = new_solution[0]\n        for i in range(2, len(route)-1):\n            # Calculate the cost of splitting at position i\n            split_cost = distance_matrix[route[i-1], 0] + distance_matrix[0, route[i]] - distance_matrix[route[i-1], route[i]]\n            if split_cost < best_split_cost:\n                best_split_cost = split_cost\n                best_split_pos = i\n\n        if best_split_cost < float('inf'):\n            # Split the route\n            route1 = route[:best_split_pos+1]\n            route2 = np.concatenate(([0], route[best_split_pos:]))\n            new_solution = [route1, route2]\n\n    # Reinsert nodes to improve the solution\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Select a random node to reinsert\n        node_pos = random.randint(1, len(route)-2)\n        node = route[node_pos]\n        # Remove the node\n        route = np.delete(route, node_pos)\n\n        # Find the best route to reinsert the node\n        best_route_idx = -1\n        best_insert_cost = float('inf')\n        for i, r in enumerate(new_solution):\n            if sum(demand[node] for node in r[1:-1]) + demand[node] > capacity:\n                continue\n            for j in range(1, len(r)):\n                insert_cost = distance_matrix[r[j-1], node] + distance_matrix[node, r[j]] - distance_matrix[r[j-1], r[j]]\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_route_idx = i\n                    best_pos = j\n\n        if best_route_idx != -1:\n            # Reinsert the node\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, node)\n            # Update the original route\n            for i, r in enumerate(new_solution):\n                if np.array_equal(r, route):\n                    new_solution[i] = route\n                    break\n\n    return new_solution\n\n",
        "score": [
            57.96978730948722,
            7.811907531642758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_solution = archive[0][0].copy()\n\n    # Create a copy of the selected solution for modification\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: split, merge, and reinsert nodes\n    if len(new_solution) > 1:\n        # Randomly select two routes for merging\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1]) <= capacity:\n            # Merge the routes\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n\n            # Reinsert nodes from the merged route to balance makespan\n            for node in merged_route[1:-1]:\n                # Find the best route to reinsert the node\n                best_route_idx = -1\n                best_insert_cost = float('inf')\n                for i, route in enumerate(new_solution):\n                    if sum(demand[node] for node in route[1:-1]) + demand[node] > capacity:\n                        continue\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], node] + distance_matrix[node, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < best_insert_cost:\n                            best_insert_cost = insert_cost\n                            best_route_idx = i\n                            best_pos = j\n\n                if best_route_idx != -1:\n                    # Reinsert the node\n                    new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, node)\n                    merged_route = np.delete(merged_route, np.where(merged_route == node)[0][0])\n                    new_solution[route1_idx] = merged_route\n\n    # If no merge occurred, perform a split\n    if len(new_solution) == 1 and len(new_solution[0]) > 3:\n        # Find the best split point\n        best_split_cost = float('inf')\n        best_split_pos = -1\n        route = new_solution[0]\n        for i in range(2, len(route)-1):\n            # Calculate the cost of splitting at position i\n            split_cost = distance_matrix[route[i-1], 0] + distance_matrix[0, route[i]] - distance_matrix[route[i-1], route[i]]\n            if split_cost < best_split_cost:\n                best_split_cost = split_cost\n                best_split_pos = i\n\n        if best_split_cost < float('inf'):\n            # Split the route\n            route1 = route[:best_split_pos+1]\n            route2 = np.concatenate(([0], route[best_split_pos:]))\n            new_solution = [route1, route2]\n\n    # Reinsert nodes to improve the solution\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n        # Select a random node to reinsert\n        node_pos = random.randint(1, len(route)-2)\n        node = route[node_pos]\n        # Remove the node\n        route = np.delete(route, node_pos)\n\n        # Find the best route to reinsert the node\n        best_route_idx = -1\n        best_insert_cost = float('inf')\n        for i, r in enumerate(new_solution):\n            if sum(demand[node] for node in r[1:-1]) + demand[node] > capacity:\n                continue\n            for j in range(1, len(r)):\n                insert_cost = distance_matrix[r[j-1], node] + distance_matrix[node, r[j]] - distance_matrix[r[j-1], r[j]]\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_route_idx = i\n                    best_pos = j\n\n        if best_route_idx != -1:\n            # Reinsert the node\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, node)\n            # Update the original route\n            for i, r in enumerate(new_solution):\n                if np.array_equal(r, route):\n                    new_solution[i] = route\n                    break\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search combining route splitting, customer insertion, and merging, ensuring feasibility by checking vehicle capacity constraints at each step. The process involves randomly selecting operations (splitting, reinserting, or merging routes) while evaluating their impact on both objectives, ultimately generating a new, potentially improved neighbor solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, insertion, and merging\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        if len(split_route) > 3:  # Ensure route has customers to split\n            split_pos = random.randint(1, len(split_route) - 2)\n            new_route1 = np.concatenate([split_route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], split_route[split_pos:-1]])\n\n            # Check capacity feasibility\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[split_route_idx] = new_route1\n                new_solution.insert(split_route_idx + 1, new_route2)\n\n    # Step 2: Randomly select a customer to reinsert into another route\n    if len(new_solution) > 1:\n        # Select a random route and customer (excluding depot)\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 2:  # Ensure route has customers to remove\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove customer from current route\n            new_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Find best feasible insertion position in another route\n            best_pos = -1\n            best_cost = float('inf')\n            best_route_idx = -1\n\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                for j in range(1, len(other_route)):\n                    # Insert customer between j-1 and j\n                    insert_cost = (\n                        distance_matrix[other_route[j-1], customer] +\n                        distance_matrix[customer, other_route[j]] -\n                        distance_matrix[other_route[j-1], other_route[j]]\n                    )\n                    # Check capacity\n                    current_demand = np.sum(demand[other_route[1:-1]])\n                    if current_demand + demand[customer] <= capacity and insert_cost < best_cost:\n                        best_cost = insert_cost\n                        best_pos = j\n                        best_route_idx = i\n\n            if best_pos != -1:\n                # Insert customer into best position\n                other_route = new_solution[best_route_idx]\n                new_other_route = np.concatenate([\n                    other_route[:best_pos],\n                    [customer],\n                    other_route[best_pos:]\n                ])\n                new_solution[best_route_idx] = new_other_route\n\n    # Step 3: Randomly merge two routes if feasible\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check capacity feasibility\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by connecting them\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            50.85066267712004,
            6.506053360623335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting, insertion, and merging\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to split\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        if len(split_route) > 3:  # Ensure route has customers to split\n            split_pos = random.randint(1, len(split_route) - 2)\n            new_route1 = np.concatenate([split_route[:split_pos + 1], [0]])\n            new_route2 = np.concatenate([[0], split_route[split_pos:-1]])\n\n            # Check capacity feasibility\n            demand1 = np.sum(demand[new_route1[1:-1]])\n            demand2 = np.sum(demand[new_route2[1:-1]])\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[split_route_idx] = new_route1\n                new_solution.insert(split_route_idx + 1, new_route2)\n\n    # Step 2: Randomly select a customer to reinsert into another route\n    if len(new_solution) > 1:\n        # Select a random route and customer (excluding depot)\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 2:  # Ensure route has customers to remove\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove customer from current route\n            new_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n            new_solution[route_idx] = new_route\n\n            # Find best feasible insertion position in another route\n            best_pos = -1\n            best_cost = float('inf')\n            best_route_idx = -1\n\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                for j in range(1, len(other_route)):\n                    # Insert customer between j-1 and j\n                    insert_cost = (\n                        distance_matrix[other_route[j-1], customer] +\n                        distance_matrix[customer, other_route[j]] -\n                        distance_matrix[other_route[j-1], other_route[j]]\n                    )\n                    # Check capacity\n                    current_demand = np.sum(demand[other_route[1:-1]])\n                    if current_demand + demand[customer] <= capacity and insert_cost < best_cost:\n                        best_cost = insert_cost\n                        best_pos = j\n                        best_route_idx = i\n\n            if best_pos != -1:\n                # Insert customer into best position\n                other_route = new_solution[best_route_idx]\n                new_other_route = np.concatenate([\n                    other_route[:best_pos],\n                    [customer],\n                    other_route[best_pos:]\n                ])\n                new_solution[best_route_idx] = new_other_route\n\n    # Step 3: Randomly merge two routes if feasible\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check capacity feasibility\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge routes by connecting them\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with high makespan or total distance) and applies a hybrid local search combining route splitting, a demand-balanced 2-opt variant, and customer reinsertion to improve both objectives while ensuring capacity feasibility. It intelligently balances exploration (via random selection and reinsertion) with exploitation (via demand-aware 2-opt), and validates feasibility at each step. The key innovations are the demand-aware 2-opt and the reinsertion strategy targeting the longest route.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30%\n    selected = archive_sorted[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if any route exceeds capacity)\n        for i in range(len(solution)):\n            route = solution[i]\n            if sum(demand[route[1:-1]]) > capacity:\n                # Split the route into two\n                total_d = sum(demand[route[1:-1]])\n                split_pos = 1\n                current_load = 0\n                for j in range(1, len(route)-1):\n                    current_load += demand[route[j]]\n                    if current_load > capacity / 2:\n                        split_pos = j\n                        break\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                solution[i] = new_route1\n                solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n        # Step 2: Demand-balanced 2-opt\n        for _ in range(3):  # Apply 3 times\n            # Select a random route\n            route_idx = random.randint(0, len(solution)-1)\n            route = solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            # Find two edges to swap (considering demand balance)\n            best_improvement = 0\n            best_i, best_j = -1, -1\n\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    # Calculate current and new distances\n                    current_dist = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                               distance_matrix[route[i], route[j+1]])\n                    improvement = current_dist - new_dist\n\n                    # Check demand balance after swap\n                    segment = route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    new_route = np.concatenate((route[:i], reversed_segment, route[j+1:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity and improvement > best_improvement:\n                        best_improvement = improvement\n                        best_i, best_j = i, j\n\n            if best_i != -1 and best_j != -1:\n                # Perform the swap\n                segment = route[best_i:best_j+1]\n                reversed_segment = segment[::-1]\n                new_route = np.concatenate((route[:best_i], reversed_segment, route[best_j+1:]))\n                solution[route_idx] = new_route\n\n        # Step 3: Customer reinsertion (try to improve makespan)\n        for _ in range(2):  # Apply 2 times\n            # Find the longest route\n            longest_route_idx = max(range(len(solution)), key=lambda x: sum(distance_matrix[solution[x][:-1], solution[x][1:]]))\n            longest_route = solution[longest_route_idx]\n\n            if len(longest_route) <= 3:\n                continue\n\n            # Select a random customer to reinsert\n            customer_pos = random.randint(1, len(longest_route)-2)\n            customer = longest_route[customer_pos]\n\n            # Remove the customer\n            new_route = np.concatenate((longest_route[:customer_pos], longest_route[customer_pos+1:]))\n            solution[longest_route_idx] = new_route\n\n            # Find the best position to reinsert in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for r_idx in range(len(solution)):\n                if r_idx == longest_route_idx:\n                    continue\n                route = solution[r_idx]\n\n                for pos in range(1, len(route)):\n                    # Try inserting before pos\n                    new_route = np.concatenate((route[:pos], [customer], route[pos:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        # Calculate insertion cost\n                        insertion_cost = (distance_matrix[new_route[pos-1], customer] +\n                                        distance_matrix[customer, new_route[pos+1]] -\n                                        distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_route_idx = r_idx\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the insertion\n                route = solution[best_route_idx]\n                new_route = np.concatenate((route[:best_pos], [customer], route[best_pos:]))\n                solution[best_route_idx] = new_route\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure feasibility (in case of any errors)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity + 1e-6:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            23.594599153476736,
            2.3440275877431804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30%\n    selected = archive_sorted[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if any route exceeds capacity)\n        for i in range(len(solution)):\n            route = solution[i]\n            if sum(demand[route[1:-1]]) > capacity:\n                # Split the route into two\n                total_d = sum(demand[route[1:-1]])\n                split_pos = 1\n                current_load = 0\n                for j in range(1, len(route)-1):\n                    current_load += demand[route[j]]\n                    if current_load > capacity / 2:\n                        split_pos = j\n                        break\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                solution[i] = new_route1\n                solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n        # Step 2: Demand-balanced 2-opt\n        for _ in range(3):  # Apply 3 times\n            # Select a random route\n            route_idx = random.randint(0, len(solution)-1)\n            route = solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            # Find two edges to swap (considering demand balance)\n            best_improvement = 0\n            best_i, best_j = -1, -1\n\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    # Calculate current and new distances\n                    current_dist = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                               distance_matrix[route[i], route[j+1]])\n                    improvement = current_dist - new_dist\n\n                    # Check demand balance after swap\n                    segment = route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    new_route = np.concatenate((route[:i], reversed_segment, route[j+1:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity and improvement > best_improvement:\n                        best_improvement = improvement\n                        best_i, best_j = i, j\n\n            if best_i != -1 and best_j != -1:\n                # Perform the swap\n                segment = route[best_i:best_j+1]\n                reversed_segment = segment[::-1]\n                new_route = np.concatenate((route[:best_i], reversed_segment, route[best_j+1:]))\n                solution[route_idx] = new_route\n\n        # Step 3: Customer reinsertion (try to improve makespan)\n        for _ in range(2):  # Apply 2 times\n            # Find the longest route\n            longest_route_idx = max(range(len(solution)), key=lambda x: sum(distance_matrix[solution[x][:-1], solution[x][1:]]))\n            longest_route = solution[longest_route_idx]\n\n            if len(longest_route) <= 3:\n                continue\n\n            # Select a random customer to reinsert\n            customer_pos = random.randint(1, len(longest_route)-2)\n            customer = longest_route[customer_pos]\n\n            # Remove the customer\n            new_route = np.concatenate((longest_route[:customer_pos], longest_route[customer_pos+1:]))\n            solution[longest_route_idx] = new_route\n\n            # Find the best position to reinsert in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for r_idx in range(len(solution)):\n                if r_idx == longest_route_idx:\n                    continue\n                route = solution[r_idx]\n\n                for pos in range(1, len(route)):\n                    # Try inserting before pos\n                    new_route = np.concatenate((route[:pos], [customer], route[pos:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        # Calculate insertion cost\n                        insertion_cost = (distance_matrix[new_route[pos-1], customer] +\n                                        distance_matrix[customer, new_route[pos+1]] -\n                                        distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_route_idx = r_idx\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the insertion\n                route = solution[best_route_idx]\n                new_route = np.concatenate((route[:best_pos], [customer], route[best_pos:]))\n                solution[best_route_idx] = new_route\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure feasibility (in case of any errors)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity + 1e-6:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with high makespan or total distance) and applies a hybrid local search combining route splitting, a demand-balanced 2-opt variant, and customer reinsertion to improve both objectives while ensuring capacity feasibility. It intelligently balances exploration (via random selection and reinsertion) with exploitation (via demand-aware 2-opt), and validates feasibility at each step. The key innovations are the demand-aware 2-opt and the reinsertion strategy targeting the longest route.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30%\n    selected = archive_sorted[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if any route exceeds capacity)\n        for i in range(len(solution)):\n            route = solution[i]\n            if sum(demand[route[1:-1]]) > capacity:\n                # Split the route into two\n                total_d = sum(demand[route[1:-1]])\n                split_pos = 1\n                current_load = 0\n                for j in range(1, len(route)-1):\n                    current_load += demand[route[j]]\n                    if current_load > capacity / 2:\n                        split_pos = j\n                        break\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                solution[i] = new_route1\n                solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n        # Step 2: Demand-balanced 2-opt\n        for _ in range(3):  # Apply 3 times\n            # Select a random route\n            route_idx = random.randint(0, len(solution)-1)\n            route = solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            # Find two edges to swap (considering demand balance)\n            best_improvement = 0\n            best_i, best_j = -1, -1\n\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    # Calculate current and new distances\n                    current_dist = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                               distance_matrix[route[i], route[j+1]])\n                    improvement = current_dist - new_dist\n\n                    # Check demand balance after swap\n                    segment = route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    new_route = np.concatenate((route[:i], reversed_segment, route[j+1:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity and improvement > best_improvement:\n                        best_improvement = improvement\n                        best_i, best_j = i, j\n\n            if best_i != -1 and best_j != -1:\n                # Perform the swap\n                segment = route[best_i:best_j+1]\n                reversed_segment = segment[::-1]\n                new_route = np.concatenate((route[:best_i], reversed_segment, route[best_j+1:]))\n                solution[route_idx] = new_route\n\n        # Step 3: Customer reinsertion (try to improve makespan)\n        for _ in range(2):  # Apply 2 times\n            # Find the longest route\n            longest_route_idx = max(range(len(solution)), key=lambda x: sum(distance_matrix[solution[x][:-1], solution[x][1:]]))\n            longest_route = solution[longest_route_idx]\n\n            if len(longest_route) <= 3:\n                continue\n\n            # Select a random customer to reinsert\n            customer_pos = random.randint(1, len(longest_route)-2)\n            customer = longest_route[customer_pos]\n\n            # Remove the customer\n            new_route = np.concatenate((longest_route[:customer_pos], longest_route[customer_pos+1:]))\n            solution[longest_route_idx] = new_route\n\n            # Find the best position to reinsert in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for r_idx in range(len(solution)):\n                if r_idx == longest_route_idx:\n                    continue\n                route = solution[r_idx]\n\n                for pos in range(1, len(route)):\n                    # Try inserting before pos\n                    new_route = np.concatenate((route[:pos], [customer], route[pos:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        # Calculate insertion cost\n                        insertion_cost = (distance_matrix[new_route[pos-1], customer] +\n                                        distance_matrix[customer, new_route[pos+1]] -\n                                        distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_route_idx = r_idx\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the insertion\n                route = solution[best_route_idx]\n                new_route = np.concatenate((route[:best_pos], [customer], route[best_pos:]))\n                solution[best_route_idx] = new_route\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure feasibility (in case of any errors)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity + 1e-6:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            23.594599153476736,
            2.3440275877431804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30%\n    selected = archive_sorted[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if any route exceeds capacity)\n        for i in range(len(solution)):\n            route = solution[i]\n            if sum(demand[route[1:-1]]) > capacity:\n                # Split the route into two\n                total_d = sum(demand[route[1:-1]])\n                split_pos = 1\n                current_load = 0\n                for j in range(1, len(route)-1):\n                    current_load += demand[route[j]]\n                    if current_load > capacity / 2:\n                        split_pos = j\n                        break\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                solution[i] = new_route1\n                solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n        # Step 2: Demand-balanced 2-opt\n        for _ in range(3):  # Apply 3 times\n            # Select a random route\n            route_idx = random.randint(0, len(solution)-1)\n            route = solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            # Find two edges to swap (considering demand balance)\n            best_improvement = 0\n            best_i, best_j = -1, -1\n\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    # Calculate current and new distances\n                    current_dist = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                               distance_matrix[route[i], route[j+1]])\n                    improvement = current_dist - new_dist\n\n                    # Check demand balance after swap\n                    segment = route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    new_route = np.concatenate((route[:i], reversed_segment, route[j+1:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity and improvement > best_improvement:\n                        best_improvement = improvement\n                        best_i, best_j = i, j\n\n            if best_i != -1 and best_j != -1:\n                # Perform the swap\n                segment = route[best_i:best_j+1]\n                reversed_segment = segment[::-1]\n                new_route = np.concatenate((route[:best_i], reversed_segment, route[best_j+1:]))\n                solution[route_idx] = new_route\n\n        # Step 3: Customer reinsertion (try to improve makespan)\n        for _ in range(2):  # Apply 2 times\n            # Find the longest route\n            longest_route_idx = max(range(len(solution)), key=lambda x: sum(distance_matrix[solution[x][:-1], solution[x][1:]]))\n            longest_route = solution[longest_route_idx]\n\n            if len(longest_route) <= 3:\n                continue\n\n            # Select a random customer to reinsert\n            customer_pos = random.randint(1, len(longest_route)-2)\n            customer = longest_route[customer_pos]\n\n            # Remove the customer\n            new_route = np.concatenate((longest_route[:customer_pos], longest_route[customer_pos+1:]))\n            solution[longest_route_idx] = new_route\n\n            # Find the best position to reinsert in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for r_idx in range(len(solution)):\n                if r_idx == longest_route_idx:\n                    continue\n                route = solution[r_idx]\n\n                for pos in range(1, len(route)):\n                    # Try inserting before pos\n                    new_route = np.concatenate((route[:pos], [customer], route[pos:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        # Calculate insertion cost\n                        insertion_cost = (distance_matrix[new_route[pos-1], customer] +\n                                        distance_matrix[customer, new_route[pos+1]] -\n                                        distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_route_idx = r_idx\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the insertion\n                route = solution[best_route_idx]\n                new_route = np.concatenate((route[:best_pos], [customer], route[best_pos:]))\n                solution[best_route_idx] = new_route\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure feasibility (in case of any errors)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity + 1e-6:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with high makespan or total distance) and applies a hybrid local search combining route splitting, a demand-balanced 2-opt variant, and customer reinsertion to improve both objectives while ensuring capacity feasibility. It intelligently balances exploration (via random selection and reinsertion) with exploitation (via demand-aware 2-opt), and validates feasibility at each step. The key innovations are the demand-aware 2-opt and the reinsertion strategy targeting the longest route.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30%\n    selected = archive_sorted[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if any route exceeds capacity)\n        for i in range(len(solution)):\n            route = solution[i]\n            if sum(demand[route[1:-1]]) > capacity:\n                # Split the route into two\n                total_d = sum(demand[route[1:-1]])\n                split_pos = 1\n                current_load = 0\n                for j in range(1, len(route)-1):\n                    current_load += demand[route[j]]\n                    if current_load > capacity / 2:\n                        split_pos = j\n                        break\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                solution[i] = new_route1\n                solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n        # Step 2: Demand-balanced 2-opt\n        for _ in range(3):  # Apply 3 times\n            # Select a random route\n            route_idx = random.randint(0, len(solution)-1)\n            route = solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            # Find two edges to swap (considering demand balance)\n            best_improvement = 0\n            best_i, best_j = -1, -1\n\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    # Calculate current and new distances\n                    current_dist = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                               distance_matrix[route[i], route[j+1]])\n                    improvement = current_dist - new_dist\n\n                    # Check demand balance after swap\n                    segment = route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    new_route = np.concatenate((route[:i], reversed_segment, route[j+1:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity and improvement > best_improvement:\n                        best_improvement = improvement\n                        best_i, best_j = i, j\n\n            if best_i != -1 and best_j != -1:\n                # Perform the swap\n                segment = route[best_i:best_j+1]\n                reversed_segment = segment[::-1]\n                new_route = np.concatenate((route[:best_i], reversed_segment, route[best_j+1:]))\n                solution[route_idx] = new_route\n\n        # Step 3: Customer reinsertion (try to improve makespan)\n        for _ in range(2):  # Apply 2 times\n            # Find the longest route\n            longest_route_idx = max(range(len(solution)), key=lambda x: sum(distance_matrix[solution[x][:-1], solution[x][1:]]))\n            longest_route = solution[longest_route_idx]\n\n            if len(longest_route) <= 3:\n                continue\n\n            # Select a random customer to reinsert\n            customer_pos = random.randint(1, len(longest_route)-2)\n            customer = longest_route[customer_pos]\n\n            # Remove the customer\n            new_route = np.concatenate((longest_route[:customer_pos], longest_route[customer_pos+1:]))\n            solution[longest_route_idx] = new_route\n\n            # Find the best position to reinsert in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for r_idx in range(len(solution)):\n                if r_idx == longest_route_idx:\n                    continue\n                route = solution[r_idx]\n\n                for pos in range(1, len(route)):\n                    # Try inserting before pos\n                    new_route = np.concatenate((route[:pos], [customer], route[pos:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        # Calculate insertion cost\n                        insertion_cost = (distance_matrix[new_route[pos-1], customer] +\n                                        distance_matrix[customer, new_route[pos+1]] -\n                                        distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_route_idx = r_idx\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the insertion\n                route = solution[best_route_idx]\n                new_route = np.concatenate((route[:best_pos], [customer], route[best_pos:]))\n                solution[best_route_idx] = new_route\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure feasibility (in case of any errors)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity + 1e-6:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "score": [
            23.594599153476736,
            2.3440275877431804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]), reverse=True)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30%\n    selected = archive_sorted[selected_idx][0]\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected]\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        # Step 1: Route splitting (if any route exceeds capacity)\n        for i in range(len(solution)):\n            route = solution[i]\n            if sum(demand[route[1:-1]]) > capacity:\n                # Split the route into two\n                total_d = sum(demand[route[1:-1]])\n                split_pos = 1\n                current_load = 0\n                for j in range(1, len(route)-1):\n                    current_load += demand[route[j]]\n                    if current_load > capacity / 2:\n                        split_pos = j\n                        break\n                new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n                solution[i] = new_route1\n                solution.insert(i+1, new_route2)\n                break  # Only split one route per iteration\n\n        # Step 2: Demand-balanced 2-opt\n        for _ in range(3):  # Apply 3 times\n            # Select a random route\n            route_idx = random.randint(0, len(solution)-1)\n            route = solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            # Find two edges to swap (considering demand balance)\n            best_improvement = 0\n            best_i, best_j = -1, -1\n\n            for i in range(1, len(route)-2):\n                for j in range(i+1, len(route)-1):\n                    # Calculate current and new distances\n                    current_dist = (distance_matrix[route[i-1], route[i]] +\n                                   distance_matrix[route[j], route[j+1]])\n                    new_dist = (distance_matrix[route[i-1], route[j]] +\n                               distance_matrix[route[i], route[j+1]])\n                    improvement = current_dist - new_dist\n\n                    # Check demand balance after swap\n                    segment = route[i:j+1]\n                    reversed_segment = segment[::-1]\n                    new_route = np.concatenate((route[:i], reversed_segment, route[j+1:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity and improvement > best_improvement:\n                        best_improvement = improvement\n                        best_i, best_j = i, j\n\n            if best_i != -1 and best_j != -1:\n                # Perform the swap\n                segment = route[best_i:best_j+1]\n                reversed_segment = segment[::-1]\n                new_route = np.concatenate((route[:best_i], reversed_segment, route[best_j+1:]))\n                solution[route_idx] = new_route\n\n        # Step 3: Customer reinsertion (try to improve makespan)\n        for _ in range(2):  # Apply 2 times\n            # Find the longest route\n            longest_route_idx = max(range(len(solution)), key=lambda x: sum(distance_matrix[solution[x][:-1], solution[x][1:]]))\n            longest_route = solution[longest_route_idx]\n\n            if len(longest_route) <= 3:\n                continue\n\n            # Select a random customer to reinsert\n            customer_pos = random.randint(1, len(longest_route)-2)\n            customer = longest_route[customer_pos]\n\n            # Remove the customer\n            new_route = np.concatenate((longest_route[:customer_pos], longest_route[customer_pos+1:]))\n            solution[longest_route_idx] = new_route\n\n            # Find the best position to reinsert in another route\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for r_idx in range(len(solution)):\n                if r_idx == longest_route_idx:\n                    continue\n                route = solution[r_idx]\n\n                for pos in range(1, len(route)):\n                    # Try inserting before pos\n                    new_route = np.concatenate((route[:pos], [customer], route[pos:]))\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        # Calculate insertion cost\n                        insertion_cost = (distance_matrix[new_route[pos-1], customer] +\n                                        distance_matrix[customer, new_route[pos+1]] -\n                                        distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                        if insertion_cost < best_cost:\n                            best_cost = insertion_cost\n                            best_route_idx = r_idx\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the insertion\n                route = solution[best_route_idx]\n                new_route = np.concatenate((route[:best_pos], [customer], route[best_pos:]))\n                solution[best_route_idx] = new_route\n\n        return solution\n\n    new_solution = apply_hybrid_search(new_solution)\n\n    # Ensure feasibility (in case of any errors)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity + 1e-6:\n            raise ValueError(\"Generated infeasible solution\")\n\n    return new_solution\n\n",
        "operation": "i1"
    }
]