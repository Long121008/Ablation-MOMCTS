[
    {
        "algorithm": "The heuristic selects a near-capacity solution from the archive, then applies a hybrid local search combining item swapping and random flipping, with targeted replacement for feasibility, prioritizing solutions with high potential for multi-objective improvement while ensuring all generated neighbors remain feasible. It intelligently handles infeasibility by undoing operations and adding/removing the most valuable items, with a focus on balancing both objectives through weighted value considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback to first solution if no candidates\n\n    # Select a solution with high potential (e.g., near-capacity but not fully packed)\n    selected_sol = max(candidates, key=lambda x: np.sum(weight_lst * x))\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Randomly swap two items\n    idx1, idx2 = np.random.choice(n_items, size=2, replace=False)\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility after swap\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If swap violates capacity, undo it and try another approach\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Step 2: Randomly flip one item\n        flip_idx = np.random.choice(n_items)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility after flip\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If flip violates capacity, remove the most expensive item\n            if new_solution[flip_idx] == 1:\n                new_solution[flip_idx] = 0\n            else:\n                # Find the most expensive item to add\n                available_items = np.where(new_solution == 0)[0]\n                if len(available_items) > 0:\n                    expensive_item = available_items[np.argmax(value1_lst[available_items] + value2_lst[available_items])]\n                    if np.sum(weight_lst * new_solution) + weight_lst[expensive_item] <= capacity:\n                        new_solution[expensive_item] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9035397066548494,
            0.47091394662857056
        ],
        "raw_score": [
            27.34055461589349,
            28.03176024888062
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced potential for both objectives\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate adaptive weights for objectives\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    weight1 = current_value1 / total_value1 if total_value1 > 0 else 0.5\n    weight2 = current_value2 / total_value2 if total_value2 > 0 else 0.5\n\n    # Identify promising items to consider\n    potential_items = np.where(new_solution == 0)[0]\n    if len(potential_items) > 0:\n        # Calculate weighted values for potential items\n        weighted_values = weight1 * value1_lst[potential_items] + weight2 * value2_lst[potential_items]\n        # Select top 3 items with highest weighted value\n        top_items = potential_items[np.argsort(weighted_values)[-3:]]\n\n        for item in top_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Perform targeted swapping with items in solution\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) >= 2:\n        # Select two items to swap based on their contribution to both objectives\n        swap_candidates = sorted(in_solution, key=lambda x: -(weight1 * value1_lst[x] + weight2 * value2_lst[x]))[:2]\n        if len(swap_candidates) == 2:\n            idx1, idx2 = swap_candidates\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Perform random flip with probability based on current solution quality\n    flip_prob = 0.3 if (current_value1 + current_value2) / (total_value1 + total_value2) > 0.7 else 0.7\n    if np.random.random() < flip_prob and len(new_solution) > 0:\n        flip_idx = np.random.choice(len(new_solution))\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8179565713407433,
            0.27593129873275757
        ],
        "raw_score": [
            27.604553890686965,
            28.184297658157398
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on a weighted value metric balancing both objectives (60% value1, 40% value2) and capacity utilization, then applies a hybrid local search that first adds high-value-density items and occasionally removes low-value-density items to create a feasible neighbor solution. It prioritizes items with higher combined value-to-weight ratios while ensuring feasibility through targeted removals when necessary.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weighted value metric for each solution\n    def weighted_value(sol):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            return -np.inf\n        value1 = np.sum(value1_lst * sol)\n        value2 = np.sum(value2_lst * sol)\n        # Weighted value metric combining both objectives and capacity utilization\n        return (0.6 * value1 + 0.4 * value2) * (1 - (total_weight / capacity))\n\n    # Select solution with highest weighted value\n    selected_sol, _ = max(archive, key=lambda x: weighted_value(x[0]))\n    new_solution = selected_sol.copy()\n\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Hybrid local search operator\n    # Step 1: Replace low-value items with high-value alternatives\n    total_weight = np.sum(weight_lst * new_solution)\n    available_weight = capacity - total_weight\n\n    # Calculate value density (value per weight) for all items\n    value_density = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_density)  # Highest density first\n\n    # Try to add high-value items that fit\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= available_weight:\n            new_solution[idx] = 1\n            available_weight -= weight_lst[idx]\n\n    # Step 2: Randomly perturb by removing items with low value density\n    if np.random.rand() < 0.3:  # 30% chance to perturb\n        low_density_items = np.where(new_solution == 1)[0]\n        if len(low_density_items) > 0:\n            # Remove items with lowest value density\n            low_density_items_sorted = sorted(low_density_items, key=lambda x: value_density[x])\n            for idx in low_density_items_sorted[:max(1, len(low_density_items)//3)]:\n                new_solution[idx] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        while total_weight > capacity:\n            # Find the item with lowest value density in the solution\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            remove_idx = in_solution[np.argmin(value_density[in_solution])]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8243948490542945,
            10.670056641101837
        ],
        "raw_score": [
            28.23516013650488,
            28.37749093126734
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a non-dominated solution from the archive by prioritizing those with high potential for improvement in either objective, then applies a hybrid local search operator that combines item swaps, random flips, and feasibility checks to generate diverse high-quality neighbors. It balances exploration (via random swaps and flips) with exploitation (by focusing on high-potential solutions) while ensuring all generated neighbors remain feasible. The selection prioritizes solutions with higher normalized objective sums, and the local search includes targeted item removals/additions, swaps between items, and probabilistic flips to maintain diversity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    # Here, we select the solution with the highest sum of normalized objectives\n    normalized_objectives = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        normalized_obj = (obj[0] / (np.sum(value1_lst) + 1e-8), obj[1] / (np.sum(value2_lst) + 1e-8))\n        normalized_objectives.append((sol, normalized_obj))\n\n    if not normalized_objectives:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Sort by sum of normalized objectives (prioritize solutions with higher potential)\n    normalized_objectives.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = normalized_objectives[0][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select an item to flip (basic local search)\n    candidates = np.where(new_solution == 1)[0]\n    if len(candidates) > 0:\n        idx = random.choice(candidates)\n        if new_solution[idx] == 1 and total_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n        else:\n            # If cannot remove, try adding a new item\n            candidates = np.where(new_solution == 0)[0]\n            for idx in candidates:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    break\n\n    # Apply a random swap between two items (exploration)\n    if np.sum(new_solution) > 1:\n        items = np.where(new_solution == 1)[0]\n        i, j = random.sample(list(items), 2)\n        # Check if swap is feasible\n        if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply a random flip with probability 0.3 (diversification)\n    if random.random() < 0.3:\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1 and total_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n        elif new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6616908732258407,
            0.4831783175468445
        ],
        "raw_score": [
            28.48375171154526,
            28.74721189525877
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (near-capacity but not fully packed)\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback to first solution if no candidates\n\n    selected_sol = max(candidates, key=lambda x: np.sum(weight_lst * x))\n    new_solution = selected_sol.copy()\n\n    # Novel local search operator: Weighted Value-Based Greedy Swap\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Calculate weighted values for both objectives (balance exploration and exploitation)\n    alpha = 0.6  # Weight for objective 1\n    beta = 0.4   # Weight for objective 2\n    weighted_values = alpha * value1_lst + beta * value2_lst\n\n    # Find the most valuable item currently in the knapsack\n    in_knapsack = np.where(new_solution == 1)[0]\n    if len(in_knapsack) > 0:\n        most_valuable_in = in_knapsack[np.argmax(weighted_values[in_knapsack])]\n\n        # Find the best candidate to replace it (consider both in and out of knapsack)\n        all_items = np.arange(n_items)\n        exclude_most_valuable = np.delete(all_items, most_valuable_in)\n        candidates = exclude_most_valuable\n\n        # Calculate potential new weights\n        current_weight = np.sum(weight_lst * new_solution)\n        potential_weights = current_weight - weight_lst[most_valuable_in] + weight_lst[candidates]\n\n        # Filter feasible candidates\n        feasible_mask = potential_weights <= capacity\n        feasible_candidates = candidates[feasible_mask]\n\n        if len(feasible_candidates) > 0:\n            # Select the candidate with highest weighted value\n            best_candidate = feasible_candidates[np.argmax(weighted_values[feasible_candidates])]\n\n            # Perform the swap\n            new_solution[most_valuable_in] = 0\n            new_solution[best_candidate] = 1\n\n    # Additional diversification: With probability 0.2, perform a random flip\n    if random.random() < 0.2:\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1 and np.sum(weight_lst * new_solution) - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n        elif new_solution[flip_idx] == 0 and np.sum(weight_lst * new_solution) + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6276822021074377,
            0.44365832209587097
        ],
        "raw_score": [
            28.295263699328505,
            29.17602913160117
        ]
    },
    {
        "algorithm": "The algorithm selects a near-capacity solution with diverse item distributions from the archive, then applies a hybrid local search combining value-weighted item swaps and flips, prioritizing items with high value ratios while ensuring feasibility through intelligent restoration steps. It balances both objectives by considering value ratios and dynamically adjusting the solution to maintain capacity constraints. The selection prioritizes solutions close to capacity and with balanced value distributions, while the local search intelligently explores neighboring solutions by swapping high-value items and flipping low-value items when needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (near-capacity with diverse items)\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Select solution with highest weight and most balanced value distribution\n    selected_sol = max(candidates, key=lambda x: (np.sum(weight_lst * x), np.std(value1_lst * x) + np.std(value2_lst * x)))\n    new_solution = selected_sol.copy()\n\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Hybrid local search operator\n    # Step 1: Value-weighted swap of two items\n    value_weights = value1_lst + value2_lst\n    probs = value_weights / np.sum(value_weights)\n    idx1, idx2 = np.random.choice(n_items, size=2, replace=False, p=probs)\n    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility after swap\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Undo swap and try value-weighted flip\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Step 2: Flip item with highest value ratio\n        value_ratio = (value1_lst / (value2_lst + 1e-6)) * (1 - 2 * new_solution)\n        flip_idx = np.argmax(value_ratio)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility after flip\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove lowest value ratio item if adding would violate capacity\n            if new_solution[flip_idx] == 1:\n                new_solution[flip_idx] = 0\n            else:\n                # Add highest value ratio item available\n                available_items = np.where(new_solution == 0)[0]\n                if len(available_items) > 0:\n                    ratio = (value1_lst[available_items] + value2_lst[available_items]) / (weight_lst[available_items] + 1e-6)\n                    best_item = available_items[np.argmax(ratio)]\n                    if np.sum(weight_lst * new_solution) + weight_lst[best_item] <= capacity:\n                        new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6572029456644558,
            2.1454139351844788
        ],
        "raw_score": [
            28.894898211799664,
            29.70234149994233
        ]
    },
    {
        "algorithm": "The algorithm selects the top solution from the archive (sorted by the sum of both objectives) and performs a greedy local search by iteratively adding or removing items to improve feasibility and objective values, followed by a random swap to maintain diversity. The key design ideas are prioritizing solutions with higher combined objective values and using a hybrid approach of greedy and random exploration to generate neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(base_solution * weight_lst)\n    new_solution = base_solution.copy()\n\n    # Identify items that can be swapped or added to improve objectives\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Perform a random swap to ensure diversity\n    if len(new_solution) >= 2:\n        idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n        if new_solution[idx1] != new_solution[idx2]:\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            temp_weight = np.sum(new_solution * weight_lst)\n            if temp_weight > capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5244073814411324,
            0.5121272504329681
        ],
        "raw_score": [
            30.374999737717005,
            31.044817273830414
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a high-potential solution from the archive by evaluating its improvement potential (based on marginal gains and losses in both objectives) and then applies a hybrid local search combining random perturbations with targeted flips of high-value items, while ensuring feasibility through weight checks. It prioritizes items with higher marginal gains in either objective and occasionally removes low-value items to explore the solution space more effectively. The selection is driven by a normalized improvement score that balances potential gains and losses, while the local search strategically flips items to maximize both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    current_weights = [np.sum(weight_lst[sol == 1]) for sol in archive_solutions]\n    current_values1 = [np.sum(value1_lst[sol == 1]) for sol in archive_solutions]\n    current_values2 = [np.sum(value2_lst[sol == 1]) for sol in archive_solutions]\n\n    # Calculate potential improvement scores (normalized)\n    improvement_scores = []\n    for i in range(len(archive_solutions)):\n        sol = archive_solutions[i]\n        total_weight = current_weights[i]\n        remaining_capacity = capacity - total_weight\n\n        # Calculate potential gains for items not in the solution\n        potential_gains1 = value1_lst[sol == 0] * (weight_lst[sol == 0] <= remaining_capacity)\n        potential_gains2 = value2_lst[sol == 0] * (weight_lst[sol == 0] <= remaining_capacity)\n\n        # Calculate potential losses for items in the solution\n        potential_losses1 = value1_lst[sol == 1]\n        potential_losses2 = value2_lst[sol == 1]\n\n        # Calculate improvement score (simplified)\n        score = (np.sum(potential_gains1) + np.sum(potential_gains2)) / (1 + np.sum(potential_losses1) + np.sum(potential_losses2))\n        improvement_scores.append(score)\n\n    # Select solution with highest improvement score\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random perturbation with targeted flips\n    n_items = len(weight_lst)\n    current_weight = current_weights[selected_idx]\n\n    # Step 1: Random perturbation (flip a few random items)\n    for _ in range(min(3, n_items)):\n        item = random.randint(0, n_items - 1)\n        if new_solution[item] == 1:\n            current_weight -= weight_lst[item]\n            new_solution[item] = 0\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                current_weight += weight_lst[item]\n                new_solution[item] = 1\n\n    # Step 2: Targeted flips for high-margin items\n    # Find items not in the solution with high value1\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Sort by value1 (descending) and value2 (descending)\n        sorted_items = sorted(candidate_items, key=lambda x: (-value1_lst[x], -value2_lst[x]))\n        for item in sorted_items[:min(2, len(sorted_items))]:\n            if current_weight + weight_lst[item] <= capacity:\n                current_weight += weight_lst[item]\n                new_solution[item] = 1\n\n    # Step 3: Optional: Flip low-value items in the solution\n    # Find items in the solution with low value1 and value2\n    included_items = np.where(new_solution == 1)[0]\n    if len(included_items) > 0:\n        # Sort by value1 (ascending) and value2 (ascending)\n        sorted_items = sorted(included_items, key=lambda x: (value1_lst[x], value2_lst[x]))\n        for item in sorted_items[:min(1, len(sorted_items))]:\n            current_weight -= weight_lst[item]\n            new_solution[item] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5795017757017813,
            2.2255084812641144
        ],
        "raw_score": [
            41.60249546165841,
            36.2860970163389
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive (based on the sum of its two objective values) and generates a neighbor by randomly flipping items (with a 20% chance) followed by a greedy feasibility check and improvement step. It prioritizes items with higher combined marginal values when removing excess weight or adding new items, ensuring feasibility while potentially improving both objectives. The hybrid approach balances exploration (random flips) with exploitation (greedy improvements).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., sum of objectives)\n    archive_scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by randomly flipping items, then apply greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Random flip strategy\n    flip_mask = np.random.rand(n_items) < 0.2  # 20% chance to flip each item\n    new_solution = np.where(flip_mask, 1 - new_solution, new_solution)\n\n    # Ensure feasibility by removing excess weight\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with lowest marginal value (sum of both objectives) until feasible\n        while excess > 0 and np.sum(new_solution) > 0:\n            # Calculate marginal values for included items\n            marginal_values = (value1_lst + value2_lst) * new_solution\n            if np.max(marginal_values) == 0:\n                break  # No items can be removed further\n            # Remove the item with the smallest marginal value\n            item_to_remove = np.argmax(marginal_values)\n            if new_solution[item_to_remove] == 1:\n                new_solution[item_to_remove] = 0\n                excess -= weight_lst[item_to_remove]\n\n    # Greedy improvement step: try adding items with positive marginal value\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate marginal values for excluded items\n        marginal_values = (value1_lst + value2_lst) * (1 - new_solution)\n        # Try adding items with positive marginal value\n        for item in np.argsort(-marginal_values):\n            if marginal_values[item] > 0 and weight_lst[item] <= remaining_weight:\n                new_solution[item] = 1\n                remaining_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.4356826408397726,
            0.7961173951625824
        ],
        "raw_score": [
            36.97065483014461,
            37.2599863682192
        ]
    }
]