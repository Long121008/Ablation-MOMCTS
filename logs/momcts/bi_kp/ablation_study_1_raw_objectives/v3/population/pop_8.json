[
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution using a weighted random choice\n    weights = [obj[0] + obj[1] for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Step 3: Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n\n    # Step 4: Identify candidate items to flip\n    candidate_indices = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n    if len(candidate_indices) == 0:\n        # If no items can be added, try removing low-value items\n        candidate_indices = np.where(base_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            return base_solution  # No change possible\n\n    # Step 5: Select top-k items based on combined marginal contributions\n    k = max(1, min(5, len(candidate_indices) // 2))\n    top_indices = np.argsort(combined_marginal[candidate_indices])[-k:][::-1]\n\n    # Step 6: Create new solution by flipping selected items\n    new_solution = base_solution.copy()\n    for idx in candidate_indices[top_indices]:\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Step 7: Dynamic weight adjustment phase\n    while current_weight > capacity:\n        # Identify items to remove based on least combined marginal value\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) == 0:\n            break\n        worst_item = in_items[np.argmin(combined_marginal[in_items])]\n        new_solution[worst_item] = 0\n        current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8379839795366024,
            0.18839186429977417
        ],
        "raw_score": [
            27.127153134971913,
            27.930397004202053
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive by weighting choices based on combined objective values, then applies a hybrid local search combining swaps, flips, and adaptive perturbations to explore the solution space while ensuring feasibility through strict weight constraint checks. The strategy is randomly chosen among three options, with perturbations adaptively sized for exploration, prioritizing solutions with higher combined objective values while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (prioritize high-value or diverse solutions)\n    selected_idx = random.choices(range(len(archive)), weights=[obj[0] + obj[1] for (sol, obj) in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search (swaps, flips, and adaptive perturbations)\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly choose one of three local search strategies\n    strategy = random.choice([\"swap\", \"flip\", \"perturb\"])\n\n    if strategy == \"swap\":\n        # Swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = random.choice(in_items)\n            swap_out = random.choice(out_items)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    elif strategy == \"flip\":\n        # Flip a random item (0 to 1 or 1 to 0)\n        flip_idx = random.randint(0, n_items - 1)\n\n        if new_solution[flip_idx] == 1:\n            # Check feasibility if removing the item\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[flip_idx]\n\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Check feasibility if adding the item\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight + weight_lst[flip_idx]\n\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 1\n\n    elif strategy == \"perturb\":\n        # Perturb a subset of items (adaptive based on objective values)\n        perturb_size = max(1, min(5, n_items // 10))  # Adaptive size\n        perturb_indices = random.sample(range(n_items), perturb_size)\n\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                # Check feasibility if removing the item\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight - weight_lst[idx]\n\n                if new_weight <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Check feasibility if adding the item\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight + weight_lst[idx]\n\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.34147716771420633,
            0.3407798707485199
        ],
        "raw_score": [
            49.672216305965385,
            49.76474444776558
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with high item density and near-capacity weight) and applies a hybrid local search by flipping items with the highest marginal contributions (balancing both objectives) while ensuring feasibility through a final weight-checking step. It intelligently flips a subset of items based on their combined value-to-weight ratio, with a fallback to remove heaviest items if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[0]) * (1 - (sum(weight_lst[x[0] == 1]) / capacity)) if sum(weight_lst[x[0] == 1]) <= capacity else -np.inf)[0].copy()\n\n    # Apply a hybrid local search operator: flip a subset of items based on their marginal contributions\n    new_solution = selected_solution.copy()\n    marginal_contributions = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_contributions)[::-1]\n\n    # Flip the top-k items with the highest marginal contributions\n    k = max(1, len(new_solution) // 10)\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Ensure feasibility (redundant but safe)\n    total_weight = sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, flip the heaviest items until feasible\n        sorted_heavy = np.argsort(weight_lst[new_solution == 1])[::-1]\n        for idx in sorted_heavy:\n            if total_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8267687850791628,
            1.6086755692958832
        ],
        "raw_score": [
            27.502875572787605,
            28.1224251595386
        ]
    },
    {
        "algorithm": "The algorithm first selects a solution from the archive by prioritizing those with high combined objective values and diversity (distance from centroid), then applies a hybrid local search combining value-weighted random walks and adaptive perturbations, dynamically adjusting neighborhood size based on solution properties, while ensuring feasibility through greedy repair when capacity is exceeded. The method emphasizes balancing exploration (diversity) and exploitation (value-weighted operations) while maintaining feasibility constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a diversity-aware solution\n    objectives = np.array([obj for (sol, obj) in archive])\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    diversity_scores = distances * combined_values\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search with adaptive perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Value-weighted random walk\n    for _ in range(5):\n        included = new_solution == 1\n        excluded = new_solution == 0\n\n        # Calculate value-weighted probabilities for flipping\n        if np.any(included):\n            remove_probs = (value1_lst[included] + value2_lst[included]) / np.sum(value1_lst[included] + value2_lst[included])\n            remove_idx = np.random.choice(np.where(included)[0], p=remove_probs)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n        if np.any(excluded) and current_weight < capacity:\n            add_probs = (value1_lst[excluded] + value2_lst[excluded]) / np.sum(value1_lst[excluded] + value2_lst[excluded])\n            potential_adds = np.where(excluded)[0]\n            add_idx = np.random.choice(potential_adds, p=add_probs)\n            if current_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n                current_weight += weight_lst[add_idx]\n\n    # Adaptive neighborhood perturbation\n    perturbation_size = max(1, min(3, n_items // 10))\n    perturb_indices = np.random.choice(n_items, perturbation_size, replace=False)\n\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy repair if still over capacity\n    while current_weight > capacity:\n        included = new_solution == 1\n        if not np.any(included):\n            break\n        remove_probs = (value1_lst[included] + value2_lst[included]) / np.sum(value1_lst[included] + value2_lst[included])\n        remove_idx = np.random.choice(np.where(included)[0], p=remove_probs)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.48024596244323714,
            0.9026797115802765
        ],
        "raw_score": [
            42.44937177148621,
            41.97733846309583
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random choice based on a combined objective score, then applies a hybrid local search strategy combining item swaps, flips, and adaptive perturbations with dynamic perturbation sizes and objective-aware selection to generate a feasible neighbor solution while exploring the solution space effectively. The strategy prioritizes value1 (70% weight) over value2 (30% weight) in selection and uses adaptive mechanisms like dynamic perturbation sizes and feasibility checks to ensure high-quality solutions across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution using a weighted random choice\n    combined_scores = [obj[0] * 0.7 + obj[1] * 0.3 for (sol, obj) in archive]  # Weighted sum of objectives\n    selected_idx = random.choices(range(len(archive)), weights=combined_scores, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search with novel mechanisms\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Dynamic perturbation size based on solution quality\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n    max_perturb_size = min(5, n_items // 5)  # Adaptive based on problem size\n    perturb_size = random.randint(1, max_perturb_size)\n\n    # Objective-aware selection for perturbation\n    if random.random() < 0.6:  # Higher chance for value1-focused perturbation\n        candidate_indices = np.argsort(value1_lst)[-n_items//2:]  # Top 50% value1 items\n    else:\n        candidate_indices = np.argsort(value2_lst)[-n_items//2:]  # Top 50% value2 items\n\n    # Apply hybrid strategy\n    strategy = random.choice([\"swap\", \"flip\", \"perturb\", \"adaptive_flip\"])\n\n    if strategy == \"swap\":\n        # Enhanced swap with objective-aware selection\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with high value ratio\n            value_ratios = (value1_lst + value2_lst) / weight_lst\n            swap_in = random.choice(in_items)\n            swap_out = random.choice(out_items)\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    elif strategy == \"flip\":\n        # Value-based flip with multiple attempts\n        for _ in range(3):  # Try multiple flips\n            flip_idx = random.choice(candidate_indices)\n            if new_solution[flip_idx] == 1:\n                new_weight = current_weight - weight_lst[flip_idx]\n                if new_weight <= capacity:\n                    new_solution[flip_idx] = 0\n                    break\n            else:\n                new_weight = current_weight + weight_lst[flip_idx]\n                if new_weight <= capacity:\n                    new_solution[flip_idx] = 1\n                    break\n\n    elif strategy == \"perturb\":\n        # Dynamic perturbation with multiple attempts\n        perturb_indices = random.sample(list(candidate_indices), min(perturb_size, len(candidate_indices)))\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                new_weight = current_weight - weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 0\n            else:\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n\n    elif strategy == \"adaptive_flip\":\n        # Adaptive flip based on remaining capacity\n        flip_candidates = []\n        for idx in candidate_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                flip_candidates.append(idx)\n            elif new_solution[idx] == 1 and (current_weight - weight_lst[idx]) <= capacity:\n                flip_candidates.append(idx)\n\n        if flip_candidates:\n            flip_idx = random.choice(flip_candidates)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.2619377052959229,
            0.27632978558540344
        ],
        "raw_score": [
            49.21545254802683,
            48.10415543548359
        ]
    },
    {
        "algorithm": "The algorithm selects a high-value solution from the archive (weighted by the product of its objectives) and applies one of three local search strategies: adaptive swaps (prioritizing high-value item exchanges), greedy flips (maximizing combined value improvements), or neighborhood perturbations (adaptively adjusting perturbation size based on solution quality). It ensures feasibility by strictly checking weight constraints at each step. The approach balances exploration (via random strategy selection) and exploitation (via value-weighted selections) to navigate the multi-objective solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (prioritize high-value solutions)\n    selected_idx = random.choices(range(len(archive)), weights=[obj[0] * obj[1] for (sol, obj) in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search (adaptive swaps, greedy flips, and neighborhood perturbations)\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly choose one of three local search strategies\n    strategy = random.choice([\"adaptive_swap\", \"greedy_flip\", \"neighborhood_perturb\"])\n\n    if strategy == \"adaptive_swap\":\n        # Adaptive swap: prioritize high-value items\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select high-value items to remove\n            in_values = value1_lst[in_items] * value2_lst[in_items]\n            swap_in = in_items[np.argmax(in_values)]\n\n            # Select high-value items to add\n            out_values = value1_lst[out_items] * value2_lst[out_items]\n            swap_out = out_items[np.argmax(out_values)]\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    elif strategy == \"greedy_flip\":\n        # Greedy flip: prioritize items that improve both objectives\n        flip_candidates = []\n        current_weight = np.sum(weight_lst[new_solution == 1])\n\n        for idx in range(n_items):\n            if new_solution[idx] == 1:\n                new_weight = current_weight - weight_lst[idx]\n                if new_weight <= capacity:\n                    flip_candidates.append((idx, -1))  # -1 means remove\n            else:\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    flip_candidates.append((idx, 1))  # 1 means add\n\n        if flip_candidates:\n            # Select flip that maximizes the product of value improvements\n            best_flip = None\n            best_score = -1\n\n            for idx, action in flip_candidates:\n                if action == 1:\n                    value1 = value1_lst[idx]\n                    value2 = value2_lst[idx]\n                else:\n                    value1 = -value1_lst[idx]\n                    value2 = -value2_lst[idx]\n\n                # Score based on combined value improvement\n                score = value1 * value2\n\n                if score > best_score:\n                    best_score = score\n                    best_flip = (idx, action)\n\n            if best_flip:\n                idx, action = best_flip\n                new_solution[idx] = 1 if action == 1 else 0\n\n    elif strategy == \"neighborhood_perturb\":\n        # Neighborhood perturbation: adaptive size based on solution quality\n        combined_value = archive[selected_idx][1][0] * archive[selected_idx][1][1]\n        perturb_size = max(1, min(10, int(n_items * 0.1 * (1 + 1/combined_value))))  # Larger perturbation for low-quality solutions\n\n        perturb_indices = random.sample(range(n_items), perturb_size)\n\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                # Check feasibility if removing the item\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight - weight_lst[idx]\n\n                if new_weight <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Check feasibility if adding the item\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                new_weight = current_weight + weight_lst[idx]\n\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.36170978658075825,
            0.38660886883735657
        ],
        "raw_score": [
            46.73448477806161,
            47.3380410115805
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on combined objective values, then applies a hybrid local search combining marginal contribution flips, adaptive perturbations, and feasibility-aware swaps, dynamically adjusting perturbation size and prioritizing items with high combined marginal value-to-weight ratios to generate a feasible neighbor solution. The strategy selection balances exploration (flip, perturb) and exploitation (swap) while ensuring feasibility through marginal contribution-based repair.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Weighted selection based on combined objective values\n    weights = [obj[0] + obj[1] for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 2: Hybrid local search with adaptive components\n    # Calculate marginal contributions for both objectives\n    marginal_contributions = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_contributions)[::-1]\n\n    # Strategy selection with adaptive parameters\n    strategy = random.choices(\n        [\"flip\", \"perturb\", \"swap\"],\n        weights=[0.4, 0.3, 0.3],\n        k=1\n    )[0]\n\n    if strategy == \"flip\":\n        # Flip top-k items with highest marginal contributions\n        k = max(1, min(5, n_items // 5))\n        for idx in sorted_indices[:k]:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    elif strategy == \"perturb\":\n        # Adaptive perturbation based on solution density\n        density = np.sum(new_solution) / n_items\n        perturb_size = max(1, min(5, int(n_items * (0.5 - 0.3 * density))))\n\n        for _ in range(perturb_size):\n            idx = random.randint(0, n_items - 1)\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    elif strategy == \"swap\":\n        # Feasibility-aware swap between included and excluded items\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select item to remove (lowest marginal contribution among included)\n            remove_idx = included[np.argmin(marginal_contributions[included])]\n            # Select item to add (highest marginal contribution among excluded)\n            add_idx = excluded[np.argmax(marginal_contributions[excluded])]\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n\n            if new_weight <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Final feasibility check and repair\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest marginal contributions until feasible\n        included = np.where(new_solution == 1)[0]\n        sorted_included = included[np.argsort(marginal_contributions[included])]\n\n        for idx in sorted_included:\n            if total_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.3664895686882935,
            0.4963635206222534
        ],
        "raw_score": [
            53.555185276224066,
            52.91987793367716
        ]
    },
    {
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search that randomly flips items while greedily adding items based on a weighted combination of the two objectives, ensuring feasibility by always checking the weight constraint. It prioritizes items that improve at least one objective, with weights randomly assigned to each objective during the greedy selection phase. The algorithm balances exploration (random flips) and exploitation (greedy selection) to generate high-quality neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with greedy selection\n    items = list(range(len(weight_lst)))\n    random.shuffle(items)\n\n    for item in items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Greedy selection based on weighted combination of objectives\n                weight_v1 = random.random()\n                weight_v2 = 1 - weight_v1\n                gain_v1 = value1_lst[item] * weight_v1\n                gain_v2 = value2_lst[item] * weight_v2\n\n                # Accept if it improves at least one objective\n                if gain_v1 > 0 or gain_v2 > 0:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5570059660834574,
            2.6919838190078735
        ],
        "raw_score": [
            34.39821112253557,
            34.674357321057684
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing higher combined objective values) and applies a hybrid local search: random item swaps and value-based flips (prioritizing items with high marginal value per weight). It ensures feasibility by removing the least valuable items if the weight exceeds capacity. The key design ideas are prioritizing high-value items, combining random and targeted search, and strict feasibility enforcement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps and value-based flips\n    for _ in range(10):  # Number of local search iterations\n        # Random swap: pick two items and swap their inclusion\n        if len(new_solution) >= 2:\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Value-based flip: flip an item based on its value contribution\n        # Calculate marginal contributions\n        included = new_solution == 1\n        excluded = new_solution == 0\n        marginal_value1 = value1_lst[excluded] / weight_lst[excluded] if np.any(excluded) else np.array([])\n        marginal_value2 = value2_lst[excluded] / weight_lst[excluded] if np.any(excluded) else np.array([])\n\n        if len(marginal_value1) > 0:\n            # Select item with highest marginal value\n            best_idx = np.argmax(marginal_value1 + marginal_value2)\n            item_idx = np.where(excluded)[0][best_idx]\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included = new_solution == 1\n        if not np.any(included):\n            break\n        # Remove the least valuable item\n        marginal_value = value1_lst[included] + value2_lst[included]\n        worst_idx = np.argmin(marginal_value)\n        item_idx = np.where(included)[0][worst_idx]\n        new_solution[item_idx] = 0\n        current_weight -= weight_lst[item_idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.34487702900379225,
            1.0611258447170258
        ],
        "raw_score": [
            50.781840842488485,
            50.54112839204923
        ]
    },
    {
        "algorithm": "The heuristic selects a random solution from the archive and applies a hybrid local search combining item flips, swaps, and group perturbations, ensuring feasibility by checking weight constraints at each step. It prioritizes exploration with randomness (50% for flips/swaps, 30% for group perturbations) while maintaining solution quality through feasibility checks. The algorithm balances diversification (random selection) with intensification (local search operations) to navigate the trade-off space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (prioritize non-dominated and diverse solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, base_obj = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine item swaps, flips, and group perturbations\n    num_items = len(new_solution)\n\n    # Step 1: Random item flip (add/remove one item)\n    if random.random() < 0.5:\n        flip_idx = random.randint(0, num_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Step 2: Random swap (exchange two items)\n    if random.random() < 0.5:\n        swap_i, swap_j = random.sample(range(num_items), 2)\n        if new_solution[swap_i] != new_solution[swap_j]:\n            # Check feasibility after swap\n            delta_weight = (new_solution[swap_j] * weight_lst[swap_i] +\n                           new_solution[swap_i] * weight_lst[swap_j] -\n                           new_solution[swap_i] * weight_lst[swap_i] -\n                           new_solution[swap_j] * weight_lst[swap_j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    # Step 3: Group perturbation (flip a random subset of items)\n    if random.random() < 0.3:\n        group_size = random.randint(1, min(5, num_items))\n        group_indices = random.sample(range(num_items), group_size)\n        delta_weight = np.sum((1 - 2 * new_solution[group_indices]) * weight_lst[group_indices])\n        if current_weight + delta_weight <= capacity:\n            new_solution[group_indices] = 1 - new_solution[group_indices]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.3327192514972506,
            0.6232088804244995
        ],
        "raw_score": [
            47.06101393005252,
            47.90009995257961
        ]
    }
]