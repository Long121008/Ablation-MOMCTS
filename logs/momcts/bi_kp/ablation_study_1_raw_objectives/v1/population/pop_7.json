[
    {
        "algorithm": "This heuristic selects the solution with the highest combined value (sum of both objectives) from the archive, then performs a hybrid local search by flipping items based on their marginal contributions to both objectives, prioritizing those with higher combined marginal value, while ensuring feasibility by checking the weight constraint after each flip. The algorithm sorts items by their marginal value contributions and iteratively tries to add or remove items, favoring those with the greatest potential improvement to both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined value (sum of both objectives)\n    best_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Try to flip items with high marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8416615865743579,
            0.3444518744945526
        ],
        "raw_score": [
            27.292796936643587,
            28.053736520041188
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that probabilistically adds, removes, or swaps items based on their marginal contributions to either objective, ensuring feasibility by checking weight constraints. It balances exploration and exploitation by favoring solutions with diverse marginal gains and intelligently navigates the Pareto front by leveraging both objectives' trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal gains in both objectives\n    selected_idx = 0\n    max_marginal_product = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        if len(excluded_items) == 0 or len(included_items) == 0:\n            continue\n\n        # Calculate marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_gains2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_product = np.mean(marginal_gains1) * np.mean(marginal_gains2)\n\n        if marginal_product > max_marginal_product:\n            max_marginal_product = marginal_product\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic decision between add, remove, or swap\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Probabilistic decision: 0.4 for add, 0.3 for remove, 0.3 for swap\n        decision = random.choices(['add', 'remove', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n        if decision == 'add':\n            # Add the best excluded item based on combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n        elif decision == 'remove':\n            # Remove the least marginal item in either objective\n            included_sorted = sorted(included_items, key=lambda x: min(value1_lst[x] / (weight_lst[x] + 1e-6), value2_lst[x] / (weight_lst[x] + 1e-6)))\n            for item in included_sorted:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    break\n\n        elif decision == 'swap':\n            # Swap one excluded with one included item\n            swap_excluded = random.choice(excluded_items)\n            swap_included = random.choice(included_items)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n            if new_weight <= capacity:\n                new_solution[swap_included] = 0\n                new_solution[swap_excluded] = 1\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9510446561453485,
            1.9513874053955078
        ],
        "raw_score": [
            27.300142368173844,
            27.834733828952686
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest objective diversity (difference between value1 and value2), then performs a hybrid local search by flipping items based on their normalized marginal contributions to both objectives, prioritizing those with the highest combined marginal value while ensuring feasibility. It sorts items by their normalized marginal value and iteratively flips items to maximize combined objective gains without exceeding capacity. The key design ideas are prioritizing objective diversity for selection and using normalized marginal contributions for intelligent flipping.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest objective diversity (difference between value1 and value2)\n    best_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate normalized marginal contributions for each item\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Normalize marginal contributions\n    max_marginal = np.max(marginal_combined)\n    if max_marginal > 0:\n        normalized_marginal = marginal_combined / max_marginal\n    else:\n        normalized_marginal = marginal_combined\n\n    # Sort items by normalized marginal contribution (descending)\n    sorted_indices = np.argsort(-normalized_marginal)\n\n    # Try to flip items with high normalized marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9101876645710116,
            0.3497251272201538
        ],
        "raw_score": [
            27.004661735141276,
            27.688360888346264
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive by prioritizing those with the most differing item selections, then performs a value-driven reallocation by dynamically reassigning items based on their normalized contributions to both objectives (weighted equally) while ensuring feasibility through a capacity-aware greedy process. The method balances both objectives by considering their normalized marginal gains when deciding which items to add or remove from the solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity relative to the archive\n    selected_idx = 0\n    max_diversity = -1\n\n    for i, (solution, _) in enumerate(archive):\n        diversity = 0\n        for j, (other_solution, _) in enumerate(archive):\n            if i != j:\n                diversity += np.sum(solution != other_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Normalize marginal contributions for both objectives\n    marginal_value1 = value1_lst - (new_solution * value1_lst)\n    marginal_value2 = value2_lst - (new_solution * value2_lst)\n\n    # Calculate normalized marginal gains\n    norm_value1 = marginal_value1 / (np.max(marginal_value1) + 1e-10)\n    norm_value2 = marginal_value2 / (np.max(marginal_value2) + 1e-10)\n    combined_gain = 0.5 * norm_value1 + 0.5 * norm_value2\n\n    # Sort items by combined normalized gain (descending)\n    sorted_indices = np.argsort(-combined_gain)\n\n    # Perform value-driven reallocation\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9406314534704926,
            3.105784237384796
        ],
        "raw_score": [
            27.42755884149911,
            27.854506065197445
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with high marginal gains in either objective, then applies a hybrid local search combining item swapping and dynamic reallocation to generate a feasible neighbor solution, ensuring the total weight does not exceed capacity by intelligently evaluating and selecting items based on their value-to-weight ratios. The selection process focuses on maximizing potential improvements in both objectives, while the local search dynamically adjusts the solution by swapping or adding items that offer the best marginal gains while respecting the capacity constraint.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with high marginal gains)\n    selected_idx = 0\n    max_marginal_gain = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        # Calculate marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n        marginal_gains2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Calculate marginal gains for included items\n        marginal_gains_included1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_gains_included2 = value2_lst[included_items] / weight_lst[included_items]\n\n        # Combine marginal gains (could be weighted or prioritized)\n        combined_gain = np.max(marginal_gains1) + np.max(marginal_gains2) + np.min(marginal_gains_included1) + np.min(marginal_gains_included2)\n\n        if combined_gain > max_marginal_gain:\n            max_marginal_gain = combined_gain\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or reallocate based on marginal gains\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Option 1: Swap one excluded with one included item\n        swap_excluded = random.choice(excluded_items)\n        swap_included = random.choice(included_items)\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n\n        if new_weight <= capacity:\n            new_solution[swap_included] = 0\n            new_solution[swap_excluded] = 1\n\n        # Option 2: Dynamically reallocate items based on marginal gains\n        else:\n            # Sort excluded items by marginal gain (value/weight ratio)\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            # Sort by combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9066047097248507,
            2.1325783729553223
        ],
        "raw_score": [
            27.43594203561032,
            28.25538151848722
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of normalized objectives, then performs a hybrid local search by iteratively flipping items with the highest marginal contribution to both objectives, while dynamically adjusting weights to prioritize underperforming objectives and ensuring feasibility. It also includes a diversification step to escape local optima by randomly flipping an item if no improvement is found. The key design ideas are adaptive objective weighting, marginal contribution-based flipping, and a diversification mechanism to enhance solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted sum of objectives (adaptive weights)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        best_idx = 0\n    else:\n        best_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0]/max_obj1 + archive[i][1][1]/max_obj2))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Calculate normalized marginal contributions\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_norm1 = marginal_value1 / (np.max(marginal_value1) + 1e-10)\n    marginal_norm2 = marginal_value2 / (np.max(marginal_value2) + 1e-10)\n\n    # Adaptive weight based on current solution's performance\n    weight_obj1 = 1.0 if current_value1 < 0.5 * max_obj1 else 0.7\n    weight_obj2 = 1.0 if current_value2 < 0.5 * max_obj2 else 0.7\n    marginal_combined = weight_obj1 * marginal_norm1 + weight_obj2 * marginal_norm2\n\n    # Sort items by combined marginal contribution\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Try to flip items with high marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try to remove item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional diversification: flip one random item if no improvement\n    if np.array_equal(new_solution, base_solution):\n        candidates = [i for i in range(len(weight_lst)) if (base_solution[i] == 1 and current_weight - weight_lst[i] >= 0) or\n                     (base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n        if candidates:\n            idx = np.random.choice(candidates)\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9034034519201828,
            0.4050176739692688
        ],
        "raw_score": [
            27.177010817087208,
            27.878927497500193
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on combined objective values and weight, then applies a hybrid local search combining variable neighborhood flips and item swaps to generate feasible neighbors while prioritizing improvements in both objectives. It ensures feasibility by randomly removing items when exceeding capacity, with a focus on maintaining high-value solutions through strategic flips and swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest combined objective value and lowest weight)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst * x[0]) + 1e-6))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate neighbor using hybrid local search\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Strategy 1: Randomly flip a small number of items (variable neighborhood)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Strategy 2: Swap items to improve both objectives\n    if np.sum(new_solution) > 1:\n        # Select two items to swap\n        swap_candidates = np.where(new_solution == 1)[0]\n        i, j = np.random.choice(swap_candidates, size=2, replace=False)\n\n        # Check if swap improves at least one objective\n        if (value1_lst[i] + value1_lst[j] > value1_lst[i] + value2_lst[j] and\n            value2_lst[i] + value2_lst[j] > value2_lst[i] + value1_lst[j]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = np.random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.32112441799369984,
            0.7586219608783722
        ],
        "raw_score": [
            53.86132715724975,
            52.98435862130002
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on high normalized marginal gains (sum of value-to-weight ratios for excluded items in both objectives), then applies a hybrid local search that either swaps items or adds the best excluded item (sorted by combined marginal gain) while ensuring feasibility. The selection prioritizes solutions with greater potential improvement, and the local search aggressively explores both objectives before committing to changes.\n\n*(Key points: marginal gain prioritization, combined objective evaluation, and feasibility-preserving swaps/additions.)*",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with high normalized marginal gains)\n    selected_idx = 0\n    max_marginal_gain = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        if len(excluded_items) == 0 or len(included_items) == 0:\n            continue\n\n        # Calculate normalized marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_gains2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        normalized_marginal_gain = np.sum(marginal_gains1) + np.sum(marginal_gains2)\n\n        if normalized_marginal_gain > max_marginal_gain:\n            max_marginal_gain = normalized_marginal_gain\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or reallocate based on marginal gains\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Option 1: Swap one excluded with one included item\n        swap_excluded = random.choice(excluded_items)\n        swap_included = random.choice(included_items)\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n\n        if new_weight <= capacity:\n            new_solution[swap_included] = 0\n            new_solution[swap_excluded] = 1\n\n        # Option 2: Dynamically reallocate items based on marginal gains\n        else:\n            # Sort excluded items by combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            # Sort by combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.894969087004567,
            2.173952579498291
        ],
        "raw_score": [
            30.19612069246022,
            30.10587462900969
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that swaps the worst-performing included item with the best-performing excluded item (using a combined value-to-weight ratio), ensuring feasibility by dynamically adjusting the solution. If the swap is infeasible, it greedily adds the highest-ratio excluded item. The approach balances exploration (excluded items) and exploitation (included items) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with high marginal gains)\n    selected_idx = 0\n    max_marginal_gain = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        # Calculate weighted marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n        marginal_gains2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n        combined_gain = np.sum(marginal_gains1 + marginal_gains2)\n\n        # Calculate marginal gains for included items\n        marginal_gains_included1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_gains_included2 = value2_lst[included_items] / weight_lst[included_items]\n        combined_included_gain = np.sum(marginal_gains_included1 + marginal_gains_included2)\n\n        # Total marginal gain is the sum of excluded and included gains\n        total_gain = combined_gain + combined_included_gain\n\n        if total_gain > max_marginal_gain:\n            max_marginal_gain = total_gain\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: value-weighted replacement\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Calculate weighted value-to-weight ratio for excluded items\n        excluded_weights = weight_lst[excluded_items]\n        excluded_values = value1_lst[excluded_items] + value2_lst[excluded_items]\n        excluded_ratios = excluded_values / excluded_weights\n\n        # Calculate weighted value-to-weight ratio for included items\n        included_weights = weight_lst[included_items]\n        included_values = value1_lst[included_items] + value2_lst[included_items]\n        included_ratios = included_values / included_weights\n\n        # Find the best excluded item to add\n        best_excluded_idx = np.argmax(excluded_ratios)\n        best_excluded = excluded_items[best_excluded_idx]\n\n        # Find the worst included item to remove\n        worst_included_idx = np.argmin(included_ratios)\n        worst_included = included_items[worst_included_idx]\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[worst_included] + weight_lst[best_excluded]\n\n        if new_weight <= capacity:\n            new_solution[worst_included] = 0\n            new_solution[best_excluded] = 1\n        else:\n            # If swap is infeasible, try to add the best excluded item\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n    else:\n        # If no swap possible, try to add the best excluded item\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7694450688053949,
            0.9725945889949799
        ],
        "raw_score": [
            28.012765264459624,
            28.61581539945186
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing high-objective-value and low-weight candidates, then applies a hybrid local search combining random flips, greedy swaps, and adaptive perturbations to generate a feasible neighbor solution. It ensures feasibility by intelligently removing heaviest items when necessary and uses probabilistic perturbations to escape local optima. The method balances exploration (random flips) and exploitation (greedy swaps) while prioritizing both objectives through weighted sorting and targeted improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, obj, total_weight))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Sort candidates by a heuristic score (prioritize high objectives and low weights)\n    candidates.sort(key=lambda x: (-x[1][0], -x[1][1], x[2]))\n\n    # Select top 10% candidates for random selection\n    top_percent = max(1, len(candidates) // 10)\n    selected_idx = random.randint(0, top_percent - 1)\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random flips with adaptive probability\n    flip_prob = 0.3  # Base probability\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove heaviest items until feasible\n        sorted_indices = np.argsort(weight_lst * new_solution)\n        for i in sorted_indices[::-1]:\n            if total_weight <= capacity:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Greedy swaps (improve one objective while maintaining feasibility)\n    for _ in range(5):  # Limit iterations to prevent excessive computation\n        # Try to add the best possible item for value1\n        for i in range(n_items):\n            if new_solution[i] == 0 and (total_weight + weight_lst[i]) <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                new_total_value1 = np.sum(value1_lst * temp_solution)\n                current_total_value1 = np.sum(value1_lst * new_solution)\n                if new_total_value1 > current_total_value1:\n                    new_solution = temp_solution\n                    total_weight += weight_lst[i]\n                    break\n\n        # Try to add the best possible item for value2\n        for i in range(n_items):\n            if new_solution[i] == 0 and (total_weight + weight_lst[i]) <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                new_total_value2 = np.sum(value2_lst * temp_solution)\n                current_total_value2 = np.sum(value2_lst * new_solution)\n                if new_total_value2 > current_total_value2:\n                    new_solution = temp_solution\n                    total_weight += weight_lst[i]\n                    break\n\n    # Step 3: Adaptive perturbation (remove worst items to create space)\n    if random.random() < 0.2:  # 20% chance of perturbation\n        sorted_indices = np.argsort(value1_lst + value2_lst)\n        for i in sorted_indices:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = total_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    total_weight = temp_weight\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.3789801512819108,
            0.9593010246753693
        ],
        "raw_score": [
            48.098163223369454,
            46.641509572119
        ]
    }
]