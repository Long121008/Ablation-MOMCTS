[
    {
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with high marginal gains in either objective, then applies a hybrid local search combining item swapping and dynamic reallocation to generate a feasible neighbor solution, ensuring the total weight does not exceed capacity by intelligently evaluating and selecting items based on their value-to-weight ratios. The selection process focuses on maximizing potential improvements in both objectives, while the local search dynamically adjusts the solution by swapping or adding items that offer the best marginal gains while respecting the capacity constraint.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with high marginal gains)\n    selected_idx = 0\n    max_marginal_gain = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        # Calculate marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n        marginal_gains2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Calculate marginal gains for included items\n        marginal_gains_included1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_gains_included2 = value2_lst[included_items] / weight_lst[included_items]\n\n        # Combine marginal gains (could be weighted or prioritized)\n        combined_gain = np.max(marginal_gains1) + np.max(marginal_gains2) + np.min(marginal_gains_included1) + np.min(marginal_gains_included2)\n\n        if combined_gain > max_marginal_gain:\n            max_marginal_gain = combined_gain\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or reallocate based on marginal gains\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Option 1: Swap one excluded with one included item\n        swap_excluded = random.choice(excluded_items)\n        swap_included = random.choice(included_items)\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n\n        if new_weight <= capacity:\n            new_solution[swap_included] = 0\n            new_solution[swap_excluded] = 1\n\n        # Option 2: Dynamically reallocate items based on marginal gains\n        else:\n            # Sort excluded items by marginal gain (value/weight ratio)\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            # Sort by combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9066047097248507,
            2.1325783729553223
        ],
        "raw_score": [
            27.43594203561032,
            28.25538151848722
        ]
    },
    {
        "algorithm": "This heuristic selects the solution with the highest combined value (sum of both objectives) from the archive, then performs a hybrid local search by flipping items based on their marginal contributions to both objectives, prioritizing those with higher combined marginal value, while ensuring feasibility by checking the weight constraint after each flip. The algorithm sorts items by their marginal value contributions and iteratively tries to add or remove items, favoring those with the greatest potential improvement to both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined value (sum of both objectives)\n    best_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst - (base_solution * value1_lst)\n    marginal_value2 = value2_lst - (base_solution * value2_lst)\n    marginal_combined = marginal_value1 + marginal_value2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_combined)\n\n    # Try to flip items with high marginal contribution\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # If item is in the solution, try to remove it\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is not in the solution, try to add it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8416615865743579,
            0.3444518744945526
        ],
        "raw_score": [
            27.292796936643587,
            28.053736520041188
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive by prioritizing those with the most differing item selections, then performs a value-driven reallocation by dynamically reassigning items based on their normalized contributions to both objectives (weighted equally) while ensuring feasibility through a capacity-aware greedy process. The method balances both objectives by considering their normalized marginal gains when deciding which items to add or remove from the solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity relative to the archive\n    selected_idx = 0\n    max_diversity = -1\n\n    for i, (solution, _) in enumerate(archive):\n        diversity = 0\n        for j, (other_solution, _) in enumerate(archive):\n            if i != j:\n                diversity += np.sum(solution != other_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Normalize marginal contributions for both objectives\n    marginal_value1 = value1_lst - (new_solution * value1_lst)\n    marginal_value2 = value2_lst - (new_solution * value2_lst)\n\n    # Calculate normalized marginal gains\n    norm_value1 = marginal_value1 / (np.max(marginal_value1) + 1e-10)\n    norm_value2 = marginal_value2 / (np.max(marginal_value2) + 1e-10)\n    combined_gain = 0.5 * norm_value1 + 0.5 * norm_value2\n\n    # Sort items by combined normalized gain (descending)\n    sorted_indices = np.argsort(-combined_gain)\n\n    # Perform value-driven reallocation\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9406314534704926,
            3.105784237384796
        ],
        "raw_score": [
            27.42755884149911,
            27.854506065197445
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on high normalized marginal gains (sum of value-to-weight ratios for excluded items in both objectives), then applies a hybrid local search that either swaps items or adds the best excluded item (sorted by combined marginal gain) while ensuring feasibility. The selection prioritizes solutions with greater potential improvement, and the local search aggressively explores both objectives before committing to changes.\n\n*(Key points: marginal gain prioritization, combined objective evaluation, and feasibility-preserving swaps/additions.)*",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with high normalized marginal gains)\n    selected_idx = 0\n    max_marginal_gain = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        if len(excluded_items) == 0 or len(included_items) == 0:\n            continue\n\n        # Calculate normalized marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        marginal_gains2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        normalized_marginal_gain = np.sum(marginal_gains1) + np.sum(marginal_gains2)\n\n        if normalized_marginal_gain > max_marginal_gain:\n            max_marginal_gain = normalized_marginal_gain\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or reallocate based on marginal gains\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Option 1: Swap one excluded with one included item\n        swap_excluded = random.choice(excluded_items)\n        swap_included = random.choice(included_items)\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n\n        if new_weight <= capacity:\n            new_solution[swap_included] = 0\n            new_solution[swap_excluded] = 1\n\n        # Option 2: Dynamically reallocate items based on marginal gains\n        else:\n            # Sort excluded items by combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    # If no swap possible, try to add the best excluded item\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            # Sort by combined marginal gain\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] / (weight_lst[x] + 1e-6)) + (value2_lst[x] / (weight_lst[x] + 1e-6)), reverse=True)\n\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.894969087004567,
            2.173952579498291
        ],
        "raw_score": [
            30.19612069246022,
            30.10587462900969
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on combined objective values and weight, then applies a hybrid local search combining variable neighborhood flips and item swaps to generate feasible neighbors while prioritizing improvements in both objectives. It ensures feasibility by randomly removing items when exceeding capacity, with a focus on maintaining high-value solutions through strategic flips and swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest combined objective value and lowest weight)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst * x[0]) + 1e-6))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate neighbor using hybrid local search\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Strategy 1: Randomly flip a small number of items (variable neighborhood)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Strategy 2: Swap items to improve both objectives\n    if np.sum(new_solution) > 1:\n        # Select two items to swap\n        swap_candidates = np.where(new_solution == 1)[0]\n        i, j = np.random.choice(swap_candidates, size=2, replace=False)\n\n        # Check if swap improves at least one objective\n        if (value1_lst[i] + value1_lst[j] > value1_lst[i] + value2_lst[j] and\n            value2_lst[i] + value2_lst[j] > value2_lst[i] + value1_lst[j]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = np.random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.32112441799369984,
            0.7586219608783722
        ],
        "raw_score": [
            53.86132715724975,
            52.98435862130002
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing high-objective-value and low-weight candidates, then applies a hybrid local search combining random flips, greedy swaps, and adaptive perturbations to generate a feasible neighbor solution. It ensures feasibility by intelligently removing heaviest items when necessary and uses probabilistic perturbations to escape local optima. The method balances exploration (random flips) and exploitation (greedy swaps) while prioritizing both objectives through weighted sorting and targeted improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, obj, total_weight))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Sort candidates by a heuristic score (prioritize high objectives and low weights)\n    candidates.sort(key=lambda x: (-x[1][0], -x[1][1], x[2]))\n\n    # Select top 10% candidates for random selection\n    top_percent = max(1, len(candidates) // 10)\n    selected_idx = random.randint(0, top_percent - 1)\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random flips with adaptive probability\n    flip_prob = 0.3  # Base probability\n    for i in range(n_items):\n        if random.random() < flip_prob:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove heaviest items until feasible\n        sorted_indices = np.argsort(weight_lst * new_solution)\n        for i in sorted_indices[::-1]:\n            if total_weight <= capacity:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Greedy swaps (improve one objective while maintaining feasibility)\n    for _ in range(5):  # Limit iterations to prevent excessive computation\n        # Try to add the best possible item for value1\n        for i in range(n_items):\n            if new_solution[i] == 0 and (total_weight + weight_lst[i]) <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                new_total_value1 = np.sum(value1_lst * temp_solution)\n                current_total_value1 = np.sum(value1_lst * new_solution)\n                if new_total_value1 > current_total_value1:\n                    new_solution = temp_solution\n                    total_weight += weight_lst[i]\n                    break\n\n        # Try to add the best possible item for value2\n        for i in range(n_items):\n            if new_solution[i] == 0 and (total_weight + weight_lst[i]) <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                new_total_value2 = np.sum(value2_lst * temp_solution)\n                current_total_value2 = np.sum(value2_lst * new_solution)\n                if new_total_value2 > current_total_value2:\n                    new_solution = temp_solution\n                    total_weight += weight_lst[i]\n                    break\n\n    # Step 3: Adaptive perturbation (remove worst items to create space)\n    if random.random() < 0.2:  # 20% chance of perturbation\n        sorted_indices = np.argsort(value1_lst + value2_lst)\n        for i in sorted_indices:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = total_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    total_weight = temp_weight\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.3789801512819108,
            0.9593010246753693
        ],
        "raw_score": [
            48.098163223369454,
            46.641509572119
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that swaps the worst-performing included item with the best-performing excluded item (using a combined value-to-weight ratio), ensuring feasibility by dynamically adjusting the solution. If the swap is infeasible, it greedily adds the highest-ratio excluded item. The approach balances exploration (excluded items) and exploitation (included items) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with high marginal gains)\n    selected_idx = 0\n    max_marginal_gain = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        # Calculate weighted marginal gains for excluded items\n        marginal_gains1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n        marginal_gains2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n        combined_gain = np.sum(marginal_gains1 + marginal_gains2)\n\n        # Calculate marginal gains for included items\n        marginal_gains_included1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_gains_included2 = value2_lst[included_items] / weight_lst[included_items]\n        combined_included_gain = np.sum(marginal_gains_included1 + marginal_gains_included2)\n\n        # Total marginal gain is the sum of excluded and included gains\n        total_gain = combined_gain + combined_included_gain\n\n        if total_gain > max_marginal_gain:\n            max_marginal_gain = total_gain\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: value-weighted replacement\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Calculate weighted value-to-weight ratio for excluded items\n        excluded_weights = weight_lst[excluded_items]\n        excluded_values = value1_lst[excluded_items] + value2_lst[excluded_items]\n        excluded_ratios = excluded_values / excluded_weights\n\n        # Calculate weighted value-to-weight ratio for included items\n        included_weights = weight_lst[included_items]\n        included_values = value1_lst[included_items] + value2_lst[included_items]\n        included_ratios = included_values / included_weights\n\n        # Find the best excluded item to add\n        best_excluded_idx = np.argmax(excluded_ratios)\n        best_excluded = excluded_items[best_excluded_idx]\n\n        # Find the worst included item to remove\n        worst_included_idx = np.argmin(included_ratios)\n        worst_included = included_items[worst_included_idx]\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        new_weight = current_weight - weight_lst[worst_included] + weight_lst[best_excluded]\n\n        if new_weight <= capacity:\n            new_solution[worst_included] = 0\n            new_solution[best_excluded] = 1\n        else:\n            # If swap is infeasible, try to add the best excluded item\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n    else:\n        # If no swap possible, try to add the best excluded item\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n            for item in excluded_sorted:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7694450688053949,
            0.9725945889949799
        ],
        "raw_score": [
            28.012765264459624,
            28.61581539945186
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive by prioritizing items with high marginal gains in both objectives, then applies a hybrid local search combining probabilistic flipping (removing low-marginal items and adding high-marginal ones) and swapping (exchanging low-marginal included items with high-marginal excluded items), ensuring feasibility by dynamically checking weight constraints. The algorithm balances exploration (random selection) and exploitation (targeted marginal improvement) to navigate the multi-objective solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement in both objectives\n    selected_idx = 0\n    max_marginal_gain = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n        included_items = np.where(solution == 1)[0]\n\n        # Calculate marginal gains for excluded items in both objectives\n        marginal_gains1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n        marginal_gains2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Calculate marginal gains for included items in both objectives\n        marginal_gains_included1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_gains_included2 = value2_lst[included_items] / weight_lst[included_items]\n\n        # Combine marginal gains for both objectives\n        combined_gain = np.max(marginal_gains1) + np.max(marginal_gains2) + np.min(marginal_gains_included1) + np.min(marginal_gains_included2)\n\n        if combined_gain > max_marginal_gain:\n            max_marginal_gain = combined_gain\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic flip or swap based on marginal gains\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Probabilistically decide between flip or swap\n    if random.random() < 0.5 and len(included_items) > 0:\n        # Flip operation: remove a low-marginal item and add a high-marginal item\n        flip_candidate = random.choice(included_items)\n        new_weight = current_weight - weight_lst[flip_candidate]\n\n        # Find best excluded item to add\n        if len(excluded_items) > 0:\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n            for item in excluded_sorted:\n                if new_weight + weight_lst[item] <= capacity:\n                    new_solution[flip_candidate] = 0\n                    new_solution[item] = 1\n                    break\n    else:\n        # Swap operation: swap a low-marginal included item with a high-marginal excluded item\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            # Select low-marginal included item\n            included_sorted = sorted(included_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n            swap_included = included_sorted[0]\n\n            # Select high-marginal excluded item\n            excluded_sorted = sorted(excluded_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x], reverse=True)\n            swap_excluded = excluded_sorted[0]\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[swap_included] + weight_lst[swap_excluded]\n            if new_weight <= capacity:\n                new_solution[swap_included] = 0\n                new_solution[swap_excluded] = 1\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7963353393920493,
            1.4684830904006958
        ],
        "raw_score": [
            27.46681398138317,
            27.898053472709464
        ]
    },
    {
        "algorithm": "The algorithm selects a base solution from the archive with probability proportional to its objective diversity, then applies a hybrid local search combining random item swaps and value-aware perturbations to generate a feasible neighbor solution, prioritizing items with high value-to-weight ratios while ensuring the total weight does not exceed capacity. The method intelligently balances exploration (random swaps) and exploitation (value-aware flips) to navigate the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with probability proportional to its objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    probs = diversity / np.sum(diversity) if np.sum(diversity) > 0 else np.ones(len(diversity)) / len(diversity)\n    base_idx = np.random.choice(len(archive), p=probs)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swap + value-aware perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Random swap\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = current_weight + (weight_lst[i] - weight_lst[j]) * (new_solution[i] - base_solution[i])\n            if new_weight > capacity:\n                # Undo if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Value-aware perturbation: flip items with high value ratios\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(value_ratios)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Consider removing low-value items\n            if value_ratios[idx] < np.median(value_ratios):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.282874492962377,
            4.53104841709137
        ],
        "raw_score": [
            54.204129350533236,
            53.590167331701565
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (prioritize those with high marginal gains in either objective)\n    selected_idx = 0\n    max_potential = -1\n\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        excluded_items = np.where(solution == 0)[0]\n\n        # Calculate potential improvement for each objective\n        potential1 = np.sum(value1_lst[excluded_items]) if len(excluded_items) > 0 else 0\n        potential2 = np.sum(value2_lst[excluded_items]) if len(excluded_items) > 0 else 0\n\n        # Combine potential improvements with weight utilization\n        combined_potential = (potential1 + potential2) / (capacity - current_weight + 1e-6)\n\n        if combined_potential > max_potential:\n            max_potential = combined_potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item flipping with value-driven swaps\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Phase 1: Adaptive flipping of items based on objective-specific value-to-weight ratios\n    if len(included_items) > 0:\n        # Calculate value-to-weight ratios for each objective\n        v1_ratio = value1_lst[included_items] / weight_lst[included_items]\n        v2_ratio = value2_lst[included_items] / weight_lst[included_items]\n\n        # Identify items with lowest ratios in either objective\n        worst_items = np.where((v1_ratio == np.min(v1_ratio)) | (v2_ratio == np.min(v2_ratio)))[0]\n\n        if len(worst_items) > 0:\n            flip_idx = included_items[np.random.choice(worst_items)]\n            new_solution[flip_idx] = 0\n            current_weight -= weight_lst[flip_idx]\n\n    # Phase 2: Value-driven swaps between included and excluded items\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Calculate marginal gains for excluded items\n        excluded_v1 = value1_lst[excluded_items]\n        excluded_v2 = value2_lst[excluded_items]\n        excluded_weights = weight_lst[excluded_items]\n\n        # Find best excluded item for each objective\n        best_v1_idx = np.argmax(excluded_v1 / excluded_weights)\n        best_v2_idx = np.argmax(excluded_v2 / excluded_weights)\n\n        # Select candidates for swap\n        candidates = np.unique([best_v1_idx, best_v2_idx])\n\n        for candidate in candidates:\n            item = excluded_items[candidate]\n            if current_weight + weight_lst[item] <= capacity:\n                # Find worst included item to swap out\n                included_v1 = value1_lst[included_items]\n                included_v2 = value2_lst[included_items]\n                included_weights = weight_lst[included_items]\n\n                # Calculate dominance scores for included items\n                dominance_scores = included_v1 + included_v2 - (value1_lst[item] + value2_lst[item])\n                worst_included = np.argmin(dominance_scores)\n\n                if dominance_scores[worst_included] < 0:  # Only swap if it improves at least one objective\n                    new_solution[included_items[worst_included]] = 0\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item] - weight_lst[included_items[worst_included]]\n                    break\n\n    # Ensure feasibility by removing worst items if needed\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n\n        # Calculate dominance scores for included items\n        included_v1 = value1_lst[included_items]\n        included_v2 = value2_lst[included_items]\n        dominance_scores = included_v1 + included_v2\n\n        # Remove item with lowest combined value\n        remove_idx = included_items[np.argmin(dominance_scores)]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7606937637281102,
            9.097633838653564
        ],
        "raw_score": [
            27.430295801003712,
            28.431965112987786
        ]
    }
]