[
    {
        "algorithm": "This algorithm intelligently selects a promising solution from the archive by normalizing and summing its objectives, then generates a neighbor solution through a hybrid approach combining random item flips (with a 30% probability) and strategic swaps (prioritizing high-value-to-weight items). It ensures feasibility by checking weights and removing excess items if needed, always maintaining the knapsack capacity constraint. The method balances exploration (random flips) with exploitation (value-based swaps) for effective local search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we choose the one with the highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a neighbor solution using a hybrid approach\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (with bias towards improving both objectives)\n    flip_mask = np.zeros(n_items, dtype=bool)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if base_solution[i] == 0:\n                potential_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n                if potential_weight <= capacity:\n                    flip_mask[i] = True\n            else:\n                flip_mask[i] = True\n\n    # Step 2: Apply the flips\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 3: If no flips applied, try a different approach (swap two items)\n    if not np.any(flip_mask):\n        # Find two items to swap (one in, one out)\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with high value-to-weight ratio for potential swap\n            in_ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            out_ratios = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n            best_in = in_items[np.argmin(in_ratios)]  # Item to remove (lowest ratio)\n            best_out = out_items[np.argmax(out_ratios)]  # Item to add (highest ratio)\n\n            # Check if swap is feasible\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            potential_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n            if potential_weight <= capacity:\n                new_solution[best_in] = 0\n                new_solution[best_out] = 1\n\n    # Ensure solution is feasible (in case of any errors)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        while current_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8777357135529364,
            0.6920754313468933
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, identifies critical items based on combined value-to-weight ratios, and applies a hybrid local search by toggling these items while ensuring feasibility. It also randomly flips non-critical items to escape local optima. The method prioritizes high-value items while maintaining solution feasibility through weight checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    current_solution = selected_solution.copy()\n\n    # Step 2: Identify critical items (those with high value-to-weight ratios)\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n    combined_value_to_weight = value_to_weight1 + value_to_weight2\n    critical_items = np.argsort(combined_value_to_weight)[-min(5, len(weight_lst)):]  # Top 5 items\n\n    # Step 3: Apply a hybrid local search strategy\n    # Flip critical items (if not already in the solution) or remove low-value items\n    new_solution = current_solution.copy()\n    for item in critical_items:\n        if current_solution[item] == 0:\n            # Try adding the item if it fits\n            if (np.sum(weight_lst * new_solution) + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n        else:\n            # Try removing the item\n            new_solution[item] = 0\n            if np.sum(weight_lst * new_solution) <= capacity:\n                pass  # Keep the change\n            else:\n                new_solution[item] = 1  # Revert if infeasible\n\n    # Step 4: Randomly flip a small number of non-critical items to escape local optima\n    non_critical_items = np.setdiff1d(np.arange(len(weight_lst)), critical_items)\n    if len(non_critical_items) > 0:\n        flip_indices = np.random.choice(non_critical_items, size=min(2, len(non_critical_items)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n            # Ensure feasibility\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8266459948173828,
            0.3179592788219452
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, applies a flip mutation to a random item, and then attempts to iteratively add or remove items to improve both objectives while ensuring feasibility. It prioritizes flipping a single item first, followed by greedy additions and removals of items that don't worsen either objective. The heuristic balances exploration (random selection and flipping) with exploitation (greedy improvements) to generate diverse, high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: Flip a randomly selected item and attempt to add/remove items to improve both objectives\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Randomly flip one item (basic local search)\n    flip_idx = np.random.choice(n_items)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If flipping violates capacity, undo the flip\n        new_solution[flip_idx] = base_solution[flip_idx]\n\n    # Step 2: Attempt to add items not in the solution to improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n\n    for item in remaining_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Temporarily add the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            # Check if adding improves both objectives (approximate)\n            if temp_weight <= capacity:\n                # If no objective worsens, keep the change\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Step 3: Attempt to remove items to improve both objectives\n    included_items = np.where(new_solution == 1)[0]\n    np.random.shuffle(included_items)\n\n    for item in included_items:\n        temp_solution = new_solution.copy()\n        temp_solution[item] = 0\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        # Check if removing improves both objectives (approximate)\n        if temp_weight <= capacity:\n            # If no objective worsens, keep the change\n            new_solution = temp_solution\n            current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8479368153123263,
            0.807338297367096
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using adaptive normalization (prioritizing solutions with high unexplored potential) and applies a hybrid local search combining critical-item flips (top 10% value-to-weight) with guided random swaps (biased toward high-value items), while ensuring feasibility through incremental weight checks and repair mechanisms. The method prioritizes items with the highest combined value-to-weight ratios, flips their inclusion status, and performs targeted swaps to improve both objectives while maintaining capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: prioritize solutions with unexplored neighborhoods\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(objectives, axis=0)  # Higher diversity suggests unexplored regions\n    weighted_scores = normalized_obj * diversity_scores\n    selected_idx = np.argmax(weighted_scores.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate combined value-to-weight ratios\n    combined_ratios = (value1_lst + value2_lst) / weight_lst\n    critical_items = np.argsort(combined_ratios)[-max(1, len(weight_lst) // 10):]  # Top 10% items\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid perturbation\n    # 1. Flip critical items (add if not present, remove if present)\n    for item in critical_items:\n        if new_solution[item] == 0:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        else:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # 2. Guided random swaps (bias toward high-value items)\n    non_critical_items = np.setdiff1d(np.arange(len(weight_lst)), critical_items)\n    if len(non_critical_items) > 0:\n        # Select a candidate to swap out (lowest value-to-weight ratio in current solution)\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            in_ratios = combined_ratios[in_items]\n            swap_out = in_items[np.argmin(in_ratios)]\n\n            # Select a candidate to swap in (highest value-to-weight ratio not in solution)\n            out_items = np.where(new_solution == 0)[0]\n            if len(out_items) > 0:\n                out_ratios = combined_ratios[out_items]\n                swap_in = out_items[np.argmax(out_ratios)]\n\n                # Check if swap is feasible\n                potential_weight = current_weight - weight_lst[swap_out] + weight_lst[swap_in]\n                if potential_weight <= capacity:\n                    new_solution[swap_out] = 0\n                    new_solution[swap_in] = 1\n\n    # Ensure feasibility (repair if needed)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        excess_ratios = combined_ratios[excess_items]\n        # Remove items with lowest value-to-weight ratio until feasible\n        while current_weight > capacity and len(excess_items) > 0:\n            remove_idx = excess_items[np.argmin(excess_ratios)]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            excess_items = np.where(new_solution == 1)[0]\n            excess_ratios = combined_ratios[excess_items]\n\n    return new_solution\n\n",
        "score": [
            -0.7557951720924632,
            0.38932788372039795
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high objective diversity (absolute difference between the two objectives) and low density (fewer items), then applies a hybrid local search combining random item swaps and flips with a probability of 0.3, ensuring feasibility by always checking the weight constraint. The selection emphasizes solutions with balanced objectives and simplicity, while the local search explores neighbors intelligently to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity and low density\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, obj) in enumerate(archive):\n        diversity = abs(obj[0] - obj[1])  # Measure of objective diversity\n        density = np.sum(sol)  # Number of items in the solution\n        score = diversity / (density + 1)  # Prefer solutions with high diversity and low density\n        if score > max_diversity:\n            max_diversity = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and flip with probability\n    n_items = len(weight_lst)\n    for _ in range(2):  # Perform 2 iterations of local search\n        # Randomly select two distinct items\n        i, j = np.random.choice(n_items, size=2, replace=False)\n\n        # Try swapping items i and j\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        total_weight = np.sum(temp_solution * weight_lst)\n\n        if total_weight <= capacity:\n            new_solution = temp_solution.copy()\n\n        # Try flipping item i with probability 0.3\n        if np.random.rand() < 0.3:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1 - temp_solution[i]\n            total_weight = np.sum(temp_solution * weight_lst)\n\n            if total_weight <= capacity:\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7024644525497394,
            0.6926618814468384
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (based on normalized objective scores) and generates a neighbor by first flipping high-impact \"critical\" items (top 5 by combined value-to-weight ratio) with a 70% chance, then probabilistically flipping remaining items with a decaying probability (starting at 50%) to balance exploration and exploitation, while always ensuring feasibility by removing excess items if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Phase 1: Identify critical items (high impact on both objectives)\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    critical_items = np.argsort(value_ratios)[-min(5, n_items):]  # Top 5 items by combined ratio\n\n    # Phase 2: Guided flip of critical items\n    for item in critical_items:\n        if np.random.rand() < 0.7:  # 70% chance to consider flipping\n            if new_solution[item] == 0:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n            else:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Phase 3: Probabilistic exploration (decaying probability)\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    exploration_prob = 0.5  # Initial probability\n\n    for item in remaining_items:\n        if np.random.rand() < exploration_prob:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                exploration_prob *= 0.9  # Decay probability\n\n    # Ensure feasibility\n    while current_weight > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4640978474732475,
            0.964194118976593
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Select the most promising solution using a hybrid objective scoring\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj[:, 0] * 0.6 + normalized_obj[:, 1] * 0.4  # Weighted sum of normalized objectives\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 2: Value-based strategic swaps with objective-aware selection\n    # Calculate value-to-weight ratios for both objectives\n    v1_ratio = value1_lst / weight_lst\n    v2_ratio = value2_lst / weight_lst\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Select top 10% items for potential swaps\n    n_swap_candidates = max(1, int(0.1 * n_items))\n    swap_candidates = np.argsort(combined_ratio)[-n_swap_candidates:]\n\n    # Perform swaps between items in and out of the solution\n    in_items = np.where(base_solution == 1)[0]\n    out_items = np.where(base_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Select items with highest combined ratio to add\n        potential_add = np.intersect1d(out_items, swap_candidates)\n        if len(potential_add) > 0:\n            best_add = potential_add[np.argmax(combined_ratio[potential_add])]\n\n            # Select items with lowest combined ratio to remove\n            potential_remove = np.intersect1d(in_items, swap_candidates)\n            if len(potential_remove) > 0:\n                best_remove = potential_remove[np.argmin(combined_ratio[potential_remove])]\n\n                # Check if swap is feasible\n                current_weight = np.sum(weight_lst[base_solution == 1])\n                potential_weight = current_weight - weight_lst[best_remove] + weight_lst[best_add]\n\n                if potential_weight <= capacity:\n                    new_solution[best_remove] = 0\n                    new_solution[best_add] = 1\n\n    # Phase 3: Diversity-preserving mutations with objective-aware perturbations\n    # Calculate objective-specific diversity scores\n    obj1_diversity = np.abs(value1_lst - np.mean(value1_lst[base_solution == 1]))\n    obj2_diversity = np.abs(value2_lst - np.mean(value2_lst[base_solution == 1]))\n\n    # Select items to mutate based on combined diversity and value\n    mutation_scores = (obj1_diversity + obj2_diversity) * combined_ratio\n    mutation_candidates = np.argsort(mutation_scores)[-min(3, len(mutation_scores)):]\n\n    for item in mutation_candidates:\n        if random.random() < 0.4:  # 40% chance to mutate\n            if base_solution[item] == 0:\n                # Try adding the item if it fits\n                if (np.sum(weight_lst[new_solution == 1]) + weight_lst[item]) <= capacity:\n                    new_solution[item] = 1\n            else:\n                # Try removing the item\n                new_solution[item] = 0\n                if np.sum(weight_lst[new_solution == 1]) <= capacity:\n                    pass  # Keep the change\n                else:\n                    new_solution[item] = 1  # Revert if infeasible\n\n    # Phase 4: Ensure solution feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        excess_ratios = combined_ratio[excess_items]\n        sorted_excess = excess_items[np.argsort(excess_ratios)]\n\n        for item in sorted_excess:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n            if current_weight <= capacity:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.46220826927623404,
            0.8699842989444733
        ]
    },
    {
        "algorithm": "This heuristic algorithm selects a promising solution from the archive by prioritizing those with high combined objective values, then applies a hybrid local search combining random flips (with probabilities adjusted by item impact) and greedy selection to generate feasible neighbor solutions. The algorithm ensures feasibility by checking weights during flips and includes a final step to remove items if the solution exceeds capacity. The selection focuses on the top 10% of solutions by combined objective scores, and the local search alternates between probabilistic flips and greedy improvements for one objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (high combined objective value)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate combined objective scores (normalized)\n    combined_scores = np.array([(obj[0] + obj[1]) / (2 * max(obj[0], obj[1])) if max(obj[0], obj[1]) != 0 else 0\n                               for obj in archive_objectives])\n\n    # Select top 10% of solutions by combined score\n    top_indices = np.argsort(combined_scores)[-max(1, len(archive) // 10):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Random flip with probability proportional to item's impact\n    for i in range(n_items):\n        if np.random.rand() < 0.2:  # Base probability\n            # Calculate potential impact of flipping this item\n            impact = value1_lst[i] + value2_lst[i]\n            if new_solution[i] == 1:\n                impact *= -1  # Removing would reduce total value\n\n            # Adjust flip probability based on impact\n            flip_prob = min(0.5, 0.2 + abs(impact) / (np.sum(value1_lst) + np.sum(value2_lst)))\n            if np.random.rand() < flip_prob:\n                # Check feasibility\n                if new_solution[i] == 1:\n                    if np.sum(new_solution * weight_lst) - weight_lst[i] <= capacity:\n                        new_solution[i] = 0\n                else:\n                    if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n\n    # Step 3: Apply greedy improvement for one objective\n    if np.random.rand() < 0.5:  # 50% chance to apply greedy improvement\n        # Choose objective to improve\n        obj_to_improve = np.random.choice([0, 1])\n\n        # Find items that can be added without exceeding capacity\n        current_weight = np.sum(new_solution * weight_lst)\n        available_weight = capacity - current_weight\n\n        if available_weight > 0:\n            # Find items that can be added and improve the chosen objective\n            if obj_to_improve == 0:\n                candidates = np.where((new_solution == 0) &\n                                    (weight_lst <= available_weight) &\n                                    (value1_lst > 0))[0]\n            else:\n                candidates = np.where((new_solution == 0) &\n                                    (weight_lst <= available_weight) &\n                                    (value2_lst > 0))[0]\n\n            if len(candidates) > 0:\n                # Select the best candidate based on the chosen objective\n                if obj_to_improve == 0:\n                    best_candidate = candidates[np.argmax(value1_lst[candidates])]\n                else:\n                    best_candidate = candidates[np.argmax(value2_lst[candidates])]\n\n                new_solution[best_candidate] = 1\n\n    # Ensure solution is feasible (shouldn't be necessary due to checks above)\n    if np.sum(new_solution * weight_lst) > capacity:\n        # Remove random items until feasible\n        while np.sum(new_solution * weight_lst) > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.35497509602845984,
            0.9668164849281311
        ]
    },
    {
        "algorithm": "This heuristic algorithm selects a promising solution from the archive using a weighted random approach that prioritizes high objective values (60% weight for value1, 40% for value2) and solution diversity (20% weight). It then generates a neighbor solution by first performing probabilistic item swaps based on value-to-weight ratios (40% chance per item) and then conducting a value-weighted random walk to add high-potential items (60% chance per attempt). The algorithm ensures feasibility by removing low-value items if the total weight exceeds capacity, with a focus on maintaining a balanced trade-off between both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using weighted random selection based on objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))])\n    diversity_score = np.mean(diversity_scores) if len(diversity_scores) > 0 else 1.0\n    combined_scores = normalized_obj[:, 0] * 0.6 + normalized_obj[:, 1] * 0.4 + diversity_score * 0.2\n    selected_idx = np.random.choice(len(archive), p=combined_scores/np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a neighbor solution using a hybrid approach\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Probabilistic item swaps based on value-to-weight ratio\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(value_ratios)[::-1]\n    for i in sorted_indices:\n        if random.random() < 0.4:  # 40% chance to consider swapping\n            if base_solution[i] == 0:\n                potential_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n                if potential_weight <= capacity:\n                    new_solution[i] = 1\n            else:\n                new_solution[i] = 0\n\n    # Step 2: Value-weighted random walk to explore high-potential regions\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_indices = np.where(new_solution == 0)[0]\n    if len(available_indices) > 0:\n        available_ratios = value_ratios[available_indices]\n        selection_probs = available_ratios / np.sum(available_ratios)\n        for _ in range(3):  # Try adding 3 items\n            if random.random() < 0.6:  # 60% chance to add an item\n                selected_item = np.random.choice(available_indices, p=selection_probs)\n                if current_weight + weight_lst[selected_item] <= capacity:\n                    new_solution[selected_item] = 1\n                    current_weight += weight_lst[selected_item]\n                    available_indices = np.where(new_solution == 0)[0]\n                    if len(available_indices) == 0:\n                        break\n                    available_ratios = value_ratios[available_indices]\n                    selection_probs = available_ratios / np.sum(available_ratios)\n\n    # Ensure solution is feasible\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items with lowest value-to-weight ratio first\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            included_ratios = value_ratios[included_items]\n            sorted_remove = included_items[np.argsort(included_ratios)]\n            for i in sorted_remove:\n                if current_weight <= capacity:\n                    break\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4160412044903351,
            1.355648010969162
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from an archive using a weighted combination of objectives with random weights, then generates a neighbor by strategically swapping items with high marginal gains in both objectives while ensuring feasibility through dynamic weight adjustments and targeted removals of low-marginal items. The selection prioritizes solutions with balanced objective values, and the local search focuses on improving both objectives by swapping in high-value items and removing low-value ones when necessary.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with random weighted objective combination\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate marginal gains for each item\n    in_items = np.where(base_solution == 1)[0]\n    out_items = np.where(base_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate marginal gains for items currently in the solution\n        in_marginals = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n\n        # Calculate marginal gains for items not in the solution\n        out_marginals = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n        # Find best items to swap\n        best_in = in_items[np.argmin(in_marginals)]\n        best_out = out_items[np.argmax(out_marginals)]\n\n        # Check if swap is feasible\n        current_weight = np.sum(weight_lst[base_solution == 1])\n        potential_weight = current_weight - weight_lst[best_in] + weight_lst[best_out]\n\n        if potential_weight <= capacity:\n            new_solution[best_in] = 0\n            new_solution[best_out] = 1\n        else:\n            # If swap not feasible, try removing low-marginal items\n            excess_weight = potential_weight - capacity\n            sorted_in_items = in_items[np.argsort(in_marginals)]\n            for item in sorted_in_items:\n                if excess_weight <= 0:\n                    break\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    excess_weight -= weight_lst[item]\n\n    # Ensure solution is feasible\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort((value1_lst + value2_lst) / weight_lst)\n        for item in sorted_items:\n            if excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4433003841475892,
            6.389017671346664
        ]
    }
]