[
    {
        "algorithm": "The algorithm selects a random solution from the archive and performs a hybrid local search by swapping items with a focus on improving either objective while ensuring feasibility. It prioritizes swaps that increase at least one objective value and maintains the solution's weight within capacity. The method uses a value-to-weight ratio consideration to guide the swaps and limits the search to 10 attempts for efficiency.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps with value-to-weight ratio consideration\n    for _ in range(10):  # Number of attempts to find a feasible neighbor\n        # Select two random items\n        item1, item2 = np.random.choice(len(new_solution), size=2, replace=False)\n\n        # Calculate potential weight change\n        if new_solution[item1] == 1 and new_solution[item2] == 0:\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n        elif new_solution[item1] == 0 and new_solution[item2] == 1:\n            delta_weight = weight_lst[item1] - weight_lst[item2]\n        else:\n            continue  # No change in weight\n\n        # Check feasibility\n        if current_weight + delta_weight <= capacity:\n            # Perform swap if it improves at least one objective\n            value1_delta = (value1_lst[item1] - value1_lst[item2]) if new_solution[item1] == 1 else (value1_lst[item2] - value1_lst[item1])\n            value2_delta = (value2_lst[item1] - value2_lst[item2]) if new_solution[item1] == 1 else (value2_lst[item2] - value2_lst[item1])\n\n            if value1_delta > 0 or value2_delta > 0:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.49864606700041164,
            0.321457177400589
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with the highest normalized sum of objective values, then applies a hybrid local search that combines random bit-flipping and adaptive perturbation to explore the neighborhood while ensuring feasibility. It balances exploration and exploitation by limiting bit-flips and occasionally perturbing low-marginal-contribution items to escape local optima. The selection criterion favors solutions with better combined performance, while the local search intelligently modifies the solution to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Normalize objectives to balance both criteria\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive]\n        selected_idx = np.argmax(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flipping with adaptive perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Random bit-flip with feasibility check\n    for _ in range(min(3, n_items)):  # Limit flips to avoid excessive computation\n        candidate_idx = np.random.randint(n_items)\n        if base_solution[candidate_idx] == 1:\n            if current_weight - weight_lst[candidate_idx] <= capacity:\n                new_solution[candidate_idx] = 0\n                current_weight -= weight_lst[candidate_idx]\n        else:\n            if current_weight + weight_lst[candidate_idx] <= capacity:\n                new_solution[candidate_idx] = 1\n                current_weight += weight_lst[candidate_idx]\n\n    # Step 2: Adaptive perturbation - flip items with low marginal contribution\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        marginal_contribution = (value1_lst + value2_lst) / weight_lst\n        low_contrib_indices = np.argsort(marginal_contribution)[:max(1, n_items // 4)]\n        for idx in low_contrib_indices:\n            if base_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            elif base_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3202108423479148,
            0.2685256004333496
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search strategy that prioritizes items with high marginal value (combined from both objectives) while ensuring feasibility, followed by random flips to explore diversity. It balances exploitation (targeting high-value items) with exploration (random perturbations) to generate improved neighbor solutions. The approach avoids standard local search methods like 2-opt by focusing on value-weighted flips and controlled randomness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: Flip items based on marginal contribution and diversity\n    new_solution = base_solution.copy()\n\n    # Step 1: Identify items with high marginal contribution (value/weight ratio)\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Step 2: Flip items with high marginal contribution if feasible\n    for i in np.argsort(-combined_marginal):\n        if base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif base_solution[i] == 1:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 3: Randomly flip additional items to explore diversity\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n        elif new_solution[i] == 1:\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6371576377229591,
            0.4495231509208679
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with potential for improvement (items that can be added without exceeding capacity), then applies a hybrid approach combining value-weighted greedy selection (prioritizing items with highest combined marginal value) and adaptive random perturbations (flipping items probabilistically, with flip probability adjusted based on archive diversity). Finally, it ensures feasibility through greedy backtracking by removing low-marginal-value items if the weight exceeds capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with potential for improvement by considering both value and archive diversity\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(sol * weight_lst)\n        remaining_capacity = capacity - current_weight\n        potential_items = np.where((sol == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(potential_items) > 0:\n            candidates.append(sol)\n\n    if not candidates:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(candidates).copy()\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Step 1: Value-weighted greedy selection\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    for i in np.argsort(-combined_marginal):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Step 2: Adaptive random perturbation based on solution quality\n    num_items = len(new_solution)\n    flip_prob = 0.3  # Base flip probability\n    if len(archive) > 1:\n        # Adjust flip probability based on archive diversity\n        archive_weights = np.array([sol[0] for sol, _ in archive])\n        diversity = np.mean(np.std(archive_weights, axis=0))\n        flip_prob = min(0.5, flip_prob + 0.2 * diversity)\n\n    flip_indices = [i for i in range(num_items) if random.random() < flip_prob]\n    for i in flip_indices:\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n        elif new_solution[i] == 1:\n            new_solution[i] = 0\n\n    # Step 3: Greedy backtracking to maintain feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        excess_weight = np.sum(new_solution * weight_lst) - capacity\n        removable_items = np.where(new_solution == 1)[0]\n        if len(removable_items) == 0:\n            break\n        # Remove item with smallest marginal value contribution\n        marginal_contrib = (new_solution * value1_lst + new_solution * value2_lst) / (weight_lst + 1e-10)\n        remove_idx = removable_items[np.argmin(marginal_contrib[removable_items])]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8698856534598612,
            0.7990563213825226
        ]
    },
    {
        "algorithm": "The algorithm selects top-performing solutions (top 20%) from the archive based on normalized objective sums, then applies a targeted local search prioritizing items with high marginal gains in either objective, followed by 1-2 random flips to maintain diversity while ensuring feasibility. It first evaluates items by their marginal gains (value-to-weight ratio) for both objectives, flipping the most promising ones, and then introduces randomness to escape local optima. The solution always remains feasible by checking weight constraints before each flip.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% solutions by normalized objective sum\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive]\n        top_indices = np.argsort(normalized_scores)[-max(1, len(archive)//5):]\n        selected_idx = np.random.choice(top_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each objective\n    marginal_gain1 = value1_lst / (weight_lst + 1e-10)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-10)\n\n    # Flip items with highest marginal gains in either objective\n    for i in np.argsort(-np.maximum(marginal_gain1, marginal_gain2)):\n        if base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif base_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Add 1-2 random flips to maintain diversity\n    flip_indices = np.random.choice(len(new_solution), size=np.random.randint(1, 3), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n        elif new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7693802282111715,
            0.48120638728141785
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a non-dominated solution from the archive by prioritizing those with high marginal gains, then applies a hybrid local search combining probabilistic item flips and swaps to explore the solution space while ensuring feasibility. The selection is weighted probabilistically, favoring later entries in the archive, and the local search iteratively modifies the solution by flipping or swapping items, checking feasibility at each step. The key design ideas are prioritized selection and hybrid local search with feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (prioritize those with high marginal gains)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: probabilistic item flips and swaps\n    for _ in range(5):  # Number of local search iterations\n        # Probabilistic flip: flip a random item if feasible\n        flip_idx = np.random.randint(0, n_items)\n        if new_solution[flip_idx] == 1:\n            if np.sum(weight_lst[new_solution == 1] - weight_lst[flip_idx]) <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1] + weight_lst[flip_idx]) <= capacity:\n                new_solution[flip_idx] = 1\n\n        # Item swap: swap two random items if feasible\n        swap_idx1, swap_idx2 = np.random.choice(n_items, 2, replace=False)\n        if new_solution[swap_idx1] != new_solution[swap_idx2]:\n            if new_solution[swap_idx1] == 1:\n                if np.sum(weight_lst[new_solution == 1] - weight_lst[swap_idx1] + weight_lst[swap_idx2]) <= capacity:\n                    new_solution[swap_idx1] = 0\n                    new_solution[swap_idx2] = 1\n            else:\n                if np.sum(weight_lst[new_solution == 1] - weight_lst[swap_idx2] + weight_lst[swap_idx1]) <= capacity:\n                    new_solution[swap_idx1] = 1\n                    new_solution[swap_idx2] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3688356342738096,
            0.4918815791606903
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on a weighted combination of objective values (prioritizing one objective more when its variance is higher), then applies a value-weighted flip strategy with adaptive randomness to generate a neighbor. It also incorporates crowding-aware perturbations to balance exploration and exploitation while ensuring feasibility. The key design ideas are: dynamic objective weighting, adaptive marginal value-based flips, and crowding-aware perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_weights = np.array([obj[0] for _, obj in archive])\n    obj2_weights = np.array([obj[1] for _, obj in archive])\n    obj1_std = np.std(obj1_weights)\n    obj2_std = np.std(obj2_weights)\n    alpha = obj2_std / (obj1_std + obj2_std + 1e-10)  # Weighting factor\n\n    # Select solution with highest weighted score\n    scores = alpha * obj1_weights + (1 - alpha) * obj2_weights\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate adaptive marginal values\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (alpha * marginal_value1 + (1 - alpha) * marginal_value2) / (1 + 0.1 * np.random.rand(len(weight_lst)))\n\n    # Flip items based on adaptive marginal values\n    new_solution = base_solution.copy()\n    for i in np.argsort(-combined_marginal):\n        if base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif base_solution[i] == 1:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Crowding-aware perturbation\n    if len(archive) > 1:\n        distances = np.zeros(len(archive))\n        for i, (sol, _) in enumerate(archive):\n            distances[i] = np.sum(np.abs(sol - new_solution))\n        min_dist_idx = np.argmin(distances)\n        if min_dist_idx != selected_idx:\n            crowding_factor = 1 - distances[min_dist_idx] / (np.sum(distances) + 1e-10)\n            perturb_indices = np.random.choice(len(new_solution), size=int(crowding_factor * len(new_solution)), replace=False)\n            for i in perturb_indices:\n                if np.random.rand() < 0.3:  # 30% chance to flip\n                    if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                        new_solution[i] = 1\n                    elif new_solution[i] == 1:\n                        new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5133315916615483,
            0.7007046043872833
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high normalized scores (combining both objectives), then applies a \"value-balancing\" local search: it removes items where one objective's marginal contribution is significantly higher than the other to rebalance trade-offs, and adds high-marginal-value items that improve underperforming objectives while ensuring feasibility. The selection balances exploration and exploitation, while the local search intelligently adjusts items to enhance both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive using normalized objectives\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive]\n        selected_idx = np.argmax(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Identify items where one objective's marginal contribution is significantly higher than the other\n    imbalance_threshold = 1.5  # Threshold to identify disproportionate contributions\n    for i in range(len(base_solution)):\n        if marginal_value1[i] > imbalance_threshold * marginal_value2[i]:\n            # If value1 is significantly higher, consider removing the item\n            if base_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        elif marginal_value2[i] > imbalance_threshold * marginal_value1[i]:\n            # If value2 is significantly higher, consider removing the item\n            if base_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Add items that could improve the underperforming objective\n    combined_marginal = marginal_value1 + marginal_value2\n    for i in np.argsort(-combined_marginal):\n        if base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.2885691204801242,
            0.5224335193634033
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search by flipping a small random subset of items (with feasibility checks), and then performs a greedy improvement step to add items that improve at least one objective. The design prioritizes diversity and local optimization while ensuring feasibility, using a combination of randomness and greedy selection to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    import random\n    import numpy as np\n\n    # Select a promising solution from the archive (here, we select a random one for diversity)\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: flip a random subset of items and then perform a greedy improvement\n    num_items = len(new_solution)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 random items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Only flip to 1 if it doesn't exceed capacity\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: try to add items that improve at least one objective\n    for idx in range(num_items):\n        if new_solution[idx] == 0:\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight + weight_lst[idx] <= capacity:\n                # Simulate adding the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                temp_value1 = np.sum(temp_solution * value1_lst)\n                temp_value2 = np.sum(temp_solution * value2_lst)\n                current_value1 = np.sum(new_solution * value1_lst)\n                current_value2 = np.sum(new_solution * value2_lst)\n\n                # Accept if at least one objective improves\n                if (temp_value1 > current_value1) or (temp_value2 > current_value2):\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3743656696571226,
            1.5071693360805511
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on combined marginal value (sum of normalized value1 and value2 per unit weight), then applies a two-phase local search: first flipping items with highest marginal contributions (sorted by combined value) to maximize value, followed by controlled random flips to introduce diversity while ensuring feasibility. The first phase prioritizes high-value items, while the second adds exploration through probabilistic flips.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    marginal_values = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        marginal_value1 = np.sum(value1_lst * sol) / (current_weight + 1e-10)\n        marginal_value2 = np.sum(value2_lst * sol) / (current_weight + 1e-10)\n        marginal_values.append(marginal_value1 + marginal_value2)\n    selected_idx = np.argmax(marginal_values)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: Flip items based on value-weighted bias and controlled randomness\n    new_solution = base_solution.copy()\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Step 1: Flip items with high marginal contribution if feasible\n    for i in np.argsort(-combined_marginal):\n        if base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif base_solution[i] == 1 and (current_weight - weight_lst[i]) >= 0:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 2: Controlled random flip to introduce diversity\n    flip_prob = 0.2\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n            elif new_solution[i] == 1 and (current_weight - weight_lst[i]) >= 0:\n                new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.35983047757157505,
            0.8351807594299316
        ]
    }
]