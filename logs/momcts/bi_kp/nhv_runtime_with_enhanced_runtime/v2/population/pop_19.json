[
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a diverse solution from the archive (prioritize those with high objective values but not already explored)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2, reverse=True)\n    selected_idx = min(int(len(archive) * 0.4), len(archive) - 1)  # Select from top 40% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate dynamic marginal contribution (combining both objectives with weight adjustment)\n    alpha = 0.5  # Initial balance factor between objectives\n    if current_weight > 0.7 * capacity:\n        alpha = 0.7  # Increase focus on objective 1 when close to capacity\n    marginal_contribution = alpha * (value1_lst / weight_lst) + (1 - alpha) * (value2_lst / weight_lst)\n\n    # Sort items by dynamic marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_contribution)\n\n    # Perform targeted swaps and additions\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item i if it's not critical\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item i if it fits\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                # Check if adding this item improves both objectives sufficiently\n                if (value1_lst[i] > 0 and value2_lst[i] > 0) or (temp_weight <= 0.9 * capacity):\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n                    break\n\n    # Adaptive diversification (higher probability when stuck)\n    diversification_rate = 0.2 if current_weight > 0.8 * capacity else 0.1\n    if np.random.rand() < diversification_rate:\n        # Perform multiple random flips with feasibility checks\n        flip_indices = np.random.choice(len(weight_lst), size=min(4, len(weight_lst)), replace=False)\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9208547939029279,
            1.5441421568393707
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the minimum sum of objectives, then applies a hybrid local search that prioritizes items with high marginal contribution (combining both objectives) through targeted swaps and adaptive perturbations, while ensuring feasibility by checking weight constraints at each step. The method balances exploitation (via marginal contribution sorting) and exploration (via random perturbations), with higher priority given to items that improve both objectives proportionally.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with the minimum sum of objectives (diverse selection)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: prioritize items with high marginal contribution for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    marginal_contribution = marginal_value1 + marginal_value2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_contribution)\n\n    # Step 1: Perform targeted swaps (explore neighborhood)\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n\n    # Step 2: Adaptive perturbation with higher probability (50% chance)\n    if np.random.rand() < 0.5:\n        # Select a random subset of items to perturb (up to 5 items)\n        perturbation_indices = np.random.choice(len(weight_lst), size=min(5, len(weight_lst)), replace=False)\n        for i in perturbation_indices:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8062330467894219,
            1.2104815542697906
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive using a hybrid ranking metric combining \u03b5-dominance and objective diversity, then applies a value-weighted swap operator that prioritizes items with high marginal gains for both objectives while maintaining feasibility, followed by an adaptive perturbation phase that probabilistically swaps items based on their marginal gains and current capacity utilization. The selection prioritizes items with better marginal gains for both objectives, and the perturbation phase adjusts exploration intensity based on capacity usage.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Hybrid ranking: combine \u03b5-dominance and objective diversity\n    def hybrid_rank(solutions):\n        ranks = {}\n        for i, (sol_i, obj_i) in enumerate(solutions):\n            rank = 0\n            for j, (sol_j, obj_j) in enumerate(solutions):\n                if i != j:\n                    # \u03b5-dominance component\n                    if obj_j[0] >= obj_i[0] and obj_j[1] >= obj_i[1]:\n                        if obj_j[0] > obj_i[0] or obj_j[1] > obj_i[1]:\n                            rank += 1\n                    # Objective diversity component\n                    rank += abs(obj_i[0] - obj_j[0]) + abs(obj_i[1] - obj_j[1])\n            ranks[i] = rank\n        return ranks\n\n    ranks = hybrid_rank(archive)\n    sorted_indices = sorted(ranks.keys(), key=lambda x: ranks[x])\n    top_20_percent = max(1, len(archive) // 5)\n    selected_idx = random.choice(sorted_indices[:top_20_percent])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Value-weighted swap operator\n    weight_factor = 0.5 if current_weight > 0.6 * capacity else 0.6\n    marginal_gain = (weight_factor * value1_lst + (1 - weight_factor) * value2_lst) / (weight_lst + 1e-6)\n    sorted_items = np.argsort(-marginal_gain)\n\n    # Perform value-weighted swaps\n    for i in sorted_items:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item i\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Adaptive perturbation based on marginal gains\n    perturbation_prob = 0.2 if current_weight > 0.7 * capacity else 0.1\n    if random.random() < perturbation_prob:\n        # Select items with high marginal gains for potential swap\n        candidate_indices = [i for i in sorted_items[:min(10, len(sorted_items))]\n                           if (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                              (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n        if candidate_indices:\n            num_swaps = random.randint(1, min(2, len(candidate_indices)))\n            swap_indices = random.sample(candidate_indices, num_swaps)\n            for i in swap_indices:\n                new_solution[i] = 1 - new_solution[i]\n                current_weight += (1 if new_solution[i] == 1 else -1) * weight_lst[i]\n\n    # Final feasibility check\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        # Remove item with lowest marginal gain\n        excess_items_sorted = sorted(excess_items, key=lambda x: marginal_gain[x])\n        remove_idx = excess_items_sorted[0]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9292649166811169,
            2.8038553595542908
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid ranking method combining \u03b5-dominance and objective diversity, then applies a dynamic marginal-gain-based local search with adaptive perturbation to generate a feasible neighbor solution, prioritizing high-value items while respecting capacity constraints. The method balances exploration and exploitation through weighted marginal gains and capacity-aware perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Hybrid selection: \u03b5-dominance ranking combined with objective diversity\n    def hybrid_rank(solutions):\n        ranks = {}\n        for i, (sol_i, obj_i) in enumerate(solutions):\n            rank = 0\n            for j, (sol_j, obj_j) in enumerate(solutions):\n                if i != j:\n                    # \u03b5-dominance component\n                    if obj_j[0] >= obj_i[0] and obj_j[1] >= obj_i[1]:\n                        if obj_j[0] > obj_i[0] or obj_j[1] > obj_i[1]:\n                            rank += 1\n                    # Objective diversity component\n                    rank += abs(obj_i[0] - obj_j[0]) + abs(obj_i[1] - obj_j[1])\n            ranks[i] = rank\n        return ranks\n\n    ranks = hybrid_rank(archive)\n    sorted_indices = sorted(ranks.keys(), key=lambda x: ranks[x])\n    top_30_percent = max(1, len(archive) // 3)\n    selected_idx = random.choice(sorted_indices[:top_30_percent])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic marginal gain calculation with adaptive weighting\n    weight_factor = 0.5 if current_weight > 0.6 * capacity else 0.6\n    marginal_gain = (weight_factor * value1_lst + (1 - weight_factor) * value2_lst) / (weight_lst + 1e-6)\n    sorted_items = np.argsort(-marginal_gain)\n\n    # Priority-based flips: first try to add high-gain items, then remove low-gain items\n    for i in sorted_items:\n        if new_solution[i] == 0:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    if current_weight < capacity:\n        for i in sorted_items:\n            if new_solution[i] == 1:\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n                    break\n\n    # Adaptive perturbation based on marginal gains and capacity\n    perturbation_prob = 0.3 if current_weight > 0.7 * capacity else 0.15\n    if random.random() < perturbation_prob:\n        candidate_indices = [i for i in sorted_items[:min(10, len(sorted_items))]\n                           if (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                              (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n        if candidate_indices:\n            num_swaps = random.randint(1, min(3, len(candidate_indices)))\n            swap_indices = random.sample(candidate_indices, num_swaps)\n            for i in swap_indices:\n                new_solution[i] = 1 - new_solution[i]\n                current_weight += (1 if new_solution[i] == 1 else -1) * weight_lst[i]\n\n    # Final feasibility check\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        excess_items_sorted = sorted(excess_items, key=lambda x: marginal_gain[x])\n        remove_idx = excess_items_sorted[0]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9413592984666055,
            3.0691100358963013
        ]
    },
    {
        "algorithm": "The algorithm selects a promising base solution from the archive by prioritizing those with higher combined normalized values (60% weight for value1, 40% for value2) and then applies a hybrid local search: it first flips the top 5 items that most improve both objectives while maintaining feasibility, followed by occasional aggressive random flips to escape local optima, and finally ensures feasibility by removing items if necessary. The approach balances exploitation (targeted flips) and exploration (random flips) while strictly enforcing the knapsack capacity constraint.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with high potential for improvement in both objectives\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        candidates.append((sol, obj, total_weight))\n\n    # Sort by a weighted combination of both objectives (prioritize higher values)\n    candidates.sort(key=lambda x: (0.6 * x[1][0] / np.sum(value1_lst)) + 0.4 * (x[1][1] / np.sum(value2_lst)), reverse=True)\n\n    # Select top 30% of candidates or at least 1\n    selection_pool = candidates[:max(1, len(candidates) // 3)]\n    base_sol, _, base_weight = random.choice(selection_pool)\n\n    new_solution = base_sol.copy()\n\n    # Hybrid local search strategy\n    # 1. Find items that can be flipped to improve both objectives\n    candidates_to_flip = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing this item\n            new_weight = base_weight - weight_lst[i]\n            if new_weight <= capacity:\n                improvement = (value1_lst[i] + value2_lst[i])  # Combined improvement for both objectives\n                candidates_to_flip.append((i, improvement, new_weight))\n        else:\n            # Consider adding this item\n            new_weight = base_weight + weight_lst[i]\n            if new_weight <= capacity:\n                improvement = (value1_lst[i] + value2_lst[i])  # Combined improvement for both objectives\n                candidates_to_flip.append((i, improvement, new_weight))\n\n    # 2. Select top 5 candidates with highest combined improvement\n    candidates_to_flip.sort(key=lambda x: x[1], reverse=True)\n    selected_flips = candidates_to_flip[:min(5, len(candidates_to_flip))]\n\n    # 3. Apply the flips\n    for i, _, _ in selected_flips:\n        new_solution[i] = 1 - new_solution[i]\n\n    # 4. Additional more aggressive random flips to escape local optima\n    if random.random() > 0.5:  # 50% chance\n        candidate_indices = [i for i in range(len(new_solution))\n                            if (new_solution[i] == 1 and base_weight - weight_lst[i] <= capacity) or\n                               (new_solution[i] == 0 and base_weight + weight_lst[i] <= capacity)]\n        if candidate_indices:\n            # Select multiple random flips (2-3)\n            num_flips = random.randint(2, 3)\n            flip_indices = random.sample(candidate_indices, min(num_flips, len(candidate_indices)))\n            for flip_idx in flip_indices:\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n        total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9241693697524226,
            4.843086838722229
        ]
    },
    {
        "algorithm": "The algorithm uses \u03b5-dominance ranking to select high-quality, diverse solutions from the archive, then applies a hybrid local search combining weighted marginal gain prioritization (with adaptive weights based on current knapsack utilization) and targeted perturbations (flipping 1-3 random items with probability dependent on capacity usage), ensuring feasibility at every step. The weighted marginal gain balances both objectives dynamically, while adaptive perturbations introduce controlled exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # \u03b5-dominance ranking to select diverse high-quality solutions\n    epsilon = 0.1  # \u03b5 parameter for \u03b5-dominance\n    ranked_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon and other_obj[1] >= obj[1] - epsilon and\n                (other_obj[0] > obj[0] or other_obj[1] > obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            ranked_solutions.append((sol, obj))\n\n    if not ranked_solutions:\n        ranked_solutions = archive\n\n    # Select solution with highest \u03b5-dominated rank (sum of objectives)\n    selected = max(ranked_solutions, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal gains\n    weight_factor = 0.6 if current_weight > 0.8 * capacity else 0.4\n    marginal_gain = (weight_factor * value1_lst + (1 - weight_factor) * value2_lst) / (weight_lst + 1e-6)\n\n    # Sort items by marginal gain (descending)\n    sorted_indices = np.argsort(-marginal_gain)\n\n    # Local search with targeted flips\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Adaptive perturbation\n    perturbation_prob = 0.3 if current_weight > 0.7 * capacity else 0.15\n    if np.random.rand() < perturbation_prob:\n        # Select 3 random items to perturb\n        perturb_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n        for i in perturb_indices:\n            if new_solution[i] == 1:\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n            else:\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4076089573457292,
            1.276840090751648
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using dynamic \u03b5-dominance ranking (prioritizing solutions with high combined value, weighted 70% to value1 and 30% to value2), then applies a hybrid local search that flips item selections based on weighted marginal gains while adaptively perturbing the solution to escape local optima, ensuring feasibility through strict weight constraint checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic \u03b5-dominance ranking\n    \u03b5 = 0.1  # \u03b5 parameter for dominance\n    ranked_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] and other_obj[1] >= obj[1] and\n                (other_obj[0] > obj[0] or other_obj[1] > obj[1])):\n                if not (obj[0] >= other_obj[0] - \u03b5 * other_obj[0] and obj[1] >= other_obj[1] - \u03b5 * other_obj[1]):\n                    dominated = True\n                    break\n        if not dominated:\n            ranked_solutions.append((sol, obj))\n\n    if not ranked_solutions:\n        ranked_solutions = archive\n\n    # Select a solution with high potential for improvement\n    selected = max(ranked_solutions, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal gains\n    marginal_gain = (0.7 * value1_lst + 0.3 * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(-marginal_gain)\n\n    # Targeted flips based on marginal gains\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Adaptive perturbation\n    perturbation_rate = 0.3 if np.sum(new_solution) > 0.7 * len(new_solution) else 0.1\n    if np.random.rand() < perturbation_rate:\n        candidate_indices = [i for i in range(len(new_solution))\n                           if (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                              (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n        if candidate_indices:\n            num_flips = min(3, len(candidate_indices))\n            flip_indices = np.random.choice(candidate_indices, size=num_flips, replace=False)\n            for flip_idx in flip_indices:\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7585863788249091,
            1.4973205626010895
        ]
    },
    {
        "algorithm": "The algorithm combines \u03b5-dominance ranking to prioritize high-quality solutions, adaptive perturbation strength based on capacity utilization, and marginal-gain-based flips to generate feasible neighbors while balancing exploration and exploitation. It dynamically adjusts flip probabilities and perturbation intensity to explore promising regions while ensuring feasibility, with a hybrid selection metric that balances solution quality and diversity. The key design ideas are: (1) \u03b5-dominance ranking to select promising base solutions, (2) adaptive perturbation strength based on capacity utilization, (3) marginal-gain-based flips prioritizing high-value items, and (4) feasibility-aware random flips for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Rank solutions using \u03b5-dominance\n    def epsilon_dominance_rank(solutions, epsilon=0.1):\n        ranks = [0] * len(solutions)\n        for i, (s1, obj1) in enumerate(solutions):\n            for j, (s2, obj2) in enumerate(solutions):\n                if i != j:\n                    if obj1[0] >= obj2[0] * (1 - epsilon) and obj1[1] >= obj2[1] * (1 - epsilon):\n                        ranks[i] += 1\n        return ranks\n\n    ranks = epsilon_dominance_rank(archive)\n    selected_idx = np.argmax(ranks)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate weighted marginal gains\n    alpha = 0.5\n    if current_weight > 0.7 * capacity:\n        alpha = 0.7\n    marginal_gain = (alpha * value1_lst + (1 - alpha) * value2_lst) / weight_lst\n\n    # Sort items by marginal gain (descending)\n    sorted_indices = np.argsort(-marginal_gain)\n\n    # Apply adaptive perturbation\n    perturbation_strength = 0.3 if current_weight > 0.8 * capacity else 0.15\n    num_flips = max(1, int(perturbation_strength * len(weight_lst)))\n\n    for i in sorted_indices[:num_flips]:\n        if new_solution[i] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity and (temp_weight <= 0.9 * capacity or np.random.rand() < 0.5):\n                new_solution[i] = 1\n                current_weight = temp_weight\n\n    # Additional random flips for exploration\n    if np.random.rand() < 0.2:\n        flip_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.915759104975201,
            2.8788294792175293
        ]
    },
    {
        "algorithm": "The algorithm combines dynamic \u03b5-dominance ranking to prioritize solutions with lower \u03b5-dominance ranks (indicating better potential for improvement) and applies a hybrid local search that alternates between \u03b5-aware swaps and perturbations, balancing exploration and exploitation through \u03b5-adjusted marginal gains and adaptive perturbation probabilities. It ensures feasibility by iteratively checking weight constraints and dynamically adjusts the search intensity based on the solution's \u03b5-dominance rank. The method emphasizes high-marginal-gain items while probabilistically introducing diversification through \u03b5-aware flips.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Dynamic \u03b5-dominance ranking\n    def \u03b5_dominance_rank(solutions):\n        ranks = []\n        for s in solutions:\n            dominates = 0\n            for t in solutions:\n                if (s[1][0] <= t[1][0] and s[1][1] <= t[1][1] and (s[1][0] < t[1][0] or s[1][1] < t[1][1])):\n                    dominates += 1\n            ranks.append((s, dominates))\n        return sorted(ranks, key=lambda x: x[1])\n\n    ranked_solutions = \u03b5_dominance_rank(archive)\n    selected_idx = min(int(len(ranked_solutions) * 0.3), len(ranked_solutions) - 1)\n    base_solution = ranked_solutions[selected_idx][0][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate weighted marginal gains with \u03b5-adjustment\n    \u03b5 = 0.15  # \u03b5-dominance threshold\n    marginal_gain1 = (value1_lst / (weight_lst + 1e-6)) * (1 + \u03b5)\n    marginal_gain2 = (value2_lst / (weight_lst + 1e-6)) * (1 + \u03b5)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Step 3: Hybrid local search with \u03b5-aware perturbations\n    for _ in range(3):  # Perform multiple iterations\n        # \u03b5-aware swap phase\n        swap_candidates = np.argsort(-combined_gain)\n        for i in swap_candidates:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n        # \u03b5-aware perturbation phase\n        perturbation_prob = 0.4 * (1 - min(ranked_solutions[selected_idx][1] / len(archive), 0.8))\n        if np.random.rand() < perturbation_prob:\n            # Select items based on \u03b5-adjusted gains\n            perturbation_candidates = np.argsort(-combined_gain)\n            for i in perturbation_candidates:\n                if new_solution[i] == 1:\n                    temp_solution = new_solution.copy()\n                    temp_solution[i] = 0\n                    temp_weight = current_weight - weight_lst[i]\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        current_weight = temp_weight\n                        break\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9001417874405517,
            1.749839961528778
        ]
    },
    {
        "algorithm": "The algorithm employs adaptive \u03b5-dominance weighted ranking to prioritize high-potential solutions, followed by a hybrid local search combining multi-objective greedy swaps (60% weight on value1, 40% on value2) and diversity-preserving perturbations with dynamically adjusted probabilities. It ensures feasibility by strictly enforcing capacity constraints during all operations. The \u03b5-threshold and perturbation probability adapt based on solution quality, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Adaptive \u03b5-dominance weighted ranking\n    def weighted_\u03b5_rank(solutions):\n        ranks = []\n        \u03b5 = 0.25\n        for s in solutions:\n            weighted_score = 0\n            for t in solutions:\n                if (s[1][0] <= t[1][0] and s[1][1] <= t[1][1] and (s[1][0] < t[1][0] or s[1][1] < t[1][1])):\n                    weighted_score += (1 + \u03b5) * (abs(s[1][0] - t[1][0]) + abs(s[1][1] - t[1][1]))\n            ranks.append((s, weighted_score))\n        return sorted(ranks, key=lambda x: -x[1])\n\n    ranked_solutions = weighted_\u03b5_rank(archive)\n    selected_idx = min(int(len(ranked_solutions) * 0.4), len(ranked_solutions) - 1)\n    base_solution = ranked_solutions[selected_idx][0][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Calculate normalized marginal gains with adaptive weighting\n    \u03b5_adaptive = 0.1 + 0.1 * (ranked_solutions[selected_idx][1] / (sum(s[1] for s in ranked_solutions) + 1e-6))\n    marginal_gain1 = (value1_lst / (weight_lst + 1e-6)) * (1 + \u03b5_adaptive)\n    marginal_gain2 = (value2_lst / (weight_lst + 1e-6)) * (1 + \u03b5_adaptive)\n    combined_gain = marginal_gain1 * 0.6 + marginal_gain2 * 0.4\n\n    # Step 3: Hybrid local search with adaptive perturbations\n    for _ in range(4):\n        # Multi-objective greedy swap phase\n        swap_candidates = np.argsort(-combined_gain)\n        for i in swap_candidates:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n        # Diversity-preserving perturbation phase\n        perturbation_prob = 0.3 + 0.5 * (1 - min(ranked_solutions[selected_idx][1] / (sum(s[1] for s in ranked_solutions) + 1e-6), 0.7))\n        if np.random.rand() < perturbation_prob:\n            perturbation_candidates = np.argsort(-combined_gain)\n            for i in perturbation_candidates:\n                if np.random.rand() < 0.5 and new_solution[i] == 1:\n                    temp_solution = new_solution.copy()\n                    temp_solution[i] = 0\n                    temp_weight = current_weight - weight_lst[i]\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        current_weight = temp_weight\n                        break\n                elif np.random.rand() < 0.5 and current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9122618391191433,
            2.85409277677536
        ]
    }
]