[
    {
        "algorithm": "The algorithm selects a solution from the archive with the minimum sum of objectives, then applies a hybrid local search that prioritizes items with high marginal contribution (combining both objectives) through targeted swaps and adaptive perturbations, while ensuring feasibility by checking weight constraints at each step. The method balances exploitation (via marginal contribution sorting) and exploration (via random perturbations), with higher priority given to items that improve both objectives proportionally.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with the minimum sum of objectives (diverse selection)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: prioritize items with high marginal contribution for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    marginal_contribution = marginal_value1 + marginal_value2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_contribution)\n\n    # Step 1: Perform targeted swaps (explore neighborhood)\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n\n    # Step 2: Adaptive perturbation with higher probability (50% chance)\n    if np.random.rand() < 0.5:\n        # Select a random subset of items to perturb (up to 5 items)\n        perturbation_indices = np.random.choice(len(weight_lst), size=min(5, len(weight_lst)), replace=False)\n        for i in perturbation_indices:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8062330467894219,
            1.2104815542697906
        ]
    },
    {
        "algorithm": "The algorithm combines dynamic \u03b5-dominance filtering to select promising solutions, ranks them by objective balance and total value, and generates neighbors through an objective-balanced flip strategy that prioritizes items with high combined marginal gains across both objectives while dynamically adjusting perturbation probabilities based on solution balance and capacity constraints. It ensures feasibility by strategically flipping items in order of combined gain and balance ratio, with adaptive perturbations to escape local optima when needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic \u03b5-dominance filtering and ranking\n    epsilon = 0.1\n    filtered_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon and other_obj[1] >= obj[1] - epsilon and\n                (other_obj[0] > obj[0] - epsilon or other_obj[1] > obj[1] - epsilon)):\n                dominated = True\n                break\n        if not dominated:\n            filtered_solutions.append((sol, obj))\n\n    if not filtered_solutions:\n        filtered_solutions = archive.copy()\n\n    # Rank solutions by objective balance and value\n    ranked_solutions = sorted(filtered_solutions, key=lambda x: (abs(x[1][0] - x[1][1]), x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(ranked_solutions) * 0.3), len(ranked_solutions) - 1)\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate current values\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Objective-balanced flip strategy\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort by combined gain and value balance\n    balance_ratio = value2_lst / (value1_lst + 1e-6)\n    sorted_indices = np.argsort(-combined_gain * balance_ratio)\n\n    # Try to flip items with high combined gain and balanced values\n    for i in sorted_indices:\n        if new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n            break\n        elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n            break\n\n    # Adaptive perturbation based on solution balance\n    balance_diff = abs(current_value1 - current_value2)\n    perturbation_prob = 0.2 if balance_diff > 0.1 * max(current_value1, current_value2) else 0.1\n\n    if np.random.rand() < perturbation_prob:\n        # Perturb by flipping items with low combined gain\n        low_gain_indices = np.argsort(combined_gain)\n        for i in low_gain_indices[:min(3, len(low_gain_indices))]:\n            if new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8743937739183254,
            1.3375412225723267
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from an archive using \u03b5-dominance ranking, prioritizes item flips based on weighted marginal gains combining both objectives, and applies adaptive perturbations proportional to remaining capacity while ensuring feasibility at each step. It first filters non-dominated solutions, selects the best one, calculates weighted marginal gains to guide flips, and then performs feasibility-aware additions/removals with adaptive perturbation for further exploration. The weight factor balances objectives based on current capacity utilization, and final checks ensure feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic \u03b5-dominance ranking\n    epsilon = 0.1\n    filtered_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon and other_obj[1] >= obj[1] - epsilon and\n                (other_obj[0] > obj[0] - epsilon or other_obj[1] > obj[1] - epsilon)):\n                dominated = True\n                break\n        if not dominated:\n            filtered_solutions.append((sol, obj))\n\n    if not filtered_solutions:\n        filtered_solutions = archive.copy()\n\n    # Select solution with best \u03b5-dominance rank\n    selected_idx = np.argmax([sum(obj) for _, obj in filtered_solutions])\n    base_solution = filtered_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate weighted marginal gains\n    weight_factor = 0.5 if current_weight > 0.6 * capacity else 0.6\n    marginal_gain = (weight_factor * value1_lst + (1 - weight_factor) * value2_lst) / (weight_lst + 1e-6)\n\n    # Sort by marginal gain (descending)\n    sorted_indices = np.argsort(-marginal_gain)\n\n    # Perform feasibility-aware flips\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Adaptive perturbation based on remaining capacity\n    remaining_capacity = capacity - current_weight\n    perturbation_prob = min(0.3, 0.1 + remaining_capacity / capacity * 0.2)\n\n    if np.random.rand() < perturbation_prob:\n        # Select items with low marginal gain for potential flip\n        low_gain_indices = np.argsort(marginal_gain)\n        for i in low_gain_indices[:min(3, len(low_gain_indices))]:\n            if new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        excess_items_sorted = sorted(excess_items, key=lambda x: marginal_gain[x])\n        remove_idx = excess_items_sorted[0]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9674873137843483,
            1.3716097474098206
        ]
    },
    {
        "algorithm": "The algorithm combines \u03b5-dominance ranking with a hybrid local search strategy, prioritizing solutions with higher dominance ranks (more dominated) and applying dominance-aware swaps based on weighted marginal gains (balancing both objectives and capacity ratio) followed by adaptive perturbations (probabilistically swapping low-contribution items) while ensuring feasibility. The \u03b5 value dynamically adjusts to focus on higher gains, and the perturbation probability scales with remaining capacity. The marginal gain calculation weights value1 and value2 with \u03b5, and the overall structure ensures both exploitation (via dominance-aware swaps) and exploration (via adaptive perturbations), dynamically balancing the trade-off between objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # \u03b5-dominance ranking\n    def \u03b5_dominance_rank(sol_obj):\n        rank = 0\n        \u03b5 = 0.1  # Initial \u03b5 value\n        for other_obj in [obj for (sol, obj) in archive]:\n            if other_obj[0] >= sol_obj[0] - \u03b5 * sol_obj[0] and other_obj[1] >= sol_obj[1] - \u03b5 * sol_obj[1]:\n                rank += 1\n        return rank\n\n    # Select solution with highest \u03b5-dominance rank (more dominated)\n    selected = max(archive, key=lambda x: \u03b5_dominance_rank(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic weighted marginal gain calculation\n    \u03b5 = 0.2  # Adjustable \u03b5 value\n    capacity_ratio = (capacity - current_weight) / capacity\n    marginal_gain = (value1_lst + \u03b5 * value2_lst) * (1 + capacity_ratio) / (weight_lst + 1e-6)\n\n    # Step 1: Dominance-aware swaps based on weighted marginal gains\n    sorted_indices = np.argsort(-marginal_gain)\n    for i in sorted_indices:\n        for j in sorted_indices:\n            if i != j and new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1 and new_solution[j] == 0:\n                    temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if temp_weight <= capacity:\n                        temp_solution = new_solution.copy()\n                        temp_solution[i], temp_solution[j] = 0, 1\n                        new_solution = temp_solution\n                        current_weight = temp_weight\n                        \u03b5 *= 0.9  # Reduce \u03b5 to focus on higher gains\n                        break\n        else:\n            continue\n        break\n\n    # Step 2: Adaptive perturbation based on marginal gain and remaining capacity\n    perturbation_prob = min(0.7, 0.3 + capacity_ratio * 0.4)\n    if np.random.rand() < perturbation_prob:\n        # Select items with lowest marginal gain to perturb\n        perturbation_indices = np.argsort(marginal_gain)[:min(5, len(weight_lst))]\n        for i in perturbation_indices:\n            for j in perturbation_indices:\n                if i != j and new_solution[i] != new_solution[j]:\n                    if new_solution[i] == 1 and new_solution[j] == 0:\n                        temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n                        if temp_weight <= capacity:\n                            temp_solution = new_solution.copy()\n                            temp_solution[i], temp_solution[j] = 0, 1\n                            new_solution = temp_solution\n                            current_weight = temp_weight\n                            break\n            else:\n                continue\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9686614622491247,
            4.974836885929108
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive using \u03b5-dominance ranking, prioritizes flips based on weighted marginal gains balancing both objectives, and applies adaptive feasibility-aware perturbations to generate high-quality neighbors while ensuring the solution remains feasible. It prioritizes items with higher weighted marginal gains (combining value1 and \u03b5-scaled value2) and adjusts perturbations based on remaining capacity, with final checks to enforce feasibility. The selection process emphasizes solutions with better \u03b5-dominance ranks, while the local search dynamically balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic \u03b5-dominance ranking\n    epsilon = 0.1\n    filtered_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon * obj[0] and\n                other_obj[1] >= obj[1] - epsilon * obj[1] and\n                (other_obj[0] > obj[0] - epsilon * obj[0] or\n                 other_obj[1] > obj[1] - epsilon * obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            filtered_solutions.append((sol, obj))\n\n    if not filtered_solutions:\n        filtered_solutions = archive.copy()\n\n    # Select solution with highest \u03b5-dominance rank (more dominated)\n    selected = max(filtered_solutions, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal gains\n    capacity_ratio = (capacity - current_weight) / capacity\n    marginal_gain = (value1_lst + epsilon * value2_lst) * (1 + capacity_ratio) / (weight_lst + 1e-6)\n\n    # Sort by marginal gain (descending)\n    sorted_indices = np.argsort(-marginal_gain)\n\n    # Perform feasibility-aware flips\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Adaptive perturbation based on remaining capacity\n    perturbation_prob = min(0.5, 0.2 + capacity_ratio * 0.3)\n    if np.random.rand() < perturbation_prob:\n        # Select items with low marginal gain for potential flip\n        low_gain_indices = np.argsort(marginal_gain)\n        for i in low_gain_indices[:min(3, len(low_gain_indices))]:\n            if new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        excess_items_sorted = sorted(excess_items, key=lambda x: marginal_gain[x])\n        remove_idx = excess_items_sorted[0]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.810395973782146,
            1.230062574148178
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using \u03b5-dominance ranking with adaptive \u03b5 scaling, prioritizes item flips based on weighted marginal gains combining both objectives, and applies capacity-aware perturbations to generate feasible neighbors while dynamically adjusting \u03b5 to balance exploration and exploitation. It emphasizes high-marginal-gain items and uses probabilistic perturbations to escape local optima, ensuring feasibility through iterative checks and removals. The solution selection is guided by \u03b5-dominance, while the neighbor generation balances greedy flips with adaptive perturbations to maintain diversity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic \u03b5-dominance ranking with adaptive \u03b5\n    epsilon = 0.1\n    filtered_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon * obj[0] and\n                other_obj[1] >= obj[1] - epsilon * obj[1] and\n                (other_obj[0] > obj[0] - epsilon * obj[0] or\n                 other_obj[1] > obj[1] - epsilon * obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            filtered_solutions.append((sol, obj))\n\n    if not filtered_solutions:\n        filtered_solutions = archive.copy()\n\n    # Select solution with highest \u03b5-dominance rank (more dominated)\n    selected = max(filtered_solutions, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive weighted marginal gains with dynamic \u03b5\n    capacity_ratio = (capacity - current_weight) / capacity\n    epsilon = max(0.05, 0.2 * capacity_ratio)  # Dynamic \u03b5 scaling\n    marginal_gain = (value1_lst + epsilon * value2_lst) * (1 + capacity_ratio) / (weight_lst + 1e-6)\n\n    # Sort by marginal gain (descending)\n    sorted_indices = np.argsort(-marginal_gain)\n\n    # Perform feasibility-aware flips\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Adaptive perturbation based on marginal gain and remaining capacity\n    perturbation_prob = min(0.5, 0.2 + capacity_ratio * 0.3)\n    if np.random.rand() < perturbation_prob:\n        # Select items with low marginal gain for potential flip\n        low_gain_indices = np.argsort(marginal_gain)\n        for i in low_gain_indices[:min(3, len(low_gain_indices))]:\n            if new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        excess_items_sorted = sorted(excess_items, key=lambda x: marginal_gain[x])\n        remove_idx = excess_items_sorted[0]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8363632804928134,
            1.2785993218421936
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from the archive using \u03b5-dominance ranking with adaptive \u03b5 scaling, prioritizes item flips based on weighted marginal gains combining both objectives, and applies capacity-aware perturbations to generate feasible neighbors while dynamically adjusting \u03b5 to balance exploration and exploitation. It emphasizes high-marginal-gain items and uses probabilistic perturbations to escape local optima, ensuring feasibility through iterative checks and removals. The solution selection is guided by \u03b5-dominance, while the neighbor generation balances greedy flips with adaptive perturbations to maintain diversity, with capacity_ratio dynamically adjusting perturbation intensity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic \u03b5-dominance ranking with adaptive \u03b5\n    epsilon = 0.1\n    filtered_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon * obj[0] and\n                other_obj[1] >= obj[1] - epsilon * obj[1] and\n                (other_obj[0] > obj[0] - epsilon * obj[0] or\n                 other_obj[1] > obj[1] - epsilon * obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            filtered_solutions.append((sol, obj))\n\n    if not filtered_solutions:\n        filtered_solutions = archive.copy()\n\n    # Select solution with highest \u03b5-dominance rank (more dominated)\n    selected = max(filtered_solutions, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive weighted marginal gains with dynamic \u03b5\n    capacity_ratio = (capacity - current_weight) / capacity\n    epsilon = max(0.05, 0.2 * capacity_ratio)  # Dynamic \u03b5 scaling\n    marginal_gain = (value1_lst + epsilon * value2_lst) * (1 + capacity_ratio) / (weight_lst + 1e-6)\n\n    # Sort by marginal gain (descending)\n    sorted_indices = np.argsort(-marginal_gain)\n\n    # Perform feasibility-aware flips\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Adaptive perturbation based on marginal gain and remaining capacity\n    perturbation_prob = min(0.5, 0.2 + capacity_ratio * 0.3)\n    if np.random.rand() < perturbation_prob:\n        # Select items with low marginal gain for potential flip\n        low_gain_indices = np.argsort(marginal_gain)\n        for i in low_gain_indices[:min(3, len(low_gain_indices))]:\n            if new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        excess_items_sorted = sorted(excess_items, key=lambda x: marginal_gain[x])\n        remove_idx = excess_items_sorted[0]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8485508200769776,
            1.33580282330513
        ]
    },
    {
        "algorithm": "The algorithm combines dynamic \u03b5-dominance filtering to prioritize non-dominated solutions, selects a balanced base solution, and employs a three-phase local search: first flipping items with highest hybrid marginal gains to ensure feasibility, then adaptively perturbing low-contribution items based on remaining capacity, and finally validating and correcting any remaining infeasibilities by removing the least valuable items. The hybrid marginal gain metric (value1 + value2)/(weight + \u03b5) guides item selection, while adaptive perturbation probabilities balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic \u03b5-dominance filtering\n    epsilon = 0.1\n    filtered_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon and other_obj[1] >= obj[1] - epsilon and\n                (other_obj[0] > obj[0] - epsilon or other_obj[1] > obj[1] - epsilon)):\n                dominated = True\n                break\n        if not dominated:\n            filtered_solutions.append((sol, obj))\n\n    if not filtered_solutions:\n        filtered_solutions = archive.copy()\n\n    # Select base solution with balanced objectives\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in filtered_solutions])\n    base_solution = filtered_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate hybrid marginal gains\n    hybrid_gain = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(-hybrid_gain)\n\n    # Phase 1: Feasibility-aware flips\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                break\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    # Phase 2: Adaptive perturbations\n    remaining_capacity = capacity - current_weight\n    perturbation_prob = min(0.3, 0.1 + 0.2 * (remaining_capacity / capacity))\n\n    if np.random.rand() < perturbation_prob:\n        # Select items with low hybrid gain and high weight contribution\n        low_gain_mask = hybrid_gain < np.percentile(hybrid_gain, 20)\n        candidate_indices = np.where(new_solution)[0]\n\n        if len(candidate_indices) > 0:\n            candidate_indices = sorted(candidate_indices, key=lambda x: weight_lst[x] / (value1_lst[x] + value2_lst[x] + 1e-6))\n            for i in candidate_indices[:min(3, len(candidate_indices))]:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    # Phase 3: Final feasibility validation\n    while current_weight > capacity:\n        excess_items = np.where(new_solution)[0]\n        if len(excess_items) == 0:\n            break\n        # Remove items with lowest hybrid gain\n        excess_items_sorted = sorted(excess_items, key=lambda x: hybrid_gain[x])\n        remove_idx = excess_items_sorted[0]\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9654689729056316,
            1.993800312280655
        ]
    },
    {
        "algorithm": "The algorithm uses \u03b5-dominance ranking to select high-quality, diverse solutions from the archive, then applies a hybrid local search combining weighted marginal gain prioritization (with adaptive weights based on current knapsack utilization) and targeted perturbations (flipping 1-3 random items with probability dependent on capacity usage), ensuring feasibility at every step. The weighted marginal gain balances both objectives dynamically, while adaptive perturbations introduce controlled exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # \u03b5-dominance ranking to select diverse high-quality solutions\n    epsilon = 0.1  # \u03b5 parameter for \u03b5-dominance\n    ranked_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon and other_obj[1] >= obj[1] - epsilon and\n                (other_obj[0] > obj[0] or other_obj[1] > obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            ranked_solutions.append((sol, obj))\n\n    if not ranked_solutions:\n        ranked_solutions = archive\n\n    # Select solution with highest \u03b5-dominated rank (sum of objectives)\n    selected = max(ranked_solutions, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal gains\n    weight_factor = 0.6 if current_weight > 0.8 * capacity else 0.4\n    marginal_gain = (weight_factor * value1_lst + (1 - weight_factor) * value2_lst) / (weight_lst + 1e-6)\n\n    # Sort items by marginal gain (descending)\n    sorted_indices = np.argsort(-marginal_gain)\n\n    # Local search with targeted flips\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Adaptive perturbation\n    perturbation_prob = 0.3 if current_weight > 0.7 * capacity else 0.15\n    if np.random.rand() < perturbation_prob:\n        # Select 3 random items to perturb\n        perturb_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n        for i in perturb_indices:\n            if new_solution[i] == 1:\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n            else:\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4076089573457292,
            1.276840090751648
        ]
    },
    {
        "algorithm": "The algorithm dynamically balances trade-offs between objectives using adaptive \u03b5-dominance, prioritizes items based on normalized value ratios with capacity-aware weighting, and employs multi-phase validation (trade-off flips, probabilistic perturbations, and final feasibility checks) to generate high-quality neighbor solutions while ensuring feasibility. It balances exploration (via perturbation) and exploitation (via value-based flipping) to navigate the Pareto front effectively. The trade-off parameter \u03b1 adjusts dynamically based on current capacity and objective ratios, while perturbation strength scales with remaining capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic trade-off balancing with adaptive \u03b5-dominance\n    epsilon = 0.25\n    filtered_solutions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] - epsilon and other_obj[1] >= obj[1] - epsilon and\n                (other_obj[0] > obj[0] - epsilon or other_obj[1] > obj[1] - epsilon)):\n                dominated = True\n                break\n        if not dominated:\n            filtered_solutions.append((sol, obj))\n\n    if not filtered_solutions:\n        filtered_solutions = archive.copy()\n\n    # Select solution with balanced trade-off and capacity awareness\n    selected_idx = np.argmax([(obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-6) for _, obj in filtered_solutions])\n    base_solution = filtered_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive trade-off mechanism with normalized value ratios\n    base_obj = filtered_solutions[selected_idx][1]\n    value_ratio = base_obj[0] / (base_obj[1] + 1e-6)\n    alpha = 0.6 * (1 - (current_weight / capacity)) + 0.4 * (value_ratio / (value_ratio + 1))\n\n    # Calculate normalized value ratios with weight normalization\n    value_ratio = (alpha * value1_lst / (value1_lst + 1e-6) + (1 - alpha) * value2_lst / (value2_lst + 1e-6)) * np.log(1 + weight_lst)\n    sorted_indices = np.argsort(-value_ratio)\n\n    # Phase 1: Trade-off aware flips with feasibility checks\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                break\n        else:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                break\n\n    # Phase 2: Capacity-aware probabilistic perturbations\n    remaining_capacity = capacity - current_weight\n    perturbation_prob = min(0.5, 0.3 + 0.2 * (remaining_capacity / capacity))\n\n    if np.random.rand() < perturbation_prob:\n        # Select items with low value ratio and high weight contribution\n        low_ratio_mask = value_ratio < np.percentile(value_ratio, 40)\n        candidate_indices = np.where(new_solution & low_ratio_mask)[0]\n\n        if len(candidate_indices) > 0:\n            candidate_indices = sorted(candidate_indices, key=lambda x: weight_lst[x] / (value1_lst[x] + value2_lst[x] + 1e-6))\n            for i in candidate_indices[:min(3, len(candidate_indices))]:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    # Phase 3: Final feasibility validation with value ratio-based removal\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = np.where(new_solution)[0]\n        if len(excess_items) == 0:\n            break\n        # Remove items with lowest value ratio\n        excess_items_sorted = sorted(excess_items, key=lambda x: value_ratio[x])\n        remove_idx = excess_items_sorted[0]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8488072763976486,
            1.9138112366199493
        ]
    }
]