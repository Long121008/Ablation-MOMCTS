[
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a diverse solution from the archive (prioritize those with high objective values but not already explored)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2, reverse=True)\n    selected_idx = min(int(len(archive) * 0.4), len(archive) - 1)  # Select from top 40% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate dynamic marginal contribution (combining both objectives with weight adjustment)\n    alpha = 0.5  # Initial balance factor between objectives\n    if current_weight > 0.7 * capacity:\n        alpha = 0.7  # Increase focus on objective 1 when close to capacity\n    marginal_contribution = alpha * (value1_lst / weight_lst) + (1 - alpha) * (value2_lst / weight_lst)\n\n    # Sort items by dynamic marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_contribution)\n\n    # Perform targeted swaps and additions\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item i if it's not critical\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item i if it fits\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                # Check if adding this item improves both objectives sufficiently\n                if (value1_lst[i] > 0 and value2_lst[i] > 0) or (temp_weight <= 0.9 * capacity):\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n                    break\n\n    # Adaptive diversification (higher probability when stuck)\n    diversification_rate = 0.2 if current_weight > 0.8 * capacity else 0.1\n    if np.random.rand() < diversification_rate:\n        # Perform multiple random flips with feasibility checks\n        flip_indices = np.random.choice(len(weight_lst), size=min(4, len(weight_lst)), replace=False)\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9208547939029279,
            1.5441421568393707
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high average objective values, then applies a hybrid local search combining random bit-flips and greedy item swaps to generate a neighbor solution while ensuring feasibility. It first performs a random bit-flip with feasibility checks, then greedily adds high-value items for each objective, and finally introduces occasional diversification through additional random flips. The selection focuses on the top 30% of solutions, and the local search balances exploration and exploitation to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by average objective value (ascending order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Random bit-flip with feasibility check\n    flip_idx = random.randint(0, len(new_solution) - 1)\n    if new_solution[flip_idx] == 1:\n        new_solution[flip_idx] = 0\n    else:\n        if current_weight + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    # Step 2: Greedy item swap for both objectives\n    # For objective 1\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                # Calculate potential improvement\n                if value1_lst[i] > 0:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n                    break\n\n    # For objective 2\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                # Calculate potential improvement\n                if value2_lst[i] > 0:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n                    break\n\n    # Step 3: Random diversification (small probability)\n    if random.random() < 0.2:\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8386472432390504,
            2.298644572496414
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a base solution from the archive (prioritizing those with lower weights or higher values) and applies a hybrid local search by flipping items to improve either objective 1 or 2 (randomly chosen), selecting the top 3 most beneficial flips, and occasionally adding random flips to escape local optima while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a base solution with high potential for improvement\n    # Prefer solutions with lower weights (more room for improvement) or higher values (better starting point)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        candidates.append((sol, obj, total_weight))\n\n    # Sort candidates by a weighted combination of weight and objective values\n    candidates.sort(key=lambda x: (0.4 * x[2] / capacity) + 0.3 * (1 - x[1][0] / np.sum(value1_lst)) + 0.3 * (1 - x[1][1] / np.sum(value2_lst)))\n\n    # Select top 20% of candidates or at least 1\n    selection_pool = candidates[:max(1, len(candidates) // 5)]\n    base_sol, _, base_weight = random.choice(selection_pool)\n\n    new_solution = base_sol.copy()\n\n    # Hybrid local search strategy\n    # 1. Randomly select an objective to prioritize (50% chance for each)\n    prioritize_value1 = random.random() > 0.5\n\n    # 2. Find items that can be flipped to improve the prioritized objective\n    candidates_to_flip = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing this item\n            new_weight = base_weight - weight_lst[i]\n            if new_weight <= capacity:\n                if prioritize_value1:\n                    improvement = -value1_lst[i]\n                else:\n                    improvement = -value2_lst[i]\n                candidates_to_flip.append((i, improvement, new_weight))\n        else:\n            # Consider adding this item\n            new_weight = base_weight + weight_lst[i]\n            if new_weight <= capacity:\n                if prioritize_value1:\n                    improvement = value1_lst[i]\n                else:\n                    improvement = value2_lst[i]\n                candidates_to_flip.append((i, improvement, new_weight))\n\n    # 3. Select top 3 candidates with highest improvement\n    candidates_to_flip.sort(key=lambda x: x[1], reverse=True)\n    selected_flips = candidates_to_flip[:min(3, len(candidates_to_flip))]\n\n    # 4. Apply the flips\n    for i, _, _ in selected_flips:\n        new_solution[i] = 1 - new_solution[i]\n\n    # 5. Additional random flips to escape local optima\n    if random.random() > 0.7:  # 30% chance\n        candidate_indices = [i for i in range(len(new_solution))\n                            if (new_solution[i] == 1 and base_weight - weight_lst[i] <= capacity) or\n                               (new_solution[i] == 0 and base_weight + weight_lst[i] <= capacity)]\n        if candidate_indices:\n            flip_idx = random.choice(candidate_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility (shouldn't be necessary due to checks above, but added as safeguard)\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity:\n        excess_items = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n        if not excess_items:\n            break\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n        total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8628457652707344,
            6.785836309194565
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the sum of objectives) and applies a hybrid local search strategy that prioritizes items with high marginal contribution (combining both objectives) through strategic swaps, followed by adaptive perturbation for exploration. It ensures feasibility by checking weight constraints at each step, balancing exploitation (targeted swaps) with exploration (random perturbations).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: swap items with high potential and adaptive perturbation\n    # Step 1: Identify items with high marginal contribution\n    marginal_value1 = value1_lst / weight_lst\n    marginal_value2 = value2_lst / weight_lst\n    marginal_contribution = marginal_value1 + marginal_value2\n\n    # Step 2: Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-marginal_contribution)\n\n    # Step 3: Perform item swaps (explore neighborhood)\n    for i in sorted_indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n\n    # Step 4: Adaptive perturbation (explore further)\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        perturbation_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n        for i in perturbation_indices:\n            if new_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.5071726637714051,
            1.588004618883133
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top 20% of the archive (sorted by a weighted sum of objectives) and applies a hybrid local search combining weighted random bit-flips, aggressive greedy additions for both objectives, and occasional diversification flips to generate a feasible neighbor solution while balancing exploration and exploitation. It prioritizes items with higher combined values for random selection and greedy additions, with diversification to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by weighted sum of objectives (ascending order)\n    archive_sorted = sorted(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)  # Select from top 20% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Weighted random bit-flip with feasibility check\n    flip_idx = random.choices(range(len(new_solution)), weights=value1_lst + value2_lst)[0]\n    if new_solution[flip_idx] == 1:\n        new_solution[flip_idx] = 0\n    else:\n        if current_weight + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    # Step 2: More aggressive greedy item addition for both objectives\n    # For objective 1\n    for _ in range(2):  # Try twice to add items\n        best_item = None\n        best_value = -1\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                if value1_lst[i] > best_value:\n                    best_value = value1_lst[i]\n                    best_item = i\n        if best_item is not None:\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n\n    # For objective 2\n    for _ in range(2):  # Try twice to add items\n        best_item = None\n        best_value = -1\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                if value2_lst[i] > best_value:\n                    best_value = value2_lst[i]\n                    best_item = i\n        if best_item is not None:\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n\n    # Step 3: Higher diversification probability (30%)\n    if random.random() < 0.3:\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8212227174429538,
            3.1979097723960876
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing those with lower marginal gains in either objective, then applies a hybrid local search that combines randomized item swaps and adaptive neighborhood exploration to generate a feasible neighbor solution. It limits exploration to critical items and ensures feasibility by checking weight constraints at each step. The key design ideas are prioritizing solutions with improvement potential and using a constrained, randomized search to escape local optima while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(sol * weight_lst)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity > 0:\n            # Calculate marginal gains for potential additions\n            marginal1 = np.sum((1 - sol) * value1_lst)\n            marginal2 = np.sum((1 - sol) * value2_lst)\n            candidates.append((sol, obj, marginal1, marginal2))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Sort candidates by marginal gains (prioritize solutions with lower marginal gains)\n    candidates.sort(key=lambda x: (x[2], x[3]))\n    base_solution = candidates[0][0].copy()\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Randomly select a subset of items to consider for swapping\n    n_items = len(new_solution)\n    n_swap = min(5, n_items)  # Limit swap candidates\n    swap_indices = np.random.choice(n_items, size=n_swap, replace=False)\n\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Additional adaptive neighborhood exploration\n    for _ in range(3):  # Limit iterations\n        idx = np.random.randint(0, n_items)\n        if new_solution[idx] == 1:\n            # Try removing\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.30371705139443744,
            3.1044795215129852
        ]
    },
    {
        "algorithm": "The algorithm selects the highest-value solution from the archive, then applies a hybrid local search combining weighted random flips (prioritizing items based on their contribution to objectives) and objective-specific greedy swaps (adding high-value items for the dominant objective). It also includes dynamic diversification to occasionally remove low-value items to escape local optima, all while ensuring feasibility. The search dynamically adjusts focus between objectives based on the current solution's performance, favoring the objective with higher weight.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Calculate objective weights based on current solution's performance\n    obj1_weight = archive_sorted[0][1][0] / (archive_sorted[0][1][0] + archive_sorted[0][1][1] + 1e-6)\n    obj2_weight = archive_sorted[0][1][1] / (archive_sorted[0][1][0] + archive_sorted[0][1][1] + 1e-6)\n\n    # Step 1: Weighted random flip with feasibility check\n    flip_prob = np.zeros(len(new_solution))\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            flip_prob[i] = 0.3 * (obj1_weight * value1_lst[i] + obj2_weight * value2_lst[i])\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                flip_prob[i] = 0.7 * (obj1_weight * value1_lst[i] + obj2_weight * value2_lst[i])\n\n    if np.sum(flip_prob) > 0:\n        flip_prob = flip_prob / np.sum(flip_prob)\n        flip_idx = np.random.choice(len(new_solution), p=flip_prob)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 2: Objective-specific greedy swaps\n    # For objective 1\n    if obj1_weight > 0.5:\n        value_ratio = value1_lst / (weight_lst + 1e-6)\n        for i in np.argsort(-value_ratio):\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    # For objective 2\n    if obj2_weight > 0.5:\n        value_ratio = value2_lst / (weight_lst + 1e-6)\n        for i in np.argsort(-value_ratio):\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    # Step 3: Dynamic diversification\n    diversification_prob = 0.3 * (1 - min(obj1_weight, obj2_weight))\n    if random.random() < diversification_prob:\n        # Select items to remove based on combined value-to-weight ratio\n        value_ratio = (obj1_weight * value1_lst + obj2_weight * value2_lst) / (weight_lst + 1e-6)\n        for i in np.argsort(value_ratio):\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.47596614993570746,
            3.1493912637233734
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a base solution from the archive using \u03b5-dominance-based scoring (prioritizing balanced marginal contributions) and applies a hybrid local search combining prioritized flips (top 3 improvements) and adaptive perturbation (20% chance) to escape local optima while ensuring feasibility. It balances both objectives equally (0.5 weight each) and focuses on high-impact flips first.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection using \u03b5-dominance approximation\n    def dominance_score(sol, obj):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            return -np.inf\n        # Normalized marginal contributions\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        return 0.5 * np.mean(marginal1 * sol) + 0.5 * np.mean(marginal2 * sol)\n\n    ranked = sorted(archive, key=lambda x: dominance_score(x[0], x[1]), reverse=True)\n    base_sol = ranked[0][0].copy()\n    new_solution = base_sol.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Prioritized flips + adaptive perturbation\n    # Step 1: Calculate normalized objective improvements\n    improvements = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Potential removal\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                imp1 = -value1_lst[i]\n                imp2 = -value2_lst[i]\n                improvements.append((i, imp1, imp2, new_weight))\n        else:\n            # Potential addition\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                imp1 = value1_lst[i]\n                imp2 = value2_lst[i]\n                improvements.append((i, imp1, imp2, new_weight))\n\n    # Step 2: Select top 3 flips based on combined improvement\n    improvements.sort(key=lambda x: 0.5 * x[1] + 0.5 * x[2], reverse=True)\n    selected_flips = improvements[:min(3, len(improvements))]\n\n    # Apply selected flips\n    for i, _, _, new_weight in selected_flips:\n        new_solution[i] = 1 - new_solution[i]\n        current_weight = new_weight\n\n    # Step 3: Adaptive perturbation (20% chance)\n    if random.random() < 0.2:\n        # Select a random item to flip\n        candidate_indices = [i for i in range(len(new_solution))\n                            if (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                               (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n        if candidate_indices:\n            flip_idx = random.choice(candidate_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.47754102762881034,
            4.688980668783188
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a non-dominated solution from the archive and applies a hybrid local search combining item flips, swaps, and guided perturbations to explore the solution space while ensuring feasibility, prioritizing solutions with high potential for improvement. It balances exploration through random perturbations with exploitation of the current solution's structure, dynamically adjusting the search to navigate the trade-off between the two objectives. The method emphasizes feasibility by iteratively removing the heaviest item when capacity is exceeded, ensuring all generated neighbors are valid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total weight and values for each solution in the archive\n    solution_weights = [np.sum(weight_lst[s[0]]) for s in archive]\n    solution_values1 = [s[1][0] for s in archive]\n    solution_values2 = [s[1][1] for s in archive]\n\n    # Rank solutions by their potential for improvement (e.g., those not on the Pareto front)\n    # Here, we select a solution that is not dominated by others in the archive\n    selected_idx = 0\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (solution_values1[j] >= solution_values1[i] and solution_values2[j] >= solution_values2[i] and\n                (solution_values1[j] > solution_values1[i] or solution_values2[j] > solution_values2[i])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_idx = i\n            break\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: combine random flips, swaps, and guided perturbations\n    for _ in range(3):  # Perform multiple perturbations\n        # Randomly select a subset of items to flip\n        flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # Try to remove the item if feasible\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # Try to add the item if feasible\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Randomly swap two items if feasible\n        if n_items >= 2:\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] != new_solution[j]:\n                temp_weight = np.sum(weight_lst[new_solution == 1])\n                if new_solution[i] == 1 and new_solution[j] == 0:\n                    if temp_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[i] == 0 and new_solution[j] == 1:\n                    if temp_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove the heaviest item in the solution\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        heaviest_item = included_items[np.argmax(weight_lst[included_items])]\n        new_solution[heaviest_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4020029614090404,
            3.565171241760254
        ]
    }
]