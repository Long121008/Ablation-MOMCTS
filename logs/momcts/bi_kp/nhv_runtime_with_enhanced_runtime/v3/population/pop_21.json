[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted objective score (70% value1 + 30% value2) and applies a local search by flipping up to 5 items with the highest marginal contribution (also weighted 70-30) while ensuring feasibility. It dynamically adjusts the solution by adding or removing items to maximize the combined objective without exceeding the knapsack capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted objective score (0.7*value1 + 0.3*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.7 * obj[0] + 0.3 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Dynamic flip strategy: flip up to 5 items with highest marginal contribution\n    flip_count = min(5, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8742819369527933,
            1.159465342760086
        ]
    },
    {
        "algorithm": "The heuristic selects a high-value solution from the archive (based on the maximum of either objective value) and applies a hybrid local search by flipping items prioritized by their combined value-to-weight ratios (sum of ratios for both objectives), ensuring feasibility by checking weight constraints. It randomly selects up to 5 high-priority items to flip, removing or adding them if the operation doesn\u2019t exceed capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., those with high diversity or low dominance)\n    # Here, we randomly select a solution with high value in at least one objective\n    max_value = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        if max(obj[0], obj[1]) > max_value:\n            max_value = max(obj[0], obj[1])\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items with high value-to-weight ratio in a random order\n    # First, compute value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios and sort by descending order\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(sorted_indices, size=min(5, len(sorted_indices)), replace=False)\n\n    # Flip selected items while ensuring feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.30518390165972703,
            1.3124490082263947
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing higher scores (60% value2 + 40% value1), then applies a hybrid local search that flips up to 3 high-marginal-contribution items (weighted 60% value2 + 40% value1) while ensuring feasibility, followed by a probabilistic swap of two items to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted objective score (0.4*value1 + 0.6*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.4 * obj[0] + 0.6 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item (0.6*value2 + 0.4*value1)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.6 * marginal2 + 0.4 * marginal1\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Dynamic flip strategy: flip up to 3 items with highest marginal contribution\n    flip_count = min(3, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Probabilistic swap of two items to escape local optima\n    if len(sorted_indices) >= 2:\n        swap_candidates = sorted_indices[:5]  # Consider top 5 items for swap\n        if len(swap_candidates) >= 2:\n            i, j = np.random.choice(swap_candidates, size=2, replace=False)\n            # Check if swapping is feasible\n            if new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7724345802780868,
            1.3127074539661407
        ]
    },
    {
        "algorithm": "The algorithm selects a high-scoring solution from the archive (prioritizing 70% value1 + 30% value2) and generates a neighbor by flipping up to 4 high-marginal-contribution items (weighted similarly) while ensuring feasibility, followed by a probabilistic 3-item swap to explore diverse neighborhoods. It dynamically balances exploitation (flipping high-marginal items) and exploration (random swaps) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted objective score (0.7*value1 + 0.3*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.7 * obj[0] + 0.3 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item (0.7*value1 + 0.3*value2)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Dynamic flip strategy: flip up to 4 items with highest marginal contribution\n    flip_count = min(4, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Probabilistic swap of three items to explore diverse neighborhoods\n    if len(sorted_indices) >= 3:\n        swap_candidates = sorted_indices[:6]  # Consider top 6 items for swap\n        if len(swap_candidates) >= 3:\n            i, j, k = np.random.choice(swap_candidates, size=3, replace=False)\n            # Check if swapping is feasible\n            if new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if new_solution[j] != new_solution[k]:\n                if new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[k] <= capacity:\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n                elif new_solution[k] == 1 and current_weight - weight_lst[k] + weight_lst[j] <= capacity:\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8631499479602416,
            1.3316587507724762
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive (measured by differences from the median solution) and applies a hybrid local search that prioritizes flipping items with high combined normalized value-to-weight ratios (sum of ratios for both objectives), balancing exploration and exploitation while ensuring feasibility. It randomly selects top items based on these ratios and flips them if feasible, adjusting the solution incrementally. The approach avoids standard 2-opt by combining probabilistic item selection with feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (differing from median solution)\n    median_solution = np.median([sol[0] for sol in archive], axis=0) > 0.5\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, _) in enumerate(archive):\n        diversity = np.sum(sol != median_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: prioritize items with high normalized value-to-weight ratios\n    total_weight = np.sum(weight_lst * new_solution)\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Select top k items with probability proportional to their ratio\n    k = min(5, len(sorted_indices))\n    probs = combined_ratio[sorted_indices[:k]]\n    probs = probs / np.sum(probs)\n    flip_indices = np.random.choice(sorted_indices[:k], size=k, replace=False, p=probs)\n\n    # Flip selected items while ensuring feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8417792757762104,
            4.154091060161591
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high diversity (measured by differences from the median solution) and applies a hybrid local search that prioritizes flipping items with high weighted normalized value-to-weight ratios (60% for objective 1, 40% for objective 2) while ensuring feasibility by checking capacity constraints. It flips top-3 items (or fewer) with probabilities proportional to their ratios, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (differing from median solution)\n    median_solution = np.median([sol[0] for sol in archive], axis=0) > 0.5\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, _) in enumerate(archive):\n        diversity = np.sum(sol != median_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: prioritize items with high individual normalized value-to-weight ratios\n    total_weight = np.sum(weight_lst * new_solution)\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    weighted_ratio = 0.6 * ratio1 + 0.4 * ratio2  # Weighted combination\n    sorted_indices = np.argsort(-weighted_ratio)\n\n    # Select top k items with probability proportional to their ratio\n    k = min(3, len(sorted_indices))\n    probs = weighted_ratio[sorted_indices[:k]]\n    probs = probs / np.sum(probs)\n    flip_indices = np.random.choice(sorted_indices[:k], size=k, replace=False, p=probs)\n\n    # Flip selected items while ensuring feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8611287417934537,
            5.100826621055603
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search that prioritizes items with high combined marginal value-to-weight ratios (sum of both objectives) by randomly flipping them (adding or removing) while ensuring feasibility, followed by a random swap between two items if feasible. The approach balances exploration (random selection and flipping) with exploitation (targeting high-value items) to generate diverse neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = current_obj[0]\n    current_value2 = current_obj[1]\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (with high marginal value-to-weight ratio)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Randomly select a subset of top items to flip\n    flip_candidates = sorted_indices[:max(1, n_items // 4)]\n    random.shuffle(flip_candidates)\n    flip_count = random.randint(1, min(3, len(flip_candidates)))\n\n    for i in flip_candidates[:flip_count]:\n        if base_solution[i] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 2: Perform a random swap between two items (if possible)\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Check feasibility after swap\n            if (base_solution[i] == 1 and base_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif (base_solution[i] == 0 and base_solution[j] == 1 and\n                  current_weight + weight_lst[i] - weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3285702074002692,
            1.3605346977710724
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on alternating priorities (value1, value2, or balanced) and applies a multi-stage local search: first flipping top marginal-contribution items (adaptively weighted by solution density) to improve both objectives, then probabilistically replacing items to escape local optima while maintaining feasibility. It prioritizes items with higher combined marginal gains (value1 and value2 normalized by weight) and adjusts flipping/replacement based on current solution density.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on time-varying weights (cyclic between objectives)\n    current_time = len(archive) % 3\n    if current_time == 0:\n        # Focus on value2\n        selected_idx = np.argmax([obj[1] for _, obj in archive])\n    elif current_time == 1:\n        # Focus on value1\n        selected_idx = np.argmax([obj[0] for _, obj in archive])\n    else:\n        # Balanced approach\n        selected_idx = np.argmax([0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive marginal contribution calculation\n    density = np.sum(new_solution) / len(new_solution)\n    alpha = 0.7 if density > 0.5 else 0.3  # Adjust based on solution density\n    combined_marginal = alpha * (value2_lst / (weight_lst + 1e-6)) + (1 - alpha) * (value1_lst / (weight_lst + 1e-6))\n\n    # Multi-stage local search\n    # Stage 1: Flip top items with highest marginal contribution\n    sorted_indices = np.argsort(-combined_marginal)\n    flip_count = min(4, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Stage 2: Probabilistic item replacement\n    if np.random.random() < 0.7:  # 70% chance to perform replacement\n        replace_candidates = sorted_indices[:6]  # Consider top 6 items\n        if len(replace_candidates) >= 2:\n            i, j = np.random.choice(replace_candidates, size=2, replace=False)\n            if new_solution[i] != new_solution[j]:\n                # Calculate weight difference\n                weight_diff = weight_lst[j] - weight_lst[i]\n                if new_solution[i] == 1:\n                    if current_weight + weight_diff <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                else:\n                    if current_weight - weight_diff <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8334009459878748,
            1.40790656208992
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from an archive using a hybrid metric combining marginal gains and dominance ranks, then applies a three-phase dynamic local search: first flipping high-marginal items, then randomly flipping items, and finally guided swaps, all while ensuring feasibility through weight checks. The selection prioritizes solutions with high marginal gains (70%) and good dominance ranks (30%), while the local search adaptively explores the solution space with increasing randomness to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine marginal gains and dominance rank\n    def dominance_rank(sol, obj):\n        # Count how many solutions in archive are dominated by this solution\n        count = 0\n        for (_, other_obj) in archive:\n            if (obj[0] >= other_obj[0] and obj[1] > other_obj[1]) or \\\n               (obj[0] > other_obj[0] and obj[1] >= other_obj[1]):\n                count += 1\n        return count\n\n    # Calculate marginal gains and dominance ranks\n    marginal_gains = []\n    dominance_ranks = []\n    for (sol, obj) in archive:\n        included = sol == 1\n        marginal_value1 = np.sum(value1_lst[included]) / (np.sum(weight_lst[included]) + 1e-6)\n        marginal_value2 = np.sum(value2_lst[included]) / (np.sum(weight_lst[included]) + 1e-6)\n        marginal_gains.append(marginal_value1 + marginal_value2)\n        dominance_ranks.append(dominance_rank(sol, obj))\n\n    # Combine metrics (normalized) for selection\n    combined_scores = []\n    max_marginal = max(marginal_gains) if marginal_gains else 1\n    max_rank = max(dominance_ranks) if dominance_ranks else 1\n    for i in range(len(archive)):\n        normalized_marginal = marginal_gains[i] / max_marginal if max_marginal > 0 else 0\n        normalized_rank = dominance_ranks[i] / max_rank if max_rank > 0 else 0\n        combined_scores.append(0.7 * normalized_marginal + 0.3 * normalized_rank)\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution, base_obj = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Dynamic local search with adaptive operations\n    for phase in range(3):  # Three-phase dynamic search\n        if phase == 0:  # High-marginal items phase\n            marginal_value1 = value1_lst / (weight_lst + 1e-6)\n            marginal_value2 = value2_lst / (weight_lst + 1e-6)\n            combined_marginal = marginal_value1 + marginal_value2\n            sorted_indices = np.argsort(combined_marginal)[::-1]\n\n            for i in sorted_indices[:max(1, len(sorted_indices) // 2)]:\n                if random.random() < 0.8:  # Higher probability for high-marginal items\n                    if new_solution[i] == 1:\n                        if current_weight - weight_lst[i] <= capacity:\n                            new_solution[i] = 0\n                            current_weight -= weight_lst[i]\n                    else:\n                        if current_weight + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n\n        elif phase == 1:  # Random flip phase\n            flip_candidates = np.where(new_solution == 1)[0]\n            if len(flip_candidates) > 0:\n                for _ in range(min(3, len(flip_candidates))):\n                    i = random.choice(flip_candidates)\n                    if current_weight - weight_lst[i] <= capacity:\n                        new_solution[i] = 0\n                        current_weight -= weight_lst[i]\n\n            # Add random items if capacity allows\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0 and current_weight < capacity:\n                for _ in range(min(2, len(available_items))):\n                    i = random.choice(available_items)\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n        else:  # Guided swap phase\n            if len(np.where(new_solution == 1)[0]) > 1:\n                i, j = random.sample(range(len(new_solution)), 2)\n                if new_solution[i] != new_solution[j]:\n                    temp_weight = current_weight\n                    if new_solution[i] == 1:\n                        temp_weight -= weight_lst[i]\n                    else:\n                        temp_weight += weight_lst[i]\n                    if new_solution[j] == 1:\n                        temp_weight += weight_lst[j]\n                    else:\n                        temp_weight -= weight_lst[j]\n\n                    if temp_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8250022080273637,
            5.823804974555969
        ]
    },
    {
        "algorithm": "The algorithm selects the most non-dominated solution from the archive (lowest dominance rank) and applies a hybrid local search combining adaptive item flipping (prioritizing high-marginal-contribution items) and probabilistic swapping to improve both objectives while ensuring feasibility through weight checks. It balances exploration (via probabilistic selection) and exploitation (via marginal contribution prioritization) to escape local optima while maintaining solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks for each solution\n    dominance_ranks = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        rank = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] >= obj_i[0] and obj_j[1] >= obj_i[1]) and (obj_j[0] > obj_i[0] or obj_j[1] > obj_i[1]):\n                rank += 1\n        dominance_ranks.append(rank)\n\n    # Select solution with lowest dominance rank (most non-dominated)\n    selected_idx = np.argmin(dominance_ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item (0.5*value1 + 0.5*value2)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.5 * marginal1 + 0.5 * marginal2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Adaptive flip strategy: flip items with high marginal contribution and probabilistic selection\n    flip_count = min(5, len(sorted_indices))\n    flip_probs = combined_marginal[sorted_indices[:flip_count]] / np.sum(combined_marginal[sorted_indices[:flip_count]])\n    flip_indices = np.random.choice(sorted_indices[:flip_count], size=min(3, flip_count), replace=False, p=flip_probs)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Adaptive swap operation with probabilistic selection\n    if len(sorted_indices) >= 2:\n        swap_candidates = sorted_indices[:10]  # Consider top 10 items for swap\n        if len(swap_candidates) >= 2:\n            i, j = np.random.choice(swap_candidates, size=2, replace=False)\n            swap_prob = 0.3 * (combined_marginal[i] + combined_marginal[j]) / (np.sum(combined_marginal[swap_candidates]) + 1e-6)\n            if np.random.rand() < swap_prob:\n                if new_solution[i] != new_solution[j]:\n                    if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5295947885649618,
            2.7182366847991943
        ]
    }
]