[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted objective score (70% value1 + 30% value2) and applies a local search by flipping up to 5 items with the highest marginal contribution (also weighted 70-30) while ensuring feasibility. It dynamically adjusts the solution by adding or removing items to maximize the combined objective without exceeding the knapsack capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted objective score (0.7*value1 + 0.3*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.7 * obj[0] + 0.3 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Dynamic flip strategy: flip up to 5 items with highest marginal contribution\n    flip_count = min(5, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8742819369527933,
            1.159465342760086
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from an archive using a hybrid metric of dominance rank and solution density, then applies a tiered local search combining marginal gain analysis, adaptive swaps, and probabilistic perturbations to generate a neighbor solution while ensuring feasibility through dynamic weight tracking. The search prioritizes items with high combined marginal gains (value1 + value2) and uses adaptive swaps between high and low marginal items, followed by probabilistic flips weighted by normalized marginal values.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine dominance rank and solution density\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        ranks[sorted_idx] += np.arange(len(archive))\n    density_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.linalg.norm(objectives - objectives[i], axis=1)\n        density_scores[i] = 1 / (np.sum(dist) + 1e-6)\n    combined_scores = ranks + density_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Objective-aware marginal flips\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n    sorted_indices = np.argsort(-combined_marginal)\n    for idx in sorted_indices[:min(3, len(sorted_indices))]:\n        if new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        elif new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Phase 2: Adaptive objective-aware swaps\n    if len(sorted_indices) >= 2:\n        high_idx, low_idx = sorted_indices[0], sorted_indices[-1]\n        if new_solution[high_idx] != new_solution[low_idx]:\n            weight_diff = weight_lst[high_idx] - weight_lst[low_idx]\n            if (new_solution[high_idx] == 1 and current_weight + weight_diff <= capacity) or \\\n               (new_solution[high_idx] == 0 and current_weight - weight_diff <= capacity):\n                new_solution[high_idx], new_solution[low_idx] = new_solution[low_idx], new_solution[high_idx]\n\n    # Phase 3: Probabilistic objective-aware perturbation\n    for idx in np.random.permutation(len(new_solution)):\n        if np.random.rand() < 0.2:\n            prob = 0.5 + 0.5 * (marginal1[idx] + marginal2[idx]) / (np.max(marginal1) + np.max(marginal2) + 1e-6)\n            if np.random.rand() < prob:\n                if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9828175680529148,
            8.38978260755539
        ]
    },
    {
        "algorithm": "This algorithm selects the most crowded solution from the archive (based on crowding distance) and applies a two-phase local search: first flipping high-marginal-value items and then swapping high/low-marginal items while ensuring feasibility. The selection prioritizes solutions in dense regions of the Pareto front, and the local search balances both objectives through marginal gains and adaptive swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-6)\n\n    # Select solution with maximum crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: High-marginal flips\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n    sorted_indices = np.argsort(-combined_marginal)\n\n    for idx in sorted_indices[:min(5, len(sorted_indices))]:\n        if new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        elif new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Phase 2: Adaptive objective-aware swaps\n    if len(sorted_indices) >= 2:\n        high_idx, low_idx = sorted_indices[0], sorted_indices[-1]\n        weight_diff = weight_lst[high_idx] - weight_lst[low_idx]\n        if (new_solution[high_idx] == 1 and current_weight + weight_diff <= capacity) or \\\n           (new_solution[high_idx] == 0 and current_weight - weight_diff <= capacity):\n            new_solution[high_idx], new_solution[low_idx] = new_solution[low_idx], new_solution[high_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8928027884040193,
            1.6058310270309448
        ]
    },
    {
        "algorithm": "The algorithm selects a high-quality solution from the archive using a weighted objective (40% value1, 60% value2), then applies a hybrid local search that flips up to 3 high-marginal-contribution items (prioritizing value1 over value2), performs probabilistic 3-item swaps among top marginal contributors, and has a 30% chance to remove a low-marginal item, all while ensuring feasibility. Marginal contributions are calculated as 70% value1 + 30% value2, balancing both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using weighted objective (0.4*value1 + 0.6*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.4 * obj[0] + 0.6 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item (0.7*value1 + 0.3*value2)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Hybrid flip strategy: flip up to 3 items with highest marginal contribution\n    flip_count = min(3, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Probabilistic swap of three items to explore diverse neighborhoods\n    if len(sorted_indices) >= 3:\n        swap_candidates = sorted_indices[:6]  # Consider top 6 items for swap\n        if len(swap_candidates) >= 3:\n            i, j, k = np.random.choice(swap_candidates, size=3, replace=False)\n            # Check if swapping is feasible\n            if new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if new_solution[j] != new_solution[k]:\n                if new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[k] <= capacity:\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n                elif new_solution[k] == 1 and current_weight - weight_lst[k] + weight_lst[j] <= capacity:\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # 30% chance to remove a random low-marginal item if possible\n    if np.random.rand() < 0.3:\n        low_marginal_indices = np.where((combined_marginal <= np.percentile(combined_marginal, 30)) & (new_solution == 1))[0]\n        if len(low_marginal_indices) > 0:\n            random_idx = np.random.choice(low_marginal_indices)\n            if current_weight - weight_lst[random_idx] <= capacity:\n                new_solution[random_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9596282361255002,
            1.9298218190670013
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objective ratios and weight diversity, then applies a tiered local search strategy where higher-tier items are flipped with decreasing probabilities (0.4, 0.16, 0.064) to prioritize high-value items while maintaining feasibility. It also performs value-balanced swaps between top candidates to improve both objectives adaptively based on the current solution's value imbalance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective ratio and weight diversity\n    objective_ratios = []\n    weight_diversity = []\n    for sol, obj in archive:\n        ratio = obj[0] / (obj[1] + 1e-6)\n        objective_ratios.append(ratio)\n        weight_diversity.append(np.sum(weight_lst * sol) / capacity)\n\n    # Combine metrics with adaptive weights\n    selection_scores = []\n    for i in range(len(archive)):\n        weight_ratio = 0.5 if len(archive) > 15 else 0.7\n        weight_div = 1 - weight_ratio\n        selection_scores.append(weight_ratio * objective_ratios[i] + weight_div * weight_diversity[i])\n\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Adaptive value prioritization\n    value_ratio = current_value1 / (current_value2 + 1e-6)\n    if value_ratio < 0.7:\n        primary_gain = value2_lst / (weight_lst + 1e-6)\n        secondary_gain = value1_lst / (weight_lst + 1e-6)\n    elif value_ratio > 1.3:\n        primary_gain = value1_lst / (weight_lst + 1e-6)\n        secondary_gain = value2_lst / (weight_lst + 1e-6)\n    else:\n        primary_gain = (value1_lst + value2_lst) / (2 * (weight_lst + 1e-6))\n        secondary_gain = primary_gain\n\n    # Tiered improvement strategy\n    combined_gain = 0.6 * primary_gain + 0.4 * secondary_gain\n    sorted_indices = np.argsort(-combined_gain)\n\n    # Dynamic tier sizes\n    tier1_size = max(1, len(sorted_indices) // 5)\n    tier2_size = max(1, len(sorted_indices) // 4)\n    tiers = [\n        sorted_indices[:tier1_size],\n        sorted_indices[tier1_size:tier1_size+tier2_size],\n        sorted_indices[tier1_size+tier2_size:]\n    ]\n\n    # Tiered flips with adaptive probabilities\n    for tier in [0, 1, 2]:\n        for idx in tiers[tier]:\n            flip_prob = 0.4 ** tier\n            if np.random.rand() < flip_prob:\n                if new_solution[idx] == 1:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n                else:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    # Value-balanced swaps\n    if len(new_solution) >= 2:\n        swap_candidates = np.argsort(-primary_gain)[:min(10, len(new_solution))]\n\n        if len(swap_candidates) >= 2:\n            i, j = np.random.choice(swap_candidates, size=2, replace=False)\n            if new_solution[i] != new_solution[j]:\n                weight_diff = weight_lst[j] - weight_lst[i]\n                if new_solution[i] == 1 and current_weight + weight_diff <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[j] == 1 and current_weight - weight_diff <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9284465210543387,
            4.479097753763199
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on alternating priorities (value1, value2, or a hybrid) and applies a two-stage local search: first flipping items with the highest normalized marginal gains (weighted by a time-varying factor) to improve both objectives, then performing a probabilistic swap of items to explore the solution space while maintaining feasibility. The selection strategy cycles through different objective preferences, and the local search uses both deterministic and stochastic operations to balance exploitation and exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on time-varying weights (cyclic between objectives)\n    current_time = len(archive) % 4\n    if current_time == 0:\n        # Focus on value2\n        selected_idx = np.argmax([obj[1] for _, obj in archive])\n    elif current_time == 1:\n        # Focus on value1\n        selected_idx = np.argmax([obj[0] for _, obj in archive])\n    elif current_time == 2:\n        # Hybrid approach (weighted sum)\n        selected_idx = np.argmax([0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive])\n    else:\n        # Random selection to encourage diversity\n        selected_idx = np.random.randint(0, len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Time-varying marginal contribution calculation\n    beta = 0.8 if (current_time % 2 == 0) else 0.2  # Alternate between objectives\n    combined_marginal = beta * (value1_lst / (weight_lst + 1e-6)) + (1 - beta) * (value2_lst / (weight_lst + 1e-6))\n\n    # Stage 1: Flip top items with highest marginal contribution\n    sorted_indices = np.argsort(-combined_marginal)\n    flip_count = min(3, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Stage 2: Probabilistic item swap\n    if np.random.random() < 0.6:  # 60% chance to perform swap\n        swap_candidates = sorted_indices[:5]  # Consider top 5 items\n        if len(swap_candidates) >= 2:\n            i, j = np.random.choice(swap_candidates, size=2, replace=False)\n            if new_solution[i] != new_solution[j]:\n                weight_diff = weight_lst[j] - weight_lst[i]\n                if new_solution[i] == 1:\n                    if current_weight + weight_diff <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                else:\n                    if current_weight - weight_diff <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7210599016669208,
            1.2667514085769653
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on combined objective values) and applies a hybrid local search strategy combining value-weighted random walks, dynamic marginal contribution analysis, and objective-aware swaps to generate feasible neighbors while prioritizing high-marginal items and ensuring feasibility through adaptive weight adjustments. It emphasizes items with high combined marginal contributions for both objectives, probabilistically flips items to add/remove them, and performs targeted swaps between high and low-marginal items while maintaining capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined_obj = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = (marginal1 + marginal2) * (1 - new_solution)  # Prefer adding items\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Value-weighted random walk: flip top k items with probability proportional to marginal\n    k = min(5, len(sorted_indices))\n    for idx in sorted_indices[:k]:\n        flip_prob = combined_marginal[idx] / np.sum(combined_marginal[:k])\n        if np.random.rand() < flip_prob and new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Dynamic marginal contribution analysis: flip items with high marginal improvement\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Calculate marginal improvement if removed\n            marginal_improvement = (value1_lst[idx] + value2_lst[idx]) / weight_lst[idx]\n            if np.random.rand() < 0.3 and current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Objective-aware swap: swap between high and low marginal items\n    if len(sorted_indices) >= 4:\n        high_marginal = sorted_indices[:4]\n        low_marginal = sorted_indices[-4:]\n\n        for _ in range(3):  # Perform 3 swaps\n            a = np.random.choice(high_marginal)\n            b = np.random.choice(low_marginal)\n            if new_solution[a] != new_solution[b]:\n                weight_diff = weight_lst[b] - weight_lst[a] if new_solution[a] == 1 else weight_lst[a] - weight_lst[b]\n                if current_weight + weight_diff <= capacity:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                    current_weight += weight_diff\n\n    # Adaptive weight adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest marginal contribution first\n        for idx in sorted_indices[::-1]:\n            if new_solution[idx] == 1 and excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.923986168630412,
            3.0276444256305695
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing higher scores (60% value2 + 40% value1), then applies a hybrid local search that flips up to 3 high-marginal-contribution items (weighted 60% value2 + 40% value1) while ensuring feasibility, followed by a probabilistic swap of two items to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted objective score (0.4*value1 + 0.6*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.4 * obj[0] + 0.6 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item (0.6*value2 + 0.4*value1)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.6 * marginal2 + 0.4 * marginal1\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Dynamic flip strategy: flip up to 3 items with highest marginal contribution\n    flip_count = min(3, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Probabilistic swap of two items to escape local optima\n    if len(sorted_indices) >= 2:\n        swap_candidates = sorted_indices[:5]  # Consider top 5 items for swap\n        if len(swap_candidates) >= 2:\n            i, j = np.random.choice(swap_candidates, size=2, replace=False)\n            # Check if swapping is feasible\n            if new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7724345802780868,
            1.3127074539661407
        ]
    },
    {
        "algorithm": "The algorithm selects a high-crowding-distance solution from the archive and applies a tiered local search: first flipping top 3 high-marginal items for both objectives, then performing adaptive swaps between high- and low-marginal items to balance exploration and exploitation while ensuring feasibility. It prioritizes items with combined marginal gains (value1/weight + value2/weight) and dynamically adjusts the search focus through random swaps between item categories.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for improvement)\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-6)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Tiered local search\n    # Phase 1: High marginal items for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Flip top 3 high-marginal items\n    for idx in sorted_indices[:3]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 2: Adaptive swaps between high/low marginal items\n    low_marginal_indices = sorted_indices[-len(sorted_indices)//2:]\n    for _ in range(2):\n        # Select one high and one low marginal item\n        high_idx = np.random.choice(sorted_indices[:len(sorted_indices)//2])\n        low_idx = np.random.choice(low_marginal_indices)\n\n        # Try swap if feasible\n        if new_solution[high_idx] == 1 and new_solution[low_idx] == 0:\n            delta_weight = weight_lst[low_idx] - weight_lst[high_idx]\n            if current_weight + delta_weight <= capacity:\n                new_solution[high_idx], new_solution[low_idx] = 0, 1\n                current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9183481356302192,
            2.0823307931423187
        ]
    },
    {
        "algorithm": "The algorithm selects a high-scoring solution from the archive (prioritizing 70% value1 + 30% value2) and generates a neighbor by flipping up to 4 high-marginal-contribution items (weighted similarly) while ensuring feasibility, followed by a probabilistic 3-item swap to explore diverse neighborhoods. It dynamically balances exploitation (flipping high-marginal items) and exploration (random swaps) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted objective score (0.7*value1 + 0.3*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.7 * obj[0] + 0.3 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item (0.7*value1 + 0.3*value2)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Dynamic flip strategy: flip up to 4 items with highest marginal contribution\n    flip_count = min(4, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Probabilistic swap of three items to explore diverse neighborhoods\n    if len(sorted_indices) >= 3:\n        swap_candidates = sorted_indices[:6]  # Consider top 6 items for swap\n        if len(swap_candidates) >= 3:\n            i, j, k = np.random.choice(swap_candidates, size=3, replace=False)\n            # Check if swapping is feasible\n            if new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if new_solution[j] != new_solution[k]:\n                if new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[k] <= capacity:\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n                elif new_solution[k] == 1 and current_weight - weight_lst[k] + weight_lst[j] <= capacity:\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8631499479602416,
            1.3316587507724762
        ]
    }
]