[
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high potential improvement (based on the product of the number of items and their combined values), then applies a hybrid local search combining item swaps, random additions, and removals to generate feasible neighbors while ensuring the weight constraint is met. The approach intelligently balances exploration and exploitation by leveraging both deterministic and stochastic operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    selected_solution, _ = max(archive, key=lambda x: sum(x[0]) * (sum(value1_lst[x[0] == 1]) + sum(value2_lst[x[0] == 1])))\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search operator: combination of item swaps and random perturbations\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select two items\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Try swapping them\n        if new_solution[item1] != new_solution[item2]:\n            temp_solution = new_solution.copy()\n            temp_solution[item1], temp_solution[item2] = temp_solution[item2], temp_solution[item1]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n        # Try adding a random item if possible\n        if current_weight < capacity:\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                item = random.choice(available_items)\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n        # Try removing a random item\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            item = random.choice(included_items)\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.46429848572432897,
            4.052294582128525
        ]
    },
    {
        "algorithm": "The heuristic selects a high-value solution from the archive (based on the maximum of either objective value) and applies a hybrid local search by flipping items prioritized by their combined value-to-weight ratios (sum of ratios for both objectives), ensuring feasibility by checking weight constraints. It randomly selects up to 5 high-priority items to flip, removing or adding them if the operation doesn\u2019t exceed capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., those with high diversity or low dominance)\n    # Here, we randomly select a solution with high value in at least one objective\n    max_value = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        if max(obj[0], obj[1]) > max_value:\n            max_value = max(obj[0], obj[1])\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items with high value-to-weight ratio in a random order\n    # First, compute value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios and sort by descending order\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(sorted_indices, size=min(5, len(sorted_indices)), replace=False)\n\n    # Flip selected items while ensuring feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.30518390165972703,
            1.3124490082263947
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search that prioritizes items with high combined marginal value-to-weight ratios (sum of both objectives) by randomly flipping them (adding or removing) while ensuring feasibility, followed by a random swap between two items if feasible. The approach balances exploration (random selection and flipping) with exploitation (targeting high-value items) to generate diverse neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = current_obj[0]\n    current_value2 = current_obj[1]\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (with high marginal value-to-weight ratio)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Randomly select a subset of top items to flip\n    flip_candidates = sorted_indices[:max(1, n_items // 4)]\n    random.shuffle(flip_candidates)\n    flip_count = random.randint(1, min(3, len(flip_candidates)))\n\n    for i in flip_candidates[:flip_count]:\n        if base_solution[i] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 2: Perform a random swap between two items (if possible)\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Check feasibility after swap\n            if (base_solution[i] == 1 and base_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif (base_solution[i] == 0 and base_solution[j] == 1 and\n                  current_weight + weight_lst[i] - weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3285702074002692,
            1.3605346977710724
        ]
    },
    {
        "algorithm": "The algorithm combines a backbone selection strategy with a hybrid local search that prioritizes high-marginal-value items in a targeted phase and explores less obvious candidates in a random phase, while dynamically adjusting item inclusion/exclusion to maintain feasibility through weight checks. It alternates between phases and employs guided random swaps to further refine solutions, ensuring diversity and adaptive exploration of the solution space. Key design choices include prioritizing items with high combined marginal value, probabilistic inclusion/exclusion based on phase, and feasibility checks during all modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined value)\n    selected_solution, _ = max(archive, key=lambda x: sum(value1_lst[x[0] == 1]) + sum(value2_lst[x[0] == 1]))\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Dynamic perturbation mechanism\n    for phase in range(2):  # Alternate between targeted and random perturbations\n        if phase == 0:  # Targeted phase: prioritize high-marginal items\n            for i in sorted_indices[:max(1, len(sorted_indices) // 3)]:\n                if random.random() < 0.7:  # Higher probability for high-marginal items\n                    if new_solution[i] == 1:\n                        if current_weight - weight_lst[i] <= capacity:\n                            new_solution[i] = 0\n                            current_weight -= weight_lst[i]\n                    else:\n                        if current_weight + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n        else:  # Random phase: explore less obvious candidates\n            for i in sorted_indices[len(sorted_indices) // 3:]:\n                if random.random() < 0.3:  # Lower probability for less obvious items\n                    if new_solution[i] == 1:\n                        if current_weight - weight_lst[i] <= capacity:\n                            new_solution[i] = 0\n                            current_weight -= weight_lst[i]\n                    else:\n                        if current_weight + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n\n    # Guided random swap with adaptive weight adjustment\n    if len(np.where(new_solution == 1)[0]) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp_weight = current_weight\n            if new_solution[i] == 1:\n                temp_weight -= weight_lst[i]\n            else:\n                temp_weight += weight_lst[i]\n            if new_solution[j] == 1:\n                temp_weight += weight_lst[j]\n            else:\n                temp_weight -= weight_lst[j]\n\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.7977775119362,
            4.236347258090973
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing top 20% by combined objective value) and applies a hybrid local search: first performing random item swaps while maintaining feasibility, then using value-to-weight ratios to greedily add high-priority items and remove low-priority items. The method balances exploration (random swaps) and exploitation (targeted improvements) to navigate the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by their total value (sum of both objectives) and select the top 20% for further consideration\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Phase 1: Random item swaps (exploration)\n    num_swaps = random.randint(1, min(5, len(new_solution) // 2))\n    for _ in range(num_swaps):\n        # Select two distinct items\n        i, j = random.sample(range(len(new_solution)), 2)\n        # Swap their inclusion status\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            # If swap makes it infeasible, undo it\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 2: Targeted improvement (exploitation)\n    # Identify items with high value-to-weight ratios for both objectives\n    vw_ratio1 = value1_lst / weight_lst\n    vw_ratio2 = value2_lst / weight_lst\n\n    # Combine both ratios to get a comprehensive metric\n    combined_ratio = vw_ratio1 + vw_ratio2\n\n    # Sort items by the combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Try to add the highest-ratio items not already in the solution\n    for idx in sorted_indices:\n        if new_solution[idx] == 0:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            if np.sum(weight_lst * temp_solution) <= capacity:\n                new_solution = temp_solution\n                break\n\n    # Try to remove the lowest-ratio items currently in the solution\n    for idx in sorted_indices[::-1]:\n        if new_solution[idx] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            if np.sum(weight_lst * temp_solution) <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.3102647363559541,
            1.7155666649341583
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of its objective values and item diversity, then applies a novel hybrid local search that combines value-weighted item swaps with probabilistic additions and removals, ensuring feasibility through adaptive weight adjustments and value-based selection criteria. The method prioritizes items with higher combined value density (value1 + value2) relative to weight, favoring swaps and additions that maximize total value while maintaining capacity constraints. The structure alternates between deterministic swaps and probabilistic operations, with special handling for over-capacity scenarios by removing low-value-density items.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score and diversity\n    selected_solution, (obj1, obj2) = max(\n        archive,\n        key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) * (np.sum(x[0]) / len(x[0]))\n    )\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Novel hybrid local search\n    for _ in range(3):\n        # Value-weighted item selection for swaps\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select items with highest value density\n            density_in = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n            density_out = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n\n            item_in = random.choices(included, weights=density_in, k=1)[0]\n            item_out = random.choices(excluded, weights=density_out, k=1)[0]\n\n            # Try swap if feasible\n            if current_weight - weight_lst[item_in] + weight_lst[item_out] <= capacity:\n                new_solution[item_in], new_solution[item_out] = 0, 1\n                current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n        # Probabilistic addition based on value-weight ratio\n        if current_weight < capacity * 0.9:\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                ratios = (value1_lst[candidates] + value2_lst[candidates]) / weight_lst[candidates]\n                item = random.choices(candidates, weights=ratios, k=1)[0]\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n        # Value-based removal if solution is over-capacity\n        if current_weight > capacity:\n            included = np.where(new_solution == 1)[0]\n            ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n            item = random.choices(included, weights=1/ratios, k=1)[0]  # Remove low value-density items first\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.47017139111114425,
            4.8912599086761475
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive (prioritizing those with high normalized combined value) and applies a hybrid local search combining greedy item additions, strategic removals of low-contribution items, and probabilistic swaps, while always ensuring feasibility by respecting the weight capacity constraint.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    selected_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sqrt(np.sum(x[0])) + 1e-6))\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search operator with adaptive intensity\n    for _ in range(10):  # Increased number of perturbation attempts\n        # Targeted item selection based on value-to-weight ratio\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_items = np.argsort(value_ratios)[::-1]\n\n        # Try adding high-value items first\n        for item in sorted_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n        # Try removing low-contribution items\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Calculate contribution of each included item\n            contributions = (value1_lst[included_items] + value2_lst[included_items]) / (weight_lst[included_items] + 1e-6)\n            least_contributing = included_items[np.argmin(contributions)]\n            new_solution[least_contributing] = 0\n            current_weight -= weight_lst[least_contributing]\n\n        # Random swap with probability\n        if random.random() < 0.7:  # Higher probability for swaps\n            item1, item2 = random.sample(range(len(new_solution)), 2)\n            if new_solution[item1] != new_solution[item2]:\n                temp_solution = new_solution.copy()\n                temp_solution[item1], temp_solution[item2] = temp_solution[item2], temp_solution[item1]\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.323146566043925,
            4.441387116909027
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive based on marginal improvement potential (prioritizing items with high combined value-to-weight ratios) and applies a hybrid local search combining targeted swaps between high/low-marginal items, directed flips of high-marginal items, and occasional random perturbations to escape local optima while ensuring feasibility. It balances exploration (random perturbations) with exploitation (targeted improvements) to generate diverse, high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal improvement potential\n    def marginal_gain(sol, obj):\n        included = sol == 1\n        excluded = sol == 0\n        gain1 = sum(value1_lst[included]) + sum(value2_lst[included])\n        gain2 = sum(weight_lst[included])\n        return (gain1 / (gain2 + 1e-6))  # Avoid division by zero\n\n    selected_solution, _ = max(archive, key=lambda x: marginal_gain(x[0], x[1]))\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search operator\n    # Step 1: Targeted swaps (high marginal items with low marginal items)\n    marginal_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_ratios)\n    high_marginal = sorted_indices[-min(5, len(sorted_indices)):]\n    low_marginal = sorted_indices[:min(5, len(sorted_indices))]\n\n    for i in high_marginal:\n        for j in low_marginal:\n            if new_solution[i] != new_solution[j]:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n\n    # Step 2: Directed flips (items with high marginal gains)\n    flip_candidates = np.argsort(-marginal_ratios)[:min(5, len(marginal_ratios))]\n    for i in flip_candidates:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Random perturbations (escape local optima)\n    if random.random() < 0.3:  # 30% chance\n        available_items = np.where(new_solution == 0)[0]\n        included_items = np.where(new_solution == 1)[0]\n        if len(available_items) > 0 and len(included_items) > 0:\n            item_add = random.choice(available_items)\n            item_remove = random.choice(included_items)\n            if current_weight - weight_lst[item_remove] + weight_lst[item_add] <= capacity:\n                new_solution[item_remove] = 0\n                new_solution[item_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.6377126701996044,
            6.080775588750839
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective values) and applies a hybrid local search: first performing a random swap between two items, then adding high-value-to-weight-ratio items if capacity allows, while ensuring feasibility through random removals if capacity is exceeded. The method prioritizes combined objective values and leverages value-to-weight ratios for intelligent perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n    combined_values = [obj[0] + obj[1] for obj in archive_objectives]\n    base_solution = archive_solutions[np.argmax(combined_values)].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swap + value-to-weight ratio perturbation\n    num_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random swap (flip two random items)\n    if num_items >= 2:\n        idx1, idx2 = np.random.choice(num_items, 2, replace=False)\n        if new_solution[idx1] != new_solution[idx2]:\n            new_solution[idx1], new_solution[0] = new_solution[0], new_solution[idx1]\n            new_solution[idx2], new_solution[1] = new_solution[1], new_solution[idx2]\n\n    # Value-to-weight ratio perturbation: flip items with high ratio if space allows\n    if total_weight < capacity:\n        ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(ratios)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Ensure feasibility\n    while total_weight > capacity:\n        selected_items = np.where(new_solution == 1)[0]\n        if len(selected_items) == 0:\n            break\n        idx_to_remove = np.random.choice(selected_items)\n        new_solution[idx_to_remove] = 0\n        total_weight -= weight_lst[idx_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.4274850270191587,
            9.779397159814835
        ]
    }
]