[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted objective score (70% value1 + 30% value2) and applies a local search by flipping up to 5 items with the highest marginal contribution (also weighted 70-30) while ensuring feasibility. It dynamically adjusts the solution by adding or removing items to maximize the combined objective without exceeding the knapsack capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted objective score (0.7*value1 + 0.3*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.7 * obj[0] + 0.3 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Dynamic flip strategy: flip up to 5 items with highest marginal contribution\n    flip_count = min(5, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8742819369527933,
            1.159465342760086
        ]
    },
    {
        "algorithm": "The heuristic selects a high-value solution from the archive (based on the maximum of either objective value) and applies a hybrid local search by flipping items prioritized by their combined value-to-weight ratios (sum of ratios for both objectives), ensuring feasibility by checking weight constraints. It randomly selects up to 5 high-priority items to flip, removing or adding them if the operation doesn\u2019t exceed capacity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., those with high diversity or low dominance)\n    # Here, we randomly select a solution with high value in at least one objective\n    max_value = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        if max(obj[0], obj[1]) > max_value:\n            max_value = max(obj[0], obj[1])\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items with high value-to-weight ratio in a random order\n    # First, compute value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios and sort by descending order\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(sorted_indices, size=min(5, len(sorted_indices)), replace=False)\n\n    # Flip selected items while ensuring feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.30518390165972703,
            1.3124490082263947
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive (measured by differences from the median solution) and applies a hybrid local search that prioritizes flipping items with high combined normalized value-to-weight ratios (sum of ratios for both objectives), balancing exploration and exploitation while ensuring feasibility. It randomly selects top items based on these ratios and flips them if feasible, adjusting the solution incrementally. The approach avoids standard 2-opt by combining probabilistic item selection with feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (differing from median solution)\n    median_solution = np.median([sol[0] for sol in archive], axis=0) > 0.5\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, _) in enumerate(archive):\n        diversity = np.sum(sol != median_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: prioritize items with high normalized value-to-weight ratios\n    total_weight = np.sum(weight_lst * new_solution)\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Select top k items with probability proportional to their ratio\n    k = min(5, len(sorted_indices))\n    probs = combined_ratio[sorted_indices[:k]]\n    probs = probs / np.sum(probs)\n    flip_indices = np.random.choice(sorted_indices[:k], size=k, replace=False, p=probs)\n\n    # Flip selected items while ensuring feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8417792757762104,
            4.154091060161591
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing items with high combined marginal value-to-weight ratios for both objectives, then applies a hybrid local search that first performs targeted flips (prioritizing high-marginal items) followed by randomized swaps (ensuring feasibility through weight checks), balancing exploitation of high-potential items with exploration via randomized swaps. The selection of the base solution is based on combined marginal potential, while the local search alternates between deterministic and stochastic moves to diversify the neighborhood.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high marginal potential and dominance rank\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate marginal potential (combined value-to-weight ratio)\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal1 + marginal2\n        potential = np.sum(combined_marginal * sol)\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: targeted flips followed by randomized swaps\n    n_items = len(weight_lst)\n\n    # Step 1: Targeted flips (highest marginal items first)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n    sorted_indices = np.argsort(-combined_marginal)\n\n    flip_count = min(3, n_items)\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Randomized swaps (if feasible)\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if (new_solution[i] == 1 and new_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif (new_solution[i] == 0 and new_solution[j] == 1 and\n                  current_weight + weight_lst[i] - weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8185391357261935,
            3.3305866718292236
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing higher scores (60% value2 + 40% value1), then applies a hybrid local search that flips up to 3 high-marginal-contribution items (weighted 60% value2 + 40% value1) while ensuring feasibility, followed by a probabilistic swap of two items to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted objective score (0.4*value1 + 0.6*value2)\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.4 * obj[0] + 0.6 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Compute marginal contributions for each item (0.6*value2 + 0.4*value1)\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.6 * marginal2 + 0.4 * marginal1\n\n    # Sort items by marginal contribution (descending)\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Dynamic flip strategy: flip up to 3 items with highest marginal contribution\n    flip_count = min(3, len(sorted_indices))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try to remove if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Probabilistic swap of two items to escape local optima\n    if len(sorted_indices) >= 2:\n        swap_candidates = sorted_indices[:5]  # Consider top 5 items for swap\n        if len(swap_candidates) >= 2:\n            i, j = np.random.choice(swap_candidates, size=2, replace=False)\n            # Check if swapping is feasible\n            if new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7724345802780868,
            1.3127074539661407
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from an archive using a hybrid metric combining marginal gains and dominance ranks, then applies a three-phase dynamic local search: first flipping high-marginal items, then randomly flipping items, and finally guided swaps, all while ensuring feasibility through weight checks. The selection prioritizes solutions with high marginal gains (70%) and good dominance ranks (30%), while the local search adaptively explores the solution space with increasing randomness to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine marginal gains and dominance rank\n    def dominance_rank(sol, obj):\n        # Count how many solutions in archive are dominated by this solution\n        count = 0\n        for (_, other_obj) in archive:\n            if (obj[0] >= other_obj[0] and obj[1] > other_obj[1]) or \\\n               (obj[0] > other_obj[0] and obj[1] >= other_obj[1]):\n                count += 1\n        return count\n\n    # Calculate marginal gains and dominance ranks\n    marginal_gains = []\n    dominance_ranks = []\n    for (sol, obj) in archive:\n        included = sol == 1\n        marginal_value1 = np.sum(value1_lst[included]) / (np.sum(weight_lst[included]) + 1e-6)\n        marginal_value2 = np.sum(value2_lst[included]) / (np.sum(weight_lst[included]) + 1e-6)\n        marginal_gains.append(marginal_value1 + marginal_value2)\n        dominance_ranks.append(dominance_rank(sol, obj))\n\n    # Combine metrics (normalized) for selection\n    combined_scores = []\n    max_marginal = max(marginal_gains) if marginal_gains else 1\n    max_rank = max(dominance_ranks) if dominance_ranks else 1\n    for i in range(len(archive)):\n        normalized_marginal = marginal_gains[i] / max_marginal if max_marginal > 0 else 0\n        normalized_rank = dominance_ranks[i] / max_rank if max_rank > 0 else 0\n        combined_scores.append(0.7 * normalized_marginal + 0.3 * normalized_rank)\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution, base_obj = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Dynamic local search with adaptive operations\n    for phase in range(3):  # Three-phase dynamic search\n        if phase == 0:  # High-marginal items phase\n            marginal_value1 = value1_lst / (weight_lst + 1e-6)\n            marginal_value2 = value2_lst / (weight_lst + 1e-6)\n            combined_marginal = marginal_value1 + marginal_value2\n            sorted_indices = np.argsort(combined_marginal)[::-1]\n\n            for i in sorted_indices[:max(1, len(sorted_indices) // 2)]:\n                if random.random() < 0.8:  # Higher probability for high-marginal items\n                    if new_solution[i] == 1:\n                        if current_weight - weight_lst[i] <= capacity:\n                            new_solution[i] = 0\n                            current_weight -= weight_lst[i]\n                    else:\n                        if current_weight + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n\n        elif phase == 1:  # Random flip phase\n            flip_candidates = np.where(new_solution == 1)[0]\n            if len(flip_candidates) > 0:\n                for _ in range(min(3, len(flip_candidates))):\n                    i = random.choice(flip_candidates)\n                    if current_weight - weight_lst[i] <= capacity:\n                        new_solution[i] = 0\n                        current_weight -= weight_lst[i]\n\n            # Add random items if capacity allows\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0 and current_weight < capacity:\n                for _ in range(min(2, len(available_items))):\n                    i = random.choice(available_items)\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n        else:  # Guided swap phase\n            if len(np.where(new_solution == 1)[0]) > 1:\n                i, j = random.sample(range(len(new_solution)), 2)\n                if new_solution[i] != new_solution[j]:\n                    temp_weight = current_weight\n                    if new_solution[i] == 1:\n                        temp_weight -= weight_lst[i]\n                    else:\n                        temp_weight += weight_lst[i]\n                    if new_solution[j] == 1:\n                        temp_weight += weight_lst[j]\n                    else:\n                        temp_weight -= weight_lst[j]\n\n                    if temp_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8250022080273637,
            5.823804974555969
        ]
    },
    {
        "algorithm": "The algorithm combines a backbone selection strategy with a hybrid local search that prioritizes high-marginal-value items in a targeted phase and explores less obvious candidates in a random phase, while dynamically adjusting item inclusion/exclusion to maintain feasibility through weight checks. It alternates between phases and employs guided random swaps to further refine solutions, ensuring diversity and adaptive exploration of the solution space. Key design choices include prioritizing items with high combined marginal value, probabilistic inclusion/exclusion based on phase, and feasibility checks during all modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined value)\n    selected_solution, _ = max(archive, key=lambda x: sum(value1_lst[x[0] == 1]) + sum(value2_lst[x[0] == 1]))\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Dynamic perturbation mechanism\n    for phase in range(2):  # Alternate between targeted and random perturbations\n        if phase == 0:  # Targeted phase: prioritize high-marginal items\n            for i in sorted_indices[:max(1, len(sorted_indices) // 3)]:\n                if random.random() < 0.7:  # Higher probability for high-marginal items\n                    if new_solution[i] == 1:\n                        if current_weight - weight_lst[i] <= capacity:\n                            new_solution[i] = 0\n                            current_weight -= weight_lst[i]\n                    else:\n                        if current_weight + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n        else:  # Random phase: explore less obvious candidates\n            for i in sorted_indices[len(sorted_indices) // 3:]:\n                if random.random() < 0.3:  # Lower probability for less obvious items\n                    if new_solution[i] == 1:\n                        if current_weight - weight_lst[i] <= capacity:\n                            new_solution[i] = 0\n                            current_weight -= weight_lst[i]\n                    else:\n                        if current_weight + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n\n    # Guided random swap with adaptive weight adjustment\n    if len(np.where(new_solution == 1)[0]) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp_weight = current_weight\n            if new_solution[i] == 1:\n                temp_weight -= weight_lst[i]\n            else:\n                temp_weight += weight_lst[i]\n            if new_solution[j] == 1:\n                temp_weight += weight_lst[j]\n            else:\n                temp_weight -= weight_lst[j]\n\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.7977775119362,
            4.236347258090973
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search that prioritizes items with high combined marginal value-to-weight ratios (sum of both objectives) by randomly flipping them (adding or removing) while ensuring feasibility, followed by a random swap between two items if feasible. The approach balances exploration (random selection and flipping) with exploitation (targeting high-value items) to generate diverse neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = current_obj[0]\n    current_value2 = current_obj[1]\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (with high marginal value-to-weight ratio)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Randomly select a subset of top items to flip\n    flip_candidates = sorted_indices[:max(1, n_items // 4)]\n    random.shuffle(flip_candidates)\n    flip_count = random.randint(1, min(3, len(flip_candidates)))\n\n    for i in flip_candidates[:flip_count]:\n        if base_solution[i] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 2: Perform a random swap between two items (if possible)\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Check feasibility after swap\n            if (base_solution[i] == 1 and base_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif (base_solution[i] == 0 and base_solution[j] == 1 and\n                  current_weight + weight_lst[i] - weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3285702074002692,
            1.3605346977710724
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, then applies a hybrid local search that prioritizes flipping items with high marginal value-to-weight ratios (weighted 60% for value1 and 40% for value2) while ensuring feasibility, followed by a random swap between two items if feasible. The approach balances exploration (random selection and flipping) with exploitation (targeted marginal value optimization) to generate high-quality neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = current_obj[0]\n    current_value2 = current_obj[1]\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (with high marginal value-to-weight ratio)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = 0.6 * marginal_value1 + 0.4 * marginal_value2  # Weighted combination\n\n    # Sort items by combined marginal value (descending)\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Randomly select a subset of top items to flip\n    flip_candidates = sorted_indices[:max(1, n_items // 3)]\n    random.shuffle(flip_candidates)\n    flip_count = random.randint(1, min(4, len(flip_candidates)))\n\n    for i in flip_candidates[:flip_count]:\n        if base_solution[i] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 2: Perform a random swap between two items (if possible)\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Check feasibility after swap\n            if (base_solution[i] == 1 and base_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif (base_solution[i] == 0 and base_solution[j] == 1 and\n                  current_weight + weight_lst[i] - weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.44168295303494365,
            1.4135794341564178
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid metric combining marginal gains (60% weight) and dominance ranks (40% weight), then applies a tiered local search with three phases: (1) flipping high-value items with 70% probability, (2) swapping two items to improve balance, and (3) reintroducing frequently excluded items with 60% probability, all while ensuring feasibility through dynamic weight checks. The selection prioritizes solutions with high marginal value and low dominance rank, while the search adaptively explores different neighborhoods based on value, diversity, and exclusion patterns.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def dominance_rank(sol, obj):\n        count = 0\n        for (_, other_obj) in archive:\n            if (obj[0] >= other_obj[0] and obj[1] > other_obj[1]) or \\\n               (obj[0] > other_obj[0] and obj[1] >= other_obj[1]):\n                count += 1\n        return count\n\n    marginal_gains = []\n    dominance_ranks = []\n    for (sol, obj) in archive:\n        included = sol == 1\n        marginal_value1 = np.sum(value1_lst[included]) / (np.sum(weight_lst[included]) + 1e-6)\n        marginal_value2 = np.sum(value2_lst[included]) / (np.sum(weight_lst[included]) + 1e-6)\n        marginal_gains.append(marginal_value1 + marginal_value2)\n        dominance_ranks.append(dominance_rank(sol, obj))\n\n    max_marginal = max(marginal_gains) if marginal_gains else 1\n    max_rank = max(dominance_ranks) if dominance_ranks else 1\n\n    combined_scores = []\n    for i in range(len(archive)):\n        normalized_marginal = marginal_gains[i] / max_marginal if max_marginal > 0 else 0\n        normalized_rank = dominance_ranks[i] / max_rank if max_rank > 0 else 0\n        combined_scores.append(0.6 * normalized_marginal + 0.4 * normalized_rank)\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for tier in range(3):\n        if tier == 0:\n            combined_value = value1_lst + value2_lst\n            sorted_indices = np.argsort(combined_value)[::-1]\n\n            for i in sorted_indices[:max(1, len(sorted_indices) // 3)]:\n                if random.random() < 0.7:\n                    if new_solution[i] == 1:\n                        if current_weight - weight_lst[i] <= capacity:\n                            new_solution[i] = 0\n                            current_weight -= weight_lst[i]\n                    else:\n                        if current_weight + weight_lst[i] <= capacity:\n                            new_solution[i] = 1\n                            current_weight += weight_lst[i]\n\n        elif tier == 1:\n            if len(np.where(new_solution == 1)[0]) > 1:\n                for _ in range(min(3, len(new_solution))):\n                    i, j = random.sample(range(len(new_solution)), 2)\n                    if new_solution[i] != new_solution[j]:\n                        temp_weight = current_weight\n                        if new_solution[i] == 1:\n                            temp_weight -= weight_lst[i]\n                        else:\n                            temp_weight += weight_lst[i]\n                        if new_solution[j] == 1:\n                            temp_weight += weight_lst[j]\n                        else:\n                            temp_weight -= weight_lst[j]\n\n                        if temp_weight <= capacity:\n                            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                            current_weight = temp_weight\n\n        else:\n            exclusion_frequency = np.zeros(len(new_solution))\n            for (sol, _) in archive:\n                exclusion_frequency += (sol == 0)\n\n            sorted_indices = np.argsort(exclusion_frequency)[::-1]\n            for i in sorted_indices[:max(1, len(sorted_indices) // 4)]:\n                if new_solution[i] == 0 and random.random() < 0.6:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6128381996787529,
            3.085581749677658
        ]
    }
]