[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the product of its two objective values) and applies a hybrid local search strategy: it first tries a random item swap (if feasible) and then probabilistically flips items with low marginal contribution, ensuring feasibility by removing excess items if needed. The approach balances exploration (via random swaps and flips) and exploitation (focusing on high-potential solutions) while strictly enforcing capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential (product of objectives)\n    potentials = [obj[0] * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly swap two items (if feasible)\n    if n_items >= 2:\n        swap_indices = np.random.choice(n_items, 2, replace=False)\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            # Check feasibility\n            if new_solution[swap_indices[0]] == 1:\n                new_weight = current_weight - weight_lst[swap_indices[0]] + weight_lst[swap_indices[1]]\n            else:\n                new_weight = current_weight + weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]]\n            if new_weight <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Strategy 2: Probabilistic flip of items with low marginal contribution\n    for i in range(n_items):\n        if np.random.rand() < 0.2:  # 20% chance to flip\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight >= 0:  # Ensure non-negative weight (though capacity check is more important)\n                    new_solution[i] = 0\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility (in case of multiple changes)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = np.random.choice(included_items)\n            excess -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8969946250886272,
            2.1612739861011505
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted sum of normalized objectives (70% value1, 30% value2), then applies a hybrid local search combining probabilistic swaps, marginal contribution-based flips, and a greedy removal step to ensure feasibility. It dynamically balances exploration/exploitation based on archive size, with higher probabilities for marginal improvements and feasibility checks. The method prioritizes solutions with better combined objective scores while intelligently modifying them to improve both objectives while respecting capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives and compute combined scores\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-8)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-8)\n    combined_scores = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted sum\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Dynamic exploration/exploitation trade-off\n    exploration_prob = 0.5 + 0.5 * (1 - len(archive) / 100)  # Higher exploration for small archives\n\n    # Strategy 1: Probabilistic item swap with feasibility check\n    if np.random.rand() < exploration_prob and n_items >= 2:\n        swap_indices = np.random.choice(n_items, 2, replace=False)\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            # Check feasibility\n            delta = (weight_lst[swap_indices[1]] - weight_lst[swap_indices[0]]) if new_solution[swap_indices[0]] == 1 else (weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]])\n            if current_weight + delta <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Strategy 2: Marginal contribution-based flips\n    for i in range(n_items):\n        if np.random.rand() < 0.3:  # Higher probability than original\n            if new_solution[i] == 1:\n                # Check if removing improves both objectives\n                marginal1 = -value1_lst[i]\n                marginal2 = -value2_lst[i]\n                if marginal1 < 0 or marginal2 < 0:  # Negative marginal\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight >= 0:\n                        new_solution[i] = 0\n            else:\n                # Check if adding improves both objectives\n                marginal1 = value1_lst[i]\n                marginal2 = value2_lst[i]\n                if marginal1 > 0 and marginal2 > 0:  # Positive marginal\n                    new_weight = current_weight + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 1\n\n    # Strategy 3: Greedy removal for feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Sort items by weight/value ratio and remove until feasible\n        included_items = np.where(new_solution == 1)[0]\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        sorted_indices = included_items[np.argsort(ratios)]\n        excess = total_weight - capacity\n        for i in sorted_indices:\n            if excess <= 0:\n                break\n            excess -= weight_lst[i]\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9450039798002199,
            2.6820522248744965
        ]
    },
    {
        "algorithm": "The algorithm implements a diversity-aware selection strategy that prioritizes solutions with high potential for improvement, followed by a hybrid local search combining random flips (60% chance) for items already in the solution and a value-aware swap (40% chance) that intelligently selects high-value items to add while removing low-value items to maintain feasibility. The value-aware swap specifically targets items with top 40% combined value-to-weight ratios, ensuring both objectives are balanced.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (diversity-aware)\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with value-aware swap\n    if random.random() < 0.6:  # 60% chance for random flip\n        # Randomly flip items that could improve either objective\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            flip_idx = random.choice(candidates)\n            new_solution[flip_idx] = 0\n    else:  # 40% chance for value-aware swap\n        # Find items not in solution with high value ratios\n        not_in_solution = np.where(base_solution == 0)[0]\n        if len(not_in_solution) > 0:\n            # Calculate value ratios (value1/weight and value2/weight)\n            ratios1 = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n            ratios2 = value2_lst[not_in_solution] / weight_lst[not_in_solution]\n            combined_ratios = ratios1 + ratios2\n\n            # Select top 40% candidates by combined ratio\n            top_candidates = not_in_solution[np.argsort(combined_ratios)[-max(1, len(combined_ratios)//2):]]\n            if len(top_candidates) > 0:\n                swap_in = random.choice(top_candidates)\n\n                # Find items in solution with low value ratios to swap out\n                in_solution = np.where(base_solution == 1)[0]\n                if len(in_solution) > 0:\n                    ratios1_in = value1_lst[in_solution] / weight_lst[in_solution]\n                    ratios2_in = value2_lst[in_solution] / weight_lst[in_solution]\n                    combined_ratios_in = ratios1_in + ratios2_in\n                    swap_out = in_solution[np.argmin(combined_ratios_in)]\n\n                    # Perform swap if feasible\n                    if (np.sum(weight_lst[new_solution == 1]) - weight_lst[swap_out] + weight_lst[swap_in]) <= capacity:\n                        new_solution[swap_out] = 0\n                        new_solution[swap_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5493558789167777,
            1.034000277519226
        ]
    },
    {
        "algorithm": "The algorithm combines a diversity-aware selection strategy with a hybrid local search that prioritizes high-value items (based on combined objective ratios) while ensuring feasibility through dynamic adjustments and marginal contribution flipping. It intelligently balances exploration (via probabilistic greedy insertion and random flips) with exploitation (via value-aware replacements), dynamically adjusting the search based on item contributions and capacity constraints. The solution is refined by removing low-value items when necessary to maintain feasibility, ensuring high-quality neighbors across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with diversity-aware weighted random choice\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + r) for r in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and value ratios\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    combined_ratios = (value1_lst + value2_lst) / weight_lst\n\n    # Hybrid local search: probabilistic greedy insertion + value-aware replacement\n    if random.random() < 0.6:  # 60% chance for probabilistic greedy insertion\n        # Select items not in solution with top 40% combined ratios\n        not_in_solution = np.where(base_solution == 0)[0]\n        if len(not_in_solution) > 0:\n            top_candidates = not_in_solution[np.argsort(combined_ratios[not_in_solution])[-max(1, len(not_in_solution)//2):]]\n            if len(top_candidates) > 0:\n                insert_idx = random.choice(top_candidates)\n                if current_weight + weight_lst[insert_idx] <= capacity:\n                    new_solution[insert_idx] = 1\n    else:  # 40% chance for value-aware replacement\n        # Replace low-value items with high-value items when feasible\n        in_solution = np.where(base_solution == 1)[0]\n        if len(in_solution) > 0:\n            # Find low-value items (bottom 30%)\n            low_value_items = in_solution[np.argsort(combined_ratios[in_solution])[:max(1, len(in_solution)//3)]]\n            if len(low_value_items) > 0:\n                replace_out = random.choice(low_value_items)\n                not_in_solution = np.where(base_solution == 0)[0]\n                if len(not_in_solution) > 0:\n                    # Find high-value items (top 30%)\n                    high_value_items = not_in_solution[np.argsort(combined_ratios[not_in_solution])[-max(1, len(not_in_solution)//3):]]\n                    if len(high_value_items) > 0:\n                        replace_in = random.choice(high_value_items)\n                        if (current_weight - weight_lst[replace_out] + weight_lst[replace_in]) <= capacity:\n                            new_solution[replace_out] = 0\n                            new_solution[replace_in] = 1\n\n    # Dynamic marginal contribution flip (20% chance for each item)\n    for i in range(len(weight_lst)):\n        if random.random() < 0.2:\n            if new_solution[i] == 1:\n                # Calculate marginal contribution\n                marginal = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                threshold = np.mean(combined_ratios[new_solution == 1]) if np.sum(new_solution) > 0 else 0\n                if marginal < threshold:\n                    new_solution[i] = 0\n            else:\n                if (current_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        excess = total_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            included_items = np.where(new_solution == 1)[0]\n            remove_idx = included_items[np.argmin((value1_lst + value2_lst)[included_items] / weight_lst[included_items])]\n            excess -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8654628279882872,
            4.212311625480652
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective score (60% value1, 40% value2), then applies a hybrid local search combining probabilistic swaps (60% chance) and marginal contribution-based flips (40% chance), while ensuring feasibility through a greedy removal step. It dynamically balances exploration/exploitation based on archive size, prioritizing high-value items while intelligently modifying solutions to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Weighted objective selection (60% value1, 40% value2)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-8)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-8)\n    combined_scores = 0.6 * norm_obj1 + 0.4 * norm_obj2\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Dynamic exploration/exploitation trade-off\n    exploration_prob = 0.5 + 0.5 * (1 - len(archive) / 100)\n\n    # Strategy 1: Probabilistic swap with feasibility check (60% chance)\n    if np.random.rand() < 0.6 * exploration_prob and n_items >= 2:\n        swap_indices = np.random.choice(n_items, 2, replace=False)\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            delta = (weight_lst[swap_indices[1]] - weight_lst[swap_indices[0]]) if new_solution[swap_indices[0]] == 1 else (weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]])\n            if current_weight + delta <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Strategy 2: Marginal contribution-based flips (40% chance)\n    for i in range(n_items):\n        if np.random.rand() < 0.4:\n            if new_solution[i] == 1:\n                marginal1 = -value1_lst[i]\n                marginal2 = -value2_lst[i]\n                if marginal1 < 0 or marginal2 < 0:\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight >= 0:\n                        new_solution[i] = 0\n            else:\n                marginal1 = value1_lst[i]\n                marginal2 = value2_lst[i]\n                if marginal1 > 0 and marginal2 > 0:\n                    new_weight = current_weight + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 1\n\n    # Strategy 3: Greedy removal for feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        sorted_indices = included_items[np.argsort(ratios)]\n        excess = total_weight - capacity\n        for i in sorted_indices:\n            if excess <= 0:\n                break\n            excess -= weight_lst[i]\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.894846266927728,
            5.222519427537918
        ]
    },
    {
        "algorithm": "The heuristic algorithm prioritizes solutions with high potential for improvement through a diversity-aware selection strategy, then applies a hybrid local search combining random flips (70% chance) for items already in the solution and a value-aware swap (30% chance) that intelligently selects high-value items to add while removing low-value items to maintain feasibility. The value-aware swap specifically targets items with top 30% combined value-to-weight ratios, ensuring both objectives are balanced.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (diversity-aware)\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with value-aware swap\n    if random.random() < 0.7:  # 70% chance for random flip\n        # Randomly flip items that could improve either objective\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            flip_idx = random.choice(candidates)\n            new_solution[flip_idx] = 0\n    else:  # 30% chance for value-aware swap\n        # Find items not in solution with high value ratios\n        not_in_solution = np.where(base_solution == 0)[0]\n        if len(not_in_solution) > 0:\n            # Calculate value ratios (value1/weight and value2/weight)\n            ratios1 = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n            ratios2 = value2_lst[not_in_solution] / weight_lst[not_in_solution]\n            combined_ratios = ratios1 + ratios2\n\n            # Select top 30% candidates by combined ratio\n            top_candidates = not_in_solution[np.argsort(combined_ratios)[-max(1, len(combined_ratios)//3):]]\n            if len(top_candidates) > 0:\n                swap_in = random.choice(top_candidates)\n\n                # Find items in solution with low value ratios to swap out\n                in_solution = np.where(base_solution == 1)[0]\n                if len(in_solution) > 0:\n                    ratios1_in = value1_lst[in_solution] / weight_lst[in_solution]\n                    ratios2_in = value2_lst[in_solution] / weight_lst[in_solution]\n                    combined_ratios_in = ratios1_in + ratios2_in\n                    swap_out = in_solution[np.argmin(combined_ratios_in)]\n\n                    # Perform swap if feasible\n                    if (np.sum(weight_lst[new_solution == 1]) - weight_lst[swap_out] + weight_lst[swap_in]) <= capacity:\n                        new_solution[swap_out] = 0\n                        new_solution[swap_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4075866881488455,
            1.4317869246006012
        ]
    },
    {
        "algorithm": "The algorithm selects the highest-sum-objective solution from the archive, then applies a hybrid local search: greedily adds the most valuable item (if feasible) and probabilistically removes low-marginal-contribution items, ensuring feasibility by iteratively removing the least valuable items if capacity is exceeded. The marginal contribution is calculated as the sum of both objectives divided by weight, prioritizing items that improve both objectives efficiently. The algorithm balances exploration (random removal) and exploitation (greedy addition) while strictly maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of objectives\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Greedily add the highest marginal contribution per unit weight item (if feasible)\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate marginal contribution per unit weight\n        marginal_contributions = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        best_add_idx = excluded_items[np.argmax(marginal_contributions)]\n        if weight_lst[best_add_idx] <= (capacity - current_weight):\n            new_solution[best_add_idx] = 1\n            current_weight += weight_lst[best_add_idx]\n\n    # Strategy 2: Probabilistic removal of items with low marginal contribution\n    included_items = np.where(new_solution == 1)[0]\n    if len(included_items) > 0:\n        # Calculate marginal contribution per unit weight\n        marginal_contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        for i in included_items:\n            if np.random.rand() < 0.3:  # 30% chance to consider removal\n                if marginal_contributions[included_items == i][0] < np.median(marginal_contributions):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    # Ensure feasibility (in case of multiple changes)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest marginal contribution per unit weight until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            marginal_contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            remove_idx = included_items[np.argmin(marginal_contributions)]\n            total_weight -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.596333468860454,
            6.946243166923523
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using crowding distance to prioritize diverse, high-potential candidates, then applies a hybrid local search: a 60% chance of a biased random flip (removing low-contribution items and adding high-contribution ones) or a 40% chance of a value-aware swap (exchanging low-contribution items with high-contribution ones), ensuring feasibility by dynamically checking capacity constraints. The method balances exploration (diverse selection) and exploitation (targeted improvements) across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate crowding distances for all solutions in archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (\n                objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]\n            ) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: biased random flip or value-aware swap\n    if random.random() < 0.6:  # 60% chance for biased random flip\n        # Calculate marginal contribution ratios for all items\n        in_solution = np.where(base_solution == 1)[0]\n        not_in_solution = np.where(base_solution == 0)[0]\n\n        # Calculate marginal contribution for items in solution\n        if len(in_solution) > 0:\n            marginal_ratios_in = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n            # Select item with lowest marginal ratio to flip out\n            flip_idx = in_solution[np.argmin(marginal_ratios_in)]\n            new_solution[flip_idx] = 0\n\n        # Calculate marginal contribution for items not in solution\n        if len(not_in_solution) > 0:\n            marginal_ratios_out = (value1_lst[not_in_solution] + value2_lst[not_in_solution]) / weight_lst[not_in_solution]\n            # Select top 20% candidates by marginal ratio\n            top_candidates = not_in_solution[np.argsort(marginal_ratios_out)[-max(1, len(marginal_ratios_out)//5):]]\n            if len(top_candidates) > 0 and current_weight + weight_lst[top_candidates[0]] <= capacity:\n                flip_in = random.choice(top_candidates)\n                new_solution[flip_in] = 1\n    else:  # 40% chance for value-aware swap\n        # Find items not in solution with high value ratios\n        not_in_solution = np.where(base_solution == 0)[0]\n        if len(not_in_solution) > 0:\n            # Calculate combined value ratios\n            combined_ratios = (value1_lst[not_in_solution] + value2_lst[not_in_solution]) / weight_lst[not_in_solution]\n\n            # Select top 25% candidates by combined ratio\n            top_candidates = not_in_solution[np.argsort(combined_ratios)[-max(1, len(combined_ratios)//4):]]\n            if len(top_candidates) > 0:\n                swap_in = random.choice(top_candidates)\n\n                # Find items in solution with low value ratios to swap out\n                in_solution = np.where(base_solution == 1)[0]\n                if len(in_solution) > 0:\n                    combined_ratios_in = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n                    swap_out = in_solution[np.argmin(combined_ratios_in)]\n\n                    # Perform swap if feasible\n                    if (current_weight - weight_lst[swap_out] + weight_lst[swap_in]) <= capacity:\n                        new_solution[swap_out] = 0\n                        new_solution[swap_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.48667215636616656,
            5.513145267963409
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a promising solution from the archive based on normalized objective values, then applies a hybrid local search combining item swaps and random flips, ensuring feasibility by checking weight constraints at each step. It prioritizes solutions with higher combined normalized objectives and intelligently explores neighbors by considering both item removals/additions and random flips, accepting moves that improve at least one objective. The algorithm balances exploration and exploitation by focusing on a small subset of items for swaps and controlled random flips.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of normalized objectives)\n    normalized_scores = []\n    max_value1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_value2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_value1 if max_value1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_value2 if max_value2 > 0 else 0.0\n        normalized_scores.append(norm_obj1 + norm_obj2)\n\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate neighbor using hybrid local search\n    # Step 1: Randomly select a subset of items to consider for swaps\n    num_items = len(weight_lst)\n    subset_size = min(5, num_items)  # Consider up to 5 items for swaps\n    swap_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Perform item swaps while maintaining feasibility\n    for i in swap_indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                # After removing, try adding other items\n                for j in swap_indices:\n                    if j != i and new_solution[j] == 0:\n                        temp_solution2 = new_solution.copy()\n                        temp_solution2[j] = 1\n                        temp_weight2 = np.sum(weight_lst[temp_solution2 == 1])\n\n                        if temp_weight2 <= capacity:\n                            # Accept the move if it improves at least one objective\n                            current_value1 = np.sum(value1_lst[new_solution == 1])\n                            current_value2 = np.sum(value2_lst[new_solution == 1])\n                            new_value1 = np.sum(value1_lst[temp_solution2 == 1])\n                            new_value2 = np.sum(value2_lst[temp_solution2 == 1])\n\n                            if (new_value1 > current_value1 or new_value2 > current_value2):\n                                new_solution = temp_solution2\n                                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 3: Perform a novel neighborhood exploration (randomly flip a small number of items)\n    flip_count = min(2, num_items)  # Flip up to 2 items\n    flip_indices = random.sample(range(num_items), flip_count)\n\n    for i in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[i] = 1 - temp_solution[i]\n        temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n        if temp_weight <= capacity:\n            # Accept the flip if it improves at least one objective\n            current_value1 = np.sum(value1_lst[new_solution == 1])\n            current_value2 = np.sum(value2_lst[new_solution == 1])\n            new_value1 = np.sum(value1_lst[temp_solution == 1])\n            new_value2 = np.sum(value2_lst[temp_solution == 1])\n\n            if (new_value1 > current_value1 or new_value2 > current_value2):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3141328391655218,
            3.2796249389648438
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential and structural diversity\n    potentials = []\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate diversity score (Hamming distance to all other solutions)\n        diversity = sum(np.sum(np.abs(sol - other_sol)) for other_sol, _ in archive) / len(archive)\n        # Combine with objective potential (geometric mean)\n        potential = (obj[0] * obj[1]) ** 0.5 * diversity\n        potentials.append(potential)\n\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Value-balanced insertion operator\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Calculate value ratios and balance\n        ratios1 = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n        ratios2 = value2_lst[not_in_solution] / weight_lst[not_in_solution]\n        balance = ratios1 / (ratios2 + 1e-6)  # Avoid division by zero\n\n        # Select items with balanced value ratios\n        balanced_candidates = not_in_solution[np.abs(balance - 1) < 0.5]  # Within 50% balance\n        if len(balanced_candidates) > 0:\n            insert_idx = np.random.choice(balanced_candidates)\n            if current_weight + weight_lst[insert_idx] <= capacity:\n                new_solution[insert_idx] = 1\n                current_weight += weight_lst[insert_idx]\n\n    # Objective-biased flip mechanism\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                # Calculate objective improvement potential\n                obj1_improvement = -value1_lst[i]\n                obj2_improvement = -value2_lst[i]\n                # Higher probability to flip if improves weaker objective\n                flip_prob = 0.5 + 0.5 * (min(archive[selected_idx][1]) / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6))\n                if np.random.rand() < flip_prob:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Greedy repair if exceeded capacity\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            # Remove items with lowest value-to-weight ratio\n            in_solution = np.where(new_solution == 1)[0]\n            ratios = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n            remove_idx = in_solution[np.argmin(ratios)]\n            excess -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4767170977757553,
            8.60960704088211
        ]
    }
]