[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the product of its two objective values) and applies a hybrid local search strategy: it first tries a random item swap (if feasible) and then probabilistically flips items with low marginal contribution, ensuring feasibility by removing excess items if needed. The approach balances exploration (via random swaps and flips) and exploitation (focusing on high-potential solutions) while strictly enforcing capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential (product of objectives)\n    potentials = [obj[0] * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly swap two items (if feasible)\n    if n_items >= 2:\n        swap_indices = np.random.choice(n_items, 2, replace=False)\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            # Check feasibility\n            if new_solution[swap_indices[0]] == 1:\n                new_weight = current_weight - weight_lst[swap_indices[0]] + weight_lst[swap_indices[1]]\n            else:\n                new_weight = current_weight + weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]]\n            if new_weight <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Strategy 2: Probabilistic flip of items with low marginal contribution\n    for i in range(n_items):\n        if np.random.rand() < 0.2:  # 20% chance to flip\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight >= 0:  # Ensure non-negative weight (though capacity check is more important)\n                    new_solution[i] = 0\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility (in case of multiple changes)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = np.random.choice(included_items)\n            excess -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8969946250886272,
            2.1612739861011505
        ]
    },
    {
        "algorithm": "The heuristic algorithm prioritizes solutions with high potential for improvement through a diversity-aware selection strategy, then applies a hybrid local search combining random flips (70% chance) for items already in the solution and a value-aware swap (30% chance) that intelligently selects high-value items to add while removing low-value items to maintain feasibility. The value-aware swap specifically targets items with top 30% combined value-to-weight ratios, ensuring both objectives are balanced.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (diversity-aware)\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with value-aware swap\n    if random.random() < 0.7:  # 70% chance for random flip\n        # Randomly flip items that could improve either objective\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            flip_idx = random.choice(candidates)\n            new_solution[flip_idx] = 0\n    else:  # 30% chance for value-aware swap\n        # Find items not in solution with high value ratios\n        not_in_solution = np.where(base_solution == 0)[0]\n        if len(not_in_solution) > 0:\n            # Calculate value ratios (value1/weight and value2/weight)\n            ratios1 = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n            ratios2 = value2_lst[not_in_solution] / weight_lst[not_in_solution]\n            combined_ratios = ratios1 + ratios2\n\n            # Select top 30% candidates by combined ratio\n            top_candidates = not_in_solution[np.argsort(combined_ratios)[-max(1, len(combined_ratios)//3):]]\n            if len(top_candidates) > 0:\n                swap_in = random.choice(top_candidates)\n\n                # Find items in solution with low value ratios to swap out\n                in_solution = np.where(base_solution == 1)[0]\n                if len(in_solution) > 0:\n                    ratios1_in = value1_lst[in_solution] / weight_lst[in_solution]\n                    ratios2_in = value2_lst[in_solution] / weight_lst[in_solution]\n                    combined_ratios_in = ratios1_in + ratios2_in\n                    swap_out = in_solution[np.argmin(combined_ratios_in)]\n\n                    # Perform swap if feasible\n                    if (np.sum(weight_lst[new_solution == 1]) - weight_lst[swap_out] + weight_lst[swap_in]) <= capacity:\n                        new_solution[swap_out] = 0\n                        new_solution[swap_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4075866881488455,
            1.4317869246006012
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted sum of normalized objectives (70% value1, 30% value2), then applies a hybrid local search combining probabilistic swaps, marginal contribution-based flips, and a greedy removal step to ensure feasibility. It dynamically balances exploration/exploitation based on archive size, with higher probabilities for marginal improvements and feasibility checks. The method prioritizes solutions with better combined objective scores while intelligently modifying them to improve both objectives while respecting capacity constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives and compute combined scores\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-8)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-8)\n    combined_scores = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted sum\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Dynamic exploration/exploitation trade-off\n    exploration_prob = 0.5 + 0.5 * (1 - len(archive) / 100)  # Higher exploration for small archives\n\n    # Strategy 1: Probabilistic item swap with feasibility check\n    if np.random.rand() < exploration_prob and n_items >= 2:\n        swap_indices = np.random.choice(n_items, 2, replace=False)\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            # Check feasibility\n            delta = (weight_lst[swap_indices[1]] - weight_lst[swap_indices[0]]) if new_solution[swap_indices[0]] == 1 else (weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]])\n            if current_weight + delta <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Strategy 2: Marginal contribution-based flips\n    for i in range(n_items):\n        if np.random.rand() < 0.3:  # Higher probability than original\n            if new_solution[i] == 1:\n                # Check if removing improves both objectives\n                marginal1 = -value1_lst[i]\n                marginal2 = -value2_lst[i]\n                if marginal1 < 0 or marginal2 < 0:  # Negative marginal\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight >= 0:\n                        new_solution[i] = 0\n            else:\n                # Check if adding improves both objectives\n                marginal1 = value1_lst[i]\n                marginal2 = value2_lst[i]\n                if marginal1 > 0 and marginal2 > 0:  # Positive marginal\n                    new_weight = current_weight + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 1\n\n    # Strategy 3: Greedy removal for feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Sort items by weight/value ratio and remove until feasible\n        included_items = np.where(new_solution == 1)[0]\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        sorted_indices = included_items[np.argsort(ratios)]\n        excess = total_weight - capacity\n        for i in sorted_indices:\n            if excess <= 0:\n                break\n            excess -= weight_lst[i]\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9450039798002199,
            2.6820522248744965
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a promising solution from the archive based on normalized objective values, then applies a hybrid local search combining item swaps and random flips, ensuring feasibility by checking weight constraints at each step. It prioritizes solutions with higher combined normalized objectives and intelligently explores neighbors by considering both item removals/additions and random flips, accepting moves that improve at least one objective. The algorithm balances exploration and exploitation by focusing on a small subset of items for swaps and controlled random flips.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of normalized objectives)\n    normalized_scores = []\n    max_value1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_value2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_value1 if max_value1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_value2 if max_value2 > 0 else 0.0\n        normalized_scores.append(norm_obj1 + norm_obj2)\n\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate neighbor using hybrid local search\n    # Step 1: Randomly select a subset of items to consider for swaps\n    num_items = len(weight_lst)\n    subset_size = min(5, num_items)  # Consider up to 5 items for swaps\n    swap_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Perform item swaps while maintaining feasibility\n    for i in swap_indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                # After removing, try adding other items\n                for j in swap_indices:\n                    if j != i and new_solution[j] == 0:\n                        temp_solution2 = new_solution.copy()\n                        temp_solution2[j] = 1\n                        temp_weight2 = np.sum(weight_lst[temp_solution2 == 1])\n\n                        if temp_weight2 <= capacity:\n                            # Accept the move if it improves at least one objective\n                            current_value1 = np.sum(value1_lst[new_solution == 1])\n                            current_value2 = np.sum(value2_lst[new_solution == 1])\n                            new_value1 = np.sum(value1_lst[temp_solution2 == 1])\n                            new_value2 = np.sum(value2_lst[temp_solution2 == 1])\n\n                            if (new_value1 > current_value1 or new_value2 > current_value2):\n                                new_solution = temp_solution2\n                                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 3: Perform a novel neighborhood exploration (randomly flip a small number of items)\n    flip_count = min(2, num_items)  # Flip up to 2 items\n    flip_indices = random.sample(range(num_items), flip_count)\n\n    for i in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[i] = 1 - temp_solution[i]\n        temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n        if temp_weight <= capacity:\n            # Accept the flip if it improves at least one objective\n            current_value1 = np.sum(value1_lst[new_solution == 1])\n            current_value2 = np.sum(value2_lst[new_solution == 1])\n            new_value1 = np.sum(value1_lst[temp_solution == 1])\n            new_value2 = np.sum(value2_lst[temp_solution == 1])\n\n            if (new_value1 > current_value1 or new_value2 > current_value2):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3141328391655218,
            3.2796249389648438
        ]
    },
    {
        "algorithm": "The algorithm selects the highest-sum-objective solution from the archive, then applies a hybrid local search: greedily adds the most valuable item (if feasible) and probabilistically removes low-marginal-contribution items, ensuring feasibility by iteratively removing the least valuable items if capacity is exceeded. The marginal contribution is calculated as the sum of both objectives divided by weight, prioritizing items that improve both objectives efficiently. The algorithm balances exploration (random removal) and exploitation (greedy addition) while strictly maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest sum of objectives\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Greedily add the highest marginal contribution per unit weight item (if feasible)\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate marginal contribution per unit weight\n        marginal_contributions = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        best_add_idx = excluded_items[np.argmax(marginal_contributions)]\n        if weight_lst[best_add_idx] <= (capacity - current_weight):\n            new_solution[best_add_idx] = 1\n            current_weight += weight_lst[best_add_idx]\n\n    # Strategy 2: Probabilistic removal of items with low marginal contribution\n    included_items = np.where(new_solution == 1)[0]\n    if len(included_items) > 0:\n        # Calculate marginal contribution per unit weight\n        marginal_contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        for i in included_items:\n            if np.random.rand() < 0.3:  # 30% chance to consider removal\n                if marginal_contributions[included_items == i][0] < np.median(marginal_contributions):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    # Ensure feasibility (in case of multiple changes)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest marginal contribution per unit weight until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            marginal_contributions = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            remove_idx = included_items[np.argmin(marginal_contributions)]\n            total_weight -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.596333468860454,
            6.946243166923523
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive by prioritizing those with high combined marginal gains in both objectives, then applies a hybrid local search that intelligently adds high-marginal items, removes low-marginal items, and performs biased random swaps to generate a feasible neighbor solution while maintaining diversity. The algorithm emphasizes both objectives equally by combining their marginal utilities and balances exploration (random swaps) with exploitation (targeted item additions/removals).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high marginal gains in both objectives\n    selected_idx = np.random.choice(len(archive), p=np.array([(obj[0] + obj[1]) / (sum(weight_lst * sol) + 1e-6) for sol, obj in archive]) / sum((obj[0] + obj[1]) / (sum(weight_lst * sol) + 1e-6) for sol, obj in archive))\n    base_solution, base_obj = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal utility ratios for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n\n    # Hybrid local search: random swaps with bias toward high marginal utility items\n    current_weight = sum(weight_lst * new_solution)\n    available_items = np.where(new_solution == 0)[0]\n    selected_items = np.where(new_solution == 1)[0]\n\n    # Try to add one high-marginal item if possible\n    if len(available_items) > 0:\n        candidate_items = available_items[np.argsort(combined_marginal[available_items])[-min(5, len(available_items)):]]\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n\n    # Try to remove one low-marginal item if possible\n    if len(selected_items) > 0:\n        candidate_items = selected_items[np.argsort(combined_marginal[selected_items])[:min(5, len(selected_items))]]\n        for item in candidate_items:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n    # Randomly swap 1-3 items if no better moves found\n    if np.random.rand() < 0.5:\n        swap_count = np.random.randint(1, min(4, len(selected_items) + len(available_items)))\n        for _ in range(swap_count):\n            if len(available_items) > 0 and len(selected_items) > 0:\n                add_item = np.random.choice(available_items)\n                remove_item = np.random.choice(selected_items)\n                if current_weight - weight_lst[remove_item] + weight_lst[add_item] <= capacity:\n                    new_solution[remove_item] = 0\n                    new_solution[add_item] = 1\n                    current_weight = current_weight - weight_lst[remove_item] + weight_lst[add_item]\n\n    return new_solution\n\n",
        "score": [
            -0.31312016538162557,
            8.159506738185883
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential and structural diversity\n    potentials = []\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate diversity score (Hamming distance to all other solutions)\n        diversity = sum(np.sum(np.abs(sol - other_sol)) for other_sol, _ in archive) / len(archive)\n        # Combine with objective potential (geometric mean)\n        potential = (obj[0] * obj[1]) ** 0.5 * diversity\n        potentials.append(potential)\n\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Value-balanced insertion operator\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Calculate value ratios and balance\n        ratios1 = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n        ratios2 = value2_lst[not_in_solution] / weight_lst[not_in_solution]\n        balance = ratios1 / (ratios2 + 1e-6)  # Avoid division by zero\n\n        # Select items with balanced value ratios\n        balanced_candidates = not_in_solution[np.abs(balance - 1) < 0.5]  # Within 50% balance\n        if len(balanced_candidates) > 0:\n            insert_idx = np.random.choice(balanced_candidates)\n            if current_weight + weight_lst[insert_idx] <= capacity:\n                new_solution[insert_idx] = 1\n                current_weight += weight_lst[insert_idx]\n\n    # Objective-biased flip mechanism\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                # Calculate objective improvement potential\n                obj1_improvement = -value1_lst[i]\n                obj2_improvement = -value2_lst[i]\n                # Higher probability to flip if improves weaker objective\n                flip_prob = 0.5 + 0.5 * (min(archive[selected_idx][1]) / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6))\n                if np.random.rand() < flip_prob:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Greedy repair if exceeded capacity\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            # Remove items with lowest value-to-weight ratio\n            in_solution = np.where(new_solution == 1)[0]\n            ratios = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n            remove_idx = in_solution[np.argmin(ratios)]\n            excess -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4767170977757553,
            8.60960704088211
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive based on combined objective ratios, then applies a hybrid local search combining probabilistic flips (70% chance) for low-marginal items and value-aware swaps (30% chance) for top 30% high-value items, while ensuring feasibility through excess removal of lowest-value items. It prioritizes items with high combined value-to-weight ratios in both objectives and intelligently handles feasibility constraints by removing least valuable items when necessary.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective ratio\n    combined_ratios = [(obj[0] + obj[1]) / np.sum(weight_lst[sol == 1]) if np.sum(weight_lst[sol == 1]) > 0 else 0\n                      for sol, obj in archive]\n    selected_idx = np.argmax(combined_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 70% probabilistic flip, 30% value-aware swap\n    if np.random.rand() < 0.7:  # Probabilistic flip\n        # Flip items with low marginal contribution\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            # Calculate marginal contribution (value/weight)\n            marginal1 = value1_lst[in_solution] / weight_lst[in_solution]\n            marginal2 = value2_lst[in_solution] / weight_lst[in_solution]\n            combined_marginal = marginal1 + marginal2\n            # Select item with lowest marginal contribution\n            flip_idx = in_solution[np.argmin(combined_marginal)]\n            new_solution[flip_idx] = 0\n    else:  # Value-aware swap\n        # Find top 30% items not in solution by combined value/weight\n        not_in_solution = np.where(new_solution == 0)[0]\n        if len(not_in_solution) > 0:\n            ratios1 = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n            ratios2 = value2_lst[not_in_solution] / weight_lst[not_in_solution]\n            combined_ratios = ratios1 + ratios2\n            top_candidates = not_in_solution[np.argsort(combined_ratios)[-max(1, len(combined_ratios)//3):]]\n\n            if len(top_candidates) > 0:\n                swap_in = np.random.choice(top_candidates)\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                available_weight = capacity - current_weight\n\n                # Find item to remove with lowest value/weight\n                in_solution = np.where(new_solution == 1)[0]\n                if len(in_solution) > 0:\n                    ratios_in1 = value1_lst[in_solution] / weight_lst[in_solution]\n                    ratios_in2 = value2_lst[in_solution] / weight_lst[in_solution]\n                    combined_ratios_in = ratios_in1 + ratios_in2\n                    swap_out = in_solution[np.argmin(combined_ratios_in)]\n\n                    # Check if swap is feasible\n                    if (weight_lst[swap_in] <= available_weight + weight_lst[swap_out]):\n                        new_solution[swap_out] = 0\n                        new_solution[swap_in] = 1\n\n    # Ensure feasibility (remove excess items if needed)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        excess = total_weight - capacity\n        while excess > 0:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Remove item with lowest value/weight ratio\n            ratios1 = value1_lst[included_items] / weight_lst[included_items]\n            ratios2 = value2_lst[included_items] / weight_lst[included_items]\n            combined_ratios = ratios1 + ratios2\n            remove_idx = included_items[np.argmin(combined_ratios)]\n            excess -= weight_lst[remove_idx]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.45181926809271505,
            8.257795572280884
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a score combining its objective values and penalizing near-full solutions, then applies a hybrid local search combining random flips, guided swaps prioritizing high-value items, and occasional random perturbations to explore diverse neighborhoods while maintaining feasibility. The selection prioritizes solutions with higher combined objective values (value1 + value2), while the local search uses value-to-weight ratios to guide swaps and maintains feasibility through capacity checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, obj in archive:\n        # Score based on objective values (higher is better)\n        score = obj[0] + obj[1]\n        # Penalize solutions that are too close to the boundary\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight >= 0.9 * capacity:\n            score *= 0.5  # Reduce score for near-full solutions\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with probability based on current solution)\n    # 2. Perform a guided swap of two items (prioritizing high-value items)\n    # 3. Apply a small random perturbation to escape local optima\n\n    # Step 2.1: Random flip\n    flip_prob = 0.3  # Probability of flipping each item\n    for i in range(num_items):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # Try removing the item (check feasibility)\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Try adding the item (check feasibility)\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2.2: Guided swap\n    # Find the two items with the highest value-to-weight ratios\n    value_ratios1 = value1_lst / weight_lst\n    value_ratios2 = value2_lst / weight_lst\n    combined_ratios = value_ratios1 + value_ratios2\n\n    # Get indices of items currently in the solution\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    if len(in_solution) > 0 and len(out_solution) > 0:\n        # Find the item to remove (lowest combined ratio in solution)\n        remove_idx = in_solution[np.argmin(combined_ratios[in_solution])]\n        # Find the item to add (highest combined ratio not in solution)\n        add_idx = out_solution[np.argmax(combined_ratios[out_solution])]\n\n        # Check if swap is feasible\n        if (np.sum(weight_lst * new_solution) - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Step 2.3: Small random perturbation\n    if random.random() < 0.2:  # 20% chance of perturbation\n        # Randomly select 2-5 items to flip\n        num_perturb = random.randint(2, min(5, num_items))\n        perturb_indices = random.sample(range(num_items), num_perturb)\n\n        for i in perturb_indices:\n            if new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.39683867612639856,
            10.85266786813736
        ]
    }
]