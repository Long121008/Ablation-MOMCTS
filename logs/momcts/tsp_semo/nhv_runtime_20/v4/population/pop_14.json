[
    {
        "algorithm": "The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.925254721365585,
            0.20645654201507568
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9481146534985749,
            0.2827843427658081
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5451367216570713,
            0.20511656999588013
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.94438110626965,
            0.2759231925010681
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9756411093506061,
            0.6009257435798645
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9020578250800095,
            0.21142607927322388
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9144468290000943,
            0.25475645065307617
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9415771459065421,
            2.1370423436164856
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8834292092715244,
            0.22790420055389404
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive (prioritizing those with high normalized objective values) and applies either a constrained edge-swap (70% chance) or a partial tour reversal (30% chance) to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The edge-swap focuses on improving both objectives simultaneously, while the partial reversal allows exploration of alternative tour segments. The solution is reverted to the original if duplicates are detected, maintaining validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.893215863330194,
            0.2730424404144287
        ]
    }
]