[
    {
        "algorithm": "The algorithm selects a solution from the archive using hypervolume-based prioritization, then applies adaptive segment reinsertion and a cross-dimensional edge exchange operator to generate a neighbor solution while ensuring feasibility. It dynamically balances exploration and exploitation, with a fallback to randomized shuffling if feasibility is compromised, and explicitly considers both objective spaces during local search. The key design ideas are prioritizing Pareto-efficient regions, space-aware segment reinsertion, and cross-dimensional edge exchange, all while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge exchange\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Swap edges between i and j in both spaces\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8137926732783934,
            0.07694697380065918
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, then applies a hybrid local search combining adaptive segment reinsertion with cross-dimensional 3-opt moves, prioritizing Pareto-efficient edge exchanges while ensuring feasibility through validation and fallback mechanisms. It focuses on improving solutions by intelligently reordering segments and evaluating alternative configurations in both objective spaces, with a fallback to random shuffling if feasibility is compromised. The selection is hypervolume-based, while the local search emphasizes cross-dimensional optimization and segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional 3-opt\n    if n > 3:\n        x, y, z = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[x:y]\n        segment2 = new_solution[y:z]\n\n        # Evaluate all possible segment orderings and reversals\n        combinations = [\n            (np.concatenate([segment1, segment2]), False),\n            (np.concatenate([segment2, segment1]), False),\n            (np.concatenate([segment1[::-1], segment2]), True),\n            (np.concatenate([segment2, segment1[::-1]]), True)\n        ]\n\n        best_cost = float('inf')\n        best_combination = None\n        for comb, reversed_flag in combinations:\n            # Calculate cost for the new combination\n            cost1 = distance_matrix_1[new_solution[x-1], comb[0]] + distance_matrix_1[comb[-1], new_solution[z]]\n            cost2 = distance_matrix_2[new_solution[x-1], comb[0]] + distance_matrix_2[comb[-1], new_solution[z]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_combination = comb\n\n        if best_combination is not None:\n            new_solution = np.concatenate([new_solution[:x], best_combination, new_solution[z:]])\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9722888250495916,
            0.09567373991012573
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, applies adaptive segment reinsertion and cross-dimensional edge swaps to generate a neighbor, prioritizing Pareto-efficient edge exchanges in both objective spaces while ensuring feasibility through validation and fallback mechanisms. It emphasizes intelligent solution selection and hybrid local search with explicit multi-objective considerations, balancing exploration and exploitation in the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge swaps\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Evaluate edge swaps in both dimensions\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9674406834015334,
            0.0788697600364685
        ]
    },
    {
        "algorithm": "The algorithm combines hypervolume-based selection with a hybrid local search operator that alternates between adaptive segment reinsertion, cross-dimensional edge swaps, and dynamic segment reversal, while ensuring feasibility through strict validation and fallback mechanisms. It prioritizes nondominated solutions by maximizing hypervolume contributions, then applies segment reinsertion to explore new configurations, followed by edge swaps to exploit local improvements, and finally uses dynamic reversals to diversify the search. The operator dynamically adjusts segment sizes and reversal frequencies based on solution quality, balancing exploration and exploitation while guaranteeing feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion with dynamic segment size\n    segment_size = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    a = np.random.randint(0, n - segment_size)\n    segment = base_solution[a:a+segment_size]\n    insert_pos = np.random.randint(0, n - segment_size)\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge swaps with dynamic neighborhood size\n    neighborhood_size = min(5, n // 2)\n    for _ in range(2):\n        x, y = sorted(np.random.choice(n, size=2, replace=False))\n        if y - x >= neighborhood_size:\n            continue\n\n        # Evaluate all possible edge swaps in the neighborhood\n        best_cost = float('inf')\n        best_swap = None\n        for i in range(x, y):\n            for j in range(i+1, min(i+neighborhood_size, y)):\n                # Try swapping edges (i, i+1) and (j, j+1)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n                # Calculate cost for the new configuration\n                cost1 = distance_matrix_1[temp_sol[i-1], temp_sol[i]] + distance_matrix_1[temp_sol[j-1], temp_sol[j]]\n                cost2 = distance_matrix_2[temp_sol[i-1], temp_sol[i]] + distance_matrix_2[temp_sol[j-1], temp_sol[j]]\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 4: Dynamic segment reversal based on current solution quality\n    if np.random.random() < 0.3:  # 30% chance to apply reversal\n        k, l = np.random.choice(n, size=2, replace=False)\n        k, l = min(k, l), max(k, l)\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Step 5: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle with cross-dimensional evaluation\n        for _ in range(3):\n            np.random.shuffle(new_solution)\n            if len(new_solution) == n and len(np.unique(new_solution)) == n:\n                break\n        else:\n            # Final fallback to simple swap if all else fails\n            d, e = np.random.choice(n, size=2, replace=False)\n            new_solution[d], new_solution[e] = new_solution[e], new_solution[d]\n\n    return new_solution\n\n",
        "score": [
            -1.0591401778564862,
            0.10673314332962036
        ]
    },
    {
        "algorithm": "The algorithm combines hypervolume-based selection with a multi-phase local search: first realigning segments to improve both objectives, then contracting edges to further reduce costs, while ensuring feasibility through validation and fallback mechanisms. It prioritizes nondominated operations and adaptively balances exploration/exploitation, with the hypervolume selection favoring solutions with high potential for improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-phase local search operator\n    # Phase 1: Pareto-efficient segment realignment\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b]\n    best_pos = -1\n    best_cost1 = best_cost2 = float('inf')\n\n    for i in range(n):\n        if i >= a and i < b:\n            continue\n        # Calculate costs for inserting segment at position i\n        cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n        if cost1 < best_cost1 and cost2 < best_cost2:\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Phase 2: Cross-dimensional edge contraction\n    if np.random.rand() < 0.6:\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Check if contracting edges i-j and j-k would improve both objectives\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n\n    # Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Randomized segment inversion\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7262990116083332,
            0.07826483249664307
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, applies adaptive segment reinsertion with dynamic segment sizing, and performs cross-dimensional edge swaps weighted by solution quality, ensuring feasibility through fallback shuffling. It prioritizes objective balance by dynamically adjusting weights between the two objectives during edge swaps, while maintaining tour validity through strict feasibility checks. The hybrid approach combines large-scale segment moves with fine-grained edge optimizations, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion with dynamic segment size\n    segment_size = max(2, min(n // 3, np.random.randint(2, n // 2)))\n    a = np.random.randint(0, n - segment_size)\n    segment = base_solution[a:a+segment_size]\n    insert_pos = np.random.randint(0, n - segment_size)\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge swaps with dynamic objective weights\n    current_obj = archive[selected_idx][1]\n    obj_weight = (current_obj[0] + current_obj[1]) / (max_obj1 + max_obj2 + 1e-6)\n    obj_weight = min(max(obj_weight, 0.3), 0.7)  # Normalize between 0.3 and 0.7\n\n    neighborhood_size = min(4, n // 3)\n    for _ in range(2):\n        x, y = sorted(np.random.choice(n, size=2, replace=False))\n        if y - x >= neighborhood_size:\n            continue\n\n        best_cost = float('inf')\n        best_swap = None\n        for i in range(x, y):\n            for j in range(i+1, min(i+neighborhood_size, y)):\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n                cost1 = distance_matrix_1[temp_sol[i-1], temp_sol[i]] + distance_matrix_1[temp_sol[j-1], temp_sol[j]]\n                cost2 = distance_matrix_2[temp_sol[i-1], temp_sol[i]] + distance_matrix_2[temp_sol[j-1], temp_sol[j]]\n                total_cost = obj_weight * cost1 + (1 - obj_weight) * cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9031775542521303,
            0.0879402756690979
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from an archive using hypervolume-based prioritization, then applies a hybrid local search combining adaptive segment reinsertion and cross-dimensional edge swaps with dynamic objective weights, ensuring feasibility through fallback mechanisms. It prioritizes solutions with higher hypervolume contributions and adaptively adjusts segment sizes and objective weights during the search to balance both objectives while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion with dynamic segment size\n    segment_size = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    a = np.random.randint(0, n - segment_size)\n    segment = base_solution[a:a+segment_size]\n    insert_pos = np.random.randint(0, n - segment_size)\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge swaps with dynamic objective weights\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Calculate current cost\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate new cost with swapped edges\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            # Dynamic objective weights based on current solution quality\n            obj1, obj2 = archive[selected_idx][1]\n            weight1 = obj2 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n            weight2 = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n            # Weighted cost comparison\n            current_weighted_cost = current_cost1 * weight1 + current_cost2 * weight2\n            new_weighted_cost = new_cost1 * weight1 + new_cost2 * weight2\n\n            if new_weighted_cost < current_weighted_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle with cross-dimensional evaluation\n        for _ in range(3):\n            np.random.shuffle(new_solution)\n            if len(new_solution) == n and len(np.unique(new_solution)) == n:\n                break\n        else:\n            # Final fallback to simple swap if all else fails\n            d, e = np.random.choice(n, size=2, replace=False)\n            new_solution[d], new_solution[e] = new_solution[e], new_solution[d]\n\n    return new_solution\n\n",
        "score": [
            -0.9510420245894459,
            0.08831536769866943
        ]
    },
    {
        "algorithm": "The algorithm first selects a promising solution from the archive using a weighted combination of hypervolume contribution (70%) and the product of objectives (30%), then applies a hybrid local search operator with 60% probability for segment reinsertion and 40% for cross-dimensional edge swaps, followed by an additional 30% chance of segment reversal, while ensuring feasibility through validation and falling back to a simple swap if needed. The selection prioritizes Pareto-efficient solutions with balanced objectives, while the local search adaptively balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Combined selection criterion (70% hypervolume, 30% product of objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    product_objectives = objectives.prod(axis=1)\n    combined_score = 0.7 * hypervolume + 0.3 * product_objectives\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Hybrid local search operator\n    operator_choice = np.random.choice(['reinsertion', 'edge_swap'], p=[0.6, 0.4])\n\n    if operator_choice == 'reinsertion':\n        # Adaptive segment reinsertion\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n        segment = base_solution[a:b]\n        insert_pos = np.random.randint(0, n - len(segment))\n        new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n    else:\n        # Cross-dimensional edge swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Evaluate edge swaps in both dimensions\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional segment reversal for further improvement\n    if np.random.rand() < 0.3:\n        k, l = np.random.choice(n, size=2, replace=False)\n        k, l = min(k, l), max(k, l)\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Step 3: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.022498640977425,
            0.2626815438270569
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted adaptive strategy that prioritizes solutions with higher diversity in objectives, then applies a segment exchange move (similar to 3-opt but with a novel structure) to generate a neighbor. If the move is invalid, it falls back to a random 3-opt move to ensure feasibility. The weights dynamically adjust based on objective diversity, and the segment exchange explores inter-space correlations by rearranging segments between the two objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (sol, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity) if np.sum(diversity) > 0 else np.array([0.5, 0.5])\n    weighted_objectives = weights[0] * objectives[:, 0] + weights[1] * objectives[:, 1]\n\n    selected_idx = np.argmin(weighted_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[b:c]\n    segment3 = base_solution[c:d]\n\n    new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n    return new_solution\n\n",
        "score": [
            -0.9919248668007465,
            0.227209210395813
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using hypervolume-based selection, then applies a hybrid local search combining adaptive segment reinsertion and cross-dimensional 3-opt moves to generate a neighbor solution while ensuring feasibility through validation checks and fallback mechanisms. It prioritizes exploration through segment manipulation and exploitation through objective-aware evaluation, with fallback strategies maintaining solution validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    temp_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional 3-opt with objective-aware evaluation\n    if n > 3:\n        x, y, z = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = temp_solution[x:y]\n        segment2 = temp_solution[y:z]\n\n        combinations = [\n            (np.concatenate([segment1, segment2]), False),\n            (np.concatenate([segment2, segment1]), False),\n            (np.concatenate([segment1[::-1], segment2]), True),\n            (np.concatenate([segment2, segment1[::-1]]), True)\n        ]\n\n        best_cost = float('inf')\n        best_combination = None\n        for comb, reversed_flag in combinations:\n            cost1 = distance_matrix_1[temp_solution[x-1], comb[0]] + distance_matrix_1[comb[-1], temp_solution[z]]\n            cost2 = distance_matrix_2[temp_solution[x-1], comb[0]] + distance_matrix_2[comb[-1], temp_solution[z]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_combination = comb\n\n        if best_combination is not None:\n            temp_solution = np.concatenate([temp_solution[:x], best_combination, temp_solution[z:]])\n\n    # Step 4: Segment reversal for additional exploration\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n\n    # Step 5: Feasibility check and fallback\n    if len(temp_solution) != n or len(np.unique(temp_solution)) != n:\n        # Fallback to randomized segment shuffle with cross-dimensional evaluation\n        for _ in range(3):\n            np.random.shuffle(temp_solution)\n            if len(temp_solution) == n and len(np.unique(temp_solution)) == n:\n                break\n        else:\n            # Final fallback to simple swap if all else fails\n            d, e = np.random.choice(n, size=2, replace=False)\n            temp_solution[d], temp_solution[e] = temp_solution[e], temp_solution[d]\n\n    new_solution = temp_solution.copy()\n    return new_solution\n\n",
        "score": [
            -0.9914979101837657,
            0.12161469459533691
        ]
    }
]