[
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high-sum-objective solutions) and generates a neighbor by combining edge insertion and segment reversal, ensuring feasibility through validation and fallback to a simple swap if needed. The hybrid local search leverages random segment operations to explore diverse improvements while maintaining TSP validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Heuristic: Select a solution that is not dominated and has high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (for simplicity)\n    # In practice, you might use more sophisticated selection criteria\n    objectives = np.array([obj for (sol, obj) in archive])\n    sum_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Edge insertion + segment reversal\n    # 1. Randomly select two distinct edges and insert one between the other\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insert the edge between i and j\n    new_solution = np.concatenate([base_solution[:i+1], base_solution[j:], base_solution[i+1:j]])\n\n    # 2. Randomly select a segment and reverse it\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.9833221092967197,
            0.243777334690094
        ]
    },
    {
        "algorithm": "The heuristic function selects a promising solution from the archive (prioritizing those with lower combined objectives) and applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It first randomly selects a segment of the tour, attempts to reinsert a node optimally, and then performs targeted node swaps to improve the solution. The method balances exploration (random segment selection) with exploitation (optimized insertions and swaps) to navigate the trade-off between objectives effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and node swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Edge insertion: try to insert a random node elsewhere\n    if len(segment) > 1:\n        node_to_move = segment[np.random.randint(0, len(segment))]\n        segment = segment[segment != node_to_move]\n\n        # Find best insertion point\n        best_pos = -1\n        best_cost = float('inf')\n        for i in range(n):\n            if i >= a and i <= b:\n                continue\n            # Calculate cost after insertion\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Node swapping: swap two nodes that improve the solution\n    for _ in range(2):  # Try a few swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.866672080587731,
            0.0872378945350647
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on the sum of normalized objectives, then generates a neighbor by combining a random segment reversal with a probabilistic edge swap, ensuring feasibility through validation and fallback to a simple reversal if needed. The selection prioritizes solutions with better overall performance across both objectives, while the hybrid local search explores modifications by reversing segments and swapping edges probabilistically, with a fallback to basic reversal for validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    sum_normalized = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment reversal + probabilistic edge swap\n    # 1. Randomly select a segment and reverse it\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # 2. Probabilistically swap two edges\n    if np.random.rand() < 0.5:  # 50% chance to perform swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if i+1 < j:  # Ensure valid segment\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        m, n = min(m, n), max(m, n)\n        new_solution[m:n+1] = new_solution[m:n+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9398636422991159,
            0.23097997903823853
        ]
    },
    {
        "algorithm": "This heuristic selects a promising solution from the archive using a weighted objective score (prioritizing solutions with lower combined costs), then applies a hybrid local search combining segment reversal, objective-aware node insertion, and adaptive node swapping to generate an improved neighbor solution while ensuring feasibility. The algorithm balances exploration and exploitation by favoring moves that improve at least one objective, with higher weights given to the sum of objectives (0.7) over the maximum (0.3) in the insertion step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted objective score\n    def objective_score(obj):\n        return 0.6 * (obj[0] + obj[1]) + 0.4 * max(obj[0], obj[1])  # Balance between sum and max objectives\n\n    archive_sorted = sorted(archive, key=lambda x: objective_score(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create neighbor solution\n    new_solution = base_solution.copy()\n\n    # Segment reversal with objective-aware selection\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost before reversal\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate segment cost after reversal\n        new_seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Accept reversal if it improves at least one objective\n        if not (new_seg_cost1 <= seg_cost1 and new_seg_cost2 <= seg_cost2):\n            new_solution[a:b+1] = segment  # Revert if no improvement\n\n    # Objective-aware node insertion\n    if n > 2:\n        node_to_move = np.random.choice(new_solution)\n        mask = new_solution != node_to_move\n        remaining_nodes = new_solution[mask]\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n-1):\n            if i == node_to_move or new_solution[i] == node_to_move:\n                continue\n\n            # Calculate insertion costs\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n\n            # Weighted score combining both objectives\n            score = 0.7 * (cost1 + cost2) + 0.3 * max(cost1, cost2)\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(3):  # Try multiple swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i]])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9374014090401595,
            0.19761645793914795
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high combined objective values) and generates a neighbor by first reversing a random segment of the tour (edge inversion) and then reordering nodes within that segment based on their combined distance contributions (dynamic node reordering). The method ensures feasibility by maintaining valid TSP tours while targeting improvements in both objective spaces through adaptive segment selection and objective-aware node reordering.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high combined objective)\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge inversion: reverse a segment of the tour\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Dynamic node reordering: place nodes in order of their combined distance contribution\n    segment = new_solution[a:b+1]\n    segment_distances = []\n    for i in range(len(segment)):\n        node = segment[i]\n        prev_node = segment[i-1] if i > 0 else segment[-1]\n        next_node = segment[(i+1)%len(segment)]\n        dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        segment_distances.append((i, dist1 + dist2))\n\n    segment_distances.sort(key=lambda x: x[1])\n    reordered_segment = [segment[i] for i, _ in segment_distances]\n    new_solution[a:b+1] = reordered_segment\n\n    return new_solution\n\n",
        "score": [
            -0.978951748126899,
            0.23892003297805786
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on the sum of normalized objectives, then generates a neighbor by first reversing a random segment and optimizing it using a combined distance metric from both objective spaces, ensuring feasibility with a fallback to simple reversal if needed. The critical design ideas are prioritizing nondominated solutions, hybrid local search combining segment reversal and optimized insertion, and feasibility validation with fallback.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    sum_normalized = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2.1: Randomly select a segment and reverse it\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2.2: Optimized insertion based on combined distance contributions\n    segment = new_solution[a:b+1]\n    segment_distances = []\n    for i in range(len(segment)):\n        node = segment[i]\n        prev_node = segment[i-1] if i > 0 else segment[-1]\n        next_node = segment[(i+1)%len(segment)]\n        dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        segment_distances.append((i, dist1 + dist2))\n\n    segment_distances.sort(key=lambda x: x[1])\n    reordered_segment = [segment[i] for i, _ in segment_distances]\n    new_solution[a:b+1] = reordered_segment\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if the above fails\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9611672486138534,
            0.2324705719947815
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the lowest combined objective score (weighted 60% on the first objective and 40% on the second) and applies a hybrid local search combining segment reversal and cross-segment insertion, followed by targeted node swaps to improve both objectives while ensuring feasibility. It prioritizes solutions with balanced trade-offs between objectives and explores diverse improvements through segment manipulation and selective swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objective score (0.6*obj1 + 0.4*obj2)\n    objectives = np.array([(0.6 * obj[0] + 0.4 * obj[1]) for (sol, obj) in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal + cross-segment insertion\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1].copy()\n\n    # Reverse the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Cross-segment insertion: optimally reinsert the reversed segment elsewhere\n    best_pos = -1\n    best_cost = float('inf')\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n        # Calculate cost after insertion\n        cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Targeted node swaps to balance objectives\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9231037737797767,
            0.09395307302474976
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of objectives (70% first objective, 30% second), then applies a hybrid local search combining objective-driven segment reversals (targeting the top 5 edges per objective) and probabilistic perturbations (segment reversal, edge insertion, or edge swap). It ensures feasibility by reverting to minimal swaps with 30% probability if the solution becomes invalid. The primary objective is prioritized 60% of the time, with secondary perturbations applied probabilistically.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on combined objective scores\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_scores = objectives[:, 0] * 0.7 + objectives[:, 1] * 0.3  # Weighted combination\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Calculate edge importance scores for each objective\n    def calculate_edge_scores(solution, distance_matrix):\n        scores = np.zeros(n)\n        for i in range(n):\n            u = solution[i]\n            v = solution[(i+1) % n]\n            scores[i] = distance_matrix[u, v]\n        return scores\n\n    scores1 = calculate_edge_scores(base_solution, distance_matrix_1)\n    scores2 = calculate_edge_scores(base_solution, distance_matrix_2)\n\n    # Step 3: Adaptive segment selection based on objective-specific edge weights\n    if np.random.random() < 0.6:  # Primary objective phase\n        critical_edges = np.argsort(scores1)[-5:]  # Top 5 edges in first objective\n        if len(critical_edges) >= 2:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Secondary objective phase\n        critical_edges = np.argsort(scores2)[-5:]  # Top 5 edges in second objective\n        if len(critical_edges) >= 2:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4: Probabilistic three-phase perturbation\n    perturbation_prob = np.random.random()\n    if perturbation_prob < 0.33:\n        # Phase 1: Segment reversal\n        segment_length = min(4, n-1)\n        start = np.random.randint(1, n-segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n    elif perturbation_prob < 0.66:\n        # Phase 2: Edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n    else:\n        # Phase 3: Edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility with higher probability of minimal swap\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        if np.random.random() < 0.3:  # 30% chance of minimal swap\n            idx1, idx2 = np.random.choice(n, 2, replace=False)\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.967276626629581,
            0.2662750482559204
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive using a weighted objective score favoring solutions with lower maximum cost, then applies a hybrid local search combining segment reversal, objective-aware node insertion with modified weights, and adaptive node swapping with a different acceptance criterion. The method prioritizes improvements in both objectives while maintaining feasibility, using a balanced approach to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a different weighted objective score\n    def objective_score(obj):\n        return 0.5 * max(obj[0], obj[1]) + 0.5 * (obj[0] + obj[1])  # Different balance between max and sum\n\n    archive_sorted = sorted(archive, key=lambda x: objective_score(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create neighbor solution\n    new_solution = base_solution.copy()\n\n    # Segment reversal with different selection criteria\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost before reversal\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate segment cost after reversal\n        new_seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Accept reversal if it improves at least one objective or maintains both\n        if not (new_seg_cost1 <= seg_cost1 and new_seg_cost2 <= seg_cost2):\n            new_solution[a:b+1] = segment  # Revert if no improvement\n\n    # Objective-aware node insertion with modified weights\n    if n > 2:\n        node_to_move = np.random.choice(new_solution)\n        mask = new_solution != node_to_move\n        remaining_nodes = new_solution[mask]\n\n        # Find best insertion point with different weights\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n-1):\n            if i == node_to_move or new_solution[i] == node_to_move:\n                continue\n\n            # Calculate insertion costs\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n\n            # Different weighted score\n            score = 0.6 * (cost1 + cost2) + 0.4 * max(cost1, cost2)\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Adaptive node swapping with different acceptance criterion\n    for _ in range(3):  # Try multiple swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i]])\n\n        # Accept swap if it improves at least one objective or maintains both\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.878782050726235,
            0.19586431980133057
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective score (prioritizing solutions with lower combined cost and higher maximum cost), then applies an adaptive hybrid local search combining 3-opt edge exchanges and objective-aware segment reversals, ensuring feasibility through validation and falling back to simple swaps if needed. The weighted objective score (0.6 for sum, 0.4 for max) balances exploration of low-cost solutions while favoring those with better worst-case performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution with high potential for improvement\n    def objective_score(obj):\n        return 0.6 * (obj[0] + obj[1]) + 0.4 * max(obj[0], obj[1])\n\n    archive_sorted = sorted(archive, key=lambda x: objective_score(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    n = len(base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Adaptive hybrid local search: 3-opt edge exchange with segment reversal\n    if n > 4:\n        # Select three distinct edges to exchange (3-opt)\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Create all possible 3-opt configurations\n        candidates = [\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k:j-1:-1], new_solution[i+1:k], new_solution[j:]]),\n            np.concatenate([new_solution[:j+1], new_solution[k:i-1:-1], new_solution[j+1:k], new_solution[i:]])\n        ]\n\n        # Evaluate each candidate based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            score = 0.6 * (cost1 + cost2) + 0.4 * max(cost1, cost2)\n\n            if score < best_score and len(np.unique(candidate)) == n:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n    # Objective-aware segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost before reversal\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate segment cost after reversal\n        new_seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Accept reversal if it improves at least one objective or maintains both\n        if not (new_seg_cost1 <= seg_cost1 and new_seg_cost2 <= seg_cost2):\n            new_solution[a:b+1] = segment  # Revert if no improvement\n\n    # Ensure solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.7985926257506324,
            0.18167346715927124
        ]
    }
]