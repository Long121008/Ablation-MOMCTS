[
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high-sum-objective solutions) and generates a neighbor by combining edge insertion and segment reversal, ensuring feasibility through validation and fallback to a simple swap if needed. The hybrid local search leverages random segment operations to explore diverse improvements while maintaining TSP validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Heuristic: Select a solution that is not dominated and has high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (for simplicity)\n    # In practice, you might use more sophisticated selection criteria\n    objectives = np.array([obj for (sol, obj) in archive])\n    sum_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Edge insertion + segment reversal\n    # 1. Randomly select two distinct edges and insert one between the other\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insert the edge between i and j\n    new_solution = np.concatenate([base_solution[:i+1], base_solution[j:], base_solution[i+1:j]])\n\n    # 2. Randomly select a segment and reverse it\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.9833221092967197,
            0.243777334690094
        ]
    },
    {
        "algorithm": "The heuristic function selects a promising solution from the archive (prioritizing those with lower combined objectives) and applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It first randomly selects a segment of the tour, attempts to reinsert a node optimally, and then performs targeted node swaps to improve the solution. The method balances exploration (random segment selection) with exploitation (optimized insertions and swaps) to navigate the trade-off between objectives effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and node swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Edge insertion: try to insert a random node elsewhere\n    if len(segment) > 1:\n        node_to_move = segment[np.random.randint(0, len(segment))]\n        segment = segment[segment != node_to_move]\n\n        # Find best insertion point\n        best_pos = -1\n        best_cost = float('inf')\n        for i in range(n):\n            if i >= a and i <= b:\n                continue\n            # Calculate cost after insertion\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Node swapping: swap two nodes that improve the solution\n    for _ in range(2):  # Try a few swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.866672080587731,
            0.0872378945350647
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on the sum of normalized objectives, then generates a neighbor by combining a random segment reversal with a probabilistic edge swap, ensuring feasibility through validation and fallback to a simple reversal if needed. The selection prioritizes solutions with better overall performance across both objectives, while the hybrid local search explores modifications by reversing segments and swapping edges probabilistically, with a fallback to basic reversal for validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    sum_normalized = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment reversal + probabilistic edge swap\n    # 1. Randomly select a segment and reverse it\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # 2. Probabilistically swap two edges\n    if np.random.rand() < 0.5:  # 50% chance to perform swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if i+1 < j:  # Ensure valid segment\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        m, n = min(m, n), max(m, n)\n        new_solution[m:n+1] = new_solution[m:n+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9398636422991159,
            0.23097997903823853
        ]
    },
    {
        "algorithm": "This heuristic selects a promising solution from the archive using a weighted objective score (prioritizing solutions with lower combined costs), then applies a hybrid local search combining segment reversal, objective-aware node insertion, and adaptive node swapping to generate an improved neighbor solution while ensuring feasibility. The algorithm balances exploration and exploitation by favoring moves that improve at least one objective, with higher weights given to the sum of objectives (0.7) over the maximum (0.3) in the insertion step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted objective score\n    def objective_score(obj):\n        return 0.6 * (obj[0] + obj[1]) + 0.4 * max(obj[0], obj[1])  # Balance between sum and max objectives\n\n    archive_sorted = sorted(archive, key=lambda x: objective_score(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create neighbor solution\n    new_solution = base_solution.copy()\n\n    # Segment reversal with objective-aware selection\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost before reversal\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate segment cost after reversal\n        new_seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Accept reversal if it improves at least one objective\n        if not (new_seg_cost1 <= seg_cost1 and new_seg_cost2 <= seg_cost2):\n            new_solution[a:b+1] = segment  # Revert if no improvement\n\n    # Objective-aware node insertion\n    if n > 2:\n        node_to_move = np.random.choice(new_solution)\n        mask = new_solution != node_to_move\n        remaining_nodes = new_solution[mask]\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n-1):\n            if i == node_to_move or new_solution[i] == node_to_move:\n                continue\n\n            # Calculate insertion costs\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n\n            # Weighted score combining both objectives\n            score = 0.7 * (cost1 + cost2) + 0.3 * max(cost1, cost2)\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(3):  # Try multiple swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i]])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9374014090401595,
            0.19761645793914795
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high combined objective values) and generates a neighbor by first reversing a random segment of the tour (edge inversion) and then reordering nodes within that segment based on their combined distance contributions (dynamic node reordering). The method ensures feasibility by maintaining valid TSP tours while targeting improvements in both objective spaces through adaptive segment selection and objective-aware node reordering.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high combined objective)\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge inversion: reverse a segment of the tour\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Dynamic node reordering: place nodes in order of their combined distance contribution\n    segment = new_solution[a:b+1]\n    segment_distances = []\n    for i in range(len(segment)):\n        node = segment[i]\n        prev_node = segment[i-1] if i > 0 else segment[-1]\n        next_node = segment[(i+1)%len(segment)]\n        dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        segment_distances.append((i, dist1 + dist2))\n\n    segment_distances.sort(key=lambda x: x[1])\n    reordered_segment = [segment[i] for i, _ in segment_distances]\n    new_solution[a:b+1] = reordered_segment\n\n    return new_solution\n\n",
        "score": [
            -0.978951748126899,
            0.23892003297805786
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on the sum of normalized objectives, then generates a neighbor by first reversing a random segment and optimizing it using a combined distance metric from both objective spaces, ensuring feasibility with a fallback to simple reversal if needed. The critical design ideas are prioritizing nondominated solutions, hybrid local search combining segment reversal and optimized insertion, and feasibility validation with fallback.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    sum_normalized = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2.1: Randomly select a segment and reverse it\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2.2: Optimized insertion based on combined distance contributions\n    segment = new_solution[a:b+1]\n    segment_distances = []\n    for i in range(len(segment)):\n        node = segment[i]\n        prev_node = segment[i-1] if i > 0 else segment[-1]\n        next_node = segment[(i+1)%len(segment)]\n        dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        segment_distances.append((i, dist1 + dist2))\n\n    segment_distances.sort(key=lambda x: x[1])\n    reordered_segment = [segment[i] for i, _ in segment_distances]\n    new_solution[a:b+1] = reordered_segment\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if the above fails\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9611672486138534,
            0.2324705719947815
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive using a weighted objective score favoring solutions with lower maximum cost, then applies a hybrid local search combining segment reversal, objective-aware node insertion with modified weights, and adaptive node swapping with a different acceptance criterion. The method prioritizes improvements in both objectives while maintaining feasibility, using a balanced approach to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a different weighted objective score\n    def objective_score(obj):\n        return 0.5 * max(obj[0], obj[1]) + 0.5 * (obj[0] + obj[1])  # Different balance between max and sum\n\n    archive_sorted = sorted(archive, key=lambda x: objective_score(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create neighbor solution\n    new_solution = base_solution.copy()\n\n    # Segment reversal with different selection criteria\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost before reversal\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate segment cost after reversal\n        new_seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Accept reversal if it improves at least one objective or maintains both\n        if not (new_seg_cost1 <= seg_cost1 and new_seg_cost2 <= seg_cost2):\n            new_solution[a:b+1] = segment  # Revert if no improvement\n\n    # Objective-aware node insertion with modified weights\n    if n > 2:\n        node_to_move = np.random.choice(new_solution)\n        mask = new_solution != node_to_move\n        remaining_nodes = new_solution[mask]\n\n        # Find best insertion point with different weights\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n-1):\n            if i == node_to_move or new_solution[i] == node_to_move:\n                continue\n\n            # Calculate insertion costs\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n\n            # Different weighted score\n            score = 0.6 * (cost1 + cost2) + 0.4 * max(cost1, cost2)\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Adaptive node swapping with different acceptance criterion\n    for _ in range(3):  # Try multiple swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i]])\n\n        # Accept swap if it improves at least one objective or maintains both\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.878782050726235,
            0.19586431980133057
        ]
    },
    {
        "algorithm": "The algorithm selects a nondominated solution from the archive (prioritizing those with lower normalized objective sums) and generates a neighbor by probabilistically reversing segments and swapping edges, with a fallback to simple swaps to ensure feasibility. It balances exploration (segment reversal) and exploitation (edge swaps) while maintaining TSP validity through validation checks. The hybrid approach outperforms isolated methods by dynamically adapting local search intensity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a nondominated solution from the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    sum_normalized = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(sum_normalized)  # Select nondominated (lowest sum of normalized objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Probabilistic segment reversal + optimized edge swap\n    # 1. Probabilistically reverse a segment\n    if np.random.rand() < 0.7:  # Higher chance to reverse\n        k, l = np.random.choice(n, size=2, replace=False)\n        k, l = min(k, l), max(k, l)\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # 2. Optimized edge swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    if j - i > 1:  # Ensure valid segment\n        # Swap edges between i and j\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.8985283237370951,
            0.22499316930770874
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of objectives (60% first objective, 40% second), then applies a hybrid local search combining edge importance-based segment reversal (prioritizing critical edges in either objective space) and probabilistic two-phase perturbations (segment reversal or edge insertion). It ensures feasibility by reverting to a minimal swap if needed, with the first objective given higher priority in selection and phase transitions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on combined objective scores\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Calculate edge importance scores for each objective\n    def calculate_edge_scores(solution, distance_matrix):\n        scores = np.zeros(n)\n        for i in range(n):\n            u = solution[i]\n            v = solution[(i+1) % n]\n            scores[i] = distance_matrix[u, v]\n        return scores\n\n    scores1 = calculate_edge_scores(base_solution, distance_matrix_1)\n    scores2 = calculate_edge_scores(base_solution, distance_matrix_2)\n\n    # Step 3: Adaptive segment selection based on objective-specific edge weights\n    if np.random.random() < 0.7:  # Primary objective phase\n        critical_edges = np.argsort(scores1)[-3:]  # Top 3 edges in first objective\n        if len(critical_edges) >= 2:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Secondary objective phase\n        critical_edges = np.argsort(scores2)[-3:]  # Top 3 edges in second objective\n        if len(critical_edges) >= 2:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4: Probabilistic two-phase perturbation\n    if np.random.random() < 0.5:\n        # Phase 1: Segment reversal with objective-specific probability\n        if np.random.random() < 0.6:\n            segment_length = min(3, n-1)\n            start = np.random.randint(1, n-segment_length)\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:\n            # Phase 2: Edge insertion with complementary objective guidance\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    # Ensure feasibility\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Minimal perturbation if infeasible\n        idx1, idx2 = np.random.choice(n, 2, replace=False)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.9119137505906443,
            0.24568456411361694
        ]
    },
    {
        "algorithm": "This algorithm selects a solution from the archive using crowding distance to prioritize under-explored regions of the Pareto front, then applies a hybrid local search combining adaptive segment relocation, objective-weighted node relocation, and dynamic pairwise exchange, with a validation mechanism to ensure tour feasibility. The method balances exploration of solution space with exploitation of promising regions, using weighted objectives (60% combined cost, 40% max cost) to guide node relocations, while maintaining tour validity through segment-based operations and pairwise exchanges.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    fronts = np.argsort(objectives, axis=0)\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_indices = fronts[:, i]\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        f_max = objectives[sorted_indices[-1], i]\n        f_min = objectives[sorted_indices[0], i]\n\n        if f_max == f_min:\n            continue\n\n        for j in range(1, len(archive)-1):\n            idx = sorted_indices[j]\n            prev_idx = sorted_indices[j-1]\n            next_idx = sorted_indices[j+1]\n            crowding[idx] += (objectives[next_idx, i] - objectives[prev_idx, i]) / (f_max - f_min)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment relocation\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n-segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length+1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length+1))\n\n        # Find best relocation position\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n-segment_length):\n            if pos >= start and pos < start+segment_length:\n                continue\n\n            # Calculate new costs\n            new_cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                        distance_matrix_1[segment[-1], new_solution[(pos+segment_length)%n]] +\n                        sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(segment_length-1)))\n            new_cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                        distance_matrix_2[segment[-1], new_solution[(pos+segment_length)%n]] +\n                        sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(segment_length-1)))\n\n            # Calculate improvement\n            improvement = (seg_cost1 - new_cost1) + (seg_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            # Remove segment and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:],\n                segment\n            ])\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Objective-weighted node relocation\n    if n > 3:\n        node = np.random.choice(new_solution)\n        mask = new_solution != node\n        remaining = new_solution[mask]\n\n        # Calculate current costs\n        idx = np.where(new_solution == node)[0][0]\n        current_cost1 = distance_matrix_1[new_solution[idx-1], node] + distance_matrix_1[node, new_solution[(idx+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[idx-1], node] + distance_matrix_2[node, new_solution[(idx+1)%n]]\n\n        # Find best relocation position\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n-1):\n            if new_solution[i] == node:\n                continue\n\n            # Calculate new costs\n            new_cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n\n            # Weighted score\n            score = 0.6 * (new_cost1 + new_cost2) + 0.4 * max(new_cost1, new_cost2)\n\n            if score < best_score and (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:idx],\n                new_solution[idx+1:],\n                [node]\n            ])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic node pairwise exchange\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[i]])\n\n        # Accept exchange if it improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9436892376218808,
            0.42108988761901855
        ]
    }
]