[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective cost from the archive and applies a hybrid local search combining random edge swaps and path reversals to generate neighbors, ensuring feasibility by checking for duplicates and falling back to a simple swap if needed. The algorithm prioritizes solutions with better combined performance and uses a creative, non-standard local search approach to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with path reversal\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform path reversal between two random points\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.035545407236826,
            0.22458416223526
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest product of the two objectives from the archive, then applies a hybrid local search combining segment reversal and a fallback swap to ensure feasibility. It prioritizes solutions with balanced objective values and uses a novel segment-based perturbation to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n\n    # Apply a hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(i, j)\n    new_solution[i:k] = new_solution[i:k][::-1]\n    new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9689691333391046,
            0.196405291557312
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective value from the archive, applies a hybrid local search combining segment inversion and node swaps, and ensures feasibility by validating the tour. It prioritizes solutions with higher combined costs (potentially non-dominated) and uses random segment inversion followed by conditional node swaps to explore neighbors, with a fallback to simple swaps if the tour becomes invalid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    target_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    N = len(target_solution)\n    new_solution = target_solution.copy()\n\n    # Hybrid local search: segment inversion + node swap\n    i, j = sorted(np.random.choice(N, 2, replace=False))\n    k = np.random.randint(0, N)\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node swap with probability\n    if np.random.rand() < 0.7:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Feasibility check\n    if len(set(new_solution)) != N:\n        # Fallback to simple swap if invalid\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -1.0017648199131555,
            0.21665334701538086
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a Pareto-aware heuristic (prioritizing solutions with balanced objective costs) and applies a hybrid local search combining adaptive segment relinking and multi-objective edge refinement, ensuring feasibility through validation checks and fallback mechanisms. It dynamically adjusts operator depth based on solution quality and probabilistically refines edges to improve both objectives, while maintaining diversity through segment relinking. The selection prioritizes solutions near the Pareto front, and the local search ensures feasibility by reverting to simpler swaps when improvements are not found.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with adaptive depth\n    selected = min(archive, key=lambda x: max(x[1]) - 0.15 * min(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segment relinking with edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    while b - a < 2:  # Ensure segment length >= 2\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    segment = base_solution[a:b+1]\n    c = np.random.randint(0, n)\n    while abs(c - a) <= 1 or abs(c - b) <= 1:  # Ensure non-adjacent\n        c = np.random.randint(0, n)\n\n    # Relink segment with edge insertion\n    new_solution = np.concatenate([base_solution[:c], segment, np.delete(base_solution, slice(a, b+1))])\n\n    # Multi-objective edge refinement\n    if np.random.random() < 0.35:  # Probability of refinement\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.25):\n            # Insert edge between k and l\n            if k < l:\n                new_solution = np.concatenate([new_solution[:k+1], new_solution[l:], new_solution[k+1:l]])\n            else:\n                new_solution = np.concatenate([new_solution[:l+1], new_solution[k:], new_solution[l+1:k]])\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert to original\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Simple swap\n\n    return new_solution\n\n",
        "score": [
            -0.7973105683635894,
            0.05677461624145508
        ]
    },
    {
        "algorithm": "This algorithm selects a solution from the archive based on balanced objective values, then applies a hybrid local search that combines segment reversal (with a higher probability) and adaptive node insertion to generate a neighbor solution while ensuring feasibility. The method prioritizes objective balance in selection and uses a probabilistic approach to explore both segment reversal and insertion, with a fallback to simple swaps when improvements aren't found. The solution always maintains a valid TSP tour by checking for duplicates and ensuring tour length consistency.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda s: abs(s[1][0] - s[1][1]))[0].copy()\n    n = len(selected)\n\n    # Hybrid operator: Segment reversal with adaptive node insertion\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = selected[i:j+1]\n\n    # Reverse segment with probability based on objective balance\n    if np.random.rand() < 0.7:  # Higher probability for reversal\n        reversed_segment = segment[::-1]\n    else:\n        reversed_segment = segment\n\n    # Insert node from elsewhere in the tour\n    k = np.random.randint(n)\n    node = selected[k]\n    pos = np.random.randint(n)\n    new_solution = np.concatenate([selected[:pos], [node], selected[pos:]])\n\n    # Ensure no duplicates and maintain tour length\n    if len(np.unique(new_solution)) == n:\n        # Check if insertion improves at least one objective\n        original_cost1 = sum(distance_matrix_1[selected[:-1], selected[1:]])\n        original_cost2 = sum(distance_matrix_2[selected[:-1], selected[1:]])\n        new_cost1 = sum(distance_matrix_1[new_solution[:-1], new_solution[1:]])\n        new_cost2 = sum(distance_matrix_2[new_solution[:-1], new_solution[1:]])\n\n        if (new_cost1 <= original_cost1) or (new_cost2 <= original_cost2):\n            return new_solution\n\n    # Fallback to simple swap if insertion doesn't help\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    return new_solution\n\n",
        "score": [
            -0.942489605061634,
            0.08392202854156494
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using Pareto-aware selection (prioritizing solutions with balanced objectives) and applies a hybrid local search combining adaptive segment rotation and multi-objective edge merging. It ensures feasibility through permutation validation and fallback mechanisms, dynamically adjusting operator depth and probabilities. The selection criterion balances objective values (favoring solutions with lower maximum cost and higher minimum cost), while the local search uses probabilistic segment rotation and edge merging to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with adaptive depth\n    selected = min(archive, key=lambda x: max(x[1]) - 0.2 * min(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segment rotation with edge merging\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    while b - a < 2:  # Ensure segment length >= 2\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    segment = base_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert rotated segment at a new position\n    c = np.random.randint(0, n)\n    while abs(c - a) <= 1 or abs(c - b) <= 1:  # Ensure non-adjacent\n        c = np.random.randint(0, n)\n\n    new_solution = np.concatenate([base_solution[:c], rotated_segment, np.delete(base_solution, slice(a, b+1))])\n\n    # Multi-objective edge merging\n    if np.random.random() < 0.4:  # Probability of merging\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.3):\n            # Merge edges between k and l\n            if k < l:\n                new_solution = np.concatenate([new_solution[:k+1], new_solution[l:], new_solution[k+1:l]])\n            else:\n                new_solution = np.concatenate([new_solution[:l+1], new_solution[k:], new_solution[l+1:k]])\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert to original\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Simple swap\n\n    return new_solution\n\n",
        "score": [
            -0.8004443765049956,
            0.07559442520141602
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-aware epsilon-dominance, then applies a hybrid local search operator that dynamically inserts segments of the tour and conditionally refines edges based on multi-objective improvements, while ensuring feasibility through permutation checks and fallback mechanisms. It balances exploration and exploitation by randomizing segment lengths and refinement probabilities, prioritizing solutions near the Pareto front while maintaining diversity through dynamic operator depth and probabilistic edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with epsilon-dominance\n    epsilon = 0.1\n    selected = min(archive, key=lambda s: max(s[1]) - epsilon * min(s[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Segment insertion with adaptive edge refinement\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    while b - a < 2:  # Ensure segment length >= 2\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Randomly select insertion point\n    c = np.random.randint(0, n)\n    while abs(c - a) <= 1 or abs(c - b) <= 1:  # Ensure non-adjacent\n        c = np.random.randint(0, n)\n\n    # Insert segment\n    segment = base_solution[a:b+1]\n    new_solution = np.concatenate([base_solution[:c], segment, np.delete(base_solution, slice(a, b+1))])\n\n    # Adaptive edge refinement\n    if np.random.random() < 0.3:  # Probabilistic refinement\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7594838300291855,
            0.06324100494384766
        ]
    },
    {
        "algorithm": "This algorithm implements a multi-objective local search that first filters solutions using Pareto dominance and quality thresholds, then adaptively selects high-diversity solutions to apply a hybrid segment-based crossover operator with edge refinement. It prioritizes solutions that dominate many others and have high structural diversity, while ensuring feasibility through constrained segment insertion and edge validation, falling back to simple edge swaps when needed. The approach dynamically balances exploration and exploitation by combining segment-based crossover with objective-aware edge refinement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective dominance filtering with quality threshold\n    front = []\n    quality_threshold = 0.7\n    for sol in archive:\n        dominated = False\n        dominates_count = 0\n        for other in archive:\n            if (other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and\n                (other[1][0] < sol[1][0] or other[1][1] < sol[1][1])):\n                dominated = True\n                break\n            if (sol[1][0] <= other[1][0] and sol[1][1] <= other[1][1] and\n                (sol[1][0] < other[1][0] or sol[1][1] < other[1][1])):\n                dominates_count += 1\n        if not dominated and dominates_count >= quality_threshold * len(archive):\n            front.append(sol)\n\n    if not front:\n        front = archive\n\n    # Adaptive selection based on solution diversity\n    diversity_scores = []\n    for sol in front:\n        diversity = sum(abs(sol[0][i] - sol[0][(i+1)%len(sol[0])]) for i in range(len(sol[0])))\n        diversity_scores.append(diversity)\n\n    if diversity_scores:\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = front[selected_idx][0].copy()\n    else:\n        selected = random.choice(front)\n        base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Novel hybrid operator: Segment-based crossover with edge refinement\n    for _ in range(random.randint(1, 2)):\n        # Dynamic segment selection based on objective improvement potential\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Create candidate segment by combining segments from other solutions\n        candidate_segments = []\n        for sol in archive:\n            candidate_segments.extend([sol[0][i:i+segment_size] for i in range(len(sol[0]) - segment_size + 1)])\n\n        if candidate_segments:\n            selected_segment = random.choice(candidate_segments)\n            # Ensure segment is compatible (no duplicates)\n            if len(np.unique(selected_segment)) == len(selected_segment):\n                # Insert segment with edge refinement\n                new_solution[start:end] = selected_segment\n                # Refine edges around segment\n                for i in [start-1, end]:\n                    if i >= 0 and i < n-1:\n                        j = i+1\n                        # Check for better edge connections\n                        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                        for k in range(n):\n                            if k != i and k != j:\n                                new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n                                new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n                                if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or random.random() < 0.2:\n                                    new_solution[i], new_solution[j] = new_solution[k], new_solution[j]\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.035109230602227,
            1.071377456188202
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a Pareto-aware selection with adaptive dominance (prioritizing solutions with balanced objectives) and applies a hybrid local search combining segment reversal and multi-objective edge refinement, while ensuring feasibility through a dynamic fallback mechanism. It favors segment reversal for larger segments and probabilistically swaps edges if they improve both objectives, with a fallback to segment shifting if feasibility is violated. The selection bias and probabilities are tuned to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with adaptive dominance (different weights)\n    selected = max(archive, key=lambda s: min(s[1]) - 0.3 * max(s[1]))  # Different bias\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Dynamic segment reversal with probabilistic edge merging\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    while b - a < 3:  # Different minimum segment length\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Segment reversal (different from rotation)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge refinement with different probability\n    if np.random.random() < 0.5:  # Different probability\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.4):  # Different threshold\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Different fallback mechanism\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply segment shift as fallback\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.9835114568906452,
            0.2518964409828186
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-frontier biased selection with dynamic objective weighting to prioritize solutions with balanced improvement potential in both objectives, then applies adaptive segment swapping (60% inversion, 40% cyclic shift) followed by probabilistic edge inversions to explore high-quality neighbors while ensuring feasibility through permutation validation and multi-objective cost checks. The method dynamically balances exploration (via random segment operations) and exploitation (via edge inversions) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-frontier biased selection with dynamic objective weighting\n    weights = np.random.uniform(0.3, 0.7)\n    selected = min(archive, key=lambda s: weights * s[1][0] + (1 - weights) * s[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segment swapping with probabilistic edge inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    while b - a < 3:  # Ensure segment length >= 3\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    segment = base_solution[a:b+1]\n    if np.random.random() < 0.6:  # 60% chance of inversion\n        segment = segment[::-1]\n    else:  # 40% chance of cyclic shift\n        shift = np.random.randint(1, len(segment))\n        segment = np.roll(segment, shift)\n\n    # Insert segment at a different position\n    c = np.random.randint(0, n)\n    while abs(c - a) <= 2:  # Ensure non-adjacent\n        c = np.random.randint(0, n)\n\n    new_solution = np.concatenate([base_solution[:c], segment, np.delete(base_solution, slice(a, b+1))])\n\n    # Multi-objective cost validation\n    for _ in range(2):  # Try up to 2 edge inversions\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k == l or abs(k - l) == 1:\n            continue\n\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.4):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i < j:\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8294794212223329,
            0.08999073505401611
        ]
    }
]