[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective cost from the archive and applies a hybrid local search combining random edge swaps and path reversals to generate neighbors, ensuring feasibility by checking for duplicates and falling back to a simple swap if needed. The algorithm prioritizes solutions with better combined performance and uses a creative, non-standard local search approach to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with path reversal\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform path reversal between two random points\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.035545407236826,
            0.22458416223526
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest product of the two objectives from the archive, then applies a hybrid local search combining segment reversal and a fallback swap to ensure feasibility. It prioritizes solutions with balanced objective values and uses a novel segment-based perturbation to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n\n    # Apply a hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(i, j)\n    new_solution[i:k] = new_solution[i:k][::-1]\n    new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9689691333391046,
            0.196405291557312
        ]
    },
    {
        "algorithm": "The heuristic function selects the solution from the archive with the lowest combined objective score and applies a hybrid local search operator that reverses two randomly selected non-adjacent segments in the tour, optionally swapping edges between them to improve solution quality while ensuring feasibility. The algorithm prioritizes solutions with better overall performance and uses a creative segment reversal strategy to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are not adjacent\n    while abs(a - b) <= 1 or abs(c - d) <= 1:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Optional: Perform edge swaps between segments\n    if random.random() < 0.5 and b < c:\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8427200718500385,
            0.1953842043876648
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects the worst-performing solution from the archive (based on the maximum of its two objectives) and applies a hybrid local search combining segment reversal and 3-opt-like adjustments to generate a neighbor solution, ensuring feasibility by validating node uniqueness and fallback to 2-opt if needed. The approach prioritizes diversification by targeting poorly performing solutions while using novel segment reversal to explore the search space beyond standard 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj = max(archive, key=lambda x: max(x[1]))\n    base_solution = worst_obj[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(np.random.choice(N, 3, replace=False))\n\n    # Segment reversal (novel operator)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt style adjustment\n    if np.random.rand() < 0.5:\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != N:\n        # Fallback to simple 2-opt if needed\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.84403300160437,
            0.20488500595092773
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective cost from the archive, then generates a neighbor by applying a hybrid local search combining random segment reversals and edge swaps, with a fallback to simple inversion if feasibility is violated, ensuring the neighbor remains a valid TSP tour. The selection prioritizes high-cost solutions for improvement, while the hybrid operator balances exploration and exploitation for better multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined cost (opposite of previous approach)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform path reversal between two random points\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if reversal causes duplicates\n        new_solution = base_solution.copy()\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9508678707472352,
            0.24227094650268555
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda s: abs(s[1][0] - s[1][1]))[0].copy()\n    n = len(selected)\n\n    # Hybrid operator: Adaptive segment reversal with edge swaps\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = selected[i:j+1]\n\n    # Reverse segment if it improves both objectives\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([selected[:i], reversed_segment, selected[j+1:]])\n\n    # Edge swap if reversal worsens both objectives\n    if (sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) > sum(distance_matrix_1[selected[:-1], selected[1:]]) and\n        sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) > sum(distance_matrix_2[selected[:-1], selected[1:]])):\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8283262443738455,
            0.22868973016738892
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, then applies a hybrid local search combining 3-opt moves with probabilistic segment inversions to generate a neighbor solution while ensuring feasibility. It evaluates all possible 3-opt configurations to find the best improvement in the combined cost of both objectives, followed by an optional segment inversion step. The selection prioritizes non-dominated and diverse solutions (though not explicitly implemented in the given code), and the local search balances exploration (random segment selection) and exploitation (3-opt optimization).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Simple selection strategy: pick a random solution for demonstration\n    # In practice, you might want to select based on non-dominated status or diversity\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small tours\n\n    # Hybrid local search: combine 3-opt with segment inversion\n    # Step 2.1: Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Step 2.2: Apply 3-opt move\n    # Try all possible 3-opt configurations\n    configurations = [\n        (a, b, c),\n        (a, c, b),\n        (b, a, c),\n        (b, c, a),\n        (c, a, b),\n        (c, b, a)\n    ]\n\n    best_config = None\n    best_improvement = 0\n\n    for config in configurations:\n        temp_solution = new_solution.copy()\n        # Reorder the segment between a and b\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n        # Reorder the segment between b and c\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        # Calculate the change in cost (sum of both objectives)\n        old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i-1]] for i in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i-1]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i-1]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i-1]] for i in range(n))\n\n        # Simple improvement metric (sum of normalized improvements)\n        improvement = (old_cost1 - new_cost1) / old_cost1 + (old_cost2 - new_cost2) / old_cost2\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_config = config\n\n    if best_config is not None:\n        # Apply the best 3-opt configuration\n        a, b, c = best_config\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 2.3: Apply segment inversion with probability 0.5\n    if np.random.rand() < 0.5:\n        # Select a random segment to invert\n        start = np.random.randint(0, n)\n        end = np.random.randint(start + 1, n + 1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9127776616572008,
            0.6040118336677551
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on balanced objective performance, then applies a hybrid local search combining segment reversal and objective-aware edge swapping to generate a neighbor solution while ensuring feasibility through validation and fallback mechanisms. It prioritizes improvements in both objectives through probabilistic operations and dynamic edge selection, with segment-based operations given higher probability (70%) to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance between objectives\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment-based operations with objective-aware edge selection\n    # Step 1: Select two non-adjacent segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n    while abs(a - b) <= 1 or abs(c - d) <= 1:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Reverse segments with probability based on objective improvement\n    if random.random() < 0.7:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Calculate potential improvement in both objectives\n        def calculate_improvement(seg1, seg2):\n            # Original cost\n            original_cost1 = distance_matrix_1[seg1[-1], seg1[0]] + distance_matrix_1[seg2[-1], seg2[0]]\n            original_cost2 = distance_matrix_2[seg1[-1], seg1[0]] + distance_matrix_2[seg2[-1], seg2[0]]\n\n            # Reversed cost\n            reversed_cost1 = distance_matrix_1[seg1[0], seg1[-1]] + distance_matrix_1[seg2[0], seg2[-1]]\n            reversed_cost2 = distance_matrix_2[seg1[0], seg2[-1]] + distance_matrix_2[seg2[0], seg1[-1]]\n\n            return (original_cost1 - reversed_cost1, original_cost2 - reversed_cost2)\n\n        imp1, imp2 = calculate_improvement(segment1, segment2)\n\n        # Apply reversal if it improves at least one objective\n        if imp1 > 0 or imp2 > 0:\n            new_solution[a:b+1] = segment1[::-1]\n            new_solution[c:d+1] = segment2[::-1]\n\n    # Step 3: Objective-aware edge selection and swap\n    if random.random() < 0.5:\n        # Find edges with potential for improvement in both objectives\n        candidates = []\n        for i in range(n):\n            j = (i + 1) % n\n            for k in range(n):\n                if k != i and k != j and k != (i - 1) % n and k != (j + 1) % n:\n                    # Calculate potential improvement\n                    old_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n                    new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[(k+1)%n]]\n                    old_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n                    new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[(k+1)%n]]\n\n                    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n                       (new_cost1 < old_cost1 and random.random() < 0.3) or \\\n                       (new_cost2 < old_cost2 and random.random() < 0.3):\n                        candidates.append((i, j, k))\n\n        if candidates:\n            i, j, k = random.choice(candidates)\n            # Perform edge swap\n            new_solution[j], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if needed\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9333935532323302,
            1.0242191553115845
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (0.7 for the first objective and 0.3 for the second), then applies a hybrid local search combining random node insertion and segment reversal, ensuring feasibility by reverting to a simple swap if duplicates occur. The method prioritizes the first objective while allowing some exploration of the second, and the local search explores diverse perturbations to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    objectives = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: node insertion with segment reversal\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Remove node at position i and insert at position k\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, k, node)\n\n    # Reverse a random segment\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if operation causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7901724545027533,
            0.22883951663970947
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive (prioritizing solutions with similar objective values) and combines segments from it with segments from two other randomly chosen solutions, merging them around a common node to create a hybrid tour. If the merge fails due to duplicates or missing nodes, it falls back to a simple segment reversal. The approach leverages archive diversity while ensuring feasibility through careful validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives (minimizing the difference between objectives)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select two other solutions from the archive\n    other_solutions = [sol for sol, _ in archive if not np.array_equal(sol, selected_solution)]\n    if len(other_solutions) < 2:\n        return new_solution  # Fallback if not enough solutions\n\n    sol1, sol2 = random.sample(other_solutions, 2)\n\n    # Find a common node to split the tours\n    common_node = np.intersect1d(selected_solution, sol1)\n    if len(common_node) == 0:\n        common_node = np.intersect1d(selected_solution, sol2)\n    if len(common_node) == 0:\n        return new_solution  # Fallback if no common node\n\n    common_node = common_node[0]\n    idx_selected = np.where(selected_solution == common_node)[0][0]\n    idx_sol1 = np.where(sol1 == common_node)[0][0]\n    idx_sol2 = np.where(sol2 == common_node)[0][0]\n\n    # Create segments from all three solutions\n    segment1 = selected_solution[:idx_selected+1]\n    segment2 = sol1[idx_sol1:]\n    segment3 = sol2[idx_sol2:]\n\n    # Merge segments ensuring no duplicates and all nodes are included\n    merged = np.concatenate([segment1, segment2, segment3])\n    unique_nodes = np.unique(merged)\n\n    if len(unique_nodes) == len(selected_solution):\n        new_solution = merged\n    else:\n        # Fallback to simple segment reversal if merge fails\n        a, b = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7625803316226084,
            0.335018515586853
        ]
    }
]