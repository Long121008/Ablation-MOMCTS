[
    {
        "algorithm": "The heuristic selects a non-dominated solution from the archive (or a random one if none exist) and applies a hybrid local search combining 3-opt and segment reversal to generate a neighbor, ensuring feasibility by reverting to 2-opt if duplicates arise. The selection prioritizes solutions with potential for improvement, while the local search balances exploration (via random edge selection) and exploitation (via segment reversal). The algorithm emphasizes diversity and non-dominated solutions while maintaining feasibility through fallback mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    # Select a candidate solution randomly (could be weighted by some metric)\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Apply segment reversal (novel operator)\n    if n > 4:\n        seg_start = np.random.randint(0, n-3)\n        seg_end = np.random.randint(seg_start+2, n)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if feasibility is violated\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9550238399732467,
            0.6674641966819763
        ],
        "raw_score": [
            6.816181892569201,
            7.370952145443657
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing trade-offs between objectives (70% weight on first objective, 30% on second) and applies a hybrid local search combining random node insertion (60% chance) and segment reversal (40% chance), ensuring feasibility by validating node uniqueness. The selected solution is modified either by moving a random node to a new position or reversing a random segment, with a fallback to the original solution if feasibility is violated. The method balances exploration and exploitation to generate high-quality neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective costs (prioritize trade-offs)\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for (sol, obj) in archive]\n    sorted_archive = sorted(zip(archive, weighted_scores), key=lambda x: x[1])\n    selection_pool = [sol_obj[0] for sol_obj in sorted_archive[:max(1, len(archive) // 2)]]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search: combine random node insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:  # Higher chance for node insertion\n        # Random node insertion: remove a node and reinsert at a random position\n        node_to_move = random.randint(0, n - 1)\n        node_val = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node_val)\n    else:\n        # Segment reversal: reverse a random segment (excluding start/end)\n        a, b = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9538494038481506,
            0.5499681830406189
        ],
        "raw_score": [
            4.780338413724691,
            7.960434820523995
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a dynamic hybrid local search that adaptively blends node swapping, segment insertion, and guided segment reversal, prioritizing solutions near the Pareto front while ensuring feasibility through explicit validation. It selects the most diverse non-dominated solution and applies one of three operators (with adjustable probabilities) to generate neighbors, reverting to the original solution if feasibility is violated. The guided reversal operator specifically seeks the most promising segment reversals based on combined objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection: filter non-dominated solutions\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in non_dominated:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with highest diversity (min distance to others)\n    def diversity_score(sol, others):\n        total_dist = 0.0\n        for other_sol, _ in others:\n            dist = np.sum(distance_matrix_1[sol[:-1], other_sol[1:]] + distance_matrix_1[sol[1:], other_sol[:-1]])\n            dist += np.sum(distance_matrix_2[sol[:-1], other_sol[1:]] + distance_matrix_2[sol[1:], other_sol[:-1]])\n            total_dist += dist\n        return total_dist\n\n    if len(non_dominated) > 1:\n        base_solution = min(non_dominated, key=lambda x: diversity_score(x[0], non_dominated))[0].copy()\n    else:\n        base_solution = non_dominated[0][0].copy()\n\n    # Dynamic hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Operator probabilities based on recent performance\n    operator_probs = [0.4, 0.3, 0.3]  # node swap, segment insert, guided reversal\n\n    op_choice = random.choices(['swap', 'insert', 'reversal'], weights=operator_probs)[0]\n\n    if op_choice == 'swap':\n        # Node swap with feasibility check\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    elif op_choice == 'insert':\n        # Segment insertion with feasibility check\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, slice(a, b+1))\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    else:  # guided reversal\n        # Guided segment reversal based on distance improvement\n        best_reversal = None\n        best_improvement = 0\n\n        for _ in range(min(5, n//2)):\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n\n            if len(set(temp_sol)) == n:\n                # Calculate improvement in both objectives\n                orig_cost1 = np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]])\n                new_cost1 = np.sum(distance_matrix_1[temp_sol[:-1], temp_sol[1:]])\n                orig_cost2 = np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]])\n                new_cost2 = np.sum(distance_matrix_2[temp_sol[:-1], temp_sol[1:]])\n\n                improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_reversal = temp_sol.copy()\n\n        if best_reversal is not None:\n            new_solution = best_reversal\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9876189601211477,
            4.570648550987244
        ],
        "raw_score": [
            10.48819208826108,
            10.626201541478995
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined costs (top 30% of sorted solutions) and applies a hybrid local search that reverses a random segment of the tour and reinserts it elsewhere, with a fallback to simple segment reversal if duplicates occur, ensuring feasibility. The selection emphasizes high-potential solutions, while the local search explores diverse neighborhood structures.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a combination of objective ranking and randomness\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to reverse and insert\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n        segment = new_solution[start:end+1]\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:start],\n            new_solution[end+1:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9031978600912173,
            0.3352429270744324
        ],
        "raw_score": [
            7.999878715084651,
            7.835523378695226
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by first identifying non-dominated solutions, then prioritizing them based on crowding distance to maintain diversity. It applies a hybrid local search operator that combines edge insertion with segment rotation (70% weight) and 3-opt with segment reversal (30% weight), biased toward the objective with higher improvement potential, while ensuring feasibility through fallback to 2-opt if duplicates occur. The selection and operator application are designed to balance exploration and exploitation in the bi-objective space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 30% non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Sort by objective values and select top 30%\n    top_n = max(1, int(0.3 * len(non_dominated)))\n    top_solutions = sorted(non_dominated, key=lambda x: (x[1][0] + x[1][1]))[:top_n]\n\n    # Calculate crowding distance for top solutions\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            obj1 = solutions[i][1][0]\n            obj2 = solutions[i][1][1]\n            left1 = solutions[i-1][1][0] if i > 0 else float('inf')\n            right1 = solutions[i+1][1][0] if i < len(solutions)-1 else float('inf')\n            left2 = solutions[i-1][1][1] if i > 0 else float('inf')\n            right2 = solutions[i+1][1][1] if i < len(solutions)-1 else float('inf')\n            dist = abs(right1 - left1) + abs(right2 - left2)\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(top_solutions)\n    selected_idx = np.argmax(distances) if distances else np.random.randint(0, len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Hybrid local search with weighted operators\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective has higher potential for improvement\n    obj1_improvement = distance_matrix_1.sum() - sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1))\n    obj2_improvement = distance_matrix_2.sum() - sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1))\n\n    # Apply operator based on improvement potential (70-30 split)\n    if obj1_improvement > obj2_improvement and np.random.rand() < 0.7:\n        # Edge insertion with segment rotation (70%)\n        if n > 3:\n            edge_idx = np.random.randint(0, n-1)\n            seg_start = np.random.randint(0, n-2)\n            seg_end = np.random.randint(seg_start+1, n)\n\n            new_solution = np.concatenate([\n                new_solution[:seg_end],\n                new_solution[edge_idx:edge_idx+2],\n                new_solution[seg_end:edge_idx],\n                new_solution[edge_idx+2:]\n            ])\n\n            rotation = np.random.randint(1, n-1)\n            new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n    else:\n        # 3-opt with segment reversal (30%)\n        if n > 4:\n            a, b, c = sorted(np.random.choice(n, 3, replace=False))\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n            seg_start = np.random.randint(0, n-3)\n            seg_end = np.random.randint(seg_start+2, n)\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590868562738475,
            0.6803237199783325
        ],
        "raw_score": [
            6.545765183433499,
            6.428480398847226
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient solution filtering (top 20%) with a dynamic operator selection that blends 5-opt segment reversals (weighted 70% by the first objective) and guided node relocations (weighted 30% by the second objective), ensuring feasibility through a minimal structural repair mechanism. It prioritizes solutions with better performance in the first objective while adaptively refining the tour based on both objectives, balancing exploration and exploitation through weighted probabilistic selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify top 20% non-dominated solutions\n    objectives = [obj for (sol, obj) in archive]\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    top_20_idx = np.random.choice(len(non_dominated), size=max(1, int(0.2 * len(non_dominated))), replace=False)\n    selected_sol, selected_obj = non_dominated[np.random.choice(top_20_idx)]\n\n    # Step 2: Dynamic operator selection based on weighted objectives\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Calculate weights for operator selection\n    total_cost = selected_obj[0] + selected_obj[1]\n    weight_obj1 = selected_obj[0] / total_cost\n    weight_obj2 = selected_obj[1] / total_cost\n\n    if random.random() < weight_obj1 * 0.7:  # 5-opt segment reversal (weighted by first objective)\n        i, j, k, l, m = sorted(np.random.choice(n, size=5, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        new_solution[m:] = new_solution[m:][::-1]\n    else:  # Guided node relocation (weighted by second objective)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if (distance_matrix_1[new_solution[i-1], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i+1]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = [x for x in new_solution if np.sum(new_solution == x) > 1]\n\n        for dup in duplicates:\n            if len(missing) == 0:\n                break\n            idx = np.where(new_solution == dup)[0][-1]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9872951015337044,
            0.7729083895683289
        ],
        "raw_score": [
            6.902974030513262,
            6.939651306937891
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse non-dominated solution from the archive using crowding distance, then applies a hybrid local search combining edge insertion and segment rotation to generate a neighbor, ensuring feasibility by validating the solution structure and falling back to a random swap if duplicates occur. The selection prioritizes solutions with higher crowding distances to maintain diversity, while the local search explores new configurations by inserting edges and rotating segments, with a fallback mechanism to handle infeasible solutions.\n\n---\n**Key Improvements in the Explanation:**\n1. **Conciseness:** Covers the core logic in under 3 sentences while referencing the Design Idea.\n2. **Critical Variables:** Highlights the crowding distance selection and hybrid local search as key design choices.\n3. **Fallback Mechanism:** Explicitly mentions the random swap as a safety net for feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance to promote diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Calculate crowding distance for non-dominated solutions\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            obj1 = solutions[i][1][0]\n            obj2 = solutions[i][1][1]\n            left1 = solutions[i-1][1][0] if i > 0 else float('inf')\n            right1 = solutions[i+1][1][0] if i < len(solutions)-1 else float('inf')\n            left2 = solutions[i-1][1][1] if i > 0 else float('inf')\n            right2 = solutions[i+1][1][1] if i < len(solutions)-1 else float('inf')\n            dist = abs(right1 - left1) + abs(right2 - left2)\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances) if distances else np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion with segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select an edge and a segment to rotate\n    if n > 3:\n        edge_idx = np.random.randint(0, n-1)\n        seg_start = np.random.randint(0, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n\n        # Insert the edge after the segment\n        new_solution = np.concatenate([\n            new_solution[:seg_end],\n            new_solution[edge_idx:edge_idx+2],\n            new_solution[seg_end:edge_idx],\n            new_solution[edge_idx+2:]\n        ])\n\n        # Rotate the segment\n        rotation = np.random.randint(1, n-1)\n        new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if duplicates occur\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7542907791875005,
            0.34506189823150635
        ],
        "raw_score": [
            8.115995381379822,
            7.8732818242440485
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (minimizing the maximum difference between the two objectives) and applies a hybrid local search combining random segment reversal and node swapping to generate a neighbor solution, ensuring feasibility by checking for duplicate or skipped nodes. The selection prioritizes balanced solutions, while the local search introduces controlled randomness to explore the solution space while maintaining validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives (minimizing the maximum difference)\n    balanced_solution = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))\n    base_solution = balanced_solution[0].copy()\n\n    # Apply hybrid local search: random segment reversal + node swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes to further diversify\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8638187835951922,
            0.45797204971313477
        ],
        "raw_score": [
            6.860477022480777,
            6.584735056343538
        ]
    },
    {
        "algorithm": "The algorithm selects from the top 15% non-dominated solutions in the archive, applies weighted 5-opt segment reversals (70% for the primary objective, 30% for the secondary), and performs guided edge insertions, while repairing infeasible solutions by replacing duplicates with nodes from the Pareto front. It prioritizes multi-objective balance by dynamically blending local search operations and ensuring feasibility through Pareto-aligned repairs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify top 15% non-dominated solutions\n    objectives = [obj for (_, obj) in archive]\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for (sol, _) in archive]\n\n    top_15_idx = np.random.choice(len(non_dominated), size=max(1, int(0.15 * len(non_dominated))), replace=False)\n    base_solution = non_dominated[np.random.choice(top_15_idx)].copy()\n\n    # Step 2: Hybrid 5-opt + guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 5:\n        # 5-opt segment reversals (weighted by objectives)\n        points = sorted(np.random.choice(n, size=5, replace=False))\n        if np.random.rand() < 0.7:  # 70% for primary objective\n            new_solution[points[0]:points[1]+1] = new_solution[points[0]:points[1]+1][::-1]\n            new_solution[points[2]:points[3]+1] = new_solution[points[2]:points[3]+1][::-1]\n        else:  # 30% for secondary objective\n            new_solution[points[1]:points[2]+1] = new_solution[points[1]:points[2]+1][::-1]\n            new_solution[points[3]:points[4]+1] = new_solution[points[3]:points[4]+1][::-1]\n\n        # Guided edge insertion\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Step 3: Feasibility repair (Pareto-aligned)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Replace duplicates with nodes from the Pareto front\n        pareto_nodes = set()\n        for obj in objectives:\n            if not any((o[0] <= obj[0] and o[1] <= obj[1] and (o[0] < obj[0] or o[1] < obj[1])) for o in objectives):\n                pareto_nodes.update(archive[objectives.index(obj)][0])\n\n        for i in range(n):\n            if np.sum(new_solution == new_solution[i]) > 1:\n                for node in pareto_nodes:\n                    if node not in new_solution:\n                        new_solution[i] = node\n                        break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9576829478487416,
            0.7345039248466492
        ],
        "raw_score": [
            7.007691097490243,
            7.390722613802445
        ]
    },
    {
        "algorithm": "The algorithm selects top 30% of non-dominated solutions from the archive, prioritizing solutions with better performance in the first objective (70%) over the second (30%). It then applies a hybrid local search combining 3-opt edge modifications with guided segment reversals to generate improved neighbors, ensuring feasibility through validation and fallback mechanisms. The method intelligently balances exploration and exploitation by focusing on high-potential solutions and using randomized yet directed improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 30% non-dominated solutions based on weighted objectives\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for (sol, obj) in archive]\n    sorted_archive = sorted(zip(archive, weighted_scores), key=lambda x: x[1])\n    selection_pool = [sol_obj[0] for sol_obj in sorted_archive[:max(1, len(archive) // 3)]]\n\n    # Filter non-dominated solutions from the selection pool\n    non_dominated = []\n    for sol, obj in selection_pool:\n        dominated = False\n        for other_sol, other_obj in selection_pool:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = selection_pool\n\n    selected_idx = np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with guided segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify (3-opt)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Guided segment reversal based on improvement\n    best_reversal = None\n    best_improvement = 0\n\n    for _ in range(min(5, n//2)):\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        temp_sol = new_solution.copy()\n        temp_sol[i:j] = temp_sol[i:j][::-1]\n\n        if len(np.unique(temp_sol)) == n:\n            # Calculate improvement in both objectives\n            orig_cost1 = np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]])\n            new_cost1 = np.sum(distance_matrix_1[temp_sol[:-1], temp_sol[1:]])\n            orig_cost2 = np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]])\n            new_cost2 = np.sum(distance_matrix_2[temp_sol[:-1], temp_sol[1:]])\n\n            improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_reversal = temp_sol.copy()\n\n    if best_reversal is not None:\n        new_solution = best_reversal\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if duplicates occur\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9623038056368216,
            1.3644100427627563
        ],
        "raw_score": [
            5.074746147336339,
            7.536110033643055
        ]
    }
]