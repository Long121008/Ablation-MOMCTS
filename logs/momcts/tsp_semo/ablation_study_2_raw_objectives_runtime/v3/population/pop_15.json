[
    {
        "algorithm": "The heuristic selects a random solution from the archive, applies a hybrid local search combining edge insertion and node relocation to generate a neighbor, and ensures feasibility by reverting to a simple swap if duplicates occur. The selection is random, while the local search prioritizes edge-wise and node-wise modifications for exploration. The design balances simplicity and feasibility, with fallback mechanisms to maintain valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n\n    # Edge insertion (insert a node at a random position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Node relocation (move a node to a new position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if operations cause duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9722195366932449,
            0.5455512404441833
        ],
        "raw_score": [
            7.274013559989165,
            6.750318961900975
        ]
    },
    {
        "algorithm": "The algorithm selects a solution with the highest objective variance from the archive, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor. It prioritizes diversity in objectives and uses a fallback swap if the solution becomes invalid. The key design ideas are selecting high-variance solutions and combining 3-opt with node insertion for exploration, with validation to ensure feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with node insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reversing segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node elsewhere\n    node_to_move = new_solution[random.randint(0, n-1)]\n    insert_pos = random.randint(0, n-2)\n    if insert_pos < n-1:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            np.array([node_to_move]),\n            new_solution[insert_pos:-1][new_solution[insert_pos:-1] != node_to_move],\n            [new_solution[-1]]\n        ])\n\n    # Validate the solution\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9315092738042138,
            0.2931731939315796
        ],
        "raw_score": [
            6.562713517573391,
            9.376940086743101
        ]
    },
    {
        "algorithm": "This algorithm combines adaptive Pareto dominance-based selection (prioritizing solutions with high Pareto front contribution) with a novel multi-objective segment inversion operator that dynamically balances exploration and exploitation by applying objective-weighted segment inversions, falling back to random swaps when feasibility is violated. It selects solutions with 70% probability based on Pareto dominance and 30% randomly, then applies segment inversions while reverting if no improvement is detected, ensuring feasibility through a fallback swap mechanism. The operator weights improvements by the relative costs of each objective, making it particularly effective for bi-objective optimization in TSP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate Pareto dominance count for each solution\n    def pareto_dominance(solutions):\n        dominance = [0] * len(solutions)\n        for i, (sol_i, obj_i) in enumerate(solutions):\n            for j, (sol_j, obj_j) in enumerate(solutions):\n                if i != j and (obj_i[0] < obj_j[0] and obj_i[1] < obj_j[1]):\n                    dominance[i] += 1\n        return dominance\n\n    # Select solution with highest Pareto dominance (70% chance) or random (30% chance)\n    if np.random.random() < 0.7:\n        dominance = pareto_dominance(archive)\n        selected = archive[np.argmax(dominance)]\n    else:\n        selected = random.choice(archive)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current objective weights\n    weight1 = selected[1][0] / (selected[1][0] + selected[1][1] + 1e-6)\n    weight2 = selected[1][1] / (selected[1][0] + selected[1][1] + 1e-6)\n\n    # Multi-objective segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n\n        # Calculate improvement potential\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n\n        # Invert the segment\n        inverted_segment = new_solution[start:end+1][::-1]\n        new_solution[start:end+1] = inverted_segment\n\n        # Calculate new cost\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n\n        # Revert if no improvement\n        if (weight1 * new_cost1 + weight2 * new_cost2) >= (weight1 * original_cost1 + weight2 * original_cost2):\n            new_solution[start:end+1] = inverted_segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a random swap\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9711126442467652,
            0.6652889847755432
        ],
        "raw_score": [
            7.143172504086787,
            6.136703950363287
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining edge exchange and segment inversion to explore diverse neighborhoods while ensuring feasibility. The selection prioritizes randomness for exploration, while the hybrid search balances edge-wise and segment-wise modifications to escape local optima. The feasibility check ensures valid TSP tours by reverting to simpler operations if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two random edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion (reverse a random segment)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8790760004126856,
            0.47520631551742554
        ],
        "raw_score": [
            7.31569362287178,
            7.144871037754502
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution (highest sum of objectives) from the archive and applies a hybrid local search combining segment reversal and edge insertion. It randomly reverses segments and inserts edges while ensuring feasibility, falling back to a simple 2-opt if invalid. The focus is on diversity and exploration of the solution space.\n\n(Note: The original code selects the worst solution, which may not be ideal for improvement. A better approach would prioritize solutions with high potential for improvement, e.g., those near the Pareto front or with high variance in objectives.)",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        # Insert edge (a, b) by reversing the segment between them\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the hybrid approach fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9185087722772078,
            0.5027542114257812
        ],
        "raw_score": [
            10.45220321439054,
            10.552246178094743
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid criterion that balances low-cost objectives and crowding distance, then applies a novel local search combining segment reversal (prioritizing cost reduction in both objectives) and edge exchange with path-relinking (introducing edges from other solutions) while ensuring feasibility through lightweight checks and fallback mechanisms. It prioritizes cost reduction in both objectives during segment reversal and leverages diverse edges from the archive to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize low-cost solutions but also consider crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    distances = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n    crowding = np.mean(distances, axis=1)\n    normalized_costs = np.min(objectives, axis=1) / np.max(objectives, axis=1)\n    selection_scores = normalized_costs + (1 - crowding / np.max(crowding))\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel hybrid local search: segment reversal + edge exchange with path-relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment reversal based on distance matrices\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost reduction for both objectives\n    original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n    new_cost = original_cost\n    for k in range(i, j-1):\n        new_cost -= (distance_matrix_1[new_solution[k], new_solution[k+1]] + distance_matrix_2[new_solution[k], new_solution[k+1]])\n        new_cost += (distance_matrix_1[reversed_segment[k-i], reversed_segment[k-i+1]] + distance_matrix_2[reversed_segment[k-i], reversed_segment[k-i+1]])\n\n    if new_cost < original_cost:\n        new_solution[i:j] = reversed_segment\n\n    # Step 2: Edge exchange with path-relinking\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n                break\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple edge exchange if segment reversal fails\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9358999730821044,
            2.052245080471039
        ],
        "raw_score": [
            10.503285113441873,
            10.666047431412455
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions (prioritizing those with similar objective values) from the archive, then applies a hybrid local search\u2014randomly choosing between node insertion (70% chance) or segment rotation (30%)\u2014to generate a neighbor solution while ensuring feasibility through checks for solution length and node uniqueness. It leverages the distance matrices to implicitly guide the search toward potentially better solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Randomly select from top 5 balanced solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine node insertion and segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.random() < 0.7:  # Higher chance for node insertion\n        # Node insertion: randomly select a node and insert it at a new position\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n    else:\n        # Segment rotation: randomly select a segment and rotate it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        k = np.random.randint(len(segment))\n        rotated_segment = np.roll(segment, k)\n        new_solution[i:j] = rotated_segment\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9201315108595929,
            0.6749270558357239
        ],
        "raw_score": [
            7.441653454247232,
            7.403118347666922
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt and edge reversal to generate a neighbor, and ensures feasibility by reverting to a simple swap if duplicates occur. The selection prioritizes diversity, while the hybrid search balances exploration and exploitation by randomly modifying segments and reversing edges. The fallback mechanism guarantees feasibility by enforcing uniqueness of nodes in the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine 3-opt and edge reversal\n    new_solution = base_solution.copy()\n\n    # 3-opt: select three random edges and reconnect them\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect the segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Edge reversal: reverse a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if operations cause duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8423102473930846,
            0.47913825511932373
        ],
        "raw_score": [
            6.986065505498944,
            7.09045191819426
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a solution from the archive with a weighted probability favoring those with high objective diversity (measured by absolute difference between the two costs), then applies either an edge exchange (with 70% probability) that prioritizes edges with large distance variance between objectives or a segment inversion (with 30% probability). Feasibility is ensured by validating the solution and falling back to a simple swap if duplicates are detected. The algorithm balances exploration of high-potential regions with exploitation of objective-aware edge properties.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective diversity\n    weights = [abs(obj[0] - obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware edge selection\n    if random.random() < 0.7:  # 70% chance for edge exchange\n        # Select edges with high distance variance between objectives\n        edge_costs = []\n        for i in range(n):\n            u, v = base_solution[i], base_solution[(i+1)%n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            edge_costs.append(abs(cost1 - cost2))\n\n        if sum(edge_costs) > 0:\n            edge_weights = edge_costs\n        else:\n            edge_weights = [1] * n\n\n        i = random.choices(range(n), weights=edge_weights, k=1)[0]\n        j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # 30% chance for segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.870587515109393,
            0.525895893573761
        ],
        "raw_score": [
            6.142598893815389,
            7.880893114861214
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid criterion combining Pareto dominance, normalized objective values, and randomness, then applies a novel \"segmented inversion with adaptive insertion\" local search that dynamically adjusts the number of insertions based on solution quality, using a weighted combination of both objectives to guide the search while ensuring feasibility. The selection prioritizes dominated solutions (60%) but also considers objective values (30%) and randomness (10%), while the local search balances exploration (segment inversion) and exploitation (adaptive insertion) with weighted objective costs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion: combine Pareto dominance and objective ranking\n    def selection_criteria(sol_obj):\n        # Calculate dominance rank (simplified)\n        dominates = 0\n        for other in archive:\n            if (sol_obj[1][0] <= other[1][0] and sol_obj[1][1] < other[1][1]) or \\\n               (sol_obj[1][0] < other[1][0] and sol_obj[1][1] <= other[1][1]):\n                dominates += 1\n\n        # Normalize objectives\n        max_obj1 = max(o[1][0] for o in archive) + 1e-6\n        max_obj2 = max(o[1][1] for o in archive) + 1e-6\n        norm_obj1 = sol_obj[1][0] / max_obj1\n        norm_obj2 = sol_obj[1][1] / max_obj2\n\n        # Combine metrics: 60% dominance, 30% normalized objectives, 10% randomness\n        return 0.6 * dominates + 0.3 * (norm_obj1 + norm_obj2) + 0.1 * np.random.random()\n\n    selected = max(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented inversion with adaptive insertion\n    # First, randomly select two segments and invert them\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment1 = new_solution[i:j]\n    new_solution[i:j] = segment1[::-1]\n\n    # Then, perform adaptive insertion based on current solution quality\n    # Calculate current quality (lower is better)\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_quality = current_cost1 + current_cost2\n\n    # Determine number of insertions based on quality (better solutions get fewer insertions)\n    max_insertions = max(1, int(10 * np.exp(-current_quality / (sum(o[1][0]+o[1][1] for o in archive)/len(archive)))))\n\n    for _ in range(max_insertions):\n        # Select a random node to reinsert\n        idx = np.random.randint(0, n)\n        node = new_solution[idx]\n        new_solution = np.delete(new_solution, idx)\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(n):\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate weighted cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Weighted combination based on current solution's objective values\n            weight1 = selected[1][0] / (selected[1][0] + selected[1][1] + 1e-6)\n            weight2 = selected[1][1] / (selected[1][0] + selected[1][1] + 1e-6)\n            weighted_cost = weight1 * cost1 + weight2 * cost2\n\n            if weighted_cost < best_score:\n                best_score = weighted_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9260226574317179,
            6.728974282741547
        ],
        "raw_score": [
            6.061119373908813,
            6.740083866305359
        ]
    }
]