[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (30% for the first objective, 70% for the second), then applies a hybrid local search combining edge reversal and a novel node reordering strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The weighted selection prioritizes solutions with better performance in the second objective, while the local search explores new configurations by reversing segments and shuffling sub-sequences.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.3*obj1 + 0.7*obj2)\n    selected = max(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal with node reordering\n    if n >= 3:\n        # Step 1: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Novel node reordering in a sub-sequence\n        sub_start = np.random.randint(0, n - 2)\n        sub_end = np.random.randint(sub_start + 2, min(sub_start + 6, n))\n        sub_seq = new_solution[sub_start:sub_end]\n        np.random.shuffle(sub_seq)\n        new_solution[sub_start:sub_end] = sub_seq\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9955506201873332,
            0.5729128122329712
        ],
        "raw_score": [
            10.473809131272606,
            10.692212489823685
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on its quality relative to the average cost, then applies a hybrid local search combining probabilistic edge reversal and adaptive segment relocation to generate a neighbor solution while maintaining feasibility through constrained segment manipulation. The selection prioritizes solutions near the average cost with slight randomness, while the local search focuses on small-scale perturbations (edges and segments) with adaptive segment sizes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on solution quality\n    total_costs = [sum(obj) for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    selected = min(archive, key=lambda x: abs(sum(x[1]) - avg_cost) * (1 + np.random.random()))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation\n    if n >= 5:\n        # Step 1: Probabilistic edge reversal\n        for i in range(n - 1):\n            if np.random.random() < 0.2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Step 2: Adaptive segment relocation\n        seg_size = min(3, max(2, int(np.random.normal(2.5, 0.5))))\n        seg_start = np.random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n        insert_pos = np.random.randint(0, n - seg_size)\n        if insert_pos >= seg_start:\n            insert_pos += seg_size\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_size:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7401874502706116,
            0.32838261127471924
        ],
        "raw_score": [
            7.617947148898726,
            8.118519850301334
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted objective (60% second objective, 40% first objective) and applies a hybrid local search combining random node insertion and segment reversal to generate a neighbor solution while ensuring feasibility. The method prioritizes diversification by favoring solutions with better performance in the second objective while still considering the first objective, and it explores the solution space through non-standard moves beyond typical 2-opt operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.6*obj2 + 0.4*obj1)\n    selected = max(archive, key=lambda x: 0.6 * x[1][1] + 0.4 * x[1][0])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with segment reversal\n    if n >= 4:\n        # Step 1: Random node insertion\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Segment reversal\n        seg_start = np.random.randint(0, n - 3)\n        seg_end = np.random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution[seg_start:seg_end] = segment[::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9187942615714717,
            0.5609147548675537
        ],
        "raw_score": [
            10.502911486257478,
            10.571506545395131
        ]
    },
    {
        "algorithm": "The algorithm combines **adaptive Pareto frontier sampling** (prioritizing solutions with high crowding distance) with a **segmented crossover operator** that dynamically blends segments from diverse archive solutions, using a **hybrid objective weighting scheme** to evaluate segment quality while ensuring feasibility through **multi-stage validation**. It balances exploration and exploitation by probabilistically selecting segments from multiple solutions, with segment sizes and positions determined by both objective-aware metrics and spatial proximity in the coordinate spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto frontier sampling with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select multiple diverse solutions for segment crossover\n    selected_indices = np.argsort(-crowding_dist)[:min(3, len(archive))]\n    base_solution = archive[selected_indices[0]][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented crossover operator\n    if len(selected_indices) > 1:\n        # Select random segments from diverse solutions\n        segment_length = np.random.randint(2, min(4, n // 2))\n        for idx in selected_indices[1:]:\n            donor = archive[idx][0]\n            start = np.random.randint(0, n - segment_length)\n            segment = donor[start:start+segment_length]\n\n            # Find insertion point in new_solution that maintains spatial proximity\n            best_pos = start\n            min_cost = float('inf')\n            for pos in range(n - segment_length + 1):\n                # Evaluate insertion using hybrid objective weights\n                weight1 = 0.5 + 0.3 * (np.std(objectives[:, 0]) / (np.mean(objectives[:, 0]) + 1e-10))\n                weight2 = 0.5 + 0.3 * (np.std(objectives[:, 1]) / (np.mean(objectives[:, 1]) + 1e-10))\n\n                # Calculate cost before and after insertion\n                cost_before = 0\n                cost_after = 0\n                for i in range(pos - 1, pos + segment_length + 1):\n                    i = i % n\n                    j = (i + 1) % n\n                    cost_before += weight1 * distance_matrix_1[new_solution[i], new_solution[j]] + weight2 * distance_matrix_2[new_solution[i], new_solution[j]]\n\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n                for i in range(pos - 1, pos + segment_length + 1):\n                    i = i % n\n                    j = (i + 1) % n\n                    cost_after += weight1 * distance_matrix_1[temp_solution[i], temp_solution[j]] + weight2 * distance_matrix_2[temp_solution[i], temp_solution[j]]\n\n                if cost_after < min_cost:\n                    min_cost = cost_after\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos+segment_length:]])\n\n    # Multi-stage validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair missing nodes by inserting them at positions that minimize cost\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(n + 1):\n                temp_solution = np.insert(new_solution, pos, node)\n                cost = 0\n                for i in range(n):\n                    j = (i + 1) % (n + 1)\n                    cost += distance_matrix_1[temp_solution[i], temp_solution[j]] + distance_matrix_2[temp_solution[i], temp_solution[j]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0218214740148481,
            12.304687201976776
        ],
        "raw_score": [
            10.455947482879868,
            10.654918945587069
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-aware selection with a hybrid local search strategy, first filtering solutions to retain non-dominated ones and selecting a base solution using a weighted crowding-distance metric. It then applies a dynamic 4-opt reconnection and conditional edge swaps, with adaptive weights based on objective dominance, while occasionally inserting random node segments for exploration. Feasibility is maintained by validating all moves, and the method prioritizes edge swaps when objectives are balanced and 4-opt when one objective dominates.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: retain non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Weighted crowding-distance selection\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(non_dominated):\n        if i == 0:\n            left = non_dominated[-1][1]\n            right = non_dominated[1][1] if len(non_dominated) > 1 else non_dominated[0][1]\n        elif i == len(non_dominated) - 1:\n            left = non_dominated[i-1][1]\n            right = non_dominated[0][1]\n        else:\n            left = non_dominated[i-1][1]\n            right = non_dominated[i+1][1]\n\n        # Dynamic weights based on objective dominance\n        weight_obj1 = 1.0 if obj[0] < obj[1] else 0.7\n        weight_obj2 = 1.0 if obj[1] < obj[0] else 0.7\n        dist = (abs(obj[0] - left[0]) + abs(obj[0] - right[0])) * weight_obj1 + (abs(obj[1] - left[1]) + abs(obj[1] - right[1])) * weight_obj2\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 4-opt with conditional edge swaps\n    if n >= 5:\n        # Step 1: Select four distinct nodes\n        a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n        # Step 2: Generate all possible 4-opt reconnections\n        options = [\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:d], new_solution[d:]]),\n            np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], new_solution[a:b], new_solution[d:]]),\n            np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:d], new_solution[d:]]),\n            np.concatenate([new_solution[:b], new_solution[c:d], new_solution[a:c], new_solution[b:a], new_solution[d:]])\n        ]\n\n        # Step 3: Evaluate all options and select the best one\n        best_option = None\n        best_cost = float('inf')\n\n        for option in options:\n            total_cost = 0\n            for i in range(n):\n                j = (i + 1) % n\n                total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_option = option.copy()\n\n        if best_option is not None:\n            new_solution = best_option\n\n        # Step 4: Conditional edge swaps for exploitation\n        if np.random.random() < 0.3:\n            for i in range(n - 1):\n                if np.random.random() < 0.2 and (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]]) > (distance_matrix_1[new_solution[i+1], new_solution[i]] + distance_matrix_2[new_solution[i+1], new_solution[i]]):\n                    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Step 5: Adaptive node segment insertion for exploration\n    if np.random.random() < 0.2:\n        seg_size = min(3, max(1, int(np.random.normal(2, 0.5))))\n        seg_start = np.random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n        insert_pos = np.random.randint(0, n - seg_size)\n        if insert_pos >= seg_start:\n            insert_pos += seg_size\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_size:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7553705524764028,
            0.5117065906524658
        ],
        "raw_score": [
            7.171694242445008,
            7.123075592354592
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-optimality filtering with a crowding-distance-based selection to prioritize diverse non-dominated solutions, then applies a hybrid 4-opt and edge-swap strategy to generate high-quality neighbors while ensuring feasibility through validation. It balances exploration and exploitation by adaptively evaluating multiple reconnection options and occasionally performing random edge swaps, with a fallback to the original solution if invalidity is detected.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: retain non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(non_dominated):\n        if i == 0:\n            left = non_dominated[-1][1]\n            right = non_dominated[1][1] if len(non_dominated) > 1 else non_dominated[0][1]\n        elif i == len(non_dominated) - 1:\n            left = non_dominated[i-1][1]\n            right = non_dominated[0][1]\n        else:\n            left = non_dominated[i-1][1]\n            right = non_dominated[i+1][1]\n\n        dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 4-opt with edge-swap validation\n    if n >= 5:\n        # Select four distinct edges\n        a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n        # Generate all possible 4-opt reconnections\n        options = [\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[d:], new_solution[c:d]]),\n            np.concatenate([new_solution[:a], new_solution[d:], new_solution[b:c], new_solution[a:b], new_solution[c:d]]),\n            np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[d:], new_solution[c:d]]),\n            np.concatenate([new_solution[:b], new_solution[d:], new_solution[a:c], new_solution[b:a], new_solution[c:d]])\n        ]\n\n        # Evaluate all options and select the best one\n        best_option = None\n        best_cost = float('inf')\n\n        for option in options:\n            total_cost = 0\n            for i in range(n):\n                j = (i + 1) % n\n                total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_option = option.copy()\n\n        if best_option is not None:\n            new_solution = best_option\n\n        # Conditional edge swap for exploration\n        if np.random.random() < 0.3:\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            while abs(i - j) <= 1:\n                i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if i != 0 and j != n-1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8137580809726357,
            0.5121712684631348
        ],
        "raw_score": [
            7.695640846693296,
            7.2402566047336725
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding-distance-based selection, then applies a hybrid 3-opt local search with adaptive node insertion, evaluating all possible 3-opt reconnections and occasionally inserting a random node for exploration while ensuring feasibility. It prioritizes solutions with high crowding distance in the objective space and balances exploitation (3-opt) with exploration (adaptive insertion), with a 25% chance of applying the latter. The final solution is validated to ensure it remains a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            left = archive[-1][1]\n            right = archive[1][1] if len(archive) > 1 else archive[0][1]\n        elif i == len(archive) - 1:\n            left = archive[i-1][1]\n            right = archive[0][1]\n        else:\n            left = archive[i-1][1]\n            right = archive[i+1][1]\n\n        dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid 3-opt with adaptive node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select three distinct nodes\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Step 2: Generate all possible 3-opt reconnections\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[c:], new_solution[b:c], new_solution[a:b]]),\n        np.concatenate([new_solution[:b], new_solution[a:c], new_solution[b:a], new_solution[c:]]),\n        np.concatenate([new_solution[:b], new_solution[c:], new_solution[a:c], new_solution[b:a]])\n    ]\n\n    # Step 3: Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Step 4: Adaptive node insertion for exploration\n    if np.random.random() < 0.25:  # 25% chance to apply node insertion\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        while abs(i - j) <= 1:\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.694207543171247,
            0.38689321279525757
        ],
        "raw_score": [
            7.051319865362183,
            7.193925202037143
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid objective-diversity score (60% objective, 40% diversity), then applies a multi-segment relocation strategy that considers both objective spaces, with probabilistic segment inversion and adaptive segment merging to explore the solution space effectively. It prioritizes balanced exploration of both objectives (50% weight each) and uses segment-based operations to avoid standard 2-opt limitations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection mechanism combining objective values and solution diversity\n    objective_scores = np.array([(obj[0] + obj[1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2) + 1e-10)\n                                for _, obj in archive])\n    diversity_scores = np.array([np.sum(np.abs(np.diff(sol))) / len(sol) for sol, _ in archive])\n    combined_scores = 0.6 * objective_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-segment relocation strategy\n    if n >= 6:\n        segment_lengths = np.random.choice([2, 3], size=2)\n        start_positions = sorted(np.random.choice(n, size=2, replace=False))\n        segments = [new_solution[start_positions[i]:start_positions[i]+segment_lengths[i]] for i in range(2)]\n\n        # Evaluate insertion points considering both objectives\n        best_positions = []\n        for seg_idx, segment in enumerate(segments):\n            best_pos = -1\n            best_cost = float('inf')\n            for pos in range(n - len(segment) + 1):\n                if any(pos <= start_positions[i] < pos + len(segment) for i in range(2)):\n                    continue\n\n                temp_sol = new_solution.copy()\n                temp_sol = np.concatenate([\n                    temp_sol[:pos],\n                    segment,\n                    np.delete(temp_sol, [start_positions[seg_idx] + i for i in range(len(segment))])\n                ])\n\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n                weighted_cost = 0.5 * cost1 + 0.5 * cost2\n\n                if weighted_cost < best_cost:\n                    best_cost = weighted_cost\n                    best_pos = pos\n            best_positions.append(best_pos if best_pos != -1 else np.random.randint(0, n - len(segment) + 1))\n\n        # Apply the best found insertions\n        for seg_idx, segment in enumerate(segments):\n            pos = best_positions[seg_idx]\n            new_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, [start_positions[seg_idx] + i for i in range(len(segment))])\n            ])\n\n    # Adaptive segment merging with probabilistic inversion\n    if n >= 4 and np.random.random() < 0.4:\n        merge_points = sorted(np.random.choice(n, size=2, replace=False))\n        a, b = merge_points\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Evaluate merging options\n        options = [\n            np.concatenate([segment1, segment2, segment3]),  # Original\n            np.concatenate([segment1, segment3, segment2]),  # Swap middle segments\n            np.concatenate([segment2, segment1, segment3]),  # Rotate\n            np.concatenate([segment3, segment1, segment2])   # Reverse rotate\n        ]\n\n        # Evaluate each option\n        best_option = options[0]\n        best_cost = float('inf')\n        for option in options:\n            cost1 = sum(distance_matrix_1[option[i], option[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_option = option\n\n        new_solution = best_option\n\n    # Final probabilistic inversion for diversity\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9954879138255571,
            5.736187040805817
        ],
        "raw_score": [
            10.521909240547783,
            10.633749038399056
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on normalized objective values, then applies a hybrid local search combining a novel 5-opt move and adaptive edge swaps to generate a neighbor solution. The 5-opt reconnects five non-adjacent edges to reduce cost in both objective spaces, while adaptive swaps dynamically adjust the acceptance threshold based on the current solution's quality. The algorithm prioritizes solutions with higher normalized objective sums and ensures feasibility by maintaining a valid TSP tour throughout the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high normalized objective sum\n    normalized_objects = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / max(o[0] for _, o in archive), obj[1] / max(o[1] for _, o in archive))\n        normalized_objects.append(sum(norm_obj))\n    selected_idx = np.argmax(normalized_objects)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 5-opt with adaptive edge swaps\n    if n >= 8:\n        # Select 5 non-adjacent edges\n        points = sorted(np.random.choice(n, 5, replace=False))\n        while any(abs(points[i] - points[i+1]) <= 1 for i in range(4)):\n            points = sorted(np.random.choice(n, 5, replace=False))\n\n        # Reconnect edges to form a new cycle\n        for i in range(2):\n            new_solution[points[i]+1:points[i+1]+1] = new_solution[points[i]+1:points[i+1]+1][::-1]\n\n        # Adaptive edge swaps\n        current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        threshold = current_cost * 0.95  # 5% improvement threshold\n\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            while abs(a - b) <= 1:\n                a, b = sorted(np.random.choice(n, 2, replace=False))\n\n            cost_after = (current_cost -\n                          distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] -\n                          distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] -\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                          distance_matrix_1[new_solution[a], new_solution[b]] +\n                          distance_matrix_2[new_solution[a], new_solution[b]] +\n                          distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]] +\n                          distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n\n            if cost_after < threshold:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                current_cost = cost_after\n                threshold = current_cost * 0.95\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9901043979175816,
            3.6194695830345154
        ],
        "raw_score": [
            10.452823570295662,
            10.580843633434633
        ]
    },
    {
        "algorithm": "The algorithm implements a hybrid local search strategy that selects promising solutions from an archive using crowding distance (favoring non-dominated solutions with better combined objectives), then applies a novel \"segmented edge rotation\" operator with adaptive segment lengths and conditional edge swaps to generate neighbors while maintaining feasibility through uniqueness checks. It prioritizes non-dominated solutions and balances exploration/exploitation through probabilistic segment operations and objective-aware edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential using crowding distance\n    crowding = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated += 1\n        crowding.append((dominated, obj))\n\n    selected = min(crowding, key=lambda x: (x[0], sum(x[1])))\n    base_solution = next(sol for sol, obj in archive if obj == selected[1]).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented edge rotation with adaptive segment length\n    if n >= 4:\n        segment_length = max(2, min(5, int(n * np.random.uniform(0.2, 0.4))))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment with 50% probability\n        if np.random.random() < 0.5:\n            rotation = np.random.randint(1, segment_length)\n            segment = np.roll(segment, rotation)\n        else:\n            segment = segment[::-1]\n\n        new_solution[start:start+segment_length] = segment\n\n        # Conditional edge rotations\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and abs(i - j) > 1:\n                a, b = new_solution[i], new_solution[(i+1)%n]\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b]\n                cost_after = distance_matrix_1[a, c] + distance_matrix_1[b, d] + distance_matrix_2[a, c] + distance_matrix_2[b, d]\n                if cost_after < cost_before or np.random.random() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9187558219348195,
            1.462942123413086
        ],
        "raw_score": [
            6.881572597557204,
            7.037591893314195
        ]
    }
]