[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (30% for the first objective, 70% for the second), then applies a hybrid local search combining edge reversal and a novel node reordering strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The weighted selection prioritizes solutions with better performance in the second objective, while the local search explores new configurations by reversing segments and shuffling sub-sequences.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.3*obj1 + 0.7*obj2)\n    selected = max(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal with node reordering\n    if n >= 3:\n        # Step 1: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Novel node reordering in a sub-sequence\n        sub_start = np.random.randint(0, n - 2)\n        sub_end = np.random.randint(sub_start + 2, min(sub_start + 6, n))\n        sub_seq = new_solution[sub_start:sub_end]\n        np.random.shuffle(sub_seq)\n        new_solution[sub_start:sub_end] = sub_seq\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9955506201873332,
            0.5729128122329712
        ],
        "raw_score": [
            10.473809131272606,
            10.692212489823685
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on its quality relative to the average cost, then applies a hybrid local search combining probabilistic edge reversal and adaptive segment relocation to generate a neighbor solution while maintaining feasibility through constrained segment manipulation. The selection prioritizes solutions near the average cost with slight randomness, while the local search focuses on small-scale perturbations (edges and segments) with adaptive segment sizes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on solution quality\n    total_costs = [sum(obj) for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    selected = min(archive, key=lambda x: abs(sum(x[1]) - avg_cost) * (1 + np.random.random()))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation\n    if n >= 5:\n        # Step 1: Probabilistic edge reversal\n        for i in range(n - 1):\n            if np.random.random() < 0.2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Step 2: Adaptive segment relocation\n        seg_size = min(3, max(2, int(np.random.normal(2.5, 0.5))))\n        seg_start = np.random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n        insert_pos = np.random.randint(0, n - seg_size)\n        if insert_pos >= seg_start:\n            insert_pos += seg_size\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_size:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7401874502706116,
            0.32838261127471924
        ],
        "raw_score": [
            7.617947148898726,
            8.118519850301334
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted objective (60% second objective, 40% first objective) and applies a hybrid local search combining random node insertion and segment reversal to generate a neighbor solution while ensuring feasibility. The method prioritizes diversification by favoring solutions with better performance in the second objective while still considering the first objective, and it explores the solution space through non-standard moves beyond typical 2-opt operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.6*obj2 + 0.4*obj1)\n    selected = max(archive, key=lambda x: 0.6 * x[1][1] + 0.4 * x[1][0])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion with segment reversal\n    if n >= 4:\n        # Step 1: Random node insertion\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Segment reversal\n        seg_start = np.random.randint(0, n - 3)\n        seg_end = np.random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution[seg_start:seg_end] = segment[::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9187942615714717,
            0.5609147548675537
        ],
        "raw_score": [
            10.502911486257478,
            10.571506545395131
        ]
    },
    {
        "algorithm": "The algorithm selects a promising TSP solution from an archive by prioritizing those with higher objective values, then applies a hybrid local search combining a novel path reversal and a guided edge swap. It ensures feasibility by validating all moves and prioritizes improvements based on both objectives, with path reversal acting as a diversification step and edge swaps focusing on cost reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high diversity and potential improvement\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel path reversal operator\n    if n >= 4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Guided edge swap with objective-aware selection\n    if n >= 4:\n        improvements = []\n        for i in range(n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            for j in range(n):\n                if j == i or j == (i+1)%n:\n                    continue\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_1[c, d] + distance_matrix_2[c, d]\n                cost_after = distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_1[b, d] + distance_matrix_2[b, d]\n                improvement = cost_before - cost_after\n                if improvement > 0:\n                    improvements.append((improvement, i, j))\n\n        if improvements:\n            improvements.sort(reverse=True, key=lambda x: x[0])\n            best_improvement, i, j = improvements[0]\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9666645385568962,
            2.3527796864509583
        ],
        "raw_score": [
            10.441985295776638,
            10.72303720980633
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid objective weighting scheme (prioritizing either the first or second objective with 40-60% weights), then applies dynamic segment inversion and probabilistic node swapping to generate a neighbor solution. It ensures feasibility through a two-phase validation process, restoring missing nodes if needed and reverting to the original solution if invalid. The selection mechanism balances exploration (random weights) and exploitation (objective-aware probabilities), while the local search operators introduce diversity while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection mechanism\n    objectives = np.array([(obj1, obj2) for _, (obj1, obj2) in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    weights = np.array([0.4, 0.6]) if np.random.random() < 0.5 else np.array([0.6, 0.4])\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic segment inversion\n    segment_length = np.random.randint(2, min(4, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution[start:start+segment_length] = segment[::-1]\n\n    # Probabilistic node swapping with objective-aware probability\n    swap_prob = 0.2 + 0.3 * (1 - np.mean([scores[selected_idx] / np.max(scores)]))\n    for i in range(len(new_solution)):\n        if np.random.random() < swap_prob:\n            j = np.random.randint(0, len(new_solution))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Two-phase feasibility validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Phase 1: Attempt to fix by restoring missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Phase 2: Final validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If still invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.920489048706393,
            0.6569715738296509
        ],
        "raw_score": [
            7.092277860082971,
            7.9220401475402555
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted sum of objectives (70% first objective, 30% second objective), then applies a hybrid local search combining random node swapping and segment rotation to generate a neighbor solution while ensuring feasibility by validating node uniqueness. If the neighbor violates feasibility, it reverts to the original solution. The approach prioritizes the first objective (70%) while still considering the second objective (30%) for selection, and uses creative local search operators beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best weighted combination of objectives\n    def weighted_score(obj):\n        return 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n\n    selected = min(archive, key=lambda x: weighted_score(x[1]))[0].copy()\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid local search: node swapping and segment rotation\n    if n > 2:\n        # Randomly select two distinct nodes to swap\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a segment and rotate it\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8677281002252125,
            0.5868901014328003
        ],
        "raw_score": [
            6.0516388475897465,
            7.951022179966049
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a 70-30 weighted combination of objectives (prioritizing the first objective), then applies a hybrid local search combining random edge swaps and segment reinsertion to generate a neighbor solution while ensuring feasibility. The method balances exploration (random selection) and exploitation (weighted objective prioritization) while maintaining TSP feasibility through careful segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.7*obj1 + 0.3*obj2)\n    selected = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping with segment reinsertion\n    if n >= 4:\n        # Step 1: Edge swapping between two random edges\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Novel segment reinsertion\n        seg_start = np.random.randint(0, n - 3)\n        seg_end = np.random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:], segment])\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8935344901768831,
            0.6120517253875732
        ],
        "raw_score": [
            10.485652248484643,
            10.628867637178974
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment-swap and probabilistic inversion\n    segment_length = np.random.randint(2, min(5, n//3))\n    a = np.random.randint(0, n - segment_length)\n    b = np.random.randint(0, n - segment_length)\n    while abs(a - b) < segment_length:\n        b = np.random.randint(0, n - segment_length)\n\n    segment_a = new_solution[a:a+segment_length]\n    segment_b = new_solution[b:b+segment_length]\n\n    # Swap segments\n    new_solution[a:a+segment_length] = segment_b\n    new_solution[b:b+segment_length] = segment_a\n\n    # Probabilistic inversion\n    if np.random.random() < 0.3:\n        if np.random.random() < 0.5:\n            new_solution[a:a+segment_length] = segment_b[::-1]\n        else:\n            new_solution[b:b+segment_length] = segment_a[::-1]\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9134804241622831,
            7.466274678707123
        ],
        "raw_score": [
            9.971299884851701,
            8.714978436379354
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined objective value from the archive and applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution, ensuring feasibility by validating node uniqueness. It prioritizes solutions with better overall performance and uses random segment selection and insertion to explore the search space creatively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine segment reversal and edge insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse segment [a, b] if it improves the tour\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Insert segment [c, d] at a random position\n    segment_to_insert = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_insert)\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7187510415670595,
            0.6468862891197205
        ],
        "raw_score": [
            6.571400756723691,
            6.321706330194692
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated or high-cost solutions) and applies a hybrid local search combining edge insertion with a novel edge-swapping move, ensuring feasibility by maintaining a valid TSP tour. It evaluates potential improvements by reinserting edges and swaps non-adjacent edges to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify edges with high potential for improvement\n    # Calculate the improvement if we remove an edge and reinsert it elsewhere\n    improvements = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Cost before removal\n        cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b]\n        # Try inserting between other edges\n        for j in range(n):\n            if j == i or j == (i+1)%n:\n                continue\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            # Cost after insertion\n            cost_after = distance_matrix_1[a, c] + distance_matrix_1[b, d] + distance_matrix_2[a, c] + distance_matrix_2[b, d]\n            improvement = cost_before - cost_after\n            if improvement > 0:\n                improvements.append((improvement, i, j))\n\n    if improvements:\n        # Select the best improvement\n        improvements.sort(reverse=True, key=lambda x: x[0])\n        best_improvement, i, j = improvements[0]\n        # Perform the move\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Remove edge (a,b)\n        if i < (i+1)%n:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[(i+2)%n:]])\n        else:\n            new_solution = np.concatenate([new_solution[:(i+1)%n], new_solution[i+1:]])\n        # Insert between j and (j+1)%n\n        new_solution = np.insert(new_solution, (j+1)%(n-1), [a, b])\n\n    # Step 2: Apply a novel move (swap of two non-adjacent edges)\n    if n >= 4:\n        # Select two non-adjacent edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            j = np.random.randint(0, n)\n        # Swap the edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9064382800779567,
            1.1508705615997314
        ],
        "raw_score": [
            10.533537607490505,
            10.598789083613973
        ]
    }
]