[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.674326029475184,
            0.20767366886138916
        ],
        "raw_score": [
            6.58180047838792,
            6.635135342386381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.674326029475184,
            0.20767366886138916
        ],
        "raw_score": [
            6.58180047838792,
            6.635135342386381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.674326029475184,
            0.20767366886138916
        ],
        "raw_score": [
            6.58180047838792,
            6.635135342386381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt (reversing segments between three randomly chosen nodes) and a novel edge-swap (swapping two randomly selected nodes), and ensures the solution remains feasible by checking for duplicate nodes. If invalid, it reverts to the original solution. The approach prioritizes randomness in selection and local search while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9141278146430662,
            0.20425432920455933
        ],
        "raw_score": [
            7.516685444492311,
            7.107547319728423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt (reversing segments between three randomly chosen nodes) and a novel edge-swap (swapping two randomly selected nodes), and ensures the solution remains feasible by checking for duplicate nodes. If invalid, it reverts to the original solution. The approach prioritizes randomness in selection and local search while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9141278146430662,
            0.20425432920455933
        ],
        "raw_score": [
            7.516685444492311,
            7.107547319728423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt (reversing segments between three randomly chosen nodes) and a novel edge-swap (swapping two randomly selected nodes), and ensures the solution remains feasible by checking for duplicate nodes. If invalid, it reverts to the original solution. The approach prioritizes randomness in selection and local search while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9141278146430662,
            0.20425432920455933
        ],
        "raw_score": [
            7.516685444492311,
            7.107547319728423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The algorithm selects the solution from the archive with the highest average cost (sum of both objectives) and applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The method prioritizes solutions with higher costs for exploration while using randomized segment operations to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple heuristic: select solution with average higher cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments of the tour\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Step 2: Reverse the middle segment (similar to 2-opt but with a twist)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 3: Apply a node insertion from another part of the tour\n    k = np.random.randint(0, n)\n    if k < i or k > j:\n        node = new_solution[k]\n        # Remove node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Insert node at a random position in the remaining tour\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.897717814643579,
            0.2321699857711792
        ],
        "raw_score": [
            10.432104059327493,
            10.71529906201301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple heuristic: select solution with average higher cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments of the tour\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Step 2: Reverse the middle segment (similar to 2-opt but with a twist)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 3: Apply a node insertion from another part of the tour\n    k = np.random.randint(0, n)\n    if k < i or k > j:\n        node = new_solution[k]\n        # Remove node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Insert node at a random position in the remaining tour\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects a solution from the archive with weighted randomness favoring less crowded regions in the objective space, then applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower crowding distances (indicating sparser regions) and modifies a random segment of the tour by reinserting it at a different position and swapping nodes within the segment.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives to [0, 1] range\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance (inverse of crowding)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        # Select with probability proportional to crowding\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    segment_length = random.randint(2, min(5, n-1))\n    start_idx = random.randint(0, n - segment_length - 1)\n\n    # Extract the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Randomly insert the segment at a different position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Perform node swapping within the segment\n    if len(segment) > 1:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9540619132712067,
            0.8583815097808838
        ],
        "raw_score": [
            9.511737934686852,
            9.40223169448624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives to [0, 1] range\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance (inverse of crowding)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        # Select with probability proportional to crowding\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    segment_length = random.randint(2, min(5, n-1))\n    start_idx = random.randint(0, n - segment_length - 1)\n\n    # Extract the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Randomly insert the segment at a different position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Perform node swapping within the segment\n    if len(segment) > 1:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects a solution from the archive with weighted randomness favoring less crowded regions in the objective space, then applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower crowding distances (indicating sparser regions) and modifies a random segment of the tour by reinserting it at a different position and swapping nodes within the segment.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives to [0, 1] range\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance (inverse of crowding)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        # Select with probability proportional to crowding\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    segment_length = random.randint(2, min(5, n-1))\n    start_idx = random.randint(0, n - segment_length - 1)\n\n    # Extract the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Randomly insert the segment at a different position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Perform node swapping within the segment\n    if len(segment) > 1:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9540619132712067,
            0.8583815097808838
        ],
        "raw_score": [
            9.511737934686852,
            9.40223169448624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives to [0, 1] range\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance (inverse of crowding)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        # Select with probability proportional to crowding\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    segment_length = random.randint(2, min(5, n-1))\n    start_idx = random.randint(0, n - segment_length - 1)\n\n    # Extract the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Randomly insert the segment at a different position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Perform node swapping within the segment\n    if len(segment) > 1:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8636049510339466,
            0.18204081058502197
        ],
        "raw_score": [
            7.5179651549670625,
            7.634740644178684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8636049510339466,
            0.18204081058502197
        ],
        "raw_score": [
            7.5179651549670625,
            7.634740644178684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm selects a solution with high objective variance from the archive, then applies a two-phase local search: first reversing a random segment if it improves at least one objective, followed by inserting a node at a position that improves both objectives simultaneously, with a fallback to random swaps if the solution becomes invalid. The method prioritizes complementary improvements across both objectives while maintaining feasibility through systematic validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (diverse potential)\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Objective-aware segment rearrangement\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n    # Try both orientations\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n\n    # Choose orientation that improves at least one objective\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n        new_solution[i:j+1] = reversed_segment\n\n    # Phase 2: Complementary node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find insertion point that improves both objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Calculate improvement\n        old_cost1 = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]]\n        imp1 = old_cost1 - new_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]]\n        imp2 = old_cost2 - new_cost2\n\n        # Prioritize moves that improve both objectives\n        if imp1 > 0 and imp2 > 0:\n            if imp1 + imp2 > best_improvement:\n                best_improvement = imp1 + imp2\n                best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        # Fallback to small change if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8164803375080893,
            0.2819095849990845
        ],
        "raw_score": [
            7.627838887615997,
            8.516883313520752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (diverse potential)\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Objective-aware segment rearrangement\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n    # Try both orientations\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n\n    # Choose orientation that improves at least one objective\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n        new_solution[i:j+1] = reversed_segment\n\n    # Phase 2: Complementary node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find insertion point that improves both objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Calculate improvement\n        old_cost1 = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]]\n        imp1 = old_cost1 - new_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]]\n        imp2 = old_cost2 - new_cost2\n\n        # Prioritize moves that improve both objectives\n        if imp1 > 0 and imp2 > 0:\n            if imp1 + imp2 > best_improvement:\n                best_improvement = imp1 + imp2\n                best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        # Fallback to small change if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 7,
        "algorithm": "The algorithm selects a promising solution from the archive (biased towards balanced Pareto-frontier solutions) and applies a dynamic chain of local search operations (segment inversion and rotation) to improve it in at least one objective, while ensuring feasibility by validating node coverage and reverting to a small random change if invalid. The key design ideas include objective-balanced selection, adaptive segment-based improvement, and feasibility validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (Pareto-frontier biased)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))  # Balance between objectives\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic chain reordering: adaptively adjust segments based on objective improvement\n    for _ in range(2):  # Number of chain operations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j+1))\n\n        # Try both inversion and rotation\n        for operation in ['invert', 'rotate']:\n            if operation == 'invert':\n                modified_segment = segment[::-1]\n            else:\n                modified_segment = np.roll(segment, 1)\n\n            # Temporarily apply the operation\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = modified_segment\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[(k-1)%n], temp_solution[k]] for k in range(i, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[(k-1)%n], temp_solution[k]] for k in range(i, j+1))\n\n            # Accept if at least one objective improves\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution = temp_solution\n                break\n\n    # Validate and ensure feasibility\n    if len(set(new_solution)) != n:\n        # Revert to original with a small random change if invalid\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5485327025857956,
            0.2826789617538452
        ],
        "raw_score": [
            6.151942171711805,
            8.775545431529052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (Pareto-frontier biased)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))  # Balance between objectives\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic chain reordering: adaptively adjust segments based on objective improvement\n    for _ in range(2):  # Number of chain operations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j+1))\n\n        # Try both inversion and rotation\n        for operation in ['invert', 'rotate']:\n            if operation == 'invert':\n                modified_segment = segment[::-1]\n            else:\n                modified_segment = np.roll(segment, 1)\n\n            # Temporarily apply the operation\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = modified_segment\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[(k-1)%n], temp_solution[k]] for k in range(i, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[(k-1)%n], temp_solution[k]] for k in range(i, j+1))\n\n            # Accept if at least one objective improves\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution = temp_solution\n                break\n\n    # Validate and ensure feasibility\n    if len(set(new_solution)) != n:\n        # Revert to original with a small random change if invalid\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 8,
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of both objectives), then applies a hybrid local search combining segment reversal and probabilistic node insertion, ensuring feasibility and accepting changes only if at least one objective improves. The segment reversal randomly selects and reverses a tour segment, while the probabilistic insertion moves a node to a new position, with acceptance based on cost comparisons in both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal with probabilistic insertion\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]  # Reverse the segment\n\n    # Probabilistic node insertion considering both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Calculate cost changes for both objectives\n        def calculate_cost(solution, matrix):\n            cost = 0\n            for k in range(len(solution)):\n                cost += matrix[solution[k-1], solution[k]]\n            return cost\n\n        original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        # Accept if at least one objective improves\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution = base_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7994981620302367,
            1.0027939677238464
        ],
        "raw_score": [
            6.231254859075396,
            5.633401252994187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal with probabilistic insertion\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]  # Reverse the segment\n\n    # Probabilistic node insertion considering both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Calculate cost changes for both objectives\n        def calculate_cost(solution, matrix):\n            cost = 0\n            for k in range(len(solution)):\n                cost += matrix[solution[k-1], solution[k]]\n            return cost\n\n        original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        # Accept if at least one objective improves\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution = base_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 9,
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of objectives) and applies a hybrid local search combining 4-opt with a selective node swap: first, it performs a 4-opt move on randomly selected segments, then attempts a node swap only if it improves both objectives, reverting otherwise. The selection prioritizes solutions with lower combined costs, while the hybrid search balances exploration (4-opt) and exploitation (selective swaps).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct positions\n    a, b, c, d = sorted(np.random.choice(range(n), size=4, replace=False))\n\n    # Apply 4-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_segment = np.concatenate([segment2, segment3, segment1])\n\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[d:]])\n\n    # Selective node swap: swap two random nodes if it improves both objectives\n    i, j = np.random.choice(range(n), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    new_solution[i], new_solution[j] = node_j, node_i\n\n    # Check if the swap improves both objectives\n    original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[(i+1)%n]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(j+1)%n]]\n    original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[(i+1)%n]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(j+1)%n]]\n\n    if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n        new_solution[i], new_solution[j] = node_i, node_j  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7665006364404907,
            0.21281850337982178
        ],
        "raw_score": [
            6.3026048771364085,
            6.1579562663129455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct positions\n    a, b, c, d = sorted(np.random.choice(range(n), size=4, replace=False))\n\n    # Apply 4-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_segment = np.concatenate([segment2, segment3, segment1])\n\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[d:]])\n\n    # Selective node swap: swap two random nodes if it improves both objectives\n    i, j = np.random.choice(range(n), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    new_solution[i], new_solution[j] = node_j, node_i\n\n    # Check if the swap improves both objectives\n    original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[(i+1)%n]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(j+1)%n]]\n    original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[(i+1)%n]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(j+1)%n]]\n\n    if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n        new_solution[i], new_solution[j] = node_i, node_j  # Revert if no improvement\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 3 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt (reversing segments between three randomly chosen nodes) and a novel edge-swap (swapping two randomly selected nodes), and ensures the solution remains feasible by checking for duplicate nodes. If invalid, it reverts to the original solution. The approach prioritizes randomness in selection and local search while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with weighted randomness favoring less crowded regions in the objective space, then applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower crowding distances (indicating sparser regions) and modifies a random segment of the tour by reinserting it at a different position and swapping nodes within the segment.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives to [0, 1] range\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance (inverse of crowding)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        # Select with probability proportional to crowding\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    segment_length = random.randint(2, min(5, n-1))\n    start_idx = random.randint(0, n - segment_length - 1)\n\n    # Extract the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Randomly insert the segment at a different position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Perform node swapping within the segment\n    if len(segment) > 1:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### Ineffective Self-Reflection\n- **Keywords**: Randomness, feasibility, crowding distance, segment manipulation.\n- **Advice**: Prioritize crowding distance for selection and combine structured operators (e.g., segment inversion + edge reassignment) to ensure both diversity and validity.\n- **Avoid**: Over-relying on randomness in operators; avoid operators that risk invalid tours (e.g., 2-opt variants).\n- **Explanation**: Randomness can hinder targeted improvement, while structured operators ensure feasibility and exploit problem patterns. Crowding distance helps focus on sparse regions for better trade-offs.\n\n### Improved Heuristic Design\n1. **Selection**:\n   - Use crowding distance to select solutions in sparse Pareto regions, ensuring diverse exploration.\n2. **Local Search**:\n   - **Segment Inversion + Edge Reassignment**:\n     - Randomly invert a tour segment (ensuring no duplicates).\n     - Reassign edges between segments to minimize both objectives, using a greedy criterion (e.g., minimize the sum of squared distances).\n   - **Feasibility Check**: If reassignment causes duplicates, revert to a simple swap (ensuring validity).\n3. **Hybrid Strategy**:\n   - Combine with edge insertion: Insert a node into a segment and reassign edges to optimize both objectives.\n4. **Objective Awareness**:\n   - Use a weighted sum of objectives to guide reassignment (e.g., \u03b1\u00b7cost1 + (1-\u03b1)\u00b7cost2, where \u03b1 is randomly sampled).\n\n**Example Code**:\n```python\nimport numpy as np\n\ndef select_neighbor(archive):\n    # Step 1: Select a solution using crowding distance\n    crowding_distances = compute_crowding_distances(archive)\n    selected_idx = np.random.choice(\n        len(archive),\n        p=crowding_distances / np.sum(crowding_distances)\n    )\n    tour = archive[selected_idx].copy()\n\n    # Step 2: Apply segment inversion + edge reassignment\n    n = len(tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = tour[a:b+1]\n    np.random.shuffle(segment)\n    new_tour = np.concatenate([tour[:a], segment, tour[b+1:]])\n\n    # Step 3: Validate and revert if invalid\n    if len(np.unique(new_tour)) != n:\n        # Fallback: simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]\n\n    return new_tour\n```\n\n**Key Insight**: Structured operators (segment inversion + reassignment) combined with crowding-based selection yield higher-quality neighbors while ensuring feasibility.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 10,
        "algorithm": "The algorithm selects solutions from the archive using crowding distance to prioritize sparse regions, applies a hybrid local search combining segment inversion and objective-aware edge reassignment, and ensures feasibility by reverting invalid moves to simple swaps. The objective-aware reassignment balances improvements in both objectives via a weighted random factor \u03b1, while segment inversion introduces diversity. The method emphasizes sparsity in the Pareto front and balances exploration/exploitation in local search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Edge reassignment with objective awareness\n    if n > 3:\n        alpha = np.random.random()\n        i, j = np.random.choice(n, 2, replace=False)\n        cost_before = (alpha * (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) +\n                       (1 - alpha) * (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]))\n        cost_after = (alpha * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]) +\n                      (1 - alpha) * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]))\n\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 4: Validate and revert if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7745007223356508,
            0.41001057624816895
        ],
        "raw_score": [
            6.622513716949411,
            6.290123140551893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Edge reassignment with objective awareness\n    if n > 3:\n        alpha = np.random.random()\n        i, j = np.random.choice(n, 2, replace=False)\n        cost_before = (alpha * (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) +\n                       (1 - alpha) * (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]))\n        cost_after = (alpha * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]) +\n                      (1 - alpha) * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]))\n\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 4: Validate and revert if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution with high objective variance from the archive, then applies a two-phase local search: first reversing a random segment if it improves at least one objective, followed by inserting a node at a position that improves both objectives simultaneously, with a fallback to random swaps if the solution becomes invalid. The method prioritizes complementary improvements across both objectives while maintaining feasibility through systematic validation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (diverse potential)\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Objective-aware segment rearrangement\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n    # Try both orientations\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n\n    # Choose orientation that improves at least one objective\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n        new_solution[i:j+1] = reversed_segment\n\n    # Phase 2: Complementary node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find insertion point that improves both objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Calculate improvement\n        old_cost1 = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]]\n        imp1 = old_cost1 - new_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]]\n        imp2 = old_cost2 - new_cost2\n\n        # Prioritize moves that improve both objectives\n        if imp1 > 0 and imp2 > 0:\n            if imp1 + imp2 > best_improvement:\n                best_improvement = imp1 + imp2\n                best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        # Fallback to small change if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection\n- **Keywords**: Randomness, feasibility, crowding distance, segment manipulation.\n- **Advice**: Prioritize crowding distance for selection and combine structured operators (e.g., segment inversion + edge reassignment) to ensure both diversity and validity.\n- **Avoid**: Over-relying on randomness in operators; avoid operators that risk invalid tours (e.g., 2-opt variants).\n- **Explanation**: Randomness can hinder targeted improvement, while structured operators ensure feasibility and exploit problem patterns. Crowding distance helps focus on sparse regions for better trade-offs.\n\n### Improved Heuristic Design\n1. **Selection**:\n   - Use crowding distance to select solutions in sparse Pareto regions, ensuring diverse exploration.\n2. **Local Search**:\n   - **Segment Inversion + Edge Reassignment**:\n     - Randomly invert a tour segment (ensuring no duplicates).\n     - Reassign edges between segments to minimize both objectives, using a greedy criterion (e.g., minimize the sum of squared distances).\n   - **Feasibility Check**: If reassignment causes duplicates, revert to a simple swap (ensuring validity).\n3. **Hybrid Strategy**:\n   - Combine with edge insertion: Insert a node into a segment and reassign edges to optimize both objectives.\n4. **Objective Awareness**:\n   - Use a weighted sum of objectives to guide reassignment (e.g., \u03b1\u00b7cost1 + (1-\u03b1)\u00b7cost2, where \u03b1 is randomly sampled).\n\n**Example Code**:\n```python\nimport numpy as np\n\ndef select_neighbor(archive):\n    # Step 1: Select a solution using crowding distance\n    crowding_distances = compute_crowding_distances(archive)\n    selected_idx = np.random.choice(\n        len(archive),\n        p=crowding_distances / np.sum(crowding_distances)\n    )\n    tour = archive[selected_idx].copy()\n\n    # Step 2: Apply segment inversion + edge reassignment\n    n = len(tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = tour[a:b+1]\n    np.random.shuffle(segment)\n    new_tour = np.concatenate([tour[:a], segment, tour[b+1:]])\n\n    # Step 3: Validate and revert if invalid\n    if len(np.unique(new_tour)) != n:\n        # Fallback: simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]\n\n    return new_tour\n```\n\n**Key Insight**: Structured operators (segment inversion + reassignment) combined with crowding-based selection yield higher-quality neighbors while ensuring feasibility.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 11,
        "algorithm": "The algorithm selects promising solutions from an archive using crowding distance (prioritizing solutions in less crowded objective regions), then applies a three-phase local search: segment-based perturbation (shuffling segments while preserving node order), greedy edge reassignment (minimizing a weighted sum of distances), and feasibility validation with geometric-aware repair. The crowding distance calculation ensures diversity, while the hybrid local search balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    n = len(archive)\n    crowding = np.zeros(n)\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        if len(sorted_idx) > 2:\n            normalized = (objectives[sorted_idx, m] - np.min(objectives[:, m])) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n            crowding[sorted_idx[1:-1]] += (normalized[2:] - normalized[:-2]) / (normalized[-1] - normalized[0])\n\n    return crowding\n\n",
        "metric_score": [
            -0.9689729216794778,
            0.08812719583511353
        ],
        "raw_score": [
            10.414143869602936,
            10.509930187184857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    n = len(archive)\n    crowding = np.zeros(n)\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        if len(sorted_idx) > 2:\n            normalized = (objectives[sorted_idx, m] - np.min(objectives[:, m])) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n            crowding[sorted_idx[1:-1]] += (normalized[2:] - normalized[:-2]) / (normalized[-1] - normalized[0])\n\n    return crowding\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution with high objective variance from the archive, then applies a two-phase local search: first reversing a random segment if it improves at least one objective, followed by inserting a node at a position that improves both objectives simultaneously, with a fallback to random swaps if the solution becomes invalid. The method prioritizes complementary improvements across both objectives while maintaining feasibility through systematic validation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (diverse potential)\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Objective-aware segment rearrangement\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n    # Try both orientations\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n\n    # Choose orientation that improves at least one objective\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n        new_solution[i:j+1] = reversed_segment\n\n    # Phase 2: Complementary node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find insertion point that improves both objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Calculate improvement\n        old_cost1 = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]]\n        imp1 = old_cost1 - new_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]]\n        imp2 = old_cost2 - new_cost2\n\n        # Prioritize moves that improve both objectives\n        if imp1 > 0 and imp2 > 0:\n            if imp1 + imp2 > best_improvement:\n                best_improvement = imp1 + imp2\n                best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        # Fallback to small change if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection\n- **Keywords**: Randomness, feasibility, crowding distance, segment manipulation.\n- **Advice**: Prioritize crowding distance for selection and combine structured operators (e.g., segment inversion + edge reassignment) to ensure both diversity and validity.\n- **Avoid**: Over-relying on randomness in operators; avoid operators that risk invalid tours (e.g., 2-opt variants).\n- **Explanation**: Randomness can hinder targeted improvement, while structured operators ensure feasibility and exploit problem patterns. Crowding distance helps focus on sparse regions for better trade-offs.\n\n### Improved Heuristic Design\n1. **Selection**:\n   - Use crowding distance to select solutions in sparse Pareto regions, ensuring diverse exploration.\n2. **Local Search**:\n   - **Segment Inversion + Edge Reassignment**:\n     - Randomly invert a tour segment (ensuring no duplicates).\n     - Reassign edges between segments to minimize both objectives, using a greedy criterion (e.g., minimize the sum of squared distances).\n   - **Feasibility Check**: If reassignment causes duplicates, revert to a simple swap (ensuring validity).\n3. **Hybrid Strategy**:\n   - Combine with edge insertion: Insert a node into a segment and reassign edges to optimize both objectives.\n4. **Objective Awareness**:\n   - Use a weighted sum of objectives to guide reassignment (e.g., \u03b1\u00b7cost1 + (1-\u03b1)\u00b7cost2, where \u03b1 is randomly sampled).\n\n**Example Code**:\n```python\nimport numpy as np\n\ndef select_neighbor(archive):\n    # Step 1: Select a solution using crowding distance\n    crowding_distances = compute_crowding_distances(archive)\n    selected_idx = np.random.choice(\n        len(archive),\n        p=crowding_distances / np.sum(crowding_distances)\n    )\n    tour = archive[selected_idx].copy()\n\n    # Step 2: Apply segment inversion + edge reassignment\n    n = len(tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = tour[a:b+1]\n    np.random.shuffle(segment)\n    new_tour = np.concatenate([tour[:a], segment, tour[b+1:]])\n\n    # Step 3: Validate and revert if invalid\n    if len(np.unique(new_tour)) != n:\n        # Fallback: simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]\n\n    return new_tour\n```\n\n**Key Insight**: Structured operators (segment inversion + reassignment) combined with crowding-based selection yield higher-quality neighbors while ensuring feasibility.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 11,
        "algorithm": "The algorithm selects promising solutions from an archive using crowding distance (prioritizing solutions in less crowded objective regions), then applies a three-phase local search: segment-based perturbation (shuffling segments while preserving node order), greedy edge reassignment (minimizing a weighted sum of distances), and feasibility validation with geometric-aware repair. The crowding distance calculation ensures diversity, while the hybrid local search balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    n = len(archive)\n    crowding = np.zeros(n)\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        if len(sorted_idx) > 2:\n            normalized = (objectives[sorted_idx, m] - np.min(objectives[:, m])) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n            crowding[sorted_idx[1:-1]] += (normalized[2:] - normalized[:-2]) / (normalized[-1] - normalized[0])\n\n    return crowding\n\n",
        "metric_score": [
            -0.9689729216794778,
            0.08812719583511353
        ],
        "raw_score": [
            10.414143869602936,
            10.509930187184857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    n = len(archive)\n    crowding = np.zeros(n)\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        if len(sorted_idx) > 2:\n            normalized = (objectives[sorted_idx, m] - np.min(objectives[:, m])) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n            crowding[sorted_idx[1:-1]] += (normalized[2:] - normalized[:-2]) / (normalized[-1] - normalized[0])\n\n    return crowding\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution with high objective variance from the archive, then applies a two-phase local search: first reversing a random segment if it improves at least one objective, followed by inserting a node at a position that improves both objectives simultaneously, with a fallback to random swaps if the solution becomes invalid. The method prioritizes complementary improvements across both objectives while maintaining feasibility through systematic validation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (diverse potential)\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Objective-aware segment rearrangement\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n    # Try both orientations\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n\n    # Choose orientation that improves at least one objective\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n        new_solution[i:j+1] = reversed_segment\n\n    # Phase 2: Complementary node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find insertion point that improves both objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Calculate improvement\n        old_cost1 = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]]\n        imp1 = old_cost1 - new_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]]\n        imp2 = old_cost2 - new_cost2\n\n        # Prioritize moves that improve both objectives\n        if imp1 > 0 and imp2 > 0:\n            if imp1 + imp2 > best_improvement:\n                best_improvement = imp1 + imp2\n                best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        # Fallback to small change if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection\n- **Keywords**: Randomness, feasibility, crowding distance, segment manipulation.\n- **Advice**: Prioritize crowding distance for selection and combine structured operators (e.g., segment inversion + edge reassignment) to ensure both diversity and validity.\n- **Avoid**: Over-relying on randomness in operators; avoid operators that risk invalid tours (e.g., 2-opt variants).\n- **Explanation**: Randomness can hinder targeted improvement, while structured operators ensure feasibility and exploit problem patterns. Crowding distance helps focus on sparse regions for better trade-offs.\n\n### Improved Heuristic Design\n1. **Selection**:\n   - Use crowding distance to select solutions in sparse Pareto regions, ensuring diverse exploration.\n2. **Local Search**:\n   - **Segment Inversion + Edge Reassignment**:\n     - Randomly invert a tour segment (ensuring no duplicates).\n     - Reassign edges between segments to minimize both objectives, using a greedy criterion (e.g., minimize the sum of squared distances).\n   - **Feasibility Check**: If reassignment causes duplicates, revert to a simple swap (ensuring validity).\n3. **Hybrid Strategy**:\n   - Combine with edge insertion: Insert a node into a segment and reassign edges to optimize both objectives.\n4. **Objective Awareness**:\n   - Use a weighted sum of objectives to guide reassignment (e.g., \u03b1\u00b7cost1 + (1-\u03b1)\u00b7cost2, where \u03b1 is randomly sampled).\n\n**Example Code**:\n```python\nimport numpy as np\n\ndef select_neighbor(archive):\n    # Step 1: Select a solution using crowding distance\n    crowding_distances = compute_crowding_distances(archive)\n    selected_idx = np.random.choice(\n        len(archive),\n        p=crowding_distances / np.sum(crowding_distances)\n    )\n    tour = archive[selected_idx].copy()\n\n    # Step 2: Apply segment inversion + edge reassignment\n    n = len(tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = tour[a:b+1]\n    np.random.shuffle(segment)\n    new_tour = np.concatenate([tour[:a], segment, tour[b+1:]])\n\n    # Step 3: Validate and revert if invalid\n    if len(np.unique(new_tour)) != n:\n        # Fallback: simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]\n\n    return new_tour\n```\n\n**Key Insight**: Structured operators (segment inversion + reassignment) combined with crowding-based selection yield higher-quality neighbors while ensuring feasibility.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 11,
        "algorithm": "The algorithm selects promising solutions from an archive using crowding distance (prioritizing solutions in less crowded objective regions), then applies a three-phase local search: segment-based perturbation (shuffling segments while preserving node order), greedy edge reassignment (minimizing a weighted sum of distances), and feasibility validation with geometric-aware repair. The crowding distance calculation ensures diversity, while the hybrid local search balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    n = len(archive)\n    crowding = np.zeros(n)\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        if len(sorted_idx) > 2:\n            normalized = (objectives[sorted_idx, m] - np.min(objectives[:, m])) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n            crowding[sorted_idx[1:-1]] += (normalized[2:] - normalized[:-2]) / (normalized[-1] - normalized[0])\n\n    return crowding\n\n",
        "metric_score": [
            -0.9689729216794778,
            0.08812719583511353
        ],
        "raw_score": [
            10.414143869602936,
            10.509930187184857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    n = len(archive)\n    crowding = np.zeros(n)\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        if len(sorted_idx) > 2:\n            normalized = (objectives[sorted_idx, m] - np.min(objectives[:, m])) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n            crowding[sorted_idx[1:-1]] += (normalized[2:] - normalized[:-2]) / (normalized[-1] - normalized[0])\n\n    return crowding\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the solution from the archive with the highest average cost (sum of both objectives) and applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The method prioritizes solutions with higher costs for exploration while using randomized segment operations to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple heuristic: select solution with average higher cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments of the tour\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Step 2: Reverse the middle segment (similar to 2-opt but with a twist)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 3: Apply a node insertion from another part of the tour\n    k = np.random.randint(0, n)\n    if k < i or k > j:\n        node = new_solution[k]\n        # Remove node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Insert node at a random position in the remaining tour\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection\n- **Keywords**: Randomness, feasibility, crowding distance, segment manipulation.\n- **Advice**: Prioritize crowding distance for selection and combine structured operators (e.g., segment inversion + edge reassignment) to ensure both diversity and validity.\n- **Avoid**: Over-relying on randomness in operators; avoid operators that risk invalid tours (e.g., 2-opt variants).\n- **Explanation**: Randomness can hinder targeted improvement, while structured operators ensure feasibility and exploit problem patterns. Crowding distance helps focus on sparse regions for better trade-offs.\n\n### Improved Heuristic Design\n1. **Selection**:\n   - Use crowding distance to select solutions in sparse Pareto regions, ensuring diverse exploration.\n2. **Local Search**:\n   - **Segment Inversion + Edge Reassignment**:\n     - Randomly invert a tour segment (ensuring no duplicates).\n     - Reassign edges between segments to minimize both objectives, using a greedy criterion (e.g., minimize the sum of squared distances).\n   - **Feasibility Check**: If reassignment causes duplicates, revert to a simple swap (ensuring validity).\n3. **Hybrid Strategy**:\n   - Combine with edge insertion: Insert a node into a segment and reassign edges to optimize both objectives.\n4. **Objective Awareness**:\n   - Use a weighted sum of objectives to guide reassignment (e.g., \u03b1\u00b7cost1 + (1-\u03b1)\u00b7cost2, where \u03b1 is randomly sampled).\n\n**Example Code**:\n```python\nimport numpy as np\n\ndef select_neighbor(archive):\n    # Step 1: Select a solution using crowding distance\n    crowding_distances = compute_crowding_distances(archive)\n    selected_idx = np.random.choice(\n        len(archive),\n        p=crowding_distances / np.sum(crowding_distances)\n    )\n    tour = archive[selected_idx].copy()\n\n    # Step 2: Apply segment inversion + edge reassignment\n    n = len(tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = tour[a:b+1]\n    np.random.shuffle(segment)\n    new_tour = np.concatenate([tour[:a], segment, tour[b+1:]])\n\n    # Step 3: Validate and revert if invalid\n    if len(np.unique(new_tour)) != n:\n        # Fallback: simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]\n\n    return new_tour\n```\n\n**Key Insight**: Structured operators (segment inversion + reassignment) combined with crowding-based selection yield higher-quality neighbors while ensuring feasibility.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 12,
        "algorithm": "The algorithm selects promising solutions from an archive using crowding distance to identify non-dominated regions, then applies a novel local search operator that combines weighted segment inversion and cross-segment edge reassignment to generate high-quality neighbors while ensuring feasibility through multi-step validation. The method prioritizes objectives dynamically and balances exploration/exploitation by greedily minimizing the weighted sum of distances in both spaces while maintaining TSP feasibility. The crowding distance calculation ensures diverse selection from the archive, while the local search operator innovatively restructures tour segments to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n\n        if np.all(objectives[sorted_idx, m] == objectives[sorted_idx[0], m]):\n            continue\n\n        norm = objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m]\n        for i in range(1, len(sorted_idx)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / norm\n\n    return crowding_dist\n\n",
        "metric_score": [
            -0.9397600711212551,
            0.2425137162208557
        ],
        "raw_score": [
            10.525425132280422,
            10.612088079039633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n\n        if np.all(objectives[sorted_idx, m] == objectives[sorted_idx[0], m]):\n            continue\n\n        norm = objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m]\n        for i in range(1, len(sorted_idx)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / norm\n\n    return crowding_dist\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 13,
        "algorithm": "The algorithm selects the best solution from the archive based on the sum of its objectives, then applies a hybrid local search combining partial tour rotation, edge flipping, and probabilistic segment shuffling to generate a neighbor while ensuring feasibility through validation and repair. The selection prioritizes solutions with lower combined costs, while the local search operators (applied probabilistically) introduce diversity while maintaining tour validity. The critical design ideas are the intelligent selection of promising solutions and the novel combination of local search moves beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective score\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(best_solution)\n\n    # Generate neighbor solution\n    new_solution = best_solution.copy()\n\n    # Step 1: Partial tour rotation\n    if n > 2:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n    # Step 2: Edge flipping with probability\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Probabilistic segment shuffle\n    if random.random() < 0.5 and n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Validation and repair\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small change\n        new_solution = best_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7843364445093757,
            0.18577027320861816
        ],
        "raw_score": [
            6.107051635145718,
            6.701037815376555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective score\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(best_solution)\n\n    # Generate neighbor solution\n    new_solution = best_solution.copy()\n\n    # Step 1: Partial tour rotation\n    if n > 2:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n    # Step 2: Edge flipping with probability\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Probabilistic segment shuffle\n    if random.random() < 0.5 and n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Validation and repair\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small change\n        new_solution = best_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 14,
        "algorithm": "The algorithm selects a diverse solution from the archive based on objective variance, then applies a hybrid local search combining segment rotation and edge crossover to generate a neighbor. It ensures feasibility by validating uniqueness of nodes and reverting to a small random swap if invalid. The selection prioritizes diversity (high objective variance) while the local search balances structure (segment rotation) and connectivity (edge crossover).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on objective values\n    objectives = [obj for _, obj in archive]\n    selected_idx = np.argmax([np.std([o1, o2]) for o1, o2 in objectives])\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment rotation (shift a segment by a random amount)\n    i, j = sorted(random.sample(range(n), 2))\n    shift = random.randint(1, j - i)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, shift)\n\n    # Step 2: Random edge crossover (swap two non-adjacent edges)\n    if n > 4:\n        a, b, c, d = random.sample(range(n), 4)\n        if abs(a - b) > 1 and abs(c - d) > 1:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6051259687075864,
            0.3765289783477783
        ],
        "raw_score": [
            8.69919961948662,
            6.443658185640861
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on objective values\n    objectives = [obj for _, obj in archive]\n    selected_idx = np.argmax([np.std([o1, o2]) for o1, o2 in objectives])\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment rotation (shift a segment by a random amount)\n    i, j = sorted(random.sample(range(n), 2))\n    shift = random.randint(1, j - i)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, shift)\n\n    # Step 2: Random edge crossover (swap two non-adjacent edges)\n    if n > 4:\n        a, b, c, d = random.sample(range(n), 4)\n        if abs(a - b) > 1 and abs(c - d) > 1:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 3 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt (reversing segments between three randomly chosen nodes) and a novel edge-swap (swapping two randomly selected nodes), and ensures the solution remains feasible by checking for duplicate nodes. If invalid, it reverts to the original solution. The approach prioritizes randomness in selection and local search while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with weighted randomness favoring less crowded regions in the objective space, then applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower crowding distances (indicating sparser regions) and modifies a random segment of the tour by reinserting it at a different position and swapping nodes within the segment.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives to [0, 1] range\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance (inverse of crowding)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        # Select with probability proportional to crowding\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    segment_length = random.randint(2, min(5, n-1))\n    start_idx = random.randint(0, n - segment_length - 1)\n\n    # Extract the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Randomly insert the segment at a different position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Perform node swapping within the segment\n    if len(segment) > 1:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### Improved Heuristic Design (Refined)\n**Keywords**: Crowding-aware selection, segment inversion, edge reassignment, objective-aware reassignment.\n**Advice**: Combine crowding distance with weighted objective reassignment to guide segment inversion, ensuring both diversity and validity.\n**Avoid**: Pure randomness in operators; ensure all operators preserve tour feasibility.\n**Explanation**: Crowding distance focuses selection on sparse regions, while weighted reassignment balances objectives. Segment inversion + reassignment exploits local structure, and fallback swaps maintain feasibility.\n\n**Step-by-Step Refinement**:\n1. **Selection**: Use crowding distance to bias selection toward sparse Pareto regions.\n2. **Operator**: Invert a segment and reassign edges to minimize a weighted sum of objectives (\u03b1\u00b7cost1 + (1-\u03b1)\u00b7cost2).\n3. **Feasibility**: If reassignment causes duplicates, revert to a simple swap.\n4. **Hybrid**: Alternate between segment inversion and edge insertion for broader exploration.\n\n**Example Code**:\n```python\ndef select_neighbor(archive):\n    # Step 1: Crowding-aware selection\n    crowding = compute_crowding_distances(archive)\n    selected_idx = np.random.choice(len(archive), p=crowding/np.sum(crowding))\n    tour = archive[selected_idx].copy()\n\n    # Step 2: Segment inversion + weighted reassignment\n    n = len(tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = tour[a:b+1]\n    np.random.shuffle(segment)\n    new_tour = np.concatenate([tour[:a], segment, tour[b+1:]])\n\n    # Step 3: Objective-aware reassignment\n    alpha = np.random.random()\n    for i in range(a, b+1):\n        for j in range(a, b+1):\n            if i != j:\n                temp = new_tour.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                cost1, cost2 = evaluate(temp)\n                if alpha*cost1 + (1-alpha)*cost2 < alpha*cost1 + (1-alpha)*cost2:\n                    new_tour = temp\n\n    # Step 4: Fallback to swap if invalid\n    if len(np.unique(new_tour)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]\n\n    return new_tour\n```\n\n**Key Insight**: This hybrid approach balances exploration (crowding + segment inversion) and exploitation (weighted reassignment), while ensuring feasibility through adaptive checks.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 15,
        "algorithm": "The algorithm selects a solution from the archive using crowding distance to prioritize solutions in sparse regions, then applies a hybrid local search combining segment inversion, objective-aware edge swaps, and a fallback swap to generate a neighbor solution while ensuring feasibility. It balances exploration and exploitation by weighting objectives with a random alpha, and falls back to a simple swap if the solution becomes invalid. The key design ideas are crowding-aware selection, objective-aware local search, and a robust fallback mechanism.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Crowding-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Objective-aware edge reassignment\n    alpha = np.random.random()\n    for i in range(a, b+1):\n        for j in range(a, b+1):\n            if i != j:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                if alpha * cost1 + (1 - alpha) * cost2 < alpha * sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]] + (1 - alpha) * sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]:\n                    new_solution = temp\n\n    # Step 4: Fallback to swap if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8713257827633827,
            4.056185245513916
        ],
        "raw_score": [
            6.198748582862009,
            6.09509063153882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Crowding-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Objective-aware edge reassignment\n    alpha = np.random.random()\n    for i in range(a, b+1):\n        for j in range(a, b+1):\n            if i != j:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                if alpha * cost1 + (1 - alpha) * cost2 < alpha * sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]] + (1 - alpha) * sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]:\n                    new_solution = temp\n\n    # Step 4: Fallback to swap if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt (reversing segments between three randomly chosen nodes) and a novel edge-swap (swapping two randomly selected nodes), and ensures the solution remains feasible by checking for duplicate nodes. If invalid, it reverts to the original solution. The approach prioritizes randomness in selection and local search while maintaining feasibility.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 16,
        "algorithm": "The algorithm selects a solution from the archive with a weighted randomness favoring lower-cost solutions, then applies a hybrid local search combining dynamic segment reversal (randomly reversing a short segment of the tour) and a dynamic edge insertion strategy (randomly moving a node to a new position while ensuring feasibility). The method prioritizes diversity and exploration by dynamically adjusting segment lengths and insertion points, while maintaining feasibility through checks for duplicate nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / np.sum(objectives, axis=0)\n    weights = 1 / (1 + np.sum(normalized_obj, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal with variable segment length\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic edge insertion strategy\n    insert_pos = np.random.randint(0, n)\n    node_to_move = new_solution[np.random.randint(0, n)]\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n    if len(new_solution) > n:\n        new_solution = np.delete(new_solution, np.random.randint(0, len(new_solution)))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7553409324365372,
            1.0935337543487549
        ],
        "raw_score": [
            8.365069414578095,
            8.389159447955226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / np.sum(objectives, axis=0)\n    weights = 1 / (1 + np.sum(normalized_obj, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal with variable segment length\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic edge insertion strategy\n    insert_pos = np.random.randint(0, n)\n    node_to_move = new_solution[np.random.randint(0, n)]\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n    if len(new_solution) > n:\n        new_solution = np.delete(new_solution, np.random.randint(0, len(new_solution)))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    }
]