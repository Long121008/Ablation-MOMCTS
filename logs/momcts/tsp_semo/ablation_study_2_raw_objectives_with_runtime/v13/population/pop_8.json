[
    {
        "algorithm": "The algorithm selects promising solutions from an archive using crowding distance (prioritizing solutions in less crowded objective regions), then applies a three-phase local search: segment-based perturbation (shuffling segments while preserving node order), greedy edge reassignment (minimizing a weighted sum of distances), and feasibility validation with geometric-aware repair. The crowding distance calculation ensures diversity, while the hybrid local search balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    n = len(archive)\n    crowding = np.zeros(n)\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        if len(sorted_idx) > 2:\n            normalized = (objectives[sorted_idx, m] - np.min(objectives[:, m])) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n            crowding[sorted_idx[1:-1]] += (normalized[2:] - normalized[:-2]) / (normalized[-1] - normalized[0])\n\n    return crowding\n\n",
        "metric_score": [
            -0.9689729216794778,
            0.08812719583511353
        ],
        "raw_score": [
            10.414143869602936,
            10.509930187184857
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt (reversing segments between three randomly chosen nodes) and a novel edge-swap (swapping two randomly selected nodes), and ensures the solution remains feasible by checking for duplicate nodes. If invalid, it reverts to the original solution. The approach prioritizes randomness in selection and local search while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9141278146430662,
            0.20425432920455933
        ],
        "raw_score": [
            7.516685444492311,
            7.107547319728423
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with weighted randomness favoring less crowded regions in the objective space, then applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower crowding distances (indicating sparser regions) and modifies a random segment of the tour by reinserting it at a different position and swapping nodes within the segment.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives to [0, 1] range\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance (inverse of crowding)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        # Select with probability proportional to crowding\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    segment_length = random.randint(2, min(5, n-1))\n    start_idx = random.randint(0, n - segment_length - 1)\n\n    # Extract the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Randomly insert the segment at a different position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Perform node swapping within the segment\n    if len(segment) > 1:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9540619132712067,
            0.8583815097808838
        ],
        "raw_score": [
            9.511737934686852,
            9.40223169448624
        ]
    },
    {
        "algorithm": "The heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8636049510339466,
            0.18204081058502197
        ],
        "raw_score": [
            7.5179651549670625,
            7.634740644178684
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from an archive using crowding distance to identify non-dominated regions, then applies a novel local search operator that combines weighted segment inversion and cross-segment edge reassignment to generate high-quality neighbors while ensuring feasibility through multi-step validation. The method prioritizes objectives dynamically and balances exploration/exploitation by greedily minimizing the weighted sum of distances in both spaces while maintaining TSP feasibility. The crowding distance calculation ensures diverse selection from the archive, while the local search operator innovatively restructures tour segments to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n\n        if np.all(objectives[sorted_idx, m] == objectives[sorted_idx[0], m]):\n            continue\n\n        norm = objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m]\n        for i in range(1, len(sorted_idx)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / norm\n\n    return crowding_dist\n\n",
        "metric_score": [
            -0.9397600711212551,
            0.2425137162208557
        ],
        "raw_score": [
            10.525425132280422,
            10.612088079039633
        ]
    },
    {
        "algorithm": "The algorithm selects the solution from the archive with the highest average cost (sum of both objectives) and applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The method prioritizes solutions with higher costs for exploration while using randomized segment operations to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple heuristic: select solution with average higher cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments of the tour\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Step 2: Reverse the middle segment (similar to 2-opt but with a twist)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 3: Apply a node insertion from another part of the tour\n    k = np.random.randint(0, n)\n    if k < i or k > j:\n        node = new_solution[k]\n        # Remove node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Insert node at a random position in the remaining tour\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.897717814643579,
            0.2321699857711792
        ],
        "raw_score": [
            10.432104059327493,
            10.71529906201301
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive based on the sum of its objectives, then applies a hybrid local search combining partial tour rotation, edge flipping, and probabilistic segment shuffling to generate a neighbor while ensuring feasibility through validation and repair. The selection prioritizes solutions with lower combined costs, while the local search operators (applied probabilistically) introduce diversity while maintaining tour validity. The critical design ideas are the intelligent selection of promising solutions and the novel combination of local search moves beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective score\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(best_solution)\n\n    # Generate neighbor solution\n    new_solution = best_solution.copy()\n\n    # Step 1: Partial tour rotation\n    if n > 2:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n    # Step 2: Edge flipping with probability\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Probabilistic segment shuffle\n    if random.random() < 0.5 and n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Validation and repair\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small change\n        new_solution = best_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7843364445093757,
            0.18577027320861816
        ],
        "raw_score": [
            6.107051635145718,
            6.701037815376555
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.674326029475184,
            0.20767366886138916
        ],
        "raw_score": [
            6.58180047838792,
            6.635135342386381
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using crowding distance to prioritize solutions in sparse regions, then applies a hybrid local search combining segment inversion, objective-aware edge swaps, and a fallback swap to generate a neighbor solution while ensuring feasibility. It balances exploration and exploitation by weighting objectives with a random alpha, and falls back to a simple swap if the solution becomes invalid. The key design ideas are crowding-aware selection, objective-aware local search, and a robust fallback mechanism.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Crowding-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Objective-aware edge reassignment\n    alpha = np.random.random()\n    for i in range(a, b+1):\n        for j in range(a, b+1):\n            if i != j:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                if alpha * cost1 + (1 - alpha) * cost2 < alpha * sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]] + (1 - alpha) * sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]:\n                    new_solution = temp\n\n    # Step 4: Fallback to swap if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8713257827633827,
            4.056185245513916
        ],
        "raw_score": [
            6.198748582862009,
            6.09509063153882
        ]
    },
    {
        "algorithm": "The algorithm selects a solution with high objective variance from the archive, then applies a two-phase local search: first reversing a random segment if it improves at least one objective, followed by inserting a node at a position that improves both objectives simultaneously, with a fallback to random swaps if the solution becomes invalid. The method prioritizes complementary improvements across both objectives while maintaining feasibility through systematic validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (diverse potential)\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Objective-aware segment rearrangement\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n    # Try both orientations\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n\n    # Choose orientation that improves at least one objective\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n        new_solution[i:j+1] = reversed_segment\n\n    # Phase 2: Complementary node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find insertion point that improves both objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Calculate improvement\n        old_cost1 = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]]\n        imp1 = old_cost1 - new_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]]\n        imp2 = old_cost2 - new_cost2\n\n        # Prioritize moves that improve both objectives\n        if imp1 > 0 and imp2 > 0:\n            if imp1 + imp2 > best_improvement:\n                best_improvement = imp1 + imp2\n                best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        # Fallback to small change if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8164803375080893,
            0.2819095849990845
        ],
        "raw_score": [
            7.627838887615997,
            8.516883313520752
        ]
    }
]