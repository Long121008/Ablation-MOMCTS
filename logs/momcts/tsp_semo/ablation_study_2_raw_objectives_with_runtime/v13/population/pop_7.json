[
    {
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining 3-opt (reversing segments between three randomly chosen nodes) and a novel edge-swap (swapping two randomly selected nodes), and ensures the solution remains feasible by checking for duplicate nodes. If invalid, it reverts to the original solution. The approach prioritizes randomness in selection and local search while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Novel edge-swap: swap edges between two randomly selected nodes\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9141278146430662,
            0.20425432920455933
        ],
        "raw_score": [
            7.516685444492311,
            7.107547319728423
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with weighted randomness favoring less crowded regions in the objective space, then applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower crowding distances (indicating sparser regions) and modifies a random segment of the tour by reinserting it at a different position and swapping nodes within the segment.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives to [0, 1] range\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance (inverse of crowding)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        # Select with probability proportional to crowding\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    segment_length = random.randint(2, min(5, n-1))\n    start_idx = random.randint(0, n - segment_length - 1)\n\n    # Extract the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Randomly insert the segment at a different position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Perform node swapping within the segment\n    if len(segment) > 1:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9540619132712067,
            0.8583815097808838
        ],
        "raw_score": [
            9.511737934686852,
            9.40223169448624
        ]
    },
    {
        "algorithm": "The heuristic selects a random solution from the archive, then applies a hybrid local search combining segment inversion (randomly reversing a segment of the tour) and edge reassignment (randomly swapping two pairs of edges) to generate a neighbor. It ensures feasibility by validating the solution and, if invalid, reverting to a small random swap. The selection prioritizes diversity, while the local search balances exploration and exploitation through these creative operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random segment inversion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random edge reassignment (swap two edges)\n    if n > 3:\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[a], new_solution[d], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original with a small random change\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8636049510339466,
            0.18204081058502197
        ],
        "raw_score": [
            7.5179651549670625,
            7.634740644178684
        ]
    },
    {
        "algorithm": "The algorithm selects the solution from the archive with the highest average cost (sum of both objectives) and applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The method prioritizes solutions with higher costs for exploration while using randomized segment operations to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple heuristic: select solution with average higher cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge exchange with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments of the tour\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Step 2: Reverse the middle segment (similar to 2-opt but with a twist)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 3: Apply a node insertion from another part of the tour\n    k = np.random.randint(0, n)\n    if k < i or k > j:\n        node = new_solution[k]\n        # Remove node from its current position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        # Insert node at a random position in the remaining tour\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.897717814643579,
            0.2321699857711792
        ],
        "raw_score": [
            10.432104059327493,
            10.71529906201301
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of both objectives) and applies a hybrid local search combining 3-opt and selective insertion. It first performs a 3-opt move on randomly selected segments and then attempts a node swap if it improves both objectives, reverting otherwise. The method prioritizes solutions with lower combined costs while using a novel hybrid approach to explore the solution space beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with selective insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_segment = np.concatenate([segment2, segment1])\n\n    # Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[c:]])\n\n    # Apply selective insertion: move a random node to a new position if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[(i+1)%n]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.674326029475184,
            0.20767366886138916
        ],
        "raw_score": [
            6.58180047838792,
            6.635135342386381
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of objectives) and applies a hybrid local search combining 4-opt with a selective node swap: first, it performs a 4-opt move on randomly selected segments, then attempts a node swap only if it improves both objectives, reverting otherwise. The selection prioritizes solutions with lower combined costs, while the hybrid search balances exploration (4-opt) and exploitation (selective swaps).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct positions\n    a, b, c, d = sorted(np.random.choice(range(n), size=4, replace=False))\n\n    # Apply 4-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_segment = np.concatenate([segment2, segment3, segment1])\n\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[d:]])\n\n    # Selective node swap: swap two random nodes if it improves both objectives\n    i, j = np.random.choice(range(n), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    new_solution[i], new_solution[j] = node_j, node_i\n\n    # Check if the swap improves both objectives\n    original_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[(i+1)%n]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]] + distance_matrix_1[selected_solution[i], selected_solution[(j+1)%n]]\n    original_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[(i+1)%n]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]] + distance_matrix_2[selected_solution[i], selected_solution[(j+1)%n]]\n\n    if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n        new_solution[i], new_solution[j] = node_i, node_j  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7665006364404907,
            0.21281850337982178
        ],
        "raw_score": [
            6.3026048771364085,
            6.1579562663129455
        ]
    },
    {
        "algorithm": "The algorithm selects a solution with high objective variance from the archive, then applies a two-phase local search: first reversing a random segment if it improves at least one objective, followed by inserting a node at a position that improves both objectives simultaneously, with a fallback to random swaps if the solution becomes invalid. The method prioritizes complementary improvements across both objectives while maintaining feasibility through systematic validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective variance (diverse potential)\n    objectives = np.array([obj for (_, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Objective-aware segment rearrangement\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n    # Try both orientations\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[k-1], reversed_segment[k-i]] for k in range(i, j+1))\n\n    # Choose orientation that improves at least one objective\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n        new_solution[i:j+1] = reversed_segment\n\n    # Phase 2: Complementary node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find insertion point that improves both objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Calculate improvement\n        old_cost1 = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]]\n        imp1 = old_cost1 - new_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]]\n        imp2 = old_cost2 - new_cost2\n\n        # Prioritize moves that improve both objectives\n        if imp1 > 0 and imp2 > 0:\n            if imp1 + imp2 > best_improvement:\n                best_improvement = imp1 + imp2\n                best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        # Fallback to small change if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8164803375080893,
            0.2819095849990845
        ],
        "raw_score": [
            7.627838887615997,
            8.516883313520752
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (biased towards balanced Pareto-frontier solutions) and applies a dynamic chain of local search operations (segment inversion and rotation) to improve it in at least one objective, while ensuring feasibility by validating node coverage and reverting to a small random change if invalid. The key design ideas include objective-balanced selection, adaptive segment-based improvement, and feasibility validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (Pareto-frontier biased)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))  # Balance between objectives\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic chain reordering: adaptively adjust segments based on objective improvement\n    for _ in range(2):  # Number of chain operations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j+1))\n\n        # Try both inversion and rotation\n        for operation in ['invert', 'rotate']:\n            if operation == 'invert':\n                modified_segment = segment[::-1]\n            else:\n                modified_segment = np.roll(segment, 1)\n\n            # Temporarily apply the operation\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = modified_segment\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[(k-1)%n], temp_solution[k]] for k in range(i, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[(k-1)%n], temp_solution[k]] for k in range(i, j+1))\n\n            # Accept if at least one objective improves\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution = temp_solution\n                break\n\n    # Validate and ensure feasibility\n    if len(set(new_solution)) != n:\n        # Revert to original with a small random change if invalid\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5485327025857956,
            0.2826789617538452
        ],
        "raw_score": [
            6.151942171711805,
            8.775545431529052
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of both objectives), then applies a hybrid local search combining segment reversal and probabilistic node insertion, ensuring feasibility and accepting changes only if at least one objective improves. The segment reversal randomly selects and reverses a tour segment, while the probabilistic insertion moves a node to a new position, with acceptance based on cost comparisons in both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal with probabilistic insertion\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]  # Reverse the segment\n\n    # Probabilistic node insertion considering both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Calculate cost changes for both objectives\n        def calculate_cost(solution, matrix):\n            cost = 0\n            for k in range(len(solution)):\n                cost += matrix[solution[k-1], solution[k]]\n            return cost\n\n        original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        # Accept if at least one objective improves\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution = base_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7994981620302367,
            1.0027939677238464
        ],
        "raw_score": [
            6.231254859075396,
            5.633401252994187
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive using crowding distance to prioritize sparse regions, applies a hybrid local search combining segment inversion and objective-aware edge reassignment, and ensures feasibility by reverting invalid moves to simple swaps. The objective-aware reassignment balances improvements in both objectives via a weighted random factor \u03b1, while segment inversion introduces diversity. The method emphasizes sparsity in the Pareto front and balances exploration/exploitation in local search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            distances = np.linalg.norm(normalized - normalized[i], axis=1)\n            crowding[i] = 1.0 / (np.sum(distances) + 1e-10)\n\n        prob = crowding / np.sum(crowding)\n        selected_idx = np.random.choice(len(archive), p=prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Edge reassignment with objective awareness\n    if n > 3:\n        alpha = np.random.random()\n        i, j = np.random.choice(n, 2, replace=False)\n        cost_before = (alpha * (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) +\n                       (1 - alpha) * (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]))\n        cost_after = (alpha * (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]) +\n                      (1 - alpha) * (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]))\n\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 4: Validate and revert if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7745007223356508,
            0.41001057624816895
        ],
        "raw_score": [
            6.622513716949411,
            6.290123140551893
        ]
    }
]