[
    {
        "algorithm": "The heuristic selects the most promising solution from the archive (based on normalized combined objective scores) and applies a hybrid local search combining 3-opt moves with greedy edge insertion to generate a neighbor while ensuring feasibility. The algorithm prioritizes solutions with better combined performance and uses a mix of random and greedy operations to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined normalized objective score\n    def normalize_objectives(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return norm1 + norm2\n\n    best_solution = min(archive, key=lambda x: normalize_objectives(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 3-opt move (randomly select 3 edges and reconnect them)\n        if n >= 4:\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[:i]\n            segment2 = new_solution[i:j+1]\n            segment3 = new_solution[j+1:k+1]\n            segment4 = new_solution[k+1:]\n\n            # Try all possible reconnections\n            possible_solutions = [\n                np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n                np.concatenate([segment1, segment3, segment2, segment4]),\n                np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n                np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n                np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n                np.concatenate([segment1, segment3, segment2[::-1], segment4])\n            ]\n\n            # Select the best solution based on both objectives\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return cost1 + cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Greedy edge insertion (try to improve by inserting nodes in a better position)\n        for _ in range(3):  # Limit iterations to avoid excessive computation\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n\n            # Remove the node\n            temp_solution = np.delete(new_solution, i)\n\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                candidate = np.insert(temp_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(best_solution)\n    return neighbor\n\n",
        "score": [
            5.426902453633912,
            6.119995236995279
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of normalized objectives (prioritizing the first objective with a 0.7 weight), then applies a hybrid local search combining 4-opt moves with adaptive edge swapping. The 4-opt operator reconnects randomly selected segments in all possible ways and evaluates them using adaptive weighting (0.6 for the first objective), while the edge swapping focuses on high-improvement regions to refine the solution. The method ensures feasibility by maintaining valid TSP tours throughout all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    def weighted_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.7 * norm1 + 0.3 * norm2  # Weighted toward first objective\n\n    selected_solution = min(archive, key=lambda x: weighted_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid 4-opt with adaptive edge swapping\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move (randomly select 4 edges and reconnect)\n        if n >= 6:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Generate all possible 4-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n            ]\n\n            # Evaluate with adaptive weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.6 * cost1 + 0.4 * cost2  # Adaptive weighting\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Adaptive edge swapping\n        for _ in range(2):\n            # Select high-improvement region\n            region_size = max(3, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            # Try swapping edges within the region\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    # Check if improvement\n                    current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                               sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.676603931493985,
            7.643328294004073
        ]
    },
    {
        "algorithm": "The heuristic function selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility through validation checks. The algorithm focuses on improving solutions by strategically breaking and rearranging segments of the tour, with randomness in edge selection to explore diverse neighborhoods, though it reverts to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (minimizing both objectives)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: Randomly select two non-adjacent edges to break\n    a, b = sorted(np.random.choice(range(n-1), 2, replace=False))\n    while abs(a - b) == 1:  # Ensure not adjacent\n        a, b = sorted(np.random.choice(range(n-1), 2, replace=False))\n\n    # Step 2: Remove the edges and reverse the segment between them\n    segment = new_solution[a+1:b+1]\n    new_solution[a+1:b+1] = segment[::-1]\n\n    # Step 3: Randomly insert a segment between two other edges\n    c, d = sorted(np.random.choice(range(n-1), 2, replace=False))\n    while abs(c - d) == 1:  # Ensure not adjacent\n        c, d = sorted(np.random.choice(range(n-1), 2, replace=False))\n\n    segment = new_solution[c+1:d+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.1486496758090725,
            6.291455144403966
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on combined objective costs) and applies a novel multi-objective segment relocation strategy, prioritizing edges with high combined importance from both objectives. It probabilistically relocates segments to better positions, balancing both objectives while ensuring feasibility through validation. The method dynamically adapts segment selection and insertion based on edge importance across both spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (minimizing both objectives)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation strategy\n    def calculate_edge_importance(solution, matrix):\n        importance = []\n        for i in range(n):\n            j = (i + 1) % n\n            importance.append(matrix[solution[i], solution[j]])\n        return np.array(importance)\n\n    # Calculate edge importance for both objectives\n    imp1 = calculate_edge_importance(base_solution, distance_matrix_1)\n    imp2 = calculate_edge_importance(base_solution, distance_matrix_2)\n    combined_importance = imp1 + imp2\n\n    # Select segments based on importance\n    sorted_edges = np.argsort(combined_importance)[::-1]\n    selected_edges = sorted_edges[:max(2, n//4)]\n\n    # Relocate segments probabilistically\n    for edge in selected_edges:\n        if np.random.rand() < 0.7:  # 70% chance to relocate\n            segment_start = edge\n            segment_end = (edge + 1) % n\n\n            # Remove segment\n            segment = new_solution[segment_start:segment_end+1]\n            remaining = np.delete(new_solution, slice(segment_start, segment_end+1))\n\n            # Find insertion points based on both objectives\n            insertion_scores = []\n            for i in range(len(remaining)):\n                candidate = np.insert(remaining, i, segment)\n                cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n                cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n                insertion_scores.append(cost1 + cost2)\n\n            best_insertion = np.argmin(insertion_scores)\n            new_solution = np.insert(remaining, best_insertion, segment)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.748072244320239,
            7.36351065315697
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive with high objective variance (indicating potential for improvement), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor solution while ensuring feasibility through validation checks. The selection prioritizes solutions with diverse objectives, while the local search strategically modifies the tour by moving nodes and reversing segments to explore the solution space. The algorithm maintains feasibility by validating the solution length and node uniqueness after each operation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Filter non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    # Select a solution with high potential (e.g., high variance in objectives)\n    if len(non_dominated) > 1:\n        # Sort by objective variance (higher variance indicates more potential)\n        non_dominated.sort(key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n        selected = non_dominated[0][0].copy()\n    else:\n        selected = non_dominated[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Node insertion: move node at position j to position i+1\n        node = new_solution[j]\n        new_pos = (i + 1) % n\n        new_solution = np.insert(new_solution, new_pos, node)\n        if j < new_pos:\n            new_solution = np.delete(new_solution, j)\n        else:\n            new_solution = np.delete(new_solution, j + 1)\n\n        # Edge exchange: swap edges between i and j\n        if i + 1 < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility (though the operations above should maintain it)\n    assert len(new_solution) == len(selected), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected), \"Duplicate nodes introduced\"\n\n    return new_solution\n\n",
        "score": [
            8.064875610090384,
            7.627547120134032
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on a weighted combination of objectives (60% first objective, 40% second objective) and applies a hybrid local search combining 4-opt moves with simulated annealing-inspired edge swaps to generate a neighbor solution while ensuring feasibility. The 4-opt move reconnects four randomly selected edges in all possible ways, while the simulated annealing approach probabilistically accepts edge swaps to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective combination\n    def weighted_objective(obj1, obj2):\n        return 0.6 * obj1 + 0.4 * obj2\n\n    selected_solution = min(archive, key=lambda x: weighted_objective(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search combining 4-opt and simulated annealing edge swaps\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move (randomly select 4 edges and reconnect them)\n        if n >= 5:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Try all possible reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[1], segments[2], segments[4]])\n            ]\n\n            # Select best solution based on both objectives\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return cost1 + cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Simulated annealing-inspired edge swaps\n        temp = 100.0\n        cooling_rate = 0.99\n        current = new_solution.copy()\n\n        for _ in range(10):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Create candidate solution with swapped edges\n            candidate = current.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Evaluate costs\n            current_cost1 = sum(distance_matrix_1[current[k], current[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[current[k], current[(k+1)%n]] for k in range(n))\n            candidate_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            candidate_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Acceptance criteria\n            delta_cost = (candidate_cost1 + candidate_cost2) - (current_cost1 + current_cost2)\n            if delta_cost < 0 or np.random.random() < np.exp(-delta_cost / temp):\n                current = candidate\n\n            temp *= cooling_rate\n\n        return current\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            8.091014852562742,
            8.094147814058651
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective values) and applies a hybrid local search combining 3-opt moves with randomized edge swaps to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The 3-opt moves explore different segment reversals, while the randomized edge swaps introduce diversity, with both strategies prioritizing solutions that improve the combined cost across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: 3-opt with randomized edge swaps\n    for _ in range(10):  # Number of iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Generate three possible 3-opt moves\n        moves = [\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n        ]\n\n        # Evaluate all moves based on both objectives\n        best_move = None\n        best_score = float('inf')\n\n        for move in moves:\n            cost1 = sum(distance_matrix_1[move[i], move[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[move[i], move[(i+1)%n]] for i in range(n))\n            score = cost1 + cost2  # Combined score for selection\n\n            if score < best_score:\n                best_score = score\n                best_move = move\n\n        if best_move is not None:\n            new_solution = best_move\n\n        # Randomized edge swap for diversification\n        if random.random() < 0.3:  # 30% chance\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.180994436644973,
            8.169521320452091
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective score (indicating potential for improvement)\n    def combined_objective(obj):\n        return obj[0] + obj[1]\n\n    selected_solution = max(archive, key=lambda x: combined_objective(x[1]))[0].copy()\n\n    # Adaptive local search combining segment reversal and node relocation with objective-aware selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment reversal with objective-aware selection\n    if n >= 3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Try reversing the segment and evaluate both options\n        reversed_segment = segment[::-1]\n        candidates = [\n            np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]]),\n            new_solution.copy()\n        ]\n\n        # Evaluate candidates based on both objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n            return (cost1, cost2)\n\n        evals = [evaluate(c) for c in candidates]\n        if sum(evals[0]) < sum(evals[1]):\n            new_solution = candidates[0]\n\n    # Objective-aware node relocation\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        temp_solution = np.delete(new_solution, i)\n\n        # Find the best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            candidate = np.insert(temp_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%(n-1)]] for k in range(n-1))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%(n-1)]] for k in range(n-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(temp_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes introduced\"\n\n    return new_solution\n\n",
        "score": [
            8.171488340413655,
            8.565872819343804
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive (based on summed objective values) and applies a hybrid local search combining segment insertion and reversal, balancing both objectives in the evaluation. It prioritizes solutions with higher combined costs, uses random segment lengths for variability, and occasionally reverses segments to escape local optima. The neighbor solution is always feasible, ensuring a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions or those with high objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion and segment reversal\n    # Step 1: Randomly select a segment of the tour\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))  # Segment length between 2 and 5 (or half the tour length)\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Step 2: Remove the segment from the tour\n    if start < end:\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        new_solution = new_solution[end:start]\n\n    # Step 3: Evaluate insertion positions using both distance matrices\n    best_pos = 0\n    best_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        # Insert segment before position i\n        candidate = np.insert(new_solution, i, segment)\n        # Calculate cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 4: Apply segment reversal with probability 0.5 to introduce diversity\n    if np.random.rand() < 0.5:\n        start_rev = np.random.randint(0, n)\n        length_rev = np.random.randint(2, min(5, n // 2))\n        end_rev = (start_rev + length_rev) % n\n\n        if start_rev < end_rev:\n            new_solution[start_rev:end_rev] = new_solution[start_rev:end_rev][::-1]\n        else:\n            segment_rev = np.concatenate([new_solution[start_rev:], new_solution[:end_rev]])\n            segment_rev = segment_rev[::-1]\n            new_solution[start_rev:] = segment_rev[:len(new_solution[start_rev:])]\n            new_solution[:end_rev] = segment_rev[len(new_solution[start_rev:]):]\n\n    return new_solution\n\n",
        "score": [
            10.453925999638443,
            10.701631296659878
        ]
    }
]