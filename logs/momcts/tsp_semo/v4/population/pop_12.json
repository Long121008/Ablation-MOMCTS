[
    {
        "algorithm": "The heuristic selects the most promising solution from the archive (based on normalized combined objective scores) and applies a hybrid local search combining 3-opt moves with greedy edge insertion to generate a neighbor while ensuring feasibility. The algorithm prioritizes solutions with better combined performance and uses a mix of random and greedy operations to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined normalized objective score\n    def normalize_objectives(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return norm1 + norm2\n\n    best_solution = min(archive, key=lambda x: normalize_objectives(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 3-opt move (randomly select 3 edges and reconnect them)\n        if n >= 4:\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[:i]\n            segment2 = new_solution[i:j+1]\n            segment3 = new_solution[j+1:k+1]\n            segment4 = new_solution[k+1:]\n\n            # Try all possible reconnections\n            possible_solutions = [\n                np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n                np.concatenate([segment1, segment3, segment2, segment4]),\n                np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n                np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n                np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n                np.concatenate([segment1, segment3, segment2[::-1], segment4])\n            ]\n\n            # Select the best solution based on both objectives\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return cost1 + cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Greedy edge insertion (try to improve by inserting nodes in a better position)\n        for _ in range(3):  # Limit iterations to avoid excessive computation\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n\n            # Remove the node\n            temp_solution = np.delete(new_solution, i)\n\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                candidate = np.insert(temp_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(best_solution)\n    return neighbor\n\n",
        "score": [
            5.426902453633912,
            6.119995236995279
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best Pareto front position\n    def pareto_dominance(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return (norm1, norm2)\n\n    # Sort by Pareto dominance (lexicographic order)\n    archive_sorted = sorted(archive, key=lambda x: pareto_dominance(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search combining adaptive 5-opt and dynamic edge insertion\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Adaptive 5-opt move\n        if n >= 7:\n            # Select 5 distinct positions\n            points = sorted(np.random.choice(n, 5, replace=False))\n            segments = [\n                new_solution[:points[0]],\n                new_solution[points[0]:points[1]+1],\n                new_solution[points[1]+1:points[2]+1],\n                new_solution[points[2]+1:points[3]+1],\n                new_solution[points[3]+1:points[4]+1],\n                new_solution[points[4]+1:]\n            ]\n\n            # Generate all possible 5-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]])\n            ]\n\n            # Evaluate with dynamic weighting based on current solution quality\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                # Dynamic weighting: favor objective with higher current cost\n                if cost1 > cost2:\n                    return 0.7 * cost1 + 0.3 * cost2\n                else:\n                    return 0.3 * cost1 + 0.7 * cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Dynamic edge insertion\n        for _ in range(3):\n            # Select a random node to reinsert\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n\n            # Remove the node\n            temp_solution = np.delete(new_solution, node_idx)\n\n            # Find best insertion position with dynamic evaluation\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                candidate = np.insert(temp_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n\n                # Dynamic evaluation based on current solution quality\n                current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                if current_cost1 > current_cost2:\n                    total_cost = 0.7 * cost1 + 0.3 * cost2\n                else:\n                    total_cost = 0.3 * cost1 + 0.7 * cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            5.1956880402110865,
            7.488018690703704
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with high objective variance and low dominance) and applies a hybrid local search combining adaptive segment reconnection and directed edge swapping to generate a neighbor solution, dynamically balancing the two objectives during evaluation while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance and low dominance\n    def dominance_score(obj):\n        dominated_count = sum(1 for other_obj in (o[1] for o in archive)\n                           if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                           (other_obj[0] < obj[0] or other_obj[1] < obj[1]))\n        return abs(obj[0] - obj[1]) / (1 + dominated_count)\n\n    selected = max(archive, key=lambda x: dominance_score(x[1]))[0].copy()\n\n    # Hybrid local search: adaptive segment reconnection + directed edge swapping\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reconnection\n    if n >= 5:\n        # Select 3 segments to reconnect\n        indices = sorted(np.random.choice(n, 3, replace=False))\n        segments = [\n            new_solution[:indices[0]],\n            new_solution[indices[0]:indices[1]],\n            new_solution[indices[1]:indices[2]],\n            new_solution[indices[2]:]\n        ]\n\n        # Generate possible reconnections\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1], segments[3], segments[2]]),\n            np.concatenate([segments[0], segments[2], segments[3], segments[1]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[3], segments[1][::-1]])\n        ]\n\n        # Evaluate with dynamic weights\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            # Dynamic weight based on current solution's trade-off\n            weight = 0.5 + 0.2 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            return weight * cost1 + (1 - weight) * cost2\n\n        new_solution = min(possible_solutions, key=evaluate)\n\n    # Directed edge swapping in high-improvement regions\n    for _ in range(3):\n        # Select a region with potential improvement\n        region_size = max(3, n // 4)\n        region_start = np.random.randint(0, n - region_size)\n        region = new_solution[region_start:region_start+region_size]\n\n        # Try swapping edges within the region\n        for i in range(len(region)-1):\n            for j in range(i+1, len(region)):\n                temp = new_solution.copy()\n                temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                # Check if improvement with dynamic weights\n                current_cost = evaluate(new_solution)\n                new_cost = evaluate(temp)\n\n                if new_cost < current_cost:\n                    new_solution = temp\n                    break\n\n    # Ensure feasibility\n    assert len(new_solution) == len(selected), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected), \"Duplicate nodes introduced\"\n\n    return new_solution\n\n",
        "score": [
            6.712775664958901,
            5.634876524307218
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of normalized objectives (prioritizing the second objective with a 0.6 weight), then applies a hybrid local search combining 5-opt moves with adaptive edge insertion, where the 5-opt operator evaluates all possible reconnections using adaptive weighting (0.7 for the first objective) and the edge insertion focuses on improving the second objective by inserting nodes in high-improvement regions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives (different weights)\n    def weighted_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.4 * norm1 + 0.6 * norm2  # Different weighted toward second objective\n\n    selected_solution = min(archive, key=lambda x: weighted_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid 5-opt with adaptive edge insertion\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 5-opt move (randomly select 5 edges and reconnect)\n        if n >= 7:\n            i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:m+1],\n                new_solution[m+1:]\n            ]\n\n            # Generate all possible 5-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[1], segments[4], segments[3], segments[2], segments[5]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]])\n            ]\n\n            # Evaluate with adaptive weighting (different weights)\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.7 * cost1 + 0.3 * cost2  # Different adaptive weighting\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Adaptive edge insertion (focus on second objective)\n        for _ in range(2):\n            # Select high-improvement region based on second objective\n            region_size = max(3, n // 4)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            # Try inserting nodes within the region\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    node = temp[region_start+j]\n                    temp = np.delete(temp, region_start+j)\n                    insert_pos = np.random.randint(region_start, region_start+region_size)\n                    temp = np.insert(temp, insert_pos, node)\n\n                    # Check if improvement in second objective\n                    current_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            7.754321393825167,
            4.665304336687817
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized objectives (prioritizing the first objective more heavily) and applies a hybrid local search combining 4-opt with adaptive edge swapping and greedy edge insertion. It ensures feasibility by maintaining valid TSP tours throughout, with adaptive weighting favoring the first objective in both selection and local search operations. The solution is refined through iterative improvements that balance both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    def weighted_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.7 * norm1 + 0.3 * norm2  # Weighted toward first objective\n\n    selected_solution = min(archive, key=lambda x: weighted_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search combining 4-opt and adaptive edge swapping\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move with adaptive weighting\n        if n >= 6:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Generate all possible 4-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n            ]\n\n            # Evaluate with adaptive weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.6 * cost1 + 0.4 * cost2  # Adaptive weighting\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Adaptive edge swapping in high-improvement regions\n        for _ in range(3):\n            region_size = max(3, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                               sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        # Greedy edge insertion\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            temp_solution = np.delete(new_solution, i)\n\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                candidate = np.insert(temp_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.651765390545433,
            7.558972457057891
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from an archive using Pareto-based weighted scoring, then applies a hybrid local search combining 4-opt moves with adaptive edge insertion, where the 4-opt prioritizes the objective with higher potential improvement and edge insertion focuses on high-improvement regions by considering both objectives with dynamic weighting. The selection prioritizes solutions with better normalized objective values, while the local search balances exploration and exploitation through weighted cost evaluations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted selection based on Pareto front position\n    def pareto_weighted_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n\n        # Dynamic weights based on Pareto front position\n        if norm1 < norm2:\n            return 0.6 * norm1 + 0.4 * norm2\n        else:\n            return 0.4 * norm1 + 0.6 * norm2\n\n    selected_solution = min(archive, key=lambda x: pareto_weighted_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid 4-opt with adaptive edge insertion\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move with dynamic weighting\n        if n >= 6:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Generate all possible 4-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n            ]\n\n            # Dynamic evaluation with Pareto-based weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n\n                # Adjust weights based on current solution's performance\n                if cost1 < cost2:\n                    return 0.7 * cost1 + 0.3 * cost2\n                else:\n                    return 0.3 * cost1 + 0.7 * cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Adaptive edge insertion in high-improvement regions\n        for _ in range(3):\n            # Select region based on both objectives\n            region_size = max(3, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            # Try inserting nodes within the region\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    node = temp[region_start+j]\n                    temp = np.delete(temp, region_start+j)\n\n                    # Find best insertion position considering both objectives\n                    best_pos = region_start\n                    best_cost = float('inf')\n\n                    for pos in range(region_start, region_start+region_size):\n                        candidate = np.insert(temp, pos, node)\n                        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n                        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n                        # Weighted cost based on current solution's performance\n                        if cost1 < cost2:\n                            total_cost = 0.6 * cost1 + 0.4 * cost2\n                        else:\n                            total_cost = 0.4 * cost1 + 0.6 * cost2\n\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_pos = pos\n\n                    new_solution = np.insert(temp, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            6.050657734573221,
            6.07836241199832
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-based dominance and adaptive objective weighting, then applies a hybrid local search combining 3-opt and 5-opt moves with dynamic edge swaps and adaptive Pareto evaluation to generate high-quality neighbor solutions while maintaining feasibility. The selection prioritizes solutions with better trade-offs between objectives, while the local search adaptively chooses between 3-opt and 5-opt moves based on the solution's complexity and trade-off, and evaluates neighbors using dynamic Pareto-based weighting.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based selection with adaptive weighting\n    def pareto_score(obj):\n        dominated = sum(1 for other in archive if other[1][0] <= obj[0] and other[1][1] <= obj[1] and (other[1][0] < obj[0] or other[1][1] < obj[1]))\n        return (obj[0] + obj[1]) / (1 + dominated)\n\n    selected = min(archive, key=lambda x: pareto_score(x[1]))[0].copy()\n\n    # Hybrid local search combining 3-opt and 5-opt with dynamic edge swaps\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Adaptive 3-opt or 5-opt move based on solution quality\n        if n >= 5:\n            # Choose between 3-opt or 5-opt based on current solution's trade-off\n            current_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n            tradeoff = abs(current_cost1 - current_cost2) / (current_cost1 + current_cost2 + 1e-6)\n\n            if n >= 7 and tradeoff > 0.3:  # Use 5-opt for more complex solutions\n                i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:l+1],\n                    new_solution[l+1:m+1],\n                    new_solution[m+1:]\n                ]\n                possible_solutions = [\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n                    np.concatenate([segments[0], segments[1], segments[4], segments[3], segments[2], segments[5]]),\n                    np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n                    np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]])\n                ]\n            else:  # Use 3-opt for simpler solutions\n                i, j, k = sorted(np.random.choice(n, 3, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:]\n                ]\n                possible_solutions = [\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2]]),\n                    np.concatenate([segments[0], segments[2], segments[3], segments[1]]),\n                    np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1]])\n                ]\n\n            # Evaluate with dynamic Pareto-based weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                # Dynamic weighting based on current trade-off\n                weight = 0.5 + 0.3 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n                return weight * cost1 + (1 - weight) * cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Dynamic edge swaps in high-improvement regions\n        for _ in range(2):\n            region_size = max(3, n // 4)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    current_cost = evaluate(new_solution)\n                    new_cost = evaluate(temp)\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        # Ensure feasibility\n        assert len(new_solution) == len(selected), \"Solution length changed\"\n        assert len(np.unique(new_solution)) == len(selected), \"Duplicate nodes introduced\"\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected)\n    return neighbor\n\n",
        "score": [
            6.1876179195857,
            5.987595735735196
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using dynamic objective weighting that balances improvements in both objectives, then applies a fragment insertion local search to intelligently reinsert random path segments into the best position, evaluated with an adaptive multi-objective cost function. The selection prioritizes solutions with better combined objective values, while the fragment insertion operator focuses on improving the tour by reordering segments while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic objective weighting based on archive diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj1_weights = np.exp(-(objectives[:, 0] - np.min(objectives[:, 0])) / (np.max(objectives[:, 0]) - np.min(objectives[:, 0]) + 1e-8))\n    obj2_weights = np.exp(-(objectives[:, 1] - np.min(objectives[:, 1])) / (np.max(objectives[:, 1]) - np.min(objectives[:, 1]) + 1e-8))\n    combined_weights = obj1_weights * 0.5 + obj2_weights * 0.5\n\n    # Select solution with highest combined weight\n    selected_idx = np.argmax(combined_weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Fragment insertion local search\n    def fragment_insertion(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Select a random fragment of size 3-5 nodes\n        frag_size = np.random.randint(3, min(6, n//2))\n        frag_start = np.random.randint(0, n - frag_size)\n        fragment = new_solution[frag_start:frag_start+frag_size]\n\n        # Remove the fragment\n        new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_start+frag_size:]])\n\n        # Try inserting the fragment in different positions\n        best_insert_pos = frag_start\n        best_cost = float('inf')\n\n        for pos in range(0, len(new_solution) - frag_size + 1):\n            # Create candidate solution\n            candidate = np.concatenate([new_solution[:pos], fragment, new_solution[pos:]])\n\n            # Evaluate with adaptive multi-objective function\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Adaptive weighting based on current archive\n            weight1 = np.mean(obj1_weights)\n            weight2 = np.mean(obj2_weights)\n            total_cost = weight1 * cost1 + weight2 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n\n        # Insert the fragment in the best position\n        new_solution = np.concatenate([new_solution[:best_insert_pos], fragment, new_solution[best_insert_pos:]])\n\n        return new_solution\n\n    neighbor = fragment_insertion(selected_solution)\n    return neighbor\n\n",
        "score": [
            5.8404099170567125,
            6.446978519338639
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of normalized objectives (prioritizing the first objective with a 0.7 weight), then applies a hybrid local search combining 4-opt moves with adaptive edge swapping. The 4-opt operator reconnects randomly selected segments in all possible ways and evaluates them using adaptive weighting (0.6 for the first objective), while the edge swapping focuses on high-improvement regions to refine the solution. The method ensures feasibility by maintaining valid TSP tours throughout all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    def weighted_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.7 * norm1 + 0.3 * norm2  # Weighted toward first objective\n\n    selected_solution = min(archive, key=lambda x: weighted_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid 4-opt with adaptive edge swapping\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move (randomly select 4 edges and reconnect)\n        if n >= 6:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Generate all possible 4-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n            ]\n\n            # Evaluate with adaptive weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.6 * cost1 + 0.4 * cost2  # Adaptive weighting\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Adaptive edge swapping\n        for _ in range(2):\n            # Select high-improvement region\n            region_size = max(3, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            # Try swapping edges within the region\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    # Check if improvement\n                    current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                               sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.676603931493985,
            7.643328294004073
        ]
    },
    {
        "algorithm": "The heuristic function selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility through validation checks. The algorithm focuses on improving solutions by strategically breaking and rearranging segments of the tour, with randomness in edge selection to explore diverse neighborhoods, though it reverts to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (minimizing both objectives)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: Randomly select two non-adjacent edges to break\n    a, b = sorted(np.random.choice(range(n-1), 2, replace=False))\n    while abs(a - b) == 1:  # Ensure not adjacent\n        a, b = sorted(np.random.choice(range(n-1), 2, replace=False))\n\n    # Step 2: Remove the edges and reverse the segment between them\n    segment = new_solution[a+1:b+1]\n    new_solution[a+1:b+1] = segment[::-1]\n\n    # Step 3: Randomly insert a segment between two other edges\n    c, d = sorted(np.random.choice(range(n-1), 2, replace=False))\n    while abs(c - d) == 1:  # Ensure not adjacent\n        c, d = sorted(np.random.choice(range(n-1), 2, replace=False))\n\n    segment = new_solution[c+1:d+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.1486496758090725,
            6.291455144403966
        ]
    }
]