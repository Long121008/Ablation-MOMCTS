[
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on a novel hybrid scoring metric\n    def hybrid_score(obj1, obj2):\n        # Normalize objectives\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n\n        # Dynamic weighting based on solution quality\n        quality = 1 - (norm1 * norm2)  # Higher quality when both objectives are balanced\n        return quality * norm1 + (1 - quality) * norm2\n\n    selected_solution = min(archive, key=lambda x: hybrid_score(x[1][0], x[1][1]))[0].copy()\n\n    # Step 2: Novel hybrid local search combining segment inversion and adaptive edge insertion\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Segment inversion with objective-aware selection\n        for _ in range(3):\n            segment_size = min(5, n // 3)\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start + segment_size]\n\n            # Evaluate inversion\n            inverted = segment[::-1]\n            temp = new_solution.copy()\n            temp[start:start + segment_size] = inverted\n\n            # Calculate improvement\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost1 = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n            # Accept if better in either objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution = temp\n\n        # Adaptive edge insertion\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i != j:\n                temp = new_solution.copy()\n                node = temp[i]\n                temp = np.delete(temp, i)\n                insert_pos = np.random.randint(0, n-1)\n                temp = np.insert(temp, insert_pos, node)\n\n                # Evaluate\n                current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                              sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                          sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                # Accept if better in either objective\n                if new_cost < current_cost:\n                    new_solution = temp\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.637813998335584,
            8.642715335480199
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    def calculate_objective_weights(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n\n        return (0.7 * norm1 + 0.3 * (1 - norm2), 0.3 * norm1 + 0.7 * (1 - norm2))\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    selected_solution = max(pareto_front, key=lambda x: sum(calculate_objective_weights(x[1][0], x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2)\n\n    current_cost = evaluate(new_solution)\n\n    def adaptive_segment_operator():\n        nonlocal new_solution\n        k = np.random.choice([3, 4, 5])\n        if k == 3 and n >= 4:\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:]\n            ]\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]])\n            ]\n        elif k == 4 and n >= 5:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n            ]\n        else:\n            i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:m+1],\n                new_solution[m+1:]\n            ]\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]])\n            ]\n\n        best_candidate = min(possible_solutions, key=lambda x: sum(evaluate(x)))\n        new_solution = best_candidate\n\n    def edge_based_swap():\n        nonlocal new_solution\n        for _ in range(3):\n            region_size = max(3, n // 6)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                               sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n    adaptive_segment_operator()\n    edge_based_swap()\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.967031454289973,
            4.133381056826081
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive using a Pareto-aware dynamic weighting scheme, then applies a hybrid local search combining adaptive k-opt (3-opt/5-opt) moves with probabilistic edge swaps and segment relocations, prioritizing high-importance edges identified by combined distance metrics while ensuring feasibility through lightweight validation. It emphasizes edge importance in both objective spaces and dynamically balances improvement across objectives, with higher priority given to edges with larger combined distances. The solution is progressively refined through targeted segment relocations and local swaps, with fallback mechanisms to maintain feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    def dynamic_weighting(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n\n        avg1 = sum(o[1][0] for o in archive) / len(archive)\n        avg2 = sum(o[1][1] for o in archive) / len(archive)\n\n        weight1 = 0.7 if obj1 <= avg1 else 0.3\n        weight2 = 0.3 if obj2 <= avg2 else 0.7\n\n        return weight1 * norm1 + weight2 * norm2\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    selected_solution = min(pareto_front, key=lambda x: dynamic_weighting(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    def calculate_edge_importance(solution, matrix):\n        importance = []\n        for i in range(n):\n            j = (i + 1) % n\n            importance.append(matrix[solution[i], solution[j]])\n        return np.array(importance)\n\n    imp1 = calculate_edge_importance(new_solution, distance_matrix_1)\n    imp2 = calculate_edge_importance(new_solution, distance_matrix_2)\n    combined_importance = imp1 + imp2\n    sorted_edges = np.argsort(combined_importance)[::-1]\n    selected_edges = sorted_edges[:max(3, n//4)]\n\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost = evaluate(new_solution)\n\n    for edge in selected_edges:\n        if np.random.rand() < 0.7:\n            segment_start = edge\n            segment_end = (edge + 1) % n\n            segment = new_solution[segment_start:segment_end+1]\n            remaining = np.delete(new_solution, slice(segment_start, segment_end+1))\n\n            insertion_scores = []\n            for i in range(len(remaining)):\n                candidate = np.insert(remaining, i, segment)\n                cost1, cost2 = evaluate(candidate)\n                insertion_scores.append(dynamic_weighting(cost1, cost2))\n\n            best_insertion = np.argmin(insertion_scores)\n            new_solution = np.insert(remaining, best_insertion, segment)\n\n    k = 3 if n < 8 else np.random.choice([3, 5])\n    if k == 3 and n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:]\n        ]\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n            np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]])\n        ]\n    else:\n        i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:l+1],\n            new_solution[l+1:m+1],\n            new_solution[m+1:]\n        ]\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]])\n        ]\n\n    best_candidate = min(possible_solutions, key=lambda x: sum(evaluate(x)))\n    new_solution = best_candidate\n\n    for _ in range(2):\n        region_size = max(3, n // 5)\n        region_start = np.random.randint(0, n - region_size)\n        region = new_solution[region_start:region_start+region_size]\n\n        for i in range(len(region)-1):\n            for j in range(i+1, len(region)):\n                temp = new_solution.copy()\n                temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                              sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                           sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                if new_cost < current_cost:\n                    new_solution = temp\n                    break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.469672357291428,
            4.567764317744583
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive using Pareto dominance and normalization, then applies a hybrid local search combining adaptive 3-opt/5-opt moves and probabilistic edge swaps, prioritizing edges with high combined importance from both objectives while ensuring feasibility through validation. The search dynamically balances exploration and exploitation by probabilistically applying moves based on edge importance and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution using Pareto dominance\n    def is_dominated(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Normalize objectives to select the most promising solution\n    def normalize_objectives(obj1, obj2):\n        min1 = min(o[1][0] for o in non_dominated)\n        max1 = max(o[1][0] for o in non_dominated)\n        min2 = min(o[1][1] for o in non_dominated)\n        max2 = max(o[1][1] for o in non_dominated)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return norm1 + norm2\n\n    selected_idx = np.argmin([normalize_objectives(obj[0], obj[1]) for _, obj in non_dominated])\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Calculate edge importance for both objectives\n    def calculate_edge_importance(solution, matrix):\n        importance = []\n        for i in range(n):\n            j = (i + 1) % n\n            importance.append(matrix[solution[i], solution[j]])\n        return np.array(importance)\n\n    imp1 = calculate_edge_importance(base_solution, distance_matrix_1)\n    imp2 = calculate_edge_importance(base_solution, distance_matrix_2)\n    combined_importance = imp1 + imp2\n\n    sorted_edges = np.argsort(combined_importance)[::-1]\n    selected_edges = sorted_edges[:max(3, n//5)]\n\n    # Hybrid local search combining adaptive 3-opt/5-opt moves and probabilistic edge swaps\n    for edge in selected_edges:\n        if np.random.rand() < 0.6:\n            # Adaptive 3-opt or 5-opt move\n            if np.random.rand() < 0.5 and n >= 5:\n                # 5-opt move\n                i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n                segment1 = new_solution[:i]\n                segment2 = new_solution[i:j+1]\n                segment3 = new_solution[j+1:k+1]\n                segment4 = new_solution[k+1:l+1]\n                segment5 = new_solution[l+1:m+1]\n                segment6 = new_solution[m+1:]\n\n                possible_solutions = [\n                    np.concatenate([segment1, segment2[::-1], segment3, segment4, segment5, segment6]),\n                    np.concatenate([segment1, segment3, segment2, segment4, segment5, segment6]),\n                    np.concatenate([segment1, segment2, segment3[::-1], segment4, segment5, segment6]),\n                    np.concatenate([segment1, segment4, segment2, segment3, segment5, segment6]),\n                    np.concatenate([segment1, segment2, segment4, segment3, segment5, segment6]),\n                    np.concatenate([segment1, segment5, segment2, segment3, segment4, segment6]),\n                ]\n\n                def evaluate(sol):\n                    cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                    cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                    return cost1 + cost2\n\n                best_new = min(possible_solutions, key=evaluate)\n                new_solution = best_new\n            else:\n                # 3-opt move\n                i, j, k = sorted(np.random.choice(n, 3, replace=False))\n                segment1 = new_solution[:i]\n                segment2 = new_solution[i:j+1]\n                segment3 = new_solution[j+1:k+1]\n                segment4 = new_solution[k+1:]\n\n                possible_solutions = [\n                    np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n                    np.concatenate([segment1, segment3, segment2, segment4]),\n                    np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n                    np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n                    np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n                    np.concatenate([segment1, segment3, segment2[::-1], segment4])\n                ]\n\n                best_new = min(possible_solutions, key=lambda x: sum(distance_matrix_1[x[i], x[(i+1)%n]] for i in range(n)) + sum(distance_matrix_2[x[i], x[(i+1)%n]] for i in range(n)))\n                new_solution = best_new\n\n    # Probabilistic edge swaps based on importance\n    for edge in selected_edges:\n        if np.random.rand() < 0.4:\n            i, j = edge, (edge + 1) % n\n            k = np.random.randint(0, n)\n            while k == i or k == j or k == (i - 1) % n or k == (j + 1) % n:\n                k = np.random.randint(0, n)\n\n            candidate = new_solution.copy()\n            candidate[i], candidate[k] = candidate[k], candidate[i]\n\n            cost1 = sum(distance_matrix_1[candidate[l], candidate[(l+1)%n]] for l in range(n))\n            cost2 = sum(distance_matrix_2[candidate[l], candidate[(l+1)%n]] for l in range(n))\n            new_cost = cost1 + cost2\n\n            current_cost1 = sum(distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] for l in range(n))\n            current_cost = current_cost1 + current_cost2\n\n            if new_cost < current_cost:\n                new_solution = candidate\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.000674413708187,
            5.682267978852876
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive using Pareto dominance and adaptive objective weighting, then applies a hybrid local search combining dynamic 4-opt/6-opt moves with region-based edge optimization, prioritizing high-importance edges identified by combined distance matrix values while ensuring feasibility through lightweight checks. The selection prioritizes solutions with lower normalized objective values, particularly favoring those below average in either objective, and the local search emphasizes high-importance edges while occasionally exploring random 4-opt or 6-opt moves and small region swaps. The algorithm maintains feasibility by validating uniqueness of nodes in the final solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    def adaptive_weighting(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n\n        avg_obj1 = sum(o[1][0] for o in archive) / len(archive)\n        avg_obj2 = sum(o[1][1] for o in archive) / len(archive)\n\n        weight1 = 0.7 if obj1 <= avg_obj1 else 0.3\n        weight2 = 0.3 if obj2 <= avg_obj2 else 0.7\n\n        return weight1 * norm1 + weight2 * norm2\n\n    selected_solution = min(pareto_front, key=lambda x: adaptive_weighting(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    def calculate_edge_importance(solution, matrix):\n        importance = []\n        for i in range(n):\n            j = (i + 1) % n\n            importance.append(matrix[solution[i], solution[j]])\n        return np.array(importance)\n\n    imp1 = calculate_edge_importance(new_solution, distance_matrix_1)\n    imp2 = calculate_edge_importance(new_solution, distance_matrix_2)\n    combined_importance = imp1 + imp2\n    sorted_edges = np.argsort(combined_importance)[::-1]\n    selected_edges = sorted_edges[:max(4, n//4)]\n\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost = evaluate(new_solution)\n\n    for edge in selected_edges:\n        if np.random.rand() < 0.7:\n            segment_start = edge\n            segment_end = (edge + 1) % n\n            segment = new_solution[segment_start:segment_end+1]\n            remaining = np.delete(new_solution, slice(segment_start, segment_end+1))\n\n            insertion_scores = []\n            for i in range(len(remaining)):\n                candidate = np.insert(remaining, i, segment)\n                cost1, cost2 = evaluate(candidate)\n                insertion_scores.append(adaptive_weighting(cost1, cost2))\n\n            best_insertion = np.argmin(insertion_scores)\n            new_solution = np.insert(remaining, best_insertion, segment)\n\n    k = 4 if n < 10 else np.random.choice([4, 6])\n    if k == 4 and n >= 5:\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:l+1],\n            new_solution[l+1:]\n        ]\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n            np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n            np.concatenate([segments[0], segments[3], segments[1], segments[2], segments[4]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[3][::-1], segments[2], segments[4]])\n        ]\n    else:\n        i, j, k, l, m, o = sorted(np.random.choice(n, 6, replace=False))\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:l+1],\n            new_solution[l+1:m+1],\n            new_solution[m+1:o+1],\n            new_solution[o+1:]\n        ]\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5], segments[6]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5], segments[6]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5], segments[6]]),\n            np.concatenate([segments[0], segments[4], segments[1], segments[2], segments[3], segments[5], segments[6]])\n        ]\n\n    best_candidate = min(possible_solutions, key=lambda x: sum(evaluate(x)))\n    new_solution = best_candidate\n\n    for _ in range(3):\n        region_size = max(3, n // 5)\n        region_start = np.random.randint(0, n - region_size)\n        region = new_solution[region_start:region_start+region_size]\n\n        for i in range(len(region)-1):\n            for j in range(i+1, len(region)):\n                temp = new_solution.copy()\n                temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                              sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                           sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                if new_cost < current_cost:\n                    new_solution = temp\n                    break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.8206045435396145,
            4.963577969304601
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized objectives (prioritizing the first objective more heavily) and applies a hybrid local search combining 4-opt with adaptive edge swapping and greedy edge insertion. It ensures feasibility by maintaining valid TSP tours throughout, with adaptive weighting favoring the first objective in both selection and local search operations. The solution is refined through iterative improvements that balance both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    def weighted_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.7 * norm1 + 0.3 * norm2  # Weighted toward first objective\n\n    selected_solution = min(archive, key=lambda x: weighted_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search combining 4-opt and adaptive edge swapping\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move with adaptive weighting\n        if n >= 6:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Generate all possible 4-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n            ]\n\n            # Evaluate with adaptive weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.6 * cost1 + 0.4 * cost2  # Adaptive weighting\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Adaptive edge swapping in high-improvement regions\n        for _ in range(3):\n            region_size = max(3, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                               sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        # Greedy edge insertion\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            temp_solution = np.delete(new_solution, i)\n\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                candidate = np.insert(temp_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.651765390545433,
            7.558972457057891
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on a balanced weighting of both objectives (60% first objective, 40% second), then applies a hybrid local search combining adaptive 3-opt moves with path relinking and greedy edge reversal, ensuring feasibility by only accepting improvements in either objective. The method prioritizes the first objective more heavily in selection and evaluation, while the local search explores constrained neighborhoods to maintain solution validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on balanced objectives\n    def dynamic_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.6 * norm1 + 0.4 * norm2  # Balanced weighting\n\n    selected_solution = min(archive, key=lambda x: dynamic_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search combining adaptive 3-opt and path relinking\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Adaptive 3-opt move\n        if n >= 5:\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:]\n            ]\n\n            # Generate all possible 3-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1]])\n            ]\n\n            # Evaluate with balanced weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.5 * cost1 + 0.5 * cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Path relinking with objective-aware acceptance\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n\n                current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                              sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                           sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                # Accept if better in either objective\n                if new_cost < current_cost:\n                    new_solution = temp\n\n        # Greedy edge reversal\n        for _ in range(2):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n            temp = new_solution.copy()\n            temp[i:j+1] = temp[i:j+1][::-1]\n\n            current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                          sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                       sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n            # Accept if better in either objective\n            if new_cost < current_cost:\n                new_solution = temp\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.916729421433921,
            7.099183811604933
        ]
    },
    {
        "algorithm": "This algorithm selects the best solution from the archive (based on combined objective scores) and applies a hybrid local search combining adaptive 4-opt moves (with dynamic segment selection and weighted improvement evaluation) and objective-weighted edge optimization (focusing on small regions with prioritized objectives). The 4-opt phase explores multiple segment rearrangements with a 70/30 cost weighting, while the edge optimization refines small regions with a 60/40 weighting, ensuring balanced improvement across objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def evaluate(solution):\n        n = len(solution)\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2)\n\n    def adaptive_4_opt(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        for _ in range(5):\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n            candidates = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[1], segments[2], segments[4]])\n            ]\n\n            current_cost = evaluate(new_solution)\n            best_candidate = None\n            best_improvement = 0\n\n            for candidate in candidates:\n                candidate_cost = evaluate(candidate)\n                improvement = 0.7*(current_cost[0] - candidate_cost[0]) + 0.3*(current_cost[1] - candidate_cost[1])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                new_solution = best_candidate\n\n        return new_solution\n\n    def objective_weighted_optimization(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        for _ in range(3):\n            region_size = max(2, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            best_swap = None\n            best_improvement = 0\n\n            for i in range(len(region)):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n                    temp_cost = evaluate(temp)\n                    current_cost = evaluate(new_solution)\n                    improvement = 0.6*(current_cost[0] - temp_cost[0]) + 0.4*(current_cost[1] - temp_cost[1])\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = temp.copy()\n\n            if best_swap is not None:\n                new_solution = best_swap\n\n        return new_solution\n\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    neighbor = adaptive_4_opt(selected_solution)\n    neighbor = objective_weighted_optimization(neighbor)\n\n    return neighbor\n\n",
        "score": [
            5.295073810513461,
            6.530823489946296
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using adaptive objective weighting that balances between the two objectives with dynamic weights, applies a hybrid local search combining segment swaps (2-opt, 3-opt, 4-opt) and edge optimization in local regions, and ensures feasibility through validation while prioritizing solutions with balanced improvement potential across objectives. The selection favors Pareto-front solutions and uses weighted sums of objectives to guide the search, with the local search focusing on improving the weighted objective while maintaining diversity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    def calculate_dynamic_weights(obj1, obj2, iteration):\n        max1 = max(o[1][0] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n        if max1 == 0 or max2 == 0:\n            return (0.5, 0.5)\n        w1 = (obj2/max2) * (1 + 0.1 * np.sin(iteration/10))\n        w2 = (obj1/max1) * (1 + 0.1 * np.cos(iteration/10))\n        return (w1/(w1+w2), w2/(w1+w2))\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    iteration = len(archive) % 100\n    weights = calculate_dynamic_weights(pareto_front[0][1][0], pareto_front[0][1][1], iteration)\n    selected_solution = min(pareto_front, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            return (cost1, cost2)\n\n        current_cost = evaluate(new_solution)\n\n        for _ in range(3):\n            k = np.random.choice([2, 3, 4])\n            if k == 2:\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif k == 3:\n                i, j, k = sorted(np.random.choice(n, 3, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:]\n                ]\n                possible_solutions = [\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2]]),\n                    np.concatenate([segments[0], segments[2], segments[3], segments[1]]),\n                    np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]])\n                ]\n            else:\n                i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:l+1],\n                    new_solution[l+1:]\n                ]\n                possible_solutions = [\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                    np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                    np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3], segments[4]])\n                ]\n\n            if k > 2:\n                for candidate in possible_solutions:\n                    candidate_cost = evaluate(candidate)\n                    if (weights[0]*candidate_cost[0] + weights[1]*candidate_cost[1] <\n                        weights[0]*current_cost[0] + weights[1]*current_cost[1]):\n                        new_solution = candidate\n                        current_cost = candidate_cost\n                        break\n\n        for _ in range(2):\n            region_size = max(2, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    new_cost = evaluate(temp)\n                    if (weights[0]*new_cost[0] + weights[1]*new_cost[1] <\n                        weights[0]*current_cost[0] + weights[1]*current_cost[1]):\n                        new_solution = temp\n                        current_cost = new_cost\n                        break\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n\n    if len(np.unique(neighbor)) != len(neighbor):\n        neighbor = selected_solution.copy()\n        i, j = sorted(np.random.choice(len(neighbor), 2, replace=False))\n        neighbor[i:j+1] = neighbor[i:j+1][::-1]\n\n    return neighbor\n\n",
        "score": [
            5.372182765463692,
            6.111071139792023
        ]
    },
    {
        "algorithm": "The algorithm first identifies Pareto non-dominated solutions from the archive, then selects the most promising one based on normalized combined objective scores. It applies a hybrid local search combining adaptive 3-opt/5-opt moves with greedy edge insertion, prioritizing segments with high combined edge importance from both objectives, and dynamically alternates between segment operations and edge swaps to balance exploration and exploitation. The method ensures feasibility through lightweight validation and probabilistically selects operations based on segment importance and objective normalization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto dominance check\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    # Identify Pareto non-dominated solutions\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Normalized objective selection\n    def normalize_objectives(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return norm1 + norm2\n\n    # Select the most promising solution\n    selected_solution = min(pareto_front, key=lambda x: normalize_objectives(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(selected_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        current_solution = solution.copy()\n        n = len(current_solution)\n\n        # Calculate edge importance for both objectives\n        def calculate_edge_importance(sol, matrix):\n            importance = []\n            for i in range(n):\n                j = (i + 1) % n\n                importance.append(matrix[sol[i], sol[j]])\n            return np.array(importance)\n\n        imp1 = calculate_edge_importance(current_solution, distance_matrix_1)\n        imp2 = calculate_edge_importance(current_solution, distance_matrix_2)\n        combined_importance = imp1 + imp2\n        sorted_edges = np.argsort(combined_importance)[::-1]\n        selected_edges = sorted_edges[:max(3, n//4)]\n\n        # Adaptive 3-opt/5-opt moves\n        for edge in selected_edges:\n            if np.random.rand() < 0.6:  # Higher probability for segment operations\n                # Choose between 3-opt and 5-opt\n                k = np.random.choice([3, 5])\n                if k == 3 and n >= 4:\n                    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n                    segments = [\n                        current_solution[:i],\n                        current_solution[i:j+1],\n                        current_solution[j+1:k+1],\n                        current_solution[k+1:]\n                    ]\n                    possible_solutions = [\n                        np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                        np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n                        np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                        np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3]])\n                    ]\n                else:\n                    i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n                    segments = [\n                        current_solution[:i],\n                        current_solution[i:j+1],\n                        current_solution[j+1:k+1],\n                        current_solution[k+1:l+1],\n                        current_solution[l+1:m+1],\n                        current_solution[m+1:]\n                    ]\n                    possible_solutions = [\n                        np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n                        np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n                        np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3], segments[4], segments[5]])\n                    ]\n\n                # Evaluate all possible solutions\n                def evaluate(sol):\n                    cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                    cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                    return cost1 + cost2\n\n                best_new = min(possible_solutions, key=evaluate)\n                current_solution = best_new\n\n        # Greedy edge insertion (with importance consideration)\n        for edge in selected_edges:\n            if np.random.rand() < 0.4:  # Lower probability for edge operations\n                i = edge\n                node = current_solution[i]\n\n                # Remove the node\n                temp_solution = np.delete(current_solution, i)\n\n                # Find the best insertion position considering importance\n                best_pos = 0\n                best_cost = float('inf')\n\n                for pos in range(n-1):\n                    candidate = np.insert(temp_solution, pos, node)\n                    cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                    cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                    total_cost = cost1 + cost2\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n\n                current_solution = np.insert(temp_solution, best_pos, node)\n\n        return current_solution\n\n    neighbor = hybrid_local_search(new_solution)\n\n    # Validate solution\n    if len(np.unique(neighbor)) != n:\n        neighbor = selected_solution.copy()\n\n    return neighbor\n\n",
        "score": [
            5.820369721319258,
            5.8148541491355195
        ]
    }
]