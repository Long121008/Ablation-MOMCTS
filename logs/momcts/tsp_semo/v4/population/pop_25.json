[
    {
        "algorithm": "The algorithm dynamically selects solutions from the Pareto front using adaptive objective weighting, then applies a hybrid local search combining k-opt moves (3-opt or 5-opt) with region-based edge optimization, prioritizing high-improvement edges while ensuring feasibility through lightweight validation. It emphasizes solutions with better objective values by adjusting weights based on their relative performance compared to the archive average, and focuses local improvements on edges with combined high importance in both objective spaces. The hybrid approach alternates between segment-based relocations and region-specific swaps to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    def adaptive_weighting(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n\n        avg_obj1 = sum(o[1][0] for o in archive) / len(archive)\n        avg_obj2 = sum(o[1][1] for o in archive) / len(archive)\n\n        weight1 = 0.7 if obj1 <= avg_obj1 else 0.3\n        weight2 = 0.3 if obj2 <= avg_obj2 else 0.7\n\n        return weight1 * norm1 + weight2 * norm2\n\n    selected_solution = min(pareto_front, key=lambda x: adaptive_weighting(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    def calculate_edge_importance(solution, matrix):\n        importance = []\n        for i in range(n):\n            j = (i + 1) % n\n            importance.append(matrix[solution[i], solution[j]])\n        return np.array(importance)\n\n    imp1 = calculate_edge_importance(new_solution, distance_matrix_1)\n    imp2 = calculate_edge_importance(new_solution, distance_matrix_2)\n    combined_importance = imp1 + imp2\n    sorted_edges = np.argsort(combined_importance)[::-1]\n    selected_edges = sorted_edges[:max(3, n//5)]\n\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost = evaluate(new_solution)\n\n    for edge in selected_edges:\n        if np.random.rand() < 0.6:\n            segment_start = edge\n            segment_end = (edge + 1) % n\n            segment = new_solution[segment_start:segment_end+1]\n            remaining = np.delete(new_solution, slice(segment_start, segment_end+1))\n\n            insertion_scores = []\n            for i in range(len(remaining)):\n                candidate = np.insert(remaining, i, segment)\n                cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n                cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n                insertion_scores.append(0.5 * cost1 + 0.5 * cost2)\n\n            best_insertion = np.argmin(insertion_scores)\n            new_solution = np.insert(remaining, best_insertion, segment)\n\n    k = 3 if n < 8 else np.random.choice([3, 5])\n    if k == 3 and n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:]\n        ]\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n            np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]])\n        ]\n    else:\n        i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:l+1],\n            new_solution[l+1:m+1],\n            new_solution[m+1:]\n        ]\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]])\n        ]\n\n    best_candidate = min(possible_solutions, key=lambda x: sum(evaluate(x)))\n    new_solution = best_candidate\n\n    for _ in range(2):\n        region_size = max(3, n // 6)\n        region_start = np.random.randint(0, n - region_size)\n        region = new_solution[region_start:region_start+region_size]\n\n        for i in range(len(region)-1):\n            for j in range(i+1, len(region)):\n                temp = new_solution.copy()\n                temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                              sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                           sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                if new_cost < current_cost:\n                    new_solution = temp\n                    break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.402004582297529,
            4.663829471874413
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution based on a novel hybrid scoring metric\n    def hybrid_score(obj1, obj2):\n        # Normalize objectives\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n\n        # Dynamic weighting based on solution quality\n        quality = 1 - (norm1 * norm2)  # Higher quality when both objectives are balanced\n        return quality * norm1 + (1 - quality) * norm2\n\n    selected_solution = min(archive, key=lambda x: hybrid_score(x[1][0], x[1][1]))[0].copy()\n\n    # Step 2: Novel hybrid local search combining segment inversion and adaptive edge insertion\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Segment inversion with objective-aware selection\n        for _ in range(3):\n            segment_size = min(5, n // 3)\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start + segment_size]\n\n            # Evaluate inversion\n            inverted = segment[::-1]\n            temp = new_solution.copy()\n            temp[start:start + segment_size] = inverted\n\n            # Calculate improvement\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost1 = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n            # Accept if better in either objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution = temp\n\n        # Adaptive edge insertion\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i != j:\n                temp = new_solution.copy()\n                node = temp[i]\n                temp = np.delete(temp, i)\n                insert_pos = np.random.randint(0, n-1)\n                temp = np.insert(temp, insert_pos, node)\n\n                # Evaluate\n                current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                              sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                          sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                # Accept if better in either objective\n                if new_cost < current_cost:\n                    new_solution = temp\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.637813998335584,
            8.642715335480199
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the Pareto front using adaptive objective weighting, then applies a hybrid local search combining dynamic k-opt moves (3-opt/5-opt) with region-based edge optimization, prioritizing high-importance edges identified by combined distance matrix values while ensuring feasibility through lightweight checks. The selection process balances objective values by normalizing and weighting them based on their relative performance, while the local search dynamically adapts the move size (3-opt or 5-opt) and focuses on improving high-impact edges through segment relocation and region-specific swaps. The algorithm maintains feasibility by validating uniqueness of nodes and reverting to the original solution if invalid moves are detected.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    def adaptive_weighting(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n\n        avg_obj1 = sum(o[1][0] for o in archive) / len(archive)\n        avg_obj2 = sum(o[1][1] for o in archive) / len(archive)\n\n        weight1 = 0.7 if obj1 <= avg_obj1 else 0.3\n        weight2 = 0.3 if obj2 <= avg_obj2 else 0.7\n\n        return weight1 * norm1 + weight2 * norm2\n\n    selected_solution = min(pareto_front, key=lambda x: adaptive_weighting(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    def calculate_edge_importance(solution, matrix):\n        importance = []\n        for i in range(n):\n            j = (i + 1) % n\n            importance.append(matrix[solution[i], solution[j]])\n        return np.array(importance)\n\n    imp1 = calculate_edge_importance(new_solution, distance_matrix_1)\n    imp2 = calculate_edge_importance(new_solution, distance_matrix_2)\n    combined_importance = imp1 + imp2\n    sorted_edges = np.argsort(combined_importance)[::-1]\n    selected_edges = sorted_edges[:max(3, n//5)]\n\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost = evaluate(new_solution)\n\n    for edge in selected_edges:\n        if np.random.rand() < 0.6:\n            segment_start = edge\n            segment_end = (edge + 1) % n\n            segment = new_solution[segment_start:segment_end+1]\n            remaining = np.delete(new_solution, slice(segment_start, segment_end+1))\n\n            insertion_scores = []\n            for i in range(len(remaining)):\n                candidate = np.insert(remaining, i, segment)\n                cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n                cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n                insertion_scores.append(0.5 * cost1 + 0.5 * cost2)\n\n            best_insertion = np.argmin(insertion_scores)\n            new_solution = np.insert(remaining, best_insertion, segment)\n\n    k = 3 if n < 8 else np.random.choice([3, 5])\n    if k == 3 and n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:]\n        ]\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n            np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]])\n        ]\n    else:\n        i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:l+1],\n            new_solution[l+1:m+1],\n            new_solution[m+1:]\n        ]\n        possible_solutions = [\n            np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n            np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]])\n        ]\n\n    best_candidate = min(possible_solutions, key=lambda x: sum(evaluate(x)))\n    new_solution = best_candidate\n\n    for _ in range(2):\n        region_size = max(3, n // 6)\n        region_start = np.random.randint(0, n - region_size)\n        region = new_solution[region_start:region_start+region_size]\n\n        for i in range(len(region)-1):\n            for j in range(i+1, len(region)):\n                temp = new_solution.copy()\n                temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                              sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                           sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                if new_cost < current_cost:\n                    new_solution = temp\n                    break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.8426951355889205,
            5.110374653521863
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on a balanced weighting of both objectives (60% first objective, 40% second), then applies a hybrid local search combining adaptive 3-opt moves with path relinking and greedy edge reversal, ensuring feasibility by only accepting improvements in either objective. The method prioritizes the first objective more heavily in selection and evaluation, while the local search explores constrained neighborhoods to maintain solution validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on balanced objectives\n    def dynamic_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.6 * norm1 + 0.4 * norm2  # Balanced weighting\n\n    selected_solution = min(archive, key=lambda x: dynamic_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search combining adaptive 3-opt and path relinking\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Adaptive 3-opt move\n        if n >= 5:\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:]\n            ]\n\n            # Generate all possible 3-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1]])\n            ]\n\n            # Evaluate with balanced weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.5 * cost1 + 0.5 * cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Path relinking with objective-aware acceptance\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n\n                current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                              sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                           sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                # Accept if better in either objective\n                if new_cost < current_cost:\n                    new_solution = temp\n\n        # Greedy edge reversal\n        for _ in range(2):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n            temp = new_solution.copy()\n            temp[i:j+1] = temp[i:j+1][::-1]\n\n            current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                          sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                       sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n            # Accept if better in either objective\n            if new_cost < current_cost:\n                new_solution = temp\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.916729421433921,
            7.099183811604933
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized objectives (prioritizing the first objective more heavily) and applies a hybrid local search combining 4-opt with adaptive edge swapping and greedy edge insertion. It ensures feasibility by maintaining valid TSP tours throughout, with adaptive weighting favoring the first objective in both selection and local search operations. The solution is refined through iterative improvements that balance both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    def weighted_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.7 * norm1 + 0.3 * norm2  # Weighted toward first objective\n\n    selected_solution = min(archive, key=lambda x: weighted_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search combining 4-opt and adaptive edge swapping\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move with adaptive weighting\n        if n >= 6:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Generate all possible 4-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n            ]\n\n            # Evaluate with adaptive weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.6 * cost1 + 0.4 * cost2  # Adaptive weighting\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Adaptive edge swapping in high-improvement regions\n        for _ in range(3):\n            region_size = max(3, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                               sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        # Greedy edge insertion\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            temp_solution = np.delete(new_solution, i)\n\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                candidate = np.insert(temp_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.651765390545433,
            7.558972457057891
        ]
    },
    {
        "algorithm": "This heuristic algorithm first selects the most promising solution from the archive based on the combined objective score, then applies a hybrid local search combining adaptive k-opt moves (dynamically choosing between 3-opt and 5-opt) and region-based edge optimization, prioritizing high-improvement regions while ensuring feasibility through segment recombination. The algorithm balances exploration (random selection of segments and regions) with exploitation (greedy improvement), focusing on both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def evaluate(solution):\n        n = len(solution)\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2)\n\n    def adaptive_k_opt(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n        k = 3 if n < 10 else 5 if n < 20 else np.random.choice([3, 5])\n\n        for _ in range(3):\n            if k == 3 and n >= 4:\n                i, j, k = sorted(np.random.choice(n, 3, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:]\n                ]\n                candidates = [\n                    np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                    np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n                    np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]])\n                ]\n            else:\n                i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:l+1],\n                    new_solution[l+1:m+1],\n                    new_solution[m+1:]\n                ]\n                candidates = [\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n                    np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2], segments[4], segments[5]]),\n                    np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]])\n                ]\n\n            current_cost = evaluate(new_solution)\n            best_candidate = None\n            best_improvement = 0\n\n            for candidate in candidates:\n                candidate_cost = evaluate(candidate)\n                improvement = (current_cost[0] - candidate_cost[0]) + (current_cost[1] - candidate_cost[1])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                new_solution = best_candidate\n\n        return new_solution\n\n    def region_optimization(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        for _ in range(5):\n            region_size = max(3, n // 4)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            best_swap = None\n            best_improvement = 0\n\n            for i in range(len(region)):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n                    temp_cost = evaluate(temp)\n                    current_cost = evaluate(new_solution)\n                    improvement = (current_cost[0] - temp_cost[0]) + (current_cost[1] - temp_cost[1])\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = temp.copy()\n\n            if best_swap is not None:\n                new_solution = best_swap\n\n        return new_solution\n\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    neighbor = adaptive_k_opt(selected_solution)\n    neighbor = region_optimization(neighbor)\n\n    return neighbor\n\n",
        "score": [
            6.16582372719224,
            5.472235166135829
        ]
    },
    {
        "algorithm": "This algorithm selects the best solution from the archive (based on combined objective scores) and applies a hybrid local search combining adaptive 4-opt moves (with dynamic segment selection and weighted improvement evaluation) and objective-weighted edge optimization (focusing on small regions with prioritized objectives). The 4-opt phase explores multiple segment rearrangements with a 70/30 cost weighting, while the edge optimization refines small regions with a 60/40 weighting, ensuring balanced improvement across objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def evaluate(solution):\n        n = len(solution)\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2)\n\n    def adaptive_4_opt(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        for _ in range(5):\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n            candidates = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[1], segments[2], segments[4]])\n            ]\n\n            current_cost = evaluate(new_solution)\n            best_candidate = None\n            best_improvement = 0\n\n            for candidate in candidates:\n                candidate_cost = evaluate(candidate)\n                improvement = 0.7*(current_cost[0] - candidate_cost[0]) + 0.3*(current_cost[1] - candidate_cost[1])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                new_solution = best_candidate\n\n        return new_solution\n\n    def objective_weighted_optimization(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        for _ in range(3):\n            region_size = max(2, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            best_swap = None\n            best_improvement = 0\n\n            for i in range(len(region)):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n                    temp_cost = evaluate(temp)\n                    current_cost = evaluate(new_solution)\n                    improvement = 0.6*(current_cost[0] - temp_cost[0]) + 0.4*(current_cost[1] - temp_cost[1])\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = temp.copy()\n\n            if best_swap is not None:\n                new_solution = best_swap\n\n        return new_solution\n\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    neighbor = adaptive_4_opt(selected_solution)\n    neighbor = objective_weighted_optimization(neighbor)\n\n    return neighbor\n\n",
        "score": [
            5.295073810513461,
            6.530823489946296
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using adaptive objective weighting that balances between the two objectives with dynamic weights, applies a hybrid local search combining segment swaps (2-opt, 3-opt, 4-opt) and edge optimization in local regions, and ensures feasibility through validation while prioritizing solutions with balanced improvement potential across objectives. The selection favors Pareto-front solutions and uses weighted sums of objectives to guide the search, with the local search focusing on improving the weighted objective while maintaining diversity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    def calculate_dynamic_weights(obj1, obj2, iteration):\n        max1 = max(o[1][0] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n        if max1 == 0 or max2 == 0:\n            return (0.5, 0.5)\n        w1 = (obj2/max2) * (1 + 0.1 * np.sin(iteration/10))\n        w2 = (obj1/max1) * (1 + 0.1 * np.cos(iteration/10))\n        return (w1/(w1+w2), w2/(w1+w2))\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    iteration = len(archive) % 100\n    weights = calculate_dynamic_weights(pareto_front[0][1][0], pareto_front[0][1][1], iteration)\n    selected_solution = min(pareto_front, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            return (cost1, cost2)\n\n        current_cost = evaluate(new_solution)\n\n        for _ in range(3):\n            k = np.random.choice([2, 3, 4])\n            if k == 2:\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif k == 3:\n                i, j, k = sorted(np.random.choice(n, 3, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:]\n                ]\n                possible_solutions = [\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2]]),\n                    np.concatenate([segments[0], segments[2], segments[3], segments[1]]),\n                    np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]])\n                ]\n            else:\n                i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:l+1],\n                    new_solution[l+1:]\n                ]\n                possible_solutions = [\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                    np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                    np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3], segments[4]])\n                ]\n\n            if k > 2:\n                for candidate in possible_solutions:\n                    candidate_cost = evaluate(candidate)\n                    if (weights[0]*candidate_cost[0] + weights[1]*candidate_cost[1] <\n                        weights[0]*current_cost[0] + weights[1]*current_cost[1]):\n                        new_solution = candidate\n                        current_cost = candidate_cost\n                        break\n\n        for _ in range(2):\n            region_size = max(2, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    new_cost = evaluate(temp)\n                    if (weights[0]*new_cost[0] + weights[1]*new_cost[1] <\n                        weights[0]*current_cost[0] + weights[1]*current_cost[1]):\n                        new_solution = temp\n                        current_cost = new_cost\n                        break\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n\n    if len(np.unique(neighbor)) != len(neighbor):\n        neighbor = selected_solution.copy()\n        i, j = sorted(np.random.choice(len(neighbor), 2, replace=False))\n        neighbor[i:j+1] = neighbor[i:j+1][::-1]\n\n    return neighbor\n\n",
        "score": [
            5.372182765463692,
            6.111071139792023
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive using adaptive Pareto dominance with dynamic objective weighting, then applies a hybrid local search combining targeted edge optimization (focusing on high-importance edges) and 5-opt moves, while ensuring feasibility through lightweight validation. It prioritizes solutions with balanced objective improvements by dynamically adjusting weights based on archive size and objective magnitudes, and refines the solution through segment reinsertion and region-based swaps. The method balances exploration (via dynamic weights) and exploitation (via importance-based edge selection) to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    def calculate_dynamic_weights(obj1, obj2):\n        max1 = max(o[1][0] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n        if max1 == 0 or max2 == 0:\n            return (0.5, 0.5)\n        w1 = (obj2/max2) * (1 + 0.1 * np.sin(len(archive)/10))\n        w2 = (obj1/max1) * (1 + 0.1 * np.cos(len(archive)/10))\n        return (w1/(w1+w2), w2/(w1+w2))\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    weights = calculate_dynamic_weights(pareto_front[0][1][0], pareto_front[0][1][1])\n    selected_solution = min(pareto_front, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    def calculate_edge_importance(solution, matrix):\n        importance = []\n        for i in range(n):\n            j = (i + 1) % n\n            importance.append(matrix[solution[i], solution[j]])\n        return np.array(importance)\n\n    imp1 = calculate_edge_importance(new_solution, distance_matrix_1)\n    imp2 = calculate_edge_importance(new_solution, distance_matrix_2)\n    combined_importance = imp1 + imp2\n    sorted_edges = np.argsort(combined_importance)[::-1]\n    selected_edges = sorted_edges[:max(3, n//4)]\n\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost = evaluate(new_solution)\n\n    for edge in selected_edges:\n        segment_start = edge\n        segment_end = (edge + 1) % n\n        segment = new_solution[segment_start:segment_end+1]\n        remaining = np.delete(new_solution, slice(segment_start, segment_end+1))\n\n        insertion_scores = []\n        for i in range(len(remaining)):\n            candidate = np.insert(remaining, i, segment)\n            cost1, cost2 = evaluate(candidate)\n            insertion_scores.append(weights[0]*cost1 + weights[1]*cost2)\n\n        best_insertion = np.argmin(insertion_scores)\n        new_solution = np.insert(remaining, best_insertion, segment)\n\n    i, j, k, l, m = sorted(np.random.choice(n, 5, replace=False))\n    segments = [\n        new_solution[:i],\n        new_solution[i:j+1],\n        new_solution[j+1:k+1],\n        new_solution[k+1:l+1],\n        new_solution[l+1:m+1],\n        new_solution[m+1:]\n    ]\n    possible_solutions = [\n        np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n        np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5]]),\n        np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n        np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]]),\n        np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3][::-1], segments[4], segments[5]])\n    ]\n\n    best_candidate = min(possible_solutions, key=lambda x: weights[0]*evaluate(x)[0] + weights[1]*evaluate(x)[1])\n    new_solution = best_candidate\n\n    for _ in range(3):\n        region_size = max(3, n // 5)\n        region_start = np.random.randint(0, n - region_size)\n        region = new_solution[region_start:region_start+region_size]\n\n        for i in range(len(region)-1):\n            for j in range(i+1, len(region)):\n                temp = new_solution.copy()\n                temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                current_cost = weights[0]*evaluate(new_solution)[0] + weights[1]*evaluate(new_solution)[1]\n                new_cost = weights[0]*evaluate(temp)[0] + weights[1]*evaluate(temp)[1]\n\n                if new_cost < current_cost:\n                    new_solution = temp\n                    break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.59176527109771,
            5.888209642233294
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for solution, obj in archive:\n        dominated = False\n        for other_obj in [o[1] for o in archive]:\n            if pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((solution, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    selected_solution = min(pareto_front, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    def adaptive_segment_recombination(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        if n >= 6:\n            k = np.random.choice([4, 6])\n            if k == 4 and n >= 5:\n                i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:l+1],\n                    new_solution[l+1:]\n                ]\n\n                possible_solutions = [\n                    np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                    np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                    np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                    np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]]),\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                    np.concatenate([segments[0], segments[2][::-1], segments[1][::-1], segments[3], segments[4]])\n                ]\n            else:\n                i, j, k, l, m, o = sorted(np.random.choice(n, 6, replace=False))\n                segments = [\n                    new_solution[:i],\n                    new_solution[i:j+1],\n                    new_solution[j+1:k+1],\n                    new_solution[k+1:l+1],\n                    new_solution[l+1:m+1],\n                    new_solution[m+1:o+1],\n                    new_solution[o+1:]\n                ]\n\n                possible_solutions = [\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5], segments[6]]),\n                    np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5], segments[6]]),\n                    np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5], segments[6]]),\n                    np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5], segments[6]]),\n                    np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4], segments[5], segments[6]]),\n                    np.concatenate([segments[0], segments[2][::-1], segments[1][::-1], segments[3], segments[4], segments[5], segments[6]])\n                ]\n\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return (cost1, cost2)\n\n            current_cost = evaluate(new_solution)\n            improved = False\n\n            for candidate in possible_solutions:\n                candidate_cost = evaluate(candidate)\n                if (candidate_cost[0] <= current_cost[0] and candidate_cost[1] < current_cost[1]) or \\\n                   (candidate_cost[0] < current_cost[0] and candidate_cost[1] <= current_cost[1]):\n                    new_solution = candidate\n                    current_cost = candidate_cost\n                    improved = True\n\n            if not improved:\n                best_candidate = min(possible_solutions, key=lambda x: (evaluate(x)[0] + evaluate(x)[1]))\n                new_solution = best_candidate\n\n        region_size = max(3, n // 4)\n        for _ in range(2):\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i:region_start+j+1] = temp[region_start+i:region_start+j+1][::-1]\n\n                    current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                               sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        return new_solution\n\n    neighbor = adaptive_segment_recombination(selected_solution)\n    return neighbor\n\n",
        "score": [
            5.686714484323868,
            5.796051777787124
        ]
    }
]