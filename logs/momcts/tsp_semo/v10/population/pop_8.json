[
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (based on normalized objective scores) and applies a hybrid local search combining 3-opt moves with adaptive perturbations to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower combined normalized objectives and uses random edge selections and segment reversals to explore the search space. The adaptive perturbation (30% chance) adds diversity by occasionally reversing random segments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)  # Select the most balanced solution\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with adaptive perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Reconstruct with different orderings\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_order)) == n:\n        new_solution[i:] = new_order\n\n    # Adaptive perturbation: sometimes reverse a random segment\n    if np.random.rand() < 0.3:  # 30% chance\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.928347725901247,
            5.863588582794563
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by normalizing and summing the objective values, then applies a hybrid local search combining 3-opt with an objective-aware swap prioritizing nodes with high combined distances in both objective spaces. It systematically evaluates potential swaps to improve both objectives simultaneously, ensuring feasibility through structured node selection and cost calculations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with structured objective-aware selection\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[b:c+1] = np.flip(new_solution[b:c+1])\n\n    # Objective-aware worst-node targeting\n    total_distances = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_ = new_solution[(i+1)%n]\n        total_distances[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_] + \\\n                             distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n    worst_node = np.argmax(total_distances)\n\n    # Find the best swap candidate (node that improves both objectives)\n    best_swap = worst_node\n    for i in range(n):\n        if i != worst_node:\n            prev = new_solution[(worst_node-1)%n]\n            curr = new_solution[worst_node]\n            next_ = new_solution[(worst_node+1)%n]\n            new_prev = new_solution[(i-1)%n]\n            new_curr = new_solution[i]\n            new_next = new_solution[(i+1)%n]\n\n            old_cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n            new_cost1 = distance_matrix_1[prev, new_curr] + distance_matrix_1[new_curr, next_] + \\\n                        distance_matrix_1[new_prev, curr] + distance_matrix_1[curr, new_next]\n            delta1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n            new_cost2 = distance_matrix_2[prev, new_curr] + distance_matrix_2[new_curr, next_] + \\\n                        distance_matrix_2[new_prev, curr] + distance_matrix_2[curr, new_next]\n            delta2 = new_cost2 - old_cost2\n\n            if delta1 < 0 and delta2 < 0:\n                best_swap = i\n                break\n\n    if best_swap != worst_node:\n        new_solution[worst_node], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            6.166820109168404,
            5.767610019830773
        ]
    },
    {
        "algorithm": "The algorithm first selects the most promising solution from the archive by combining both objectives with weights (0.6 for the first objective and 0.4 for the second), then applies a hybrid local search strategy: it removes the worst segment (highest combined distance) and reinserts it in a better position, followed by an adaptive 4-opt move with a 70% probability to explore different tour configurations, and finally performs a biased edge swap (50% probability) to improve both objectives by swapping the worst edge with a better candidate. The algorithm ensures feasibility by maintaining valid TSP tours throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def combined_score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]  # Adjust weights based on preference\n    selected_solution = min(archive, key=lambda x: combined_score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify the worst segment (highest total distance in both objectives)\n    segment_scores = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_ = new_solution[(i+1)%n]\n        segment_scores[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_] + \\\n                            distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n    worst_segment = np.argmax(segment_scores)\n\n    # Step 2: Remove the worst segment and reinsert it in a better position\n    removed = new_solution[worst_segment]\n    new_solution = np.delete(new_solution, worst_segment)\n    best_pos = 0\n    best_improvement = 0\n\n    for i in range(n-1):\n        # Try inserting the removed node between i and i+1\n        temp_solution = np.insert(new_solution, i, removed)\n        # Calculate the change in both objectives\n        prev = temp_solution[i-1]\n        curr = temp_solution[i]\n        next_ = temp_solution[(i+1)%(n-1)]\n        delta1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_] - \\\n                 (distance_matrix_1[prev, new_solution[i-1]] + distance_matrix_1[new_solution[i-1], new_solution[i]])\n        delta2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_] - \\\n                 (distance_matrix_2[prev, new_solution[i-1]] + distance_matrix_2[new_solution[i-1], new_solution[i]])\n        improvement = -delta1 - delta2  # Negative because we want to minimize\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = i\n\n    new_solution = np.insert(new_solution, best_pos, removed)\n\n    # Step 3: Apply adaptive 4-opt to further refine the solution\n    if np.random.rand() < 0.7:  # Higher probability to explore\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n        # Try different 4-opt configurations\n        options = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:d][::-1], new_solution[d:]]),\n            np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], new_solution[a:b], new_solution[d:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:d], new_solution[d:]])\n        ]\n        # Evaluate all options and select the best one\n        best_option = new_solution\n        best_score = combined_score((sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                                    sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))))\n        for option in options:\n            score1 = sum(distance_matrix_1[option[i], option[(i+1)%n]] for i in range(n))\n            score2 = sum(distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n))\n            current_score = combined_score((score1, score2))\n            if current_score < best_score:\n                best_score = current_score\n                best_option = option\n        new_solution = best_option\n\n    # Step 4: Perform a biased edge swap to improve both objectives\n    if np.random.rand() < 0.5:\n        # Find the worst edge (highest sum of distances in both objectives)\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            edge_scores[i] = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr]\n        worst_edge = np.argmax(edge_scores)\n\n        # Find the best swap partner that improves both objectives\n        best_swap = worst_edge\n        best_improvement = 0\n\n        for i in range(n):\n            if i != worst_edge and abs(i - worst_edge) > 1:  # Ensure non-adjacent nodes\n                # Calculate the change in both objectives for this swap\n                prev_worst = new_solution[(worst_edge-1)%n]\n                next_worst = new_solution[(worst_edge+1)%n]\n                prev_i = new_solution[(i-1)%n]\n                next_i = new_solution[(i+1)%n]\n\n                old_cost1 = distance_matrix_1[prev_worst, new_solution[worst_edge]] + distance_matrix_1[new_solution[worst_edge], next_worst] + \\\n                            distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i]\n                new_cost1 = distance_matrix_1[prev_worst, new_solution[i]] + distance_matrix_1[new_solution[i], next_worst] + \\\n                            distance_matrix_1[prev_i, new_solution[worst_edge]] + distance_matrix_1[new_solution[worst_edge], next_i]\n                delta1 = new_cost1 - old_cost1\n\n                old_cost2 = distance_matrix_2[prev_worst, new_solution[worst_edge]] + distance_matrix_2[new_solution[worst_edge], next_worst] + \\\n                            distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i]\n                new_cost2 = distance_matrix_2[prev_worst, new_solution[i]] + distance_matrix_2[new_solution[i], next_worst] + \\\n                            distance_matrix_2[prev_i, new_solution[worst_edge]] + distance_matrix_2[new_solution[worst_edge], next_i]\n                delta2 = new_cost2 - old_cost2\n\n                improvement = -delta1 - delta2\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = i\n\n        if best_swap != worst_edge:\n            new_solution[worst_edge], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            5.691282738966747,
            6.858667235229451
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined objective values from the archive, then applies a hybrid local search combining 3-opt with a biased random swap. It first performs a 3-opt move by reversing a randomly selected segment of the tour, and with 50% probability, it identifies the worst node (based on total distance in both objectives) and attempts to swap it with a node that improves both objectives. The method ensures feasibility by maintaining a valid TSP tour throughout the process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a biased random swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices for 3-opt\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt: reverse the segment between b and c\n    new_solution[b:c+1] = np.flip(new_solution[b:c+1])\n\n    # With 50% probability, perform a biased random swap to explore further\n    if np.random.rand() < 0.5:\n        # Find the node with the highest total distance in both spaces\n        total_distances = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_ = new_solution[(i+1)%n]\n            total_distances[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_] + \\\n                                 distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n        worst_node = np.argmax(total_distances)\n        best_swap = worst_node\n\n        # Find the best swap candidate (node that improves both objectives)\n        for i in range(n):\n            if i != worst_node:\n                # Calculate the change in both objectives for this swap\n                prev = new_solution[(worst_node-1)%n]\n                curr = new_solution[worst_node]\n                next_ = new_solution[(worst_node+1)%n]\n                new_prev = new_solution[(i-1)%n]\n                new_curr = new_solution[i]\n                new_next = new_solution[(i+1)%n]\n\n                old_cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n                new_cost1 = distance_matrix_1[prev, new_curr] + distance_matrix_1[new_curr, next_] + \\\n                            distance_matrix_1[new_prev, curr] + distance_matrix_1[curr, new_next]\n                delta1 = new_cost1 - old_cost1\n\n                old_cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n                new_cost2 = distance_matrix_2[prev, new_curr] + distance_matrix_2[new_curr, next_] + \\\n                            distance_matrix_2[new_prev, curr] + distance_matrix_2[curr, new_next]\n                delta2 = new_cost2 - old_cost2\n\n                if delta1 < 0 and delta2 < 0:\n                    best_swap = i\n                    break\n\n        # Perform the swap if beneficial\n        if best_swap != worst_node:\n            new_solution[worst_node], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            6.234115045215999,
            5.848944090331401
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined normalized objective values, then applies a hybrid local search combining objective-aware edge insertion (targeting the worst-performing edges in both objectives) and a controlled 2.5-opt move (with 40% probability) to generate a neighbor solution while ensuring feasibility. The edge insertion step focuses on improving both objectives simultaneously, while the 2.5-opt move adds diversity by reversing segments and reinserting nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: objective-aware edge insertion + 2.5-opt\n    # Step 1: Identify the worst edge in both objectives\n    worst_edge = None\n    max_total_cost = -1\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_ = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n        total_cost = cost1 + cost2\n        if total_cost > max_total_cost:\n            max_total_cost = total_cost\n            worst_edge = i\n\n    # Step 2: Objective-aware edge insertion\n    if worst_edge is not None:\n        # Remove the worst edge's node\n        node_to_insert = new_solution[worst_edge]\n        new_solution = np.delete(new_solution, worst_edge)\n\n        # Find the best insertion point for the removed node to improve both objectives\n        best_pos = -1\n        min_total_delta = float('inf')\n        for i in range(n-1):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_ = new_solution[(i+1)%(n-1)]\n\n            # Calculate delta for first insertion (before curr)\n            delta1 = distance_matrix_1[prev, node_to_insert] + distance_matrix_1[node_to_insert, curr] - distance_matrix_1[prev, curr]\n            delta2 = distance_matrix_2[prev, node_to_insert] + distance_matrix_2[node_to_insert, curr] - distance_matrix_2[prev, curr]\n            total_delta = delta1 + delta2\n\n            if total_delta < min_total_delta:\n                min_total_delta = total_delta\n                best_pos = i\n\n            # Calculate delta for second insertion (after curr)\n            delta1 = distance_matrix_1[curr, node_to_insert] + distance_matrix_1[node_to_insert, next_] - distance_matrix_1[curr, next_]\n            delta2 = distance_matrix_2[curr, node_to_insert] + distance_matrix_2[node_to_insert, next_] - distance_matrix_2[curr, next_]\n            total_delta = delta1 + delta2\n\n            if total_delta < min_total_delta:\n                min_total_delta = total_delta\n                best_pos = i+1\n\n        # Insert the node at the best position\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Step 3: 2.5-opt move (reverse a segment and reinsert a node)\n    if np.random.rand() < 0.4:  # 40% chance\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        # Reverse segment between a and b\n        new_solution[a:b] = new_solution[a:b][::-1]\n        # Remove node at c and reinsert it at a random position\n        node_to_move = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            6.7565940626884,
            5.849808967680021
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive using a weighted sum of normalized objectives, then applies either a 3-opt or segment relocation operator to generate a neighbor, ensuring feasibility while prioritizing exploration of the solution space. For small instances, it defaults to simple swaps, balancing diversification and intensification through random selection and hybrid local search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives and select based on weighted sum\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        weights = np.random.dirichlet(np.ones(2))\n        scores = (normalized * weights).sum(axis=1)\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n >= 5:\n        # Randomly choose between 3-opt and segment relocation\n        if np.random.rand() < 0.5:\n            # 3-opt: randomly select 3 edges and reconnect them\n            a, b, c = sorted(np.random.choice(n, 3, replace=False))\n            # Reconnect the three segments\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n            new_solution[a:c] = new_solution[a:c][::-1]\n        else:\n            # Segment relocation: move a random segment to a different position\n            seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n            new_pos = np.random.randint(0, n)\n            segment = new_solution[seg_start:seg_end]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_end:new_pos],\n                segment,\n                new_solution[new_pos:seg_start],\n                new_solution[seg_end:]\n            ])\n    else:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.762951606074603,
            6.548032432704561
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower total cost) and performs an adaptive 4-opt move to improve both objectives by reversing a worst-performing segment and reinserting nodes based on their total contribution to both distance matrices. It also occasionally applies a segment rotation (30% chance) to explore diverse neighborhoods while ensuring feasibility through careful segment manipulation and validation. The approach balances local improvement with exploration by focusing on high-contribution nodes and segments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst-performing segment in both objectives\n    worst_segment = None\n    max_total_cost = -1\n    for i in range(n):\n        a = new_solution[i-1]\n        b = new_solution[i]\n        c = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n        cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n        total_cost = cost1 + cost2\n        if total_cost > max_total_cost:\n            max_total_cost = total_cost\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Adaptive 4-opt move: reverse a segment and reinsert nodes\n        a = worst_segment\n        b = (worst_segment + 1) % n\n        c = (worst_segment + 2) % n\n\n        # Reverse the segment between a and c\n        new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n        # Reinsert nodes to improve both objectives\n        for _ in range(2):  # Perform two reinsertions\n            # Find the node with the highest contribution to the worst segment\n            max_contribution = -1\n            node_to_move = -1\n            for i in range(n):\n                prev = new_solution[i-1]\n                curr = new_solution[i]\n                next_ = new_solution[(i+1)%n]\n                cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n                cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n                if cost1 + cost2 > max_contribution and i != a and i != b and i != c:\n                    max_contribution = cost1 + cost2\n                    node_to_move = i\n\n            if node_to_move != -1:\n                # Find the best insertion point\n                best_pos = -1\n                min_total_delta = float('inf')\n                for i in range(n):\n                    if i != node_to_move and i != (node_to_move-1)%n and i != (node_to_move+1)%n:\n                        prev = new_solution[i-1]\n                        curr = new_solution[i]\n                        delta1 = (distance_matrix_1[prev, new_solution[node_to_move]] + distance_matrix_1[new_solution[node_to_move], curr]) - distance_matrix_1[prev, curr]\n                        delta2 = (distance_matrix_2[prev, new_solution[node_to_move]] + distance_matrix_2[new_solution[node_to_move], curr]) - distance_matrix_2[prev, curr]\n                        total_delta = delta1 + delta2\n                        if total_delta < min_total_delta:\n                            min_total_delta = total_delta\n                            best_pos = i\n\n                if best_pos != -1:\n                    # Remove and reinsert the node\n                    node_val = new_solution[node_to_move]\n                    new_solution = np.delete(new_solution, node_to_move)\n                    new_solution = np.insert(new_solution, best_pos, node_val)\n\n    # With 30% probability, perform a segment rotation\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        # Rotate the segment between a and b\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            7.393078502041575,
            6.663804846274625
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive by prioritizing those with lower total costs in either objective space, then applies a hybrid local search combining random segment reordering and occasional node swaps to generate a neighbor solution while ensuring feasibility. The algorithm balances exploration (random segment shuffling) and exploitation (targeting lower-cost solutions) while maintaining tour validity through duplicate checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower total cost in either objective space\n    archive_sorted = sorted(archive, key=lambda x: min(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge insertion + node reordering\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reorder\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 2, n)\n\n    # Extract the segment and reverse it\n    segment = new_solution[seg_start:seg_end]\n    np.random.shuffle(segment)\n    new_solution[seg_start:seg_end] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original segment\n        new_solution[seg_start:seg_end] = selected_solution[seg_start:seg_end]\n\n    # Additional: randomly swap two nodes to further explore\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.920911418166373,
            7.983830444680792
        ]
    },
    {
        "algorithm": "The algorithm combines objective-aware selection with a hybrid local search that adaptively improves the worst-performing segments in both objective spaces by either reversing them or inserting them at biased positions, while ensuring feasibility. It prioritizes solutions with higher normalized objective scores and applies segment-based moves to explore the solution space, with a fallback to random swaps for small instances. The method balances exploration and exploitation by dynamically selecting between segment reversal and edge insertion based on a 70% probability threshold.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        weights = np.random.dirichlet(np.ones(2))\n        scores = (normalized * weights).sum(axis=1)\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Identify the worst segment in either objective space\n        worst_segment = None\n        worst_cost = -float('inf')\n\n        for i in range(n):\n            for j in range(i + 2, min(i + n//2, n)):\n                segment = new_solution[i:j]\n                prev = new_solution[i-1]\n                next_ = new_solution[j%n]\n\n                cost1 = distance_matrix_1[prev, segment[0]] + distance_matrix_1[segment[-1], next_]\n                cost2 = distance_matrix_2[prev, segment[0]] + distance_matrix_2[segment[-1], next_]\n\n                total_cost = cost1 + cost2\n                if total_cost > worst_cost:\n                    worst_cost = total_cost\n                    worst_segment = (i, j)\n\n        if worst_segment:\n            i, j = worst_segment\n            # With 70% probability, reverse the segment; otherwise, perform biased edge insertion\n            if np.random.rand() < 0.7:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                # Biased edge insertion: find the best insertion point for the first node of the segment\n                best_insert_pos = i\n                best_improvement = 0\n\n                for pos in range(n):\n                    if pos >= i and pos < j:\n                        continue\n\n                    prev_node = new_solution[pos-1]\n                    next_node = new_solution[pos%n]\n                    node = new_solution[i]\n\n                    old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    new_cost1 = distance_matrix_1[prev_node, new_solution[i+1]] + distance_matrix_1[new_solution[i+1], next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    new_cost2 = distance_matrix_2[prev_node, new_solution[i+1]] + distance_matrix_2[new_solution[i+1], next_node]\n\n                    improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insert_pos = pos\n\n                # Insert the segment at the best position\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([\n                    new_solution[:i],\n                    new_solution[j:best_insert_pos],\n                    segment,\n                    new_solution[best_insert_pos:i],\n                    new_solution[j:]\n                ])\n    else:\n        # For small instances, perform a biased random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.95198738095552,
            7.957775794953494
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of objectives) and applies a hybrid local search combining random swaps and segment reversals to explore diverse neighborhoods while ensuring feasibility. The selected solution is copied, and then 10 iterations of random swaps and segment reversals are performed to generate a neighbor solution. The algorithm prioritizes solutions with lower combined objective values and uses stochastic local search to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: random swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            8.721355880941434,
            8.525583452943698
        ]
    }
]