[
    {
        "algorithm": "This algorithm selects promising solutions from an archive using a modified knee-point approach to balance objective improvements, then applies a hybrid local search combining adaptive 3-opt moves and objective-weighted segment inversions, dynamically adjusting move sizes based on historical improvement patterns while ensuring feasibility through validation. The selection prioritizes solutions with better knee-point scores, and the local search prioritizes moves that improve both objectives based on their historical improvement rates, with segment inversions dynamically sized to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Modified knee point selection\n    def calculate_knee_scores(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        knee_scores = np.max(normalized, axis=1) - np.sum(normalized, axis=1)\n        return knee_scores\n\n    knee_scores = calculate_knee_scores(archive)\n    selected_idx = np.argmax(knee_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 2: Historical improvement tracking\n    improvement_rates = [1.0, 1.0]\n    if len(archive) > 2:\n        obj1_prev = archive[-3][1][0]\n        obj1_curr = archive[-1][1][0]\n        obj2_prev = archive[-3][1][1]\n        obj2_curr = archive[-1][1][1]\n        improvement_rates = [\n            max(0.1, min(2.0, (obj1_prev - obj1_curr) / (obj1_prev + 1e-10))),\n            max(0.1, min(2.0, (obj2_prev - obj2_curr) / (obj2_prev + 1e-10)))\n        ]\n\n    # Step 3: Hybrid local search with adaptive 3-opt and weighted inversions\n    def evaluate_3opt(a, b, c):\n        pre_a = new_solution[a-1] if a > 0 else new_solution[-1]\n        post_c = new_solution[c+1] if c < n-1 else new_solution[0]\n\n        orig_cost1 = (distance_matrix_1[pre_a, new_solution[a]] +\n                      distance_matrix_1[new_solution[b], new_solution[c]] +\n                      distance_matrix_1[new_solution[c], post_c])\n        orig_cost2 = (distance_matrix_2[pre_a, new_solution[a]] +\n                      distance_matrix_2[new_solution[b], new_solution[c]] +\n                      distance_matrix_2[new_solution[c], post_c])\n\n        new_cost1 = (distance_matrix_1[pre_a, new_solution[b]] +\n                     distance_matrix_1[new_solution[c], new_solution[a]] +\n                     distance_matrix_1[new_solution[a], post_c])\n        new_cost2 = (distance_matrix_2[pre_a, new_solution[b]] +\n                     distance_matrix_2[new_solution[c], new_solution[a]] +\n                     distance_matrix_2[new_solution[a], post_c])\n\n        return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n    # Adaptive 3-opt moves\n    best_3opt = None\n    best_3opt_improvement = (0, 0)\n\n    for _ in range(5):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        delta1, delta2 = evaluate_3opt(a, b, c)\n        weighted_improvement = (delta1 * improvement_rates[0] + delta2 * improvement_rates[1])\n\n        if weighted_improvement < 0 and (delta1 < best_3opt_improvement[0] and delta2 < best_3opt_improvement[1]):\n            best_3opt_improvement = (delta1, delta2)\n            best_3opt = (a, b, c)\n\n    if best_3opt is not None:\n        a, b, c = best_3opt\n        new_solution[a:c+1] = np.concatenate([new_solution[b:c+1], new_solution[a:b][::-1]])\n\n    # Objective-weighted segment inversion\n    segment_size = max(3, min(7, int(n * (1.0 / (1.0 + np.sum(improvement_rates))))))\n    best_inversion = None\n    best_inversion_improvement = (0, 0)\n\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n        weighted_improvement = (delta1 * improvement_rates[0] + delta2 * improvement_rates[1])\n\n        if weighted_improvement < 0 and (delta1 < best_inversion_improvement[0] and delta2 < best_inversion_improvement[1]):\n            best_inversion_improvement = (delta1, delta2)\n            best_inversion = (start, segment_size)\n\n    if best_inversion is not None:\n        start, size = best_inversion\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.475659976277734,
            4.885485815997759
        ]
    },
    {
        "algorithm": "This algorithm combines crowding-distance-aware selection with a multi-phase hybrid operator that first performs objective-aware edge inversions, then dynamically relocates segments based on historical improvement rates, and finally adaptively reinserts nodes prioritizing positions that minimize combined objective costs while ensuring feasibility through permutation validation. The selection prioritizes solutions with higher crowding distances, and the local search operators progressively refine the tour by considering both objectives, with edge inversions and segment relocations guided by improvement rates, while node reinsertions optimize for combined costs. The algorithm maintains feasibility by validating permutations and falls back to random swaps if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding-distance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (np.max(objectives[:, i]) - np.min(objectives[:, i]) + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Calculate historical improvement rates\n    objective_history = np.array([obj for _, obj in archive])\n    improvement_rates = np.std(objective_history, axis=0)\n\n    # Objective-aware edge inversions\n    for _ in range(max(3, n // 3)):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        segment = new_solution[i:j+1]\n        inverted_segment = segment[::-1]\n\n        orig_cost1 = distance_matrix_1[new_solution[i-1] if i > 0 else new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[j+1] if j < n-1 else new_solution[0]]\n        orig_cost2 = distance_matrix_2[new_solution[i-1] if i > 0 else new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[j+1] if j < n-1 else new_solution[0]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1] if i > 0 else new_solution[-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[j+1] if j < n-1 else new_solution[0]]\n        new_cost2 = distance_matrix_2[new_solution[i-1] if i > 0 else new_solution[-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[j+1] if j < n-1 else new_solution[0]]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.2 * improvement_rates[0] and delta2 < -0.2 * improvement_rates[1]):\n            new_solution[i:j+1] = inverted_segment\n\n    # Dynamic segment relocation with adaptive size\n    segment_size = max(4, min(8, n // 2))\n    segment_size = max(2, int(segment_size * (1 / (1 + improvement_rates[0] + improvement_rates[1]))))\n\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    pre_orig = new_solution[start-1] if start > 0 else new_solution[-1]\n    post_orig = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_orig, segment[0]] + distance_matrix_1[segment[-1], post_orig]\n    orig_cost2 = distance_matrix_2[pre_orig, segment[0]] + distance_matrix_2[segment[-1], post_orig]\n\n    new_pos = np.random.randint(0, n - segment_size)\n    if new_pos == start:\n        new_pos = (new_pos + segment_size) % (n - segment_size)\n\n    pre_new = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n    post_new = new_solution[new_pos] if new_pos < n-segment_size else new_solution[0]\n\n    new_cost1 = distance_matrix_1[pre_new, segment[0]] + distance_matrix_1[segment[-1], post_new]\n    new_cost2 = distance_matrix_2[pre_new, segment[0]] + distance_matrix_2[segment[-1], post_new]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if (delta1 < 0 and delta2 < 0) or (delta1 < -0.15 * improvement_rates[0] and delta2 < -0.15 * improvement_rates[1]):\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Adaptive node reinsertion with edge inversion\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n\n    if node_pos == 0:\n        new_solution = np.concatenate([new_solution[1:], [node]])\n    else:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(n-1):\n        pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        post = new_solution[pos]\n\n        cost1 = distance_matrix_1[pre, node] + distance_matrix_1[node, post] - distance_matrix_1[pre, post]\n        cost2 = distance_matrix_2[pre, node] + distance_matrix_2[node, post] - distance_matrix_2[pre, post]\n\n        combined_cost = cost1 + cost2\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.179368986816559,
            7.296290065636853
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding distance, then applies a hybrid local search combining adaptive partial permutations and dynamic node reinsertions. It prioritizes balanced improvements in both objectives by evaluating segment flips and node insertions based on their combined cost reduction, while maintaining feasibility through permutation validation and insertion point selection. The segment size and number of iterations are dynamically adjusted to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance to select a diverse solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on historical improvements\n    segment_size = max(2, min(n // 2, 5))\n\n    # Objective-aware partial permutation with dynamic segment size\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Evaluate partial permutation\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[end] if end < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, new_solution[start]] + distance_matrix_1[new_solution[end-1], post]\n        orig_cost2 = distance_matrix_2[pre, new_solution[start]] + distance_matrix_2[new_solution[end-1], post]\n\n        # New edges after partial permutation\n        new_cost1 = distance_matrix_1[pre, new_solution[end-1]] + distance_matrix_1[new_solution[start], post]\n        new_cost2 = distance_matrix_2[pre, new_solution[end-1]] + distance_matrix_2[new_solution[start], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement (prioritize balanced improvements)\n        if (delta1 < 0 and delta2 < 0) or (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, end)\n\n    # Apply the best found partial permutation\n    if best_segment is not None:\n        start, end = best_segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node reinsertion based on improvement history\n    for _ in range(2):\n        remove_pos = np.random.randint(0, n)\n        node_to_insert = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Find best insertion point considering both objectives\n        best_insert_pos = -1\n        best_insert_cost = (np.inf, np.inf)\n\n        for i in range(n-1):\n            pre = new_solution[i-1] if i > 0 else new_solution[-1]\n            post = new_solution[i]\n\n            cost1 = distance_matrix_1[pre, node_to_insert] + distance_matrix_1[node_to_insert, post] - distance_matrix_1[pre, post]\n            cost2 = distance_matrix_2[pre, node_to_insert] + distance_matrix_2[node_to_insert, post] - distance_matrix_2[pre, post]\n\n            if (cost1 + cost2 < best_insert_cost[0] + best_insert_cost[1]) or (cost1 < 0 and cost2 < 0):\n                best_insert_pos = i\n                best_insert_cost = (cost1, cost2)\n\n        if best_insert_pos != -1:\n            new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.942471123541795,
            5.451263069957333
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding distance, then applies a hybrid local search combining objective-aware edge swaps (with adaptive selection based on historical improvements) and dynamic segment inversion (with segment sizes adjusted based on improvement rates), ensuring feasibility through validation checks. The method prioritizes solutions with high crowding distance, performs edge swaps to improve both objectives, and uses segment inversions to further refine the tour, with adaptive parameters balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Crowding-distance-aware selection\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        front = objectives.copy()\n        distances = np.zeros(len(front))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(front[:, m])\n            front = front[sorted_idx]\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(front)-1):\n                distances[sorted_idx[i]] += (front[sorted_idx[i+1], m] - front[sorted_idx[i-1], m]) / (front[-1, m] - front[0, m] + 1e-6)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    improvement_history = {1: [], 2: []}\n\n    # Phase 2: Objective-aware edge swaps with adaptive selection\n    for _ in range(max(2, n // 5)):\n        best_improvement = (0, 0)\n        best_swap = None\n\n        for i in range(n):\n            for j in range(i+2, n):\n                if j == (i+1) % n:\n                    continue\n\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                delta1 = new_cost1 - orig_cost1\n                delta2 = new_cost2 - orig_cost2\n\n                if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or \\\n                   (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n                    best_improvement = (delta1, delta2)\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n            improvement_history[1].append(best_improvement[0])\n            improvement_history[2].append(best_improvement[1])\n\n    # Phase 3: Dynamic segment inversion with adaptive size\n    if improvement_history[1] and improvement_history[2]:\n        avg_improvement1 = np.mean(improvement_history[1])\n        avg_improvement2 = np.mean(improvement_history[2])\n        segment_size = max(2, min(n//3, int(1 / (0.1 + avg_improvement1 + avg_improvement2))))\n\n        for _ in range(2):\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n\n            def evaluate_inversion(sol, start, size):\n                pre = sol[start-1] if start > 0 else sol[-1]\n                post = sol[start+size] if start+size < n else sol[0]\n\n                orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n                orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n                new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n                new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n                return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n            delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n            if (delta1 < 0 and delta2 < 0) or \\\n               (delta1 < -0.15 * avg_improvement1 or delta2 < -0.15 * avg_improvement2):\n                new_solution[start:start+segment_size] = segment[::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.644627787759498,
            6.0747009109710755
        ]
    },
    {
        "algorithm": "The algorithm selects diverse solutions from the archive (high crowding distance) and applies a hybrid local search combining large-scale segment inversions, multi-objective edge swaps, and adaptive node reinsertions, dynamically adjusting segment sizes and move acceptance criteria to balance bi-objective improvements. It prioritizes solutions with better crowding distance and uses a three-phase approach (segment inversion, edge swaps, and node reinsertion) with adaptive segment sizes and multi-objective acceptance criteria to explore high-quality neighbors while ensuring feasibility. The method emphasizes exploration of diverse regions while maintaining solution quality through careful move selection and dynamic adjustments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_indices[0]] = float('inf')\n    crowding_dist[sorted_indices[-1]] = float('inf')\n\n    for i in range(1, len(archive)-1):\n        crowding_dist[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem scale and recent improvements\n    segment_size = max(3, min(8, n // 3))\n\n    # Hybrid local search with three phases\n    for phase in range(3):\n        # Phase 1: Large-scale segment inversion\n        best_improvement = (0, 0)\n        best_segment = None\n\n        for _ in range(5):  # More attempts for larger segments\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n            orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n            orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n            new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n            new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n            delta1 = new_cost1 - orig_cost1\n            delta2 = new_cost2 - orig_cost2\n\n            if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.2 * abs(best_improvement[0]) or delta2 < -0.2 * abs(best_improvement[1])):\n                best_improvement = (delta1, delta2)\n                best_segment = (start, segment_size)\n\n        if best_segment is not None and (best_improvement[0] < 0 or best_improvement[1] < 0):\n            start, size = best_segment\n            new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n        # Phase 2: Multi-objective edge swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n        new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * abs(delta2) and delta2 < -0.1 * abs(delta1)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Phase 3: Adaptive node reinsertion\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        if node_pos == 0:\n            new_solution = np.concatenate([new_solution[1:], [node]])\n        else:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            post = new_solution[pos]\n\n            cost1 = distance_matrix_1[pre, node] + distance_matrix_1[node, post] - distance_matrix_1[pre, post]\n            cost2 = distance_matrix_2[pre, node] + distance_matrix_2[node, post] - distance_matrix_2[pre, post]\n\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.360144564634852,
            5.537172679117202
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower objectives) and applies a hybrid local search combining adaptive segment inversions (with dynamic segment sizes) and edge swaps, evaluating improvements in both objective spaces while ensuring feasibility. It balances exploration/exploitation through adaptive segment sizing and operator selection based on recent performance, favoring operators that improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and recent improvements\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]\n\n    # Hybrid local search with adaptive operator selection\n    for _ in range(2):\n        # Adaptive segment inversion\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))\n            continue\n\n        # Edge swap if inversion didn't help\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        def evaluate_swap(sol, i, j):\n            pre_i = sol[i-1] if i > 0 else sol[-1]\n            post_i = sol[i+1] if i < n-1 else sol[0]\n            pre_j = sol[j-1] if j > 0 else sol[-1]\n            post_j = sol[j+1] if j < n-1 else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n            orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n            new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n            new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n\n    return new_solution\n\n",
        "score": [
            5.650655791934891,
            5.828830062644275
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower combined objectives) and applies a dynamic, objective-aware local search combining segment inversions and edge swaps, evaluating improvements in both objectives to ensure feasibility while balancing exploration and exploitation. It adaptively selects segment sizes and accepts inversions or swaps that show significant improvements in either objective, ensuring valid TSP tours through permutation checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size\n    segment_size = max(2, min(5, n // 4))\n\n    # Objective-aware segment inversion\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(3):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # New edges after inversion\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement\n        if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.1 * abs(best_improvement[0]) or delta2 < -0.1 * abs(best_improvement[1])):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, segment_size)\n\n    # Apply the best found inversion\n    if best_segment is not None:\n        start, size = best_segment\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Edge swap with objective awareness\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    # Evaluate swap\n    pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n    pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n    orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n    new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n    new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.80145785411436,
            5.7754796233164205
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Crowding-distance-aware selection\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        front = objectives.copy()\n        distances = np.zeros(len(front))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(front[:, m])\n            front = front[sorted_idx]\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(front)-1):\n                distances[sorted_idx[i]] += (front[sorted_idx[i+1], m] - front[sorted_idx[i-1], m]) / (front[-1, m] - front[0, m] + 1e-6)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Phase 2: Objective-aware edge swaps with dynamic selection\n    for _ in range(3):\n        best_improvement = (0, 0)\n        best_swap = None\n\n        for i in range(n):\n            for j in range(i+2, n):\n                if j == (i+1) % n:\n                    continue\n\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                delta1 = new_cost1 - orig_cost1\n                delta2 = new_cost2 - orig_cost2\n\n                if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or \\\n                   (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n                    best_improvement = (delta1, delta2)\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    # Phase 3: Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]\n\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or \\\n           (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.06054686155467,
            5.75938619182241
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding distance, then applies a hybrid local search combining objective-aware edge swaps and dynamic segment inversions, with segment sizes adjusted based on historical improvement rates to balance exploration and exploitation while maintaining feasibility. Edge swaps prioritize simultaneous improvements in both objectives, while dynamic segment inversion adapts to past performance, ensuring valid TSP tours through validation checks. The method balances global and local search by dynamically adjusting exploration intensity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for selection\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n    crowding_distances = np.zeros(n)\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_nodes = len(base_solution)\n    improvement_history = {1: [], 2: []}  # Track improvement rates for each objective\n\n    # Hybrid operator: edge swaps + dynamic segment inversion\n    for _ in range(3):  # Reduced iterations for efficiency\n        # Phase 1: Objective-aware edge swaps\n        best_improvement = 0\n        best_swap = None\n\n        for i in range(n_nodes):\n            for j in range(i+2, n_nodes):\n                if j == (i+1) % n_nodes:\n                    continue\n\n                # Current edges\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n_nodes]\n\n                # Original cost\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                # Swapped cost\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n            # Record improvement\n            improvement_history[1].append(orig_cost1 - new_cost1)\n            improvement_history[2].append(orig_cost2 - new_cost2)\n\n        # Phase 2: Dynamic segment inversion\n        if improvement_history[1] and improvement_history[2]:\n            # Calculate average improvement rates\n            avg_improvement1 = np.mean(improvement_history[1])\n            avg_improvement2 = np.mean(improvement_history[2])\n\n            # Determine segment size inversely proportional to improvement rates\n            segment_size = max(2, min(n_nodes//2, int(1 / (0.1 + avg_improvement1 + avg_improvement2))))\n\n            # Select random segment\n            a = np.random.randint(0, n_nodes - segment_size)\n            b = a + segment_size\n\n            # Invert the segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n_nodes:\n        # Fallback to simple inversion if invalid\n        a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.242994893163757,
            5.674527708525447
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding distance, then applies a hybrid local search combining objective-aware edge swaps and dynamic segment inversions, with segment sizes adjusted based on historical improvement rates to balance exploration and exploitation while maintaining feasibility through validation checks. The method prioritizes solutions with high crowding distances, performs edge swaps to improve both objectives, and dynamically adjusts segment sizes for inversion based on past improvement rates.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for selection\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n    crowding_distances = np.zeros(n)\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_nodes = len(base_solution)\n    improvement_history = {1: [], 2: []}  # Track improvement rates for each objective\n\n    # Hybrid operator: edge swaps + dynamic segment inversion\n    for _ in range(3):\n        # Phase 1: Objective-aware edge swaps\n        best_improvement = (0, 0)\n        best_swap = None\n\n        for i in range(n_nodes):\n            for j in range(i+2, n_nodes):\n                if j == (i+1) % n_nodes:\n                    continue\n\n                # Current edges\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n_nodes]\n\n                # Original cost\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                # Swapped cost\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                delta1 = new_cost1 - orig_cost1\n                delta2 = new_cost2 - orig_cost2\n\n                if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n                    best_improvement = (delta1, delta2)\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n            # Record improvement\n            improvement_history[1].append(best_improvement[0])\n            improvement_history[2].append(best_improvement[1])\n\n        # Phase 2: Dynamic segment inversion\n        if improvement_history[1] and improvement_history[2]:\n            # Calculate average improvement rates\n            avg_improvement1 = np.mean(improvement_history[1])\n            avg_improvement2 = np.mean(improvement_history[2])\n\n            # Determine segment size inversely proportional to improvement rates\n            segment_size = max(2, min(n_nodes//2, int(1 / (0.1 + avg_improvement1 + avg_improvement2))))\n\n            # Select random segment\n            a = np.random.randint(0, n_nodes - segment_size)\n            b = a + segment_size\n\n            # Invert the segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n_nodes:\n        # Fallback to simple inversion if invalid\n        a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.317917230148229,
            5.553051946632512
        ]
    }
]