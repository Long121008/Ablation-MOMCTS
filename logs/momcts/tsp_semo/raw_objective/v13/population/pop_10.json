[
    {
        "algorithm": "The algorithm selects the solution with the lowest combined cost from the archive, then applies a hybrid local search combining segment reversal and edge swaps to generate a new neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses novel segment reversal to explore the solution space beyond standard edge swaps. The selection and operators ensure valid tours by maintaining node uniqueness and completeness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal (novel operator)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a random edge swap (standard operator)\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9453093012944958,
            0.1820637583732605
        ],
        "raw_score": [
            6.180186675512935,
            6.63654462139858
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (favoring lower-cost solutions but allowing some diversity) and applies a cross-segment swap operator, randomly exchanging two non-overlapping segments of the tour to generate a neighbor solution while ensuring feasibility. The selection prioritizes exploitation of good solutions but balances it with exploration by occasionally choosing from the middle of the archive. The cross-segment swap is a novel local search operator that disrupts larger tour structures compared to standard edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_threshold = min(2 * len(sorted_archive) // 3, len(sorted_archive) - 1)\n    selected_solution = random.choice(sorted_archive[:selection_threshold])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-segment swap: select two non-overlapping segments and swap them\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create new solution by swapping segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end+1:seg2_start],\n        seg1,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.837455409186324,
            0.1816069483757019
        ],
        "raw_score": [
            6.500691332763455,
            6.600301261577352
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects balanced solutions from the archive based on normalized objective scores, then applies a probabilistic hybrid local search combining segment merging and dynamic k-opt (k=2-4), ensuring feasibility through uniqueness checks and missing node repair. It prioritizes solutions with balanced objectives (lower balance score) and uses randomized segment recombination to explore the solution space while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize solutions with balanced objective improvements\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize and calculate balance score (lower is better)\n    max_obj1 = max(obj[0] for obj in objectives) if any(obj[0] for obj in objectives) else 1\n    max_obj2 = max(obj[1] for obj in objectives) if any(obj[1] for obj in objectives) else 1\n    normalized = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n    balance_scores = [abs(obj1 - obj2) for obj1, obj2 in normalized]  # Prefer balanced solutions\n\n    # Select based on balance score with some randomness\n    weights = [1/(1 + score) for score in balance_scores]\n    total_weight = sum(weights)\n    probabilities = [w/total_weight for w in weights]\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Sophisticated local search: probabilistic segment merging and dynamic k-opt\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine k for k-opt (between 2 and 4)\n    k = random.choice([2, 3, 4])\n\n    if n > k + 1:\n        # Select k random segments to modify\n        points = sorted(random.sample(range(n), k))\n        segments = []\n        for i in range(k):\n            start = points[i]\n            end = points[(i+1)%k] if (i+1)%k != 0 else n\n            if start > end:\n                segments.append(new_solution[start:] + new_solution[:end])\n            else:\n                segments.append(new_solution[start:end])\n\n        # Recombine segments in a new order\n        random.shuffle(segments)\n        new_order = []\n        for seg in segments:\n            new_order.extend(seg)\n\n        # Ensure uniqueness and fix duplicates if any\n        unique_order = []\n        seen = set()\n        for node in new_order:\n            if node not in seen:\n                seen.add(node)\n                unique_order.append(node)\n\n        # Fill missing nodes\n        missing = [node for node in base_solution if node not in seen]\n        unique_order.extend(missing)\n\n        new_solution = np.array(unique_order)\n\n    # Validate the solution remains feasible\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9672992767713314,
            0.24489057064056396
        ],
        "raw_score": [
            7.261666706830336,
            6.767282304986544
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a random solution from the archive, applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor, and ensures feasibility by checking for duplicates. The algorithm prioritizes diversity and non-dominance implicitly by random selection, while the local search explores the solution space creatively by reversing segments and reinserting edges at random positions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_end = (edge_start + 1) % n\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[edge_end]\n\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:edge_start], new_solution[edge_end+1:]])\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node1)\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node2)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8700755886195684,
            0.21495270729064941
        ],
        "raw_score": [
            7.227454476992637,
            6.950987236943185
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the lowest combined cost (sum of both objectives), then applies a hybrid local search combining segment reversal and a novel node insertion to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses random segment reversal and node insertion to explore the search space, maintaining validity by checking for duplicate nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine segment reversal with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a novel node insertion (insert a node from a random position to another)\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8447560499453636,
            0.19697046279907227
        ],
        "raw_score": [
            6.450616079700156,
            6.332469275271153
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive using weighted random sampling based on normalized objective values, then applies a hybrid local search combining adaptive segment reversal and probabilistic edge swaps to generate a feasible neighbor solution, prioritizing solutions with lower combined costs while ensuring the tour remains valid. The selection weights favor solutions with better normalized objectives, and the local search adaptively adjusts segment length and swap probability based on problem size.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection with weighted random sampling\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (1 + np.sum(normalized_costs, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with probabilistic length\n    if n > 3:\n        seg_length = min(random.randint(2, n//2), n-2)\n        start = random.randint(0, n-seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Probabilistic edge swaps with adaptive intensity\n    swap_prob = 0.3 if n > 20 else 0.5\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility validation\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8918576688915671,
            0.22738558053970337
        ],
        "raw_score": [
            6.745697351573674,
            6.870386781264237
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weighted selection based on normalized objective values\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to [0, 1] range\n    max_obj1 = max(obj[0] for obj in objectives) if any(obj[0] for obj in objectives) else 1\n    max_obj2 = max(obj[1] for obj in objectives) if any(obj[1] for obj in objectives) else 1\n    normalized = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n\n    # Calculate weights based on combined potential (inverse of normalized values)\n    weights = [1/(1 + obj1 + obj2) for obj1, obj2 in normalized]\n    total_weight = sum(weights)\n    probabilities = [w/total_weight for w in weights]\n\n    # Select a solution using weighted random choice\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: probabilistic combination of segment reversal and cross-segment swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine operator selection based on relative objective improvement potential\n    obj1_improvement = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj2_improvement = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    if random.random() < 0.7:  # 70% chance of segment reversal\n        if n > 3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # 30% chance of cross-segment swap\n        if n > 4:\n            # Select two non-overlapping segments\n            split1 = random.randint(1, n-3)\n            split2 = random.randint(split1+1, n-2)\n            # Swap the two segments\n            segment1 = new_solution[:split1]\n            segment2 = new_solution[split1:split2]\n            segment3 = new_solution[split2:]\n            new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Validate the solution remains feasible\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9111867797829649,
            0.22890198230743408
        ],
        "raw_score": [
            6.640226332160937,
            6.430528959596512
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted probability based on normalized objective values, then applies a hybrid local search combining segment reversal and cross-segment swaps to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with better combined objective values, while the local search explores diverse perturbations of the tour structure. The method dynamically balances exploration and exploitation by randomly choosing between segment reversal and cross-segment swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate weights\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + np.sum(normalized, axis=1))\n\n    # Select a solution with weighted probability\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal + cross-segment swap\n    if random.random() < 0.5:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Cross-segment swap\n        seg1_start = random.randint(0, n - 4)\n        seg1_end = random.randint(seg1_start + 1, n - 3)\n        seg2_start = random.randint(seg1_end + 1, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9143047715824839,
            0.23058104515075684
        ],
        "raw_score": [
            6.432082051238435,
            7.00090158583507
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects a solution from the archive with weighted sampling, prioritizing lower-cost solutions, and applies a hybrid local search operator (segment reversal, node insertion, or edge swap) to generate a neighbor while ensuring feasibility. The selection balances exploration and exploitation, while the hybrid operator introduces diversity beyond standard 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: weighted sampling based on inverse of combined cost\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    combined_costs = [sum(obj) for obj in objectives]\n    min_cost = min(combined_costs)\n    weights = [1.0 / (cost - min_cost + 1e-6) for cost in combined_costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(solutions)), weights=weights, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine segment reversal, node insertion, and edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three operators\n    operator = random.choice(['segment_reversal', 'node_insertion', 'edge_swap'])\n\n    if operator == 'segment_reversal' and n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    elif operator == 'node_insertion' and n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n    elif operator == 'edge_swap' and n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7972943019164536,
            0.19001930952072144
        ],
        "raw_score": [
            6.273739444916374,
            5.597086427916787
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.mean([np.linalg.norm(sol - other) for other in solutions]) for sol in solutions]\n    selection_scores = [obj[0] * 0.5 + obj[1] * 0.3 + div * 0.2 for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with controlled disruption\n    if n > 3:\n        k = random.randint(1, min(3, n//2))  # Limit rotation to small segments\n        new_solution = np.roll(new_solution, k)\n\n    # Edge insertion with feasibility check\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (i + j) // 2 if i < j else (i + j + 1) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Validate feasibility\n    if len(set(new_solution)) != len(new_solution):\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9092558547377287,
            2.49730521440506
        ],
        "raw_score": [
            5.720869650024556,
            7.851523467482659
        ]
    }
]