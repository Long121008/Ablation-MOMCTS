[
    {
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7844549425744639,
            0.07181447744369507
        ],
        "raw_score": [
            7.625964615140017,
            7.498210330113637
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9208610717093059,
            0.135880708694458
        ],
        "raw_score": [
            10.497270395519887,
            10.635201664382908
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on Pareto diversity (high crowding distance) and applies a hybrid local search combining segment reversal and probabilistic edge insertion, ensuring feasibility through objective-aware repair and falling back to 3-opt if needed. It prioritizes solutions with high crowding distance to maintain diversity in the objective space while using a novel combination of moves to explore the solution space more effectively than standard approaches.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9620178974683407,
            0.19321191310882568
        ],
        "raw_score": [
            10.474873863632933,
            10.591316583367643
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with balanced objective values (weighted between 0.4 and 0.6) and applies a hybrid local search combining segment inversion and probabilistic edge exchanges, ensuring feasibility through a node validation and repair mechanism. It dynamically adjusts segment lengths and swap probabilities to explore the solution space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.uniform(0.4, 0.6)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        segment_length = np.random.randint(3, min(6, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution[start:start + segment_length] = segment[::-1]\n\n        if np.random.rand() < 0.6:\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9700281800182895,
            0.2160702347755432
        ],
        "raw_score": [
            6.790142251435691,
            6.522603093212192
        ]
    },
    {
        "algorithm": "The algorithm selects a promising TSP tour from the archive by prioritizing solutions with balanced objective improvements, then applies a hybrid local search combining multi-segment crossover and objective-aware edge flips, while ensuring feasibility through a missing-node reinsertion mechanism. The method focuses on balancing trade-offs between objectives by preferring solutions where both costs are similarly improved, and uses randomized segment swaps and selective edge reversals to explore the search space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment crossover operator\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment1 = new_solution[a:b]\n        c, d = np.random.choice(n, 2, replace=False)\n        if c > d:\n            c, d = d, c\n        segment2 = new_solution[c:d]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]\n        ])\n\n        # Objective-aware edge flips\n        for _ in range(2):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Missing-node reinsertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7070289832216284,
            0.0992804765701294
        ],
        "raw_score": [
            7.374883770537505,
            7.453954402412746
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted sum of objectives (60% weight for the first objective, 40% for the second), then applies a segment insertion operator followed by a limited objective-aware edge exchange (2 operations max) prioritizing the objective with higher relative improvement (threshold of 5%). It ensures feasibility by repairing duplicates, replacing them with missing nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted sum of objectives\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment insertion operator\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        segment = new_solution[i:j].copy()\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        # Objective-aware edge exchange (prioritize objective with higher relative improvement)\n        for _ in range(2):  # Limit to 2 operations\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Calculate relative improvements\n            rel_improv1 = (current_obj1 - new_obj1) / current_obj1 if current_obj1 != 0 else 0\n            rel_improv2 = (current_obj2 - new_obj2) / current_obj2 if current_obj2 != 0 else 0\n\n            if rel_improv1 > rel_improv2 and rel_improv1 > 0.05:  # Threshold for objective 1\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif rel_improv2 > rel_improv1 and rel_improv2 > 0.05:  # Threshold for objective 2\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8031283573974434,
            0.1561204195022583
        ],
        "raw_score": [
            8.964035255346213,
            8.705240905356447
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from an archive based on a weighted combination of objective diversity and quality (prioritizing solutions with higher diversity and better quality), then applies a novel hybrid local search combining segment rotation, edge swapping, and probabilistic insertion to generate a neighbor solution while ensuring feasibility through a fallback 3-opt move when needed. The search is biased toward exploration (higher probabilities for rotation and insertion) but includes exploitation (edge swapping) to balance improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    quality = 1 / (np.sum(objectives, axis=1) + 1e-6)\n    scores = diversity * quality\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search\n    if n > 4:\n        # Probabilistic segment rotation\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        # Edge swapping with probability\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9505739102830555,
            0.20686876773834229
        ],
        "raw_score": [
            6.941354134240141,
            8.062030640740618
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8560720813127365,
            0.20273715257644653
        ],
        "raw_score": [
            6.3255974240085,
            7.111491827207311
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9518837954525908,
            0.27238762378692627
        ],
        "raw_score": [
            10.52352941362411,
            10.60322217529415
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590842343825071,
            0.34623414278030396
        ],
        "raw_score": [
            6.167019286646502,
            5.628168800046846
        ]
    }
]