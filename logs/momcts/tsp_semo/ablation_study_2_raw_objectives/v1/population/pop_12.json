[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9518837954525908,
            0.27238762378692627
        ],
        "raw_score": [
            10.52352941362411,
            10.60322217529415
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9261284381143133,
            0.22108149528503418
        ],
        "raw_score": [
            6.786723385928758,
            6.705123561411493
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590842343825071,
            0.34623414278030396
        ],
        "raw_score": [
            6.167019286646502,
            5.628168800046846
        ]
    },
    {
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7844549425744639,
            0.07181447744369507
        ],
        "raw_score": [
            7.625964615140017,
            7.498210330113637
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8560720813127365,
            0.20273715257644653
        ],
        "raw_score": [
            6.3255974240085,
            7.111491827207311
        ]
    },
    {
        "algorithm": "The algorithm selects high-potential solutions from an archive (prioritizing those with better normalized objective values) and applies a multi-objective-aware segment relocation strategy, moving segments to positions that minimize combined tour length in both objective spaces, while ensuring feasibility through probabilistic repair to reintroduce missing nodes with minimal disruption. It balances exploration (random segment selection) and exploitation (greedy improvement) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    if n > 3:\n        # Select segment with highest potential for improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement for segment at different positions\n        improvements = []\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            temp_sol = np.delete(new_solution, slice(start, start+segment_length))\n            temp_sol = np.insert(temp_sol, pos, segment)\n\n            # Calculate objective values\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            improvements.append((cost1 + cost2, pos))\n\n        if improvements:\n            best_pos = min(improvements, key=lambda x: x[0])[1]\n            new_solution = np.delete(new_solution, slice(start, start+segment_length))\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Probabilistic repair for feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            # Find position with minimal disruption\n            min_disruption = float('inf')\n            best_pos = 0\n            for pos in range(n):\n                temp_sol = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n                if (cost1 + cost2) < min_disruption:\n                    min_disruption = cost1 + cost2\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8588533549987851,
            0.7544171810150146
        ],
        "raw_score": [
            10.51906289614748,
            10.646458904309723
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from an archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining partial path reversal (with a 70% probability) and constrained edge swaps (only if they improve both objectives or significantly reduce them). It ensures feasibility by repairing duplicate nodes if they occur. The algorithm prioritizes solutions with lower total objective values and focuses on improving both objectives simultaneously in the local search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on inverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial path reversal with constrained edge swaps\n    # First operation: reverse a segment with probability 0.7\n    if np.random.random() < 0.7:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, min(i + 3, n))  # Limit segment length to 3 for better control\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second operation: constrained edge swap (only if it improves both objectives)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with swap\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Only accept if both objectives improve or if one improves significantly\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.768582326882922,
            0.6858882904052734
        ],
        "raw_score": [
            7.116824208662214,
            6.880367855929454
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with balanced objectives) and applies a hybrid local search: first, it performs a multi-objective-aware edge insertion by selecting segments based on the less dominant objective, followed by a segment reversal that further optimizes the tour by prioritizing cost reduction in the less dominant objective space. A dynamic repair mechanism ensures feasibility by fixing duplicate nodes through intelligent swaps. The approach balances exploration and exploitation by focusing on the weaker objective while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance of objectives (Pareto-like selection)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_costs = archive_sorted[0][1]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is less dominant\n    dominant_obj = 0 if current_costs[0] > current_costs[1] else 1\n    distance_matrix = distance_matrix_1 if dominant_obj == 0 else distance_matrix_2\n\n    # Multi-objective-aware edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Find the best insertion point based on the less dominant objective\n    min_cost = float('inf')\n    best_pos = i\n    for pos in range(i, j):\n        cost = distance_matrix[new_solution[pos], new_solution[pos+1]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    # Insert segment between i and best_pos\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Segment reversal prioritizing the less dominant objective\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(a, b))\n    reversed_cost = sum(distance_matrix[new_solution[k+1], new_solution[k]] for k in range(a, b))\n    if reversed_cost < segment_cost:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Feasibility repair with dynamic node swapping\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0]\n            for i in idx[1:]:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8461650722852155,
            3.2422823309898376
        ],
        "raw_score": [
            8.899656651742236,
            9.245569596975919
        ]
    },
    {
        "algorithm": "The algorithm selects a nondominated solution from the archive using Pareto dominance and normalized objectives, then applies a hybrid local search combining segment inversion and edge exchange with probabilistic acceptance to generate a feasible neighbor solution, ensuring feasibility by validating the tour structure and repairing duplicates if necessary. The selection prioritizes solutions with higher potential based on normalized objectives, while the local search balances exploration and exploitation through probabilistic operations. The method ensures valid TSP tours by repairing duplicates and maintains feasibility throughout the process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution using Pareto dominance and normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n\n    # Identify nondominated solutions\n    is_nondominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_nondominated[i] = False\n                break\n\n    if np.any(is_nondominated):\n        candidates = np.where(is_nondominated)[0]\n        selected_idx = candidates[np.argmax(potential[candidates])]\n    else:\n        selected_idx = np.argmax(potential)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment inversion + edge exchange with probabilistic acceptance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge exchange with probabilistic acceptance\n    if n > 3 and np.random.rand() < 0.7:  # 70% chance to perform edge exchange\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair duplicates by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7899870274657732,
            1.041724979877472
        ],
        "raw_score": [
            7.757204504735276,
            7.135608718852404
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low total cost in either objective space\n    archive.sort(key=lambda x: min(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive)))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive segment selection and edge insertion\n    n = len(new_solution)\n    segment_size = max(3, n // 10)  # Adaptive segment size\n\n    # Select a random segment to modify\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Evaluate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n\n    # Find the best insertion point outside the segment\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for i in range(n):\n        if i >= start and i < start + segment_size:\n            continue  # Skip the segment itself\n\n        # Try inserting the segment at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement (weighted sum of improvements)\n        improvement = (segment_cost1 - new_cost1) * 0.5 + (segment_cost2 - new_cost2) * 0.5\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        # Perform the best insertion\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    # Optional: Apply node relocation to further improve\n    if np.random.random() < 0.3:  # 30% chance\n        for _ in range(3):  # Try a few relocations\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Check if relocation improves both objectives\n                old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or \\\n                   (np.random.random() < 0.1):  # Small chance to accept worse solutions\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5842487266581716,
            1.438615322113037
        ],
        "raw_score": [
            8.175513976187908,
            6.494820684383937
        ]
    }
]