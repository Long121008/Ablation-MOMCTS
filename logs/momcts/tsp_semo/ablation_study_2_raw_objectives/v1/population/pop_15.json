[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9518837954525908,
            0.27238762378692627
        ],
        "raw_score": [
            10.52352941362411,
            10.60322217529415
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590842343825071,
            0.34623414278030396
        ],
        "raw_score": [
            6.167019286646502,
            5.628168800046846
        ]
    },
    {
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7844549425744639,
            0.07181447744369507
        ],
        "raw_score": [
            7.625964615140017,
            7.498210330113637
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9208610717093059,
            0.135880708694458
        ],
        "raw_score": [
            10.497270395519887,
            10.635201664382908
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from an archive based on a weighted combination of objective diversity and quality (prioritizing solutions with higher diversity and better quality), then applies a novel hybrid local search combining segment rotation, edge swapping, and probabilistic insertion to generate a neighbor solution while ensuring feasibility through a fallback 3-opt move when needed. The search is biased toward exploration (higher probabilities for rotation and insertion) but includes exploitation (edge swapping) to balance improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    quality = 1 / (np.sum(objectives, axis=1) + 1e-6)\n    scores = diversity * quality\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search\n    if n > 4:\n        # Probabilistic segment rotation\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        # Edge swapping with probability\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9505739102830555,
            0.20686876773834229
        ],
        "raw_score": [
            6.941354134240141,
            8.062030640740618
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8560720813127365,
            0.20273715257644653
        ],
        "raw_score": [
            6.3255974240085,
            7.111491827207311
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9261284381143133,
            0.22108149528503418
        ],
        "raw_score": [
            6.786723385928758,
            6.705123561411493
        ]
    },
    {
        "algorithm": "The algorithm selects the most diverse solution from the archive (based on average pairwise distance in both objective spaces) and applies a hybrid local search combining segment reversal and node relocation, where the relocation position is chosen to minimize the combined distance in both spaces, with a fallback to segment reversal if the relocation is invalid. The selection prioritizes edge diversity to explore regions of the search space with higher potential for improvement, while the hybrid local search balances exploration and exploitation while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest edge diversity (average pairwise distance in both spaces)\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        total_dist_1 = 0.0\n        total_dist_2 = 0.0\n        n = len(sol)\n        for i in range(n):\n            u = sol[i]\n            v = sol[(i + 1) % n]\n            total_dist_1 += distance_matrix_1[u, v]\n            total_dist_2 += distance_matrix_2[u, v]\n        avg_dist = (total_dist_1 + total_dist_2) / (2 * n)\n        diversity_scores.append(avg_dist)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: segment reversal + node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Node relocation to minimize combined distance\n    if n > 2:\n        node_to_relocate = np.random.randint(0, n)\n        node = new_solution[node_to_relocate]\n        new_solution = np.delete(new_solution, node_to_relocate)\n\n        best_pos = 0\n        min_total_dist = float('inf')\n        for pos in range(n - 1):\n            temp_sol = np.insert(new_solution, pos, node)\n            total_dist = 0.0\n            for i in range(n - 1):\n                u = temp_sol[i]\n                v = temp_sol[(i + 1) % (n - 1)]\n                total_dist += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            if total_dist < min_total_dist:\n                min_total_dist = total_dist\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal if relocation is invalid\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.901338027795019,
            2.059888005256653
        ],
        "raw_score": [
            10.592220026100566,
            10.584631475512897
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using Pareto-dominance-based selection with normalized objective scores, then applies a hybrid local search combining adaptive segment relocation and edge rotation, while ensuring feasibility through multi-objective improvement checks. It prioritizes solutions with higher dominance scores and dynamically adjusts segment length based on solution quality, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-frontier-based selection with normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dominance_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation and constrained edge rotation\n    segment_length = max(2, int(np.ceil(n * 0.1 * (1 - dominance_scores[selected_idx] / dominance_scores.max()))))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Relocate segment to a new position\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = np.random.randint(0, len(new_solution) - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Edge rotation within the segment\n    if len(segment) > 2:\n        rotate_pos = np.random.randint(1, len(segment))\n        segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n        new_solution[start:start+len(segment)] = segment\n\n    # Feasibility repair using multi-objective improvement checks\n    if len(np.unique(new_solution)) != n:\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8824591447798331,
            0.24096113443374634
        ],
        "raw_score": [
            10.417463459245917,
            10.6192331801284
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-frontier selection with a novel \"objective-aware segment exchange\" operator. It first identifies non-dominated solutions in the archive and selects one probabilistically based on normalized objective values, then applies a segment exchange strategy to improve both objectives while ensuring feasibility through a repair mechanism. The critical design ideas include prioritizing non-dominated solutions, normalizing objectives for selection, and exchanging segments between objectives to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution based on normalized objective values\n    objectives = np.array([obj for _, obj in nondominated])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(nondominated), p=weights)\n    selected_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment exchange\n    if n > 3:\n        # Split into segments\n        k = np.random.randint(2, min(5, n//2))\n        split_points = sorted(np.random.choice(n, k, replace=False))\n        segments = []\n        prev = 0\n        for point in split_points:\n            segments.append(new_solution[prev:point])\n            prev = point\n        segments.append(new_solution[prev:])\n\n        # Exchange segments between objectives\n        if len(segments) > 1:\n            i, j = np.random.choice(len(segments), 2, replace=False)\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8749317867880365,
            0.33353251218795776
        ],
        "raw_score": [
            6.662315869993394,
            6.674925100698902
        ]
    }
]