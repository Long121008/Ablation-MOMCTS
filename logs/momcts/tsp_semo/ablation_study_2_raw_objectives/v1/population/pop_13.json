[
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9518837954525908,
            0.27238762378692627
        ],
        "raw_score": [
            10.52352941362411,
            10.60322217529415
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9261284381143133,
            0.22108149528503418
        ],
        "raw_score": [
            6.786723385928758,
            6.705123561411493
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590842343825071,
            0.34623414278030396
        ],
        "raw_score": [
            6.167019286646502,
            5.628168800046846
        ]
    },
    {
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7844549425744639,
            0.07181447744369507
        ],
        "raw_score": [
            7.625964615140017,
            7.498210330113637
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9208610717093059,
            0.135880708694458
        ],
        "raw_score": [
            10.497270395519887,
            10.635201664382908
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8560720813127365,
            0.20273715257644653
        ],
        "raw_score": [
            6.3255974240085,
            7.111491827207311
        ]
    },
    {
        "algorithm": "The algorithm selects high-potential solutions from an archive (prioritizing those with better normalized objective values) and applies a multi-objective-aware segment relocation strategy, moving segments to positions that minimize combined tour length in both objective spaces, while ensuring feasibility through probabilistic repair to reintroduce missing nodes with minimal disruption. It balances exploration (random segment selection) and exploitation (greedy improvement) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    if n > 3:\n        # Select segment with highest potential for improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement for segment at different positions\n        improvements = []\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            temp_sol = np.delete(new_solution, slice(start, start+segment_length))\n            temp_sol = np.insert(temp_sol, pos, segment)\n\n            # Calculate objective values\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            improvements.append((cost1 + cost2, pos))\n\n        if improvements:\n            best_pos = min(improvements, key=lambda x: x[0])[1]\n            new_solution = np.delete(new_solution, slice(start, start+segment_length))\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Probabilistic repair for feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            # Find position with minimal disruption\n            min_disruption = float('inf')\n            best_pos = 0\n            for pos in range(n):\n                temp_sol = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n                if (cost1 + cost2) < min_disruption:\n                    min_disruption = cost1 + cost2\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8588533549987851,
            0.7544171810150146
        ],
        "raw_score": [
            10.51906289614748,
            10.646458904309723
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with balanced objectives) and applies a hybrid local search: first, it performs a multi-objective-aware edge insertion by selecting segments based on the less dominant objective, followed by a segment reversal that further optimizes the tour by prioritizing cost reduction in the less dominant objective space. A dynamic repair mechanism ensures feasibility by fixing duplicate nodes through intelligent swaps. The approach balances exploration and exploitation by focusing on the weaker objective while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance of objectives (Pareto-like selection)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_costs = archive_sorted[0][1]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is less dominant\n    dominant_obj = 0 if current_costs[0] > current_costs[1] else 1\n    distance_matrix = distance_matrix_1 if dominant_obj == 0 else distance_matrix_2\n\n    # Multi-objective-aware edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Find the best insertion point based on the less dominant objective\n    min_cost = float('inf')\n    best_pos = i\n    for pos in range(i, j):\n        cost = distance_matrix[new_solution[pos], new_solution[pos+1]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    # Insert segment between i and best_pos\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Segment reversal prioritizing the less dominant objective\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(a, b))\n    reversed_cost = sum(distance_matrix[new_solution[k+1], new_solution[k]] for k in range(a, b))\n    if reversed_cost < segment_cost:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Feasibility repair with dynamic node swapping\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0]\n            for i in idx[1:]:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8461650722852155,
            3.2422823309898376
        ],
        "raw_score": [
            8.899656651742236,
            9.245569596975919
        ]
    },
    {
        "algorithm": "The algorithm selects nondominated solutions from the archive using normalized objectives to prioritize balanced improvements, then applies a hybrid local search combining node insertion and edge exchange to generate neighbors while ensuring feasibility through duplicate repair. It prioritizes solutions with higher potential improvement by combining objective-aware selection with a creative local search strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the nondominated solution based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n\n    # Identify nondominated solutions\n    nondominated_indices = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated_indices.append(i)\n\n    if not nondominated_indices:\n        selected_idx = np.argmax(potential)\n    else:\n        nondominated_potential = potential[nondominated_indices]\n        selected_idx = nondominated_indices[np.argmax(nondominated_potential)]\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: node insertion + edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7736971513871133,
            0.4181164503097534
        ],
        "raw_score": [
            7.377723429664401,
            8.248767495852281
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its total cost, then applies a randomized 3-opt-like local search by permuting three distinct segments of the tour while checking feasibility, with a fallback to edge exchange if duplicates occur. The method prioritizes lower-cost solutions and explores diverse configurations through segment reversal and permutation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three distinct segments for a 3-opt-like operation\n    a, b, c = sorted(np.random.choice(N, 3, replace=False))\n    segments = [\n        (a, b),\n        (b, c),\n        (c, a)\n    ]\n\n    # Randomly permute the segments\n    np.random.shuffle(segments)\n\n    # Apply the permutation while checking feasibility\n    for i in range(len(segments)):\n        start, end = segments[i]\n        segment = new_solution[start:end+1]\n        if i == 0:\n            new_segment = segment\n        else:\n            # Reverse the segment with probability 0.5 to explore different configurations\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]\n            new_segment = np.concatenate([new_segment, segment])\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != N:\n        # Fallback to simple edge exchange if the operation causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8228763859618303,
            2.7986257672309875
        ],
        "raw_score": [
            9.330410023649147,
            9.419477159814932
        ]
    }
]