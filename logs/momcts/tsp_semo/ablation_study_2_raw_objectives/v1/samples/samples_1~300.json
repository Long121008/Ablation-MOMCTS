[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9518837954525908,
            0.27238762378692627
        ],
        "raw_score": [
            10.52352941362411,
            10.60322217529415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9518837954525908,
            0.27238762378692627
        ],
        "raw_score": [
            10.52352941362411,
            10.60322217529415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9518837954525908,
            0.27238762378692627
        ],
        "raw_score": [
            10.52352941362411,
            10.60322217529415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9261284381143133,
            0.22108149528503418
        ],
        "raw_score": [
            6.786723385928758,
            6.705123561411493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9261284381143133,
            0.22108149528503418
        ],
        "raw_score": [
            6.786723385928758,
            6.705123561411493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low total cost in either objective space\n    archive.sort(key=lambda x: min(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive)))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive segment selection and edge insertion\n    n = len(new_solution)\n    segment_size = max(3, n // 10)  # Adaptive segment size\n\n    # Select a random segment to modify\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Evaluate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n\n    # Find the best insertion point outside the segment\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for i in range(n):\n        if i >= start and i < start + segment_size:\n            continue  # Skip the segment itself\n\n        # Try inserting the segment at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement (weighted sum of improvements)\n        improvement = (segment_cost1 - new_cost1) * 0.5 + (segment_cost2 - new_cost2) * 0.5\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        # Perform the best insertion\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    # Optional: Apply node relocation to further improve\n    if np.random.random() < 0.3:  # 30% chance\n        for _ in range(3):  # Try a few relocations\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Check if relocation improves both objectives\n                old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or \\\n                   (np.random.random() < 0.1):  # Small chance to accept worse solutions\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5842487266581716,
            1.438615322113037
        ],
        "raw_score": [
            8.175513976187908,
            6.494820684383937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low total cost in either objective space\n    archive.sort(key=lambda x: min(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive)))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive segment selection and edge insertion\n    n = len(new_solution)\n    segment_size = max(3, n // 10)  # Adaptive segment size\n\n    # Select a random segment to modify\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Evaluate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n\n    # Find the best insertion point outside the segment\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for i in range(n):\n        if i >= start and i < start + segment_size:\n            continue  # Skip the segment itself\n\n        # Try inserting the segment at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement (weighted sum of improvements)\n        improvement = (segment_cost1 - new_cost1) * 0.5 + (segment_cost2 - new_cost2) * 0.5\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        # Perform the best insertion\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    # Optional: Apply node relocation to further improve\n    if np.random.random() < 0.3:  # 30% chance\n        for _ in range(3):  # Try a few relocations\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Check if relocation improves both objectives\n                old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or \\\n                   (np.random.random() < 0.1):  # Small chance to accept worse solutions\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590842343825071,
            0.34623414278030396
        ],
        "raw_score": [
            6.167019286646502,
            5.628168800046846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590842343825071,
            0.34623414278030396
        ],
        "raw_score": [
            6.167019286646502,
            5.628168800046846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7844549425744639,
            0.07181447744369507
        ],
        "raw_score": [
            7.625964615140017,
            7.498210330113637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7844549425744639,
            0.07181447744369507
        ],
        "raw_score": [
            7.625964615140017,
            7.498210330113637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with balanced objectives) and applies a hybrid local search: first, it performs a multi-objective-aware edge insertion by selecting segments based on the less dominant objective, followed by a segment reversal that further optimizes the tour by prioritizing cost reduction in the less dominant objective space. A dynamic repair mechanism ensures feasibility by fixing duplicate nodes through intelligent swaps. The approach balances exploration and exploitation by focusing on the weaker objective while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance of objectives (Pareto-like selection)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_costs = archive_sorted[0][1]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is less dominant\n    dominant_obj = 0 if current_costs[0] > current_costs[1] else 1\n    distance_matrix = distance_matrix_1 if dominant_obj == 0 else distance_matrix_2\n\n    # Multi-objective-aware edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Find the best insertion point based on the less dominant objective\n    min_cost = float('inf')\n    best_pos = i\n    for pos in range(i, j):\n        cost = distance_matrix[new_solution[pos], new_solution[pos+1]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    # Insert segment between i and best_pos\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Segment reversal prioritizing the less dominant objective\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(a, b))\n    reversed_cost = sum(distance_matrix[new_solution[k+1], new_solution[k]] for k in range(a, b))\n    if reversed_cost < segment_cost:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Feasibility repair with dynamic node swapping\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0]\n            for i in idx[1:]:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8461650722852155,
            3.2422823309898376
        ],
        "raw_score": [
            8.899656651742236,
            9.245569596975919
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance of objectives (Pareto-like selection)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    current_costs = archive_sorted[0][1]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is less dominant\n    dominant_obj = 0 if current_costs[0] > current_costs[1] else 1\n    distance_matrix = distance_matrix_1 if dominant_obj == 0 else distance_matrix_2\n\n    # Multi-objective-aware edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Find the best insertion point based on the less dominant objective\n    min_cost = float('inf')\n    best_pos = i\n    for pos in range(i, j):\n        cost = distance_matrix[new_solution[pos], new_solution[pos+1]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    # Insert segment between i and best_pos\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Segment reversal prioritizing the less dominant objective\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(a, b))\n    reversed_cost = sum(distance_matrix[new_solution[k+1], new_solution[k]] for k in range(a, b))\n    if reversed_cost < segment_cost:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Feasibility repair with dynamic node swapping\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0]\n            for i in idx[1:]:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 7,
        "algorithm": "The algorithm selects high-potential solutions from an archive (prioritizing those with better normalized objective values) and applies a multi-objective-aware segment relocation strategy, moving segments to positions that minimize combined tour length in both objective spaces, while ensuring feasibility through probabilistic repair to reintroduce missing nodes with minimal disruption. It balances exploration (random segment selection) and exploitation (greedy improvement) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    if n > 3:\n        # Select segment with highest potential for improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement for segment at different positions\n        improvements = []\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            temp_sol = np.delete(new_solution, slice(start, start+segment_length))\n            temp_sol = np.insert(temp_sol, pos, segment)\n\n            # Calculate objective values\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            improvements.append((cost1 + cost2, pos))\n\n        if improvements:\n            best_pos = min(improvements, key=lambda x: x[0])[1]\n            new_solution = np.delete(new_solution, slice(start, start+segment_length))\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Probabilistic repair for feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            # Find position with minimal disruption\n            min_disruption = float('inf')\n            best_pos = 0\n            for pos in range(n):\n                temp_sol = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n                if (cost1 + cost2) < min_disruption:\n                    min_disruption = cost1 + cost2\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8588533549987851,
            0.7544171810150146
        ],
        "raw_score": [
            10.51906289614748,
            10.646458904309723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    if n > 3:\n        # Select segment with highest potential for improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement for segment at different positions\n        improvements = []\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            temp_sol = np.delete(new_solution, slice(start, start+segment_length))\n            temp_sol = np.insert(temp_sol, pos, segment)\n\n            # Calculate objective values\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            improvements.append((cost1 + cost2, pos))\n\n        if improvements:\n            best_pos = min(improvements, key=lambda x: x[0])[1]\n            new_solution = np.delete(new_solution, slice(start, start+segment_length))\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Probabilistic repair for feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            # Find position with minimal disruption\n            min_disruption = float('inf')\n            best_pos = 0\n            for pos in range(n):\n                temp_sol = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n                if (cost1 + cost2) < min_disruption:\n                    min_disruption = cost1 + cost2\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 8,
        "algorithm": "This algorithm selects a promising solution from an archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining partial path reversal (with a 70% probability) and constrained edge swaps (only if they improve both objectives or significantly reduce them). It ensures feasibility by repairing duplicate nodes if they occur. The algorithm prioritizes solutions with lower total objective values and focuses on improving both objectives simultaneously in the local search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on inverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial path reversal with constrained edge swaps\n    # First operation: reverse a segment with probability 0.7\n    if np.random.random() < 0.7:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, min(i + 3, n))  # Limit segment length to 3 for better control\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second operation: constrained edge swap (only if it improves both objectives)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with swap\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Only accept if both objectives improve or if one improves significantly\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.768582326882922,
            0.6858882904052734
        ],
        "raw_score": [
            7.116824208662214,
            6.880367855929454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on inverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial path reversal with constrained edge swaps\n    # First operation: reverse a segment with probability 0.7\n    if np.random.random() < 0.7:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, min(i + 3, n))  # Limit segment length to 3 for better control\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second operation: constrained edge swap (only if it improves both objectives)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with swap\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Only accept if both objectives improve or if one improves significantly\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 9,
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8560720813127365,
            0.20273715257644653
        ],
        "raw_score": [
            6.3255974240085,
            7.111491827207311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 4 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### Ineffective Self-Reflection\n- **Keywords**: Over-reliance, randomness, dominated heuristics, multi-objective blindness.\n- **Advice**: Prioritize nondominated heuristics with structured selection (e.g., normalized objectives) and hybrid operators (e.g., node insertion + edge exchange).\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Randomness alone fails to exploit high-potential regions; dominated heuristics lack multi-objective awareness. Hybrid operators must balance creativity and feasibility.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 10,
        "algorithm": "The algorithm selects a nondominated solution from the archive using Pareto dominance and normalized objectives, then applies a hybrid local search combining segment inversion and edge exchange with probabilistic acceptance to generate a feasible neighbor solution, ensuring feasibility by validating the tour structure and repairing duplicates if necessary. The selection prioritizes solutions with higher potential based on normalized objectives, while the local search balances exploration and exploitation through probabilistic operations. The method ensures valid TSP tours by repairing duplicates and maintains feasibility throughout the process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution using Pareto dominance and normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n\n    # Identify nondominated solutions\n    is_nondominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_nondominated[i] = False\n                break\n\n    if np.any(is_nondominated):\n        candidates = np.where(is_nondominated)[0]\n        selected_idx = candidates[np.argmax(potential[candidates])]\n    else:\n        selected_idx = np.argmax(potential)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment inversion + edge exchange with probabilistic acceptance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge exchange with probabilistic acceptance\n    if n > 3 and np.random.rand() < 0.7:  # 70% chance to perform edge exchange\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair duplicates by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7899870274657732,
            1.041724979877472
        ],
        "raw_score": [
            7.757204504735276,
            7.135608718852404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution using Pareto dominance and normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n\n    # Identify nondominated solutions\n    is_nondominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_nondominated[i] = False\n                break\n\n    if np.any(is_nondominated):\n        candidates = np.where(is_nondominated)[0]\n        selected_idx = candidates[np.argmax(potential[candidates])]\n    else:\n        selected_idx = np.argmax(potential)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment inversion + edge exchange with probabilistic acceptance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge exchange with probabilistic acceptance\n    if n > 3 and np.random.rand() < 0.7:  # 70% chance to perform edge exchange\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair duplicates by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection\n- **Keywords**: Over-reliance, randomness, dominated heuristics, multi-objective blindness.\n- **Advice**: Prioritize nondominated heuristics with structured selection (e.g., normalized objectives) and hybrid operators (e.g., node insertion + edge exchange).\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Randomness alone fails to exploit high-potential regions; dominated heuristics lack multi-objective awareness. Hybrid operators must balance creativity and feasibility.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 11,
        "algorithm": "The algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9208610717093059,
            0.135880708694458
        ],
        "raw_score": [
            10.497270395519887,
            10.635201664382908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection\n- **Keywords**: Over-reliance, randomness, dominated heuristics, multi-objective blindness.\n- **Advice**: Prioritize nondominated heuristics with structured selection (e.g., normalized objectives) and hybrid operators (e.g., node insertion + edge exchange).\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Randomness alone fails to exploit high-potential regions; dominated heuristics lack multi-objective awareness. Hybrid operators must balance creativity and feasibility.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 12,
        "algorithm": "The algorithm selects promising solutions from an archive by prioritizing those with high potential improvement in both objectives, then applies a hybrid local search combining segment rotation and dynamic edge exchange, ensuring feasibility through validation and fallback mechanisms. It balances exploitation and exploration by favoring diverse solutions, using normalized objective values and diversity scores to guide selection. The operator intelligently selects non-overlapping segments for rotation or edge swaps based on cost reduction potential, with a fallback to simple swaps if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Structured selection with diversity awareness\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n\n    # Select top 10% of solutions by potential\n    top_indices = np.argsort(potential)[-max(1, len(archive) // 10):]\n    top_solutions = [archive[i] for i in top_indices]\n\n    # Further select based on diversity (least crowded in archive)\n    diversity_scores = []\n    for sol, _ in top_solutions:\n        distances = [np.linalg.norm(sol - other_sol) for other_sol, _ in archive]\n        diversity_scores.append(np.mean(distances))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Hybrid local search: segment rotation + dynamic edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        if a <= c <= b or a <= d <= b:\n            # Dynamic edge exchange based on current structure\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            # Swap edges with higher potential for improvement\n            cost_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n            cost_after = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]])\n            if cost_after < cost_before:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Rotate segment\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            rotated_segment = np.roll(segment, k)\n            new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8283081403820916,
            3.6484410166740417
        ],
        "raw_score": [
            10.434522329922526,
            10.55878014860232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Structured selection with diversity awareness\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    potential = normalized_objectives @ weights\n\n    # Select top 10% of solutions by potential\n    top_indices = np.argsort(potential)[-max(1, len(archive) // 10):]\n    top_solutions = [archive[i] for i in top_indices]\n\n    # Further select based on diversity (least crowded in archive)\n    diversity_scores = []\n    for sol, _ in top_solutions:\n        distances = [np.linalg.norm(sol - other_sol) for other_sol, _ in archive]\n        diversity_scores.append(np.mean(distances))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Hybrid local search: segment rotation + dynamic edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        if a <= c <= b or a <= d <= b:\n            # Dynamic edge exchange based on current structure\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            # Swap edges with higher potential for improvement\n            cost_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n            cost_after = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]])\n            if cost_after < cost_before:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Rotate segment\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            rotated_segment = np.roll(segment, k)\n            new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 13,
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its total cost, then applies a randomized 3-opt-like local search by permuting three distinct segments of the tour while checking feasibility, with a fallback to edge exchange if duplicates occur. The method prioritizes lower-cost solutions and explores diverse configurations through segment reversal and permutation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three distinct segments for a 3-opt-like operation\n    a, b, c = sorted(np.random.choice(N, 3, replace=False))\n    segments = [\n        (a, b),\n        (b, c),\n        (c, a)\n    ]\n\n    # Randomly permute the segments\n    np.random.shuffle(segments)\n\n    # Apply the permutation while checking feasibility\n    for i in range(len(segments)):\n        start, end = segments[i]\n        segment = new_solution[start:end+1]\n        if i == 0:\n            new_segment = segment\n        else:\n            # Reverse the segment with probability 0.5 to explore different configurations\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]\n            new_segment = np.concatenate([new_segment, segment])\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != N:\n        # Fallback to simple edge exchange if the operation causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8228763859618303,
            2.7986257672309875
        ],
        "raw_score": [
            9.330410023649147,
            9.419477159814932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three distinct segments for a 3-opt-like operation\n    a, b, c = sorted(np.random.choice(N, 3, replace=False))\n    segments = [\n        (a, b),\n        (b, c),\n        (c, a)\n    ]\n\n    # Randomly permute the segments\n    np.random.shuffle(segments)\n\n    # Apply the permutation while checking feasibility\n    for i in range(len(segments)):\n        start, end = segments[i]\n        segment = new_solution[start:end+1]\n        if i == 0:\n            new_segment = segment\n        else:\n            # Reverse the segment with probability 0.5 to explore different configurations\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]\n            new_segment = np.concatenate([new_segment, segment])\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != N:\n        # Fallback to simple edge exchange if the operation causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 14,
        "algorithm": "The algorithm selects a solution from the archive based on crowding distance to prioritize less explored regions, then applies a hybrid local search combining double-bridge moves (70% probability) or random segment reversals (30% probability) to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a swap if invalid. The selection emphasizes exploration of under-represented Pareto front regions, while the local search balances aggressive restructuring (double-bridge) with fine-grained adjustments (segment reversal).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance for exploration\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: double-bridge move or random segment reversal\n    if np.random.rand() < 0.7:\n        # Double-bridge move (more aggressive exploration)\n        a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n        new_solution = np.concatenate([\n            selected_solution[:a],\n            selected_solution[b:c],\n            selected_solution[a:b],\n            selected_solution[c:d],\n            selected_solution[d:]\n        ])\n    else:\n        # Random segment reversal\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Validate solution and ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        # Fallback to swap if invalid\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5068165065395432,
            0.44829505681991577
        ],
        "raw_score": [
            9.145295004191578,
            9.991662093842493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance for exploration\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: double-bridge move or random segment reversal\n    if np.random.rand() < 0.7:\n        # Double-bridge move (more aggressive exploration)\n        a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n        new_solution = np.concatenate([\n            selected_solution[:a],\n            selected_solution[b:c],\n            selected_solution[a:b],\n            selected_solution[c:d],\n            selected_solution[d:]\n        ])\n    else:\n        # Random segment reversal\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Validate solution and ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        # Fallback to swap if invalid\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 15,
        "algorithm": "The algorithm selects nondominated solutions from the archive using normalized objectives to prioritize balanced improvements, then applies a hybrid local search combining node insertion and edge exchange to generate neighbors while ensuring feasibility through duplicate repair. It prioritizes solutions with higher potential improvement by combining objective-aware selection with a creative local search strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the nondominated solution based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n\n    # Identify nondominated solutions\n    nondominated_indices = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated_indices.append(i)\n\n    if not nondominated_indices:\n        selected_idx = np.argmax(potential)\n    else:\n        nondominated_potential = potential[nondominated_indices]\n        selected_idx = nondominated_indices[np.argmax(nondominated_potential)]\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: node insertion + edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7736971513871133,
            0.4181164503097534
        ],
        "raw_score": [
            7.377723429664401,
            8.248767495852281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the nondominated solution based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n\n    # Identify nondominated solutions\n    nondominated_indices = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated_indices.append(i)\n\n    if not nondominated_indices:\n        selected_idx = np.argmax(potential)\n    else:\n        nondominated_potential = potential[nondominated_indices]\n        selected_idx = nondominated_indices[np.argmax(nondominated_potential)]\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: node insertion + edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by repairing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 16,
        "algorithm": "The algorithm prioritizes nondominated solutions from the archive, dynamically selects a base solution with probability biased toward better-performing ones, and applies a hybrid local search combining node relocations and segment reversals with objective-specific bias (prioritizing the underperforming objective) while ensuring feasibility through minimal repairs. It dynamically adjusts exploration based on objective costs and uses a repair mechanism to maintain tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                dominated[i] = True\n                break\n    nondominated_indices = np.where(~dominated)[0]\n\n    if len(nondominated_indices) > 0:\n        # Select a nondominated solution with higher probability\n        selected_idx = np.random.choice(nondominated_indices, p=np.linspace(0.5, 1, len(nondominated_indices)) / np.sum(np.linspace(0.5, 1, len(nondominated_indices))))\n    else:\n        # Fallback to random selection if no nondominated solutions\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node relocation and segment reversal with objective bias\n    if n > 3:\n        # Determine which objective to prioritize (the one with higher cost)\n        obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prioritize_obj1 = obj1_cost > obj2_cost\n\n        # Perform node relocation with bias toward the prioritized objective\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a or b == (a+1)%n or b == (a-1)%n:\n            b = np.random.randint(0, n)\n\n        # Calculate the cost change for both objectives\n        old_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n        delta_cost1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n        delta_cost2 = new_cost2 - old_cost2\n\n        # Accept the move if it improves the prioritized objective or doesn't worsen it\n        if (prioritize_obj1 and delta_cost1 <= 0) or (not prioritize_obj1 and delta_cost2 <= 0):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment reversal with bias toward the prioritized objective\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        segment = new_solution[i:j+1]\n\n        old_segment_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1))\n        reversed_segment_cost1 = sum(distance_matrix_1[segment[l], segment[l+1]] for l in range(len(segment)-1)) + distance_matrix_1[segment[-1], new_solution[i]] + distance_matrix_1[new_solution[j], segment[0]]\n        delta_segment_cost1 = reversed_segment_cost1 - old_segment_cost1\n\n        old_segment_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1))\n        reversed_segment_cost2 = sum(distance_matrix_2[segment[l], segment[l+1]] for l in range(len(segment)-1)) + distance_matrix_2[segment[-1], new_solution[i]] + distance_matrix_2[new_solution[j], segment[0]]\n        delta_segment_cost2 = reversed_segment_cost2 - old_segment_cost2\n\n        if (prioritize_obj1 and delta_segment_cost1 <= 0) or (not prioritize_obj1 and delta_segment_cost2 <= 0):\n            new_solution[i:j+1] = segment[::-1]\n\n    # Ensure feasibility with minimal repairs\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Find and replace only the smallest number of nodes necessary\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                if len(missing) == 0:\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.885082298112696,
            6.181752383708954
        ],
        "raw_score": [
            6.525271114397508,
            7.234773649737282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                dominated[i] = True\n                break\n    nondominated_indices = np.where(~dominated)[0]\n\n    if len(nondominated_indices) > 0:\n        # Select a nondominated solution with higher probability\n        selected_idx = np.random.choice(nondominated_indices, p=np.linspace(0.5, 1, len(nondominated_indices)) / np.sum(np.linspace(0.5, 1, len(nondominated_indices))))\n    else:\n        # Fallback to random selection if no nondominated solutions\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node relocation and segment reversal with objective bias\n    if n > 3:\n        # Determine which objective to prioritize (the one with higher cost)\n        obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prioritize_obj1 = obj1_cost > obj2_cost\n\n        # Perform node relocation with bias toward the prioritized objective\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a or b == (a+1)%n or b == (a-1)%n:\n            b = np.random.randint(0, n)\n\n        # Calculate the cost change for both objectives\n        old_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n        delta_cost1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n        delta_cost2 = new_cost2 - old_cost2\n\n        # Accept the move if it improves the prioritized objective or doesn't worsen it\n        if (prioritize_obj1 and delta_cost1 <= 0) or (not prioritize_obj1 and delta_cost2 <= 0):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment reversal with bias toward the prioritized objective\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        segment = new_solution[i:j+1]\n\n        old_segment_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1))\n        reversed_segment_cost1 = sum(distance_matrix_1[segment[l], segment[l+1]] for l in range(len(segment)-1)) + distance_matrix_1[segment[-1], new_solution[i]] + distance_matrix_1[new_solution[j], segment[0]]\n        delta_segment_cost1 = reversed_segment_cost1 - old_segment_cost1\n\n        old_segment_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1))\n        reversed_segment_cost2 = sum(distance_matrix_2[segment[l], segment[l+1]] for l in range(len(segment)-1)) + distance_matrix_2[segment[-1], new_solution[i]] + distance_matrix_2[new_solution[j], segment[0]]\n        delta_segment_cost2 = reversed_segment_cost2 - old_segment_cost2\n\n        if (prioritize_obj1 and delta_segment_cost1 <= 0) or (not prioritize_obj1 and delta_segment_cost2 <= 0):\n            new_solution[i:j+1] = segment[::-1]\n\n    # Ensure feasibility with minimal repairs\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Find and replace only the smallest number of nodes necessary\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                if len(missing) == 0:\n                    break\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 17,
        "algorithm": "The algorithm selects the most diverse solution from the archive (based on average pairwise distance in both objective spaces) and applies a hybrid local search combining segment reversal and node relocation, where the relocation position is chosen to minimize the combined distance in both spaces, with a fallback to segment reversal if the relocation is invalid. The selection prioritizes edge diversity to explore regions of the search space with higher potential for improvement, while the hybrid local search balances exploration and exploitation while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest edge diversity (average pairwise distance in both spaces)\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        total_dist_1 = 0.0\n        total_dist_2 = 0.0\n        n = len(sol)\n        for i in range(n):\n            u = sol[i]\n            v = sol[(i + 1) % n]\n            total_dist_1 += distance_matrix_1[u, v]\n            total_dist_2 += distance_matrix_2[u, v]\n        avg_dist = (total_dist_1 + total_dist_2) / (2 * n)\n        diversity_scores.append(avg_dist)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: segment reversal + node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Node relocation to minimize combined distance\n    if n > 2:\n        node_to_relocate = np.random.randint(0, n)\n        node = new_solution[node_to_relocate]\n        new_solution = np.delete(new_solution, node_to_relocate)\n\n        best_pos = 0\n        min_total_dist = float('inf')\n        for pos in range(n - 1):\n            temp_sol = np.insert(new_solution, pos, node)\n            total_dist = 0.0\n            for i in range(n - 1):\n                u = temp_sol[i]\n                v = temp_sol[(i + 1) % (n - 1)]\n                total_dist += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            if total_dist < min_total_dist:\n                min_total_dist = total_dist\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal if relocation is invalid\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.901338027795019,
            2.059888005256653
        ],
        "raw_score": [
            10.592220026100566,
            10.584631475512897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest edge diversity (average pairwise distance in both spaces)\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        total_dist_1 = 0.0\n        total_dist_2 = 0.0\n        n = len(sol)\n        for i in range(n):\n            u = sol[i]\n            v = sol[(i + 1) % n]\n            total_dist_1 += distance_matrix_1[u, v]\n            total_dist_2 += distance_matrix_2[u, v]\n        avg_dist = (total_dist_1 + total_dist_2) / (2 * n)\n        diversity_scores.append(avg_dist)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: segment reversal + node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Node relocation to minimize combined distance\n    if n > 2:\n        node_to_relocate = np.random.randint(0, n)\n        node = new_solution[node_to_relocate]\n        new_solution = np.delete(new_solution, node_to_relocate)\n\n        best_pos = 0\n        min_total_dist = float('inf')\n        for pos in range(n - 1):\n            temp_sol = np.insert(new_solution, pos, node)\n            total_dist = 0.0\n            for i in range(n - 1):\n                u = temp_sol[i]\n                v = temp_sol[(i + 1) % (n - 1)]\n                total_dist += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            if total_dist < min_total_dist:\n                min_total_dist = total_dist\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal if relocation is invalid\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 18,
        "algorithm": "The algorithm selects a solution from an archive based on a weighted combination of objective diversity and quality (prioritizing solutions with higher diversity and better quality), then applies a novel hybrid local search combining segment rotation, edge swapping, and probabilistic insertion to generate a neighbor solution while ensuring feasibility through a fallback 3-opt move when needed. The search is biased toward exploration (higher probabilities for rotation and insertion) but includes exploitation (edge swapping) to balance improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    quality = 1 / (np.sum(objectives, axis=1) + 1e-6)\n    scores = diversity * quality\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search\n    if n > 4:\n        # Probabilistic segment rotation\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        # Edge swapping with probability\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9505739102830555,
            0.20686876773834229
        ],
        "raw_score": [
            6.941354134240141,
            8.062030640740618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    quality = 1 / (np.sum(objectives, axis=1) + 1e-6)\n    scores = diversity * quality\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search\n    if n > 4:\n        # Probabilistic segment rotation\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        # Edge swapping with probability\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 19,
        "algorithm": "The algorithm selects the solution with the lowest combined objective value from the archive, applies a 3-opt move by randomly selecting three edges and evaluating three possible reorderings to find the best one, and falls back to a 2-opt move if the 3-opt move is invalid, ensuring feasibility by checking for duplicate nodes. The primary design focus is on leveraging higher-order edge reordering (3-opt) for potentially better solutions while maintaining feasibility through fallback mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move: randomly select three edges and reorder their connections\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Create three possible new connections and select the best one\n        candidates = [\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j][::-1], new_solution[k+1:]])\n        ]\n        # Evaluate all candidates and select the best one based on combined objective\n        best_candidate = None\n        min_cost = float('inf')\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_candidate = candidate\n        new_solution = best_candidate\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if 3-opt move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8623632696767157,
            0.3431994318962097
        ],
        "raw_score": [
            5.608084142436956,
            6.06446238402662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move: randomly select three edges and reorder their connections\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Create three possible new connections and select the best one\n        candidates = [\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j][::-1], new_solution[k+1:]])\n        ]\n        # Evaluate all candidates and select the best one based on combined objective\n        best_candidate = None\n        min_cost = float('inf')\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_candidate = candidate\n        new_solution = best_candidate\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if 3-opt move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 20,
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto dominance and crowding distance, then applies a hybrid local search combining multi-segment inversion and edge insertion, ensuring feasibility through objective-aware repair while prioritizing balanced improvement across both objectives. The selection emphasizes non-dominated solutions with high crowding distance, while the local search focuses on segment inversions and edge insertions, with objective-aware acceptance criteria and feasibility repair.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided selection with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and not (objectives[j][0] == objectives[i][0] and objectives[j][1] == objectives[i][1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n    crowding_dist = np.zeros(len(nondominated_indices))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[nondominated_indices, i])\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for j in range(1, len(nondominated_indices)-1):\n            crowding_dist[sorted_indices[j]] += (objectives[nondominated_indices[sorted_indices[j+1]], i] - objectives[nondominated_indices[sorted_indices[j-1]], i]) / (objectives[nondominated_indices[sorted_indices[-1]], i] - objectives[nondominated_indices[sorted_indices[0]], i] + 1e-8)\n    selected_idx = nondominated_indices[np.argmax(crowding_dist)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion with objective awareness\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                temp_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n                if len(np.unique(temp_solution)) == n:\n                    old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                        new_solution = temp_solution\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7546008577950253,
            0.5733449459075928
        ],
        "raw_score": [
            6.813210039536584,
            8.09020905914655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided selection with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and not (objectives[j][0] == objectives[i][0] and objectives[j][1] == objectives[i][1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n    crowding_dist = np.zeros(len(nondominated_indices))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[nondominated_indices, i])\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for j in range(1, len(nondominated_indices)-1):\n            crowding_dist[sorted_indices[j]] += (objectives[nondominated_indices[sorted_indices[j+1]], i] - objectives[nondominated_indices[sorted_indices[j-1]], i]) / (objectives[nondominated_indices[sorted_indices[-1]], i] - objectives[nondominated_indices[sorted_indices[0]], i] + 1e-8)\n    selected_idx = nondominated_indices[np.argmax(crowding_dist)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion with objective awareness\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                temp_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n                if len(np.unique(temp_solution)) == n:\n                    old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                        new_solution = temp_solution\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThis algorithm selects a promising solution from an archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining partial path reversal (with a 70% probability) and constrained edge swaps (only if they improve both objectives or significantly reduce them). It ensures feasibility by repairing duplicate nodes if they occur. The algorithm prioritizes solutions with lower total objective values and focuses on improving both objectives simultaneously in the local search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on inverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial path reversal with constrained edge swaps\n    # First operation: reverse a segment with probability 0.7\n    if np.random.random() < 0.7:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, min(i + 3, n))  # Limit segment length to 3 for better control\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second operation: constrained edge swap (only if it improves both objectives)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with swap\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Only accept if both objectives improve or if one improves significantly\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 21,
        "algorithm": "The algorithm combines Pareto-frontier selection with a novel \"objective-aware segment exchange\" operator. It first identifies non-dominated solutions in the archive and selects one probabilistically based on normalized objective values, then applies a segment exchange strategy to improve both objectives while ensuring feasibility through a repair mechanism. The critical design ideas include prioritizing non-dominated solutions, normalizing objectives for selection, and exchanging segments between objectives to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution based on normalized objective values\n    objectives = np.array([obj for _, obj in nondominated])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(nondominated), p=weights)\n    selected_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment exchange\n    if n > 3:\n        # Split into segments\n        k = np.random.randint(2, min(5, n//2))\n        split_points = sorted(np.random.choice(n, k, replace=False))\n        segments = []\n        prev = 0\n        for point in split_points:\n            segments.append(new_solution[prev:point])\n            prev = point\n        segments.append(new_solution[prev:])\n\n        # Exchange segments between objectives\n        if len(segments) > 1:\n            i, j = np.random.choice(len(segments), 2, replace=False)\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8749317867880365,
            0.33353251218795776
        ],
        "raw_score": [
            6.662315869993394,
            6.674925100698902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution based on normalized objective values\n    objectives = np.array([obj for _, obj in nondominated])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(nondominated), p=weights)\n    selected_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment exchange\n    if n > 3:\n        # Split into segments\n        k = np.random.randint(2, min(5, n//2))\n        split_points = sorted(np.random.choice(n, k, replace=False))\n        segments = []\n        prev = 0\n        for point in split_points:\n            segments.append(new_solution[prev:point])\n            prev = point\n        segments.append(new_solution[prev:])\n\n        # Exchange segments between objectives\n        if len(segments) > 1:\n            i, j = np.random.choice(len(segments), 2, replace=False)\n            segments[i], segments[j] = segments[j], segments[i]\n            new_solution = np.concatenate(segments)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThis algorithm selects a promising solution from an archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining partial path reversal (with a 70% probability) and constrained edge swaps (only if they improve both objectives or significantly reduce them). It ensures feasibility by repairing duplicate nodes if they occur. The algorithm prioritizes solutions with lower total objective values and focuses on improving both objectives simultaneously in the local search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on inverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial path reversal with constrained edge swaps\n    # First operation: reverse a segment with probability 0.7\n    if np.random.random() < 0.7:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, min(i + 3, n))  # Limit segment length to 3 for better control\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second operation: constrained edge swap (only if it improves both objectives)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with swap\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Only accept if both objectives improve or if one improves significantly\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 22,
        "algorithm": "The algorithm selects a solution from the archive using Pareto-dominance-based selection with normalized objective scores, then applies a hybrid local search combining adaptive segment relocation and edge rotation, while ensuring feasibility through multi-objective improvement checks. It prioritizes solutions with higher dominance scores and dynamically adjusts segment length based on solution quality, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-frontier-based selection with normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dominance_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation and constrained edge rotation\n    segment_length = max(2, int(np.ceil(n * 0.1 * (1 - dominance_scores[selected_idx] / dominance_scores.max()))))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Relocate segment to a new position\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = np.random.randint(0, len(new_solution) - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Edge rotation within the segment\n    if len(segment) > 2:\n        rotate_pos = np.random.randint(1, len(segment))\n        segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n        new_solution[start:start+len(segment)] = segment\n\n    # Feasibility repair using multi-objective improvement checks\n    if len(np.unique(new_solution)) != n:\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8824591447798331,
            0.24096113443374634
        ],
        "raw_score": [
            10.417463459245917,
            10.6192331801284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-frontier-based selection with normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dominance_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation and constrained edge rotation\n    segment_length = max(2, int(np.ceil(n * 0.1 * (1 - dominance_scores[selected_idx] / dominance_scores.max()))))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Relocate segment to a new position\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = np.random.randint(0, len(new_solution) - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Edge rotation within the segment\n    if len(segment) > 2:\n        rotate_pos = np.random.randint(1, len(segment))\n        segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n        new_solution[start:start+len(segment)] = segment\n\n    # Feasibility repair using multi-objective improvement checks\n    if len(np.unique(new_solution)) != n:\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        This algorithm selects a promising solution from an archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining partial path reversal (with a 70% probability) and constrained edge swaps (only if they improve both objectives or significantly reduce them). It ensures feasibility by repairing duplicate nodes if they occur. The algorithm prioritizes solutions with lower total objective values and focuses on improving both objectives simultaneously in the local search.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on inverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial path reversal with constrained edge swaps\n    # First operation: reverse a segment with probability 0.7\n    if np.random.random() < 0.7:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, min(i + 3, n))  # Limit segment length to 3 for better control\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second operation: constrained edge swap (only if it improves both objectives)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with swap\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Only accept if both objectives improve or if one improves significantly\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 23,
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-frontier dominance and objective-space clustering, then applies a hybrid local search that combines adaptive segment reversal with constrained edge swaps, where acceptance is determined by a dynamic Pareto-improvement threshold. It prioritizes solutions from the Pareto front or largest cluster, and uses adaptive segment lengths and thresholds to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution using Pareto-frontier and clustering\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n\n    # Identify Pareto front solutions\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append(i)\n\n    # If no Pareto front solutions, use all solutions\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    # Cluster solutions in objective space\n    from sklearn.cluster import KMeans\n    k = min(3, len(pareto_front))\n    if k > 1:\n        clusters = KMeans(n_clusters=k).fit_predict(objectives[pareto_front])\n        # Select from largest cluster\n        largest_cluster = np.argmax(np.bincount(clusters))\n        selected_idx = np.random.choice([i for i, c in enumerate(clusters) if c == largest_cluster])\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search with adaptive parameters\n    # First operation: adaptive segment reversal\n    segment_length = max(2, int(np.random.normal(3, 1)))\n    i = np.random.randint(0, n)\n    j = min(i + segment_length, n)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Second operation: constrained edge swap with dynamic threshold\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Dynamic Pareto-improvement threshold\n    improvement_threshold = 0.95 + 0.05 * (current_cost1 + current_cost2) / (distance_matrix_1.sum() + distance_matrix_2.sum())\n\n    if (new_cost1 < current_cost1 * improvement_threshold and new_cost2 < current_cost2 * improvement_threshold):\n        new_solution = temp_solution\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7555826785195225,
            2.4008463621139526
        ],
        "raw_score": [
            7.83075735602061,
            6.525677922877925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution using Pareto-frontier and clustering\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n\n    # Identify Pareto front solutions\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append(i)\n\n    # If no Pareto front solutions, use all solutions\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    # Cluster solutions in objective space\n    from sklearn.cluster import KMeans\n    k = min(3, len(pareto_front))\n    if k > 1:\n        clusters = KMeans(n_clusters=k).fit_predict(objectives[pareto_front])\n        # Select from largest cluster\n        largest_cluster = np.argmax(np.bincount(clusters))\n        selected_idx = np.random.choice([i for i, c in enumerate(clusters) if c == largest_cluster])\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search with adaptive parameters\n    # First operation: adaptive segment reversal\n    segment_length = max(2, int(np.random.normal(3, 1)))\n    i = np.random.randint(0, n)\n    j = min(i + segment_length, n)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Second operation: constrained edge swap with dynamic threshold\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Dynamic Pareto-improvement threshold\n    improvement_threshold = 0.95 + 0.05 * (current_cost1 + current_cost2) / (distance_matrix_1.sum() + distance_matrix_2.sum())\n\n    if (new_cost1 < current_cost1 * improvement_threshold and new_cost2 < current_cost2 * improvement_threshold):\n        new_solution = temp_solution\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        This algorithm selects a promising solution from an archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining partial path reversal (with a 70% probability) and constrained edge swaps (only if they improve both objectives or significantly reduce them). It ensures feasibility by repairing duplicate nodes if they occur. The algorithm prioritizes solutions with lower total objective values and focuses on improving both objectives simultaneously in the local search.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on inverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial path reversal with constrained edge swaps\n    # First operation: reverse a segment with probability 0.7\n    if np.random.random() < 0.7:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, min(i + 3, n))  # Limit segment length to 3 for better control\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second operation: constrained edge swap (only if it improves both objectives)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with swap\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Only accept if both objectives improve or if one improves significantly\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 24,
        "algorithm": "The algorithm dynamically selects a solution from the archive with higher priority given to better-ranked solutions, then applies a hybrid local search combining adaptive segment reversals and constrained edge insertions, ensuring feasibility through probabilistic repair while accepting moves that improve at least one objective or significantly improve both. The selection is weighted by solution quality, and the local search balances exploration (segment reversal) with exploitation (edge insertion) with objective-aware acceptance criteria.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on rank and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    weights = 1 / (ranks + 1)  # Higher weight for better solutions\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with dynamic length\n    if np.random.random() < 0.6:\n        segment_length = np.random.randint(2, min(5, n//2))\n        i = np.random.randint(0, n - segment_length)\n        new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Constrained edge insertion with objective awareness\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with insertion\n    temp_solution = np.delete(new_solution, a)\n    insert_pos = np.random.randint(0, n-1)\n    temp_solution = np.insert(temp_solution, insert_pos, new_solution[a])\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept if at least one objective improves or both improve significantly\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n       (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05) or \\\n       (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n        new_solution = temp_solution\n\n    # Probabilistic repair for feasibility\n    if np.random.random() < 0.3:\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != n:\n            all_nodes = np.arange(n)\n            missing = np.setdiff1d(all_nodes, new_solution)\n            for idx, node in enumerate(new_solution):\n                if np.sum(new_solution == node) > 1:\n                    new_solution[idx] = missing[0]\n                    missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8676603830975413,
            0.4553382396697998
        ],
        "raw_score": [
            6.231535517394921,
            7.2845837061851
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on rank and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    weights = 1 / (ranks + 1)  # Higher weight for better solutions\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with dynamic length\n    if np.random.random() < 0.6:\n        segment_length = np.random.randint(2, min(5, n//2))\n        i = np.random.randint(0, n - segment_length)\n        new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Constrained edge insertion with objective awareness\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with insertion\n    temp_solution = np.delete(new_solution, a)\n    insert_pos = np.random.randint(0, n-1)\n    temp_solution = np.insert(temp_solution, insert_pos, new_solution[a])\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept if at least one objective improves or both improve significantly\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n       (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05) or \\\n       (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 0.9):\n        new_solution = temp_solution\n\n    # Probabilistic repair for feasibility\n    if np.random.random() < 0.3:\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != n:\n            all_nodes = np.arange(n)\n            missing = np.setdiff1d(all_nodes, new_solution)\n            for idx, node in enumerate(new_solution):\n                if np.sum(new_solution == node) > 1:\n                    new_solution[idx] = missing[0]\n                    missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThis algorithm selects a promising solution from an archive using weighted random selection based on inverse objective values, then applies a hybrid local search combining partial path reversal (with a 70% probability) and constrained edge swaps (only if they improve both objectives or significantly reduce them). It ensures feasibility by repairing duplicate nodes if they occur. The algorithm prioritizes solutions with lower total objective values and focuses on improving both objectives simultaneously in the local search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on inverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial path reversal with constrained edge swaps\n    # First operation: reverse a segment with probability 0.7\n    if np.random.random() < 0.7:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, min(i + 3, n))  # Limit segment length to 3 for better control\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second operation: constrained edge swap (only if it improves both objectives)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs for both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Create temporary solution with swap\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Only accept if both objectives improve or if one improves significantly\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 25,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify Pareto front solutions\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_dominated[i] = True\n    pareto_front = [i for i in range(len(archive)) if not is_dominated[i]]\n\n    if not pareto_front:\n        # If no Pareto front, use weighted random selection\n        weights = 1 / (objectives.sum(axis=1) + 1e-10)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        # Select from Pareto front based on normalized objectives\n        normalized = objectives[pareto_front] / (objectives[pareto_front].max(axis=0) - objectives[pareto_front].min(axis=0) + 1e-10)\n        weights = 1 / (normalized.sum(axis=1) + 1e-10)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(pareto_front, p=weights)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: constrained edge exchange + segment insertion\n    # First operation: exchange edges if it improves both objectives or significantly reduces one\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Second operation: insert a random segment to maintain diversity\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, min(i + 4, n))  # Limit segment length for control\n    segment = new_solution[i:j+1]\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                if len(missing) > 0:\n                    new_solution[idx] = missing[0]\n                    missing = missing[1:]\n                else:\n                    # If no missing nodes, replace with a random node not in the current segment\n                    possible_replacements = np.setdiff1d(all_nodes, segment)\n                    if len(possible_replacements) > 0:\n                        new_solution[idx] = np.random.choice(possible_replacements)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.715708113475901,
            1.844795286655426
        ],
        "raw_score": [
            8.122860391682117,
            8.121786235498579
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify Pareto front solutions\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_dominated[i] = True\n    pareto_front = [i for i in range(len(archive)) if not is_dominated[i]]\n\n    if not pareto_front:\n        # If no Pareto front, use weighted random selection\n        weights = 1 / (objectives.sum(axis=1) + 1e-10)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        # Select from Pareto front based on normalized objectives\n        normalized = objectives[pareto_front] / (objectives[pareto_front].max(axis=0) - objectives[pareto_front].min(axis=0) + 1e-10)\n        weights = 1 / (normalized.sum(axis=1) + 1e-10)\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(pareto_front, p=weights)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: constrained edge exchange + segment insertion\n    # First operation: exchange edges if it improves both objectives or significantly reduces one\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(n):\n            cost += dist_matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n        new_solution = temp_solution\n\n    # Second operation: insert a random segment to maintain diversity\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, min(i + 4, n))  # Limit segment length for control\n    segment = new_solution[i:j+1]\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                if len(missing) > 0:\n                    new_solution[idx] = missing[0]\n                    missing = missing[1:]\n                else:\n                    # If no missing nodes, replace with a random node not in the current segment\n                    possible_replacements = np.setdiff1d(all_nodes, segment)\n                    if len(possible_replacements) > 0:\n                        new_solution[idx] = np.random.choice(possible_replacements)\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from an archive based on a weighted combination of objective diversity and quality (prioritizing solutions with higher diversity and better quality), then applies a novel hybrid local search combining segment rotation, edge swapping, and probabilistic insertion to generate a neighbor solution while ensuring feasibility through a fallback 3-opt move when needed. The search is biased toward exploration (higher probabilities for rotation and insertion) but includes exploitation (edge swapping) to balance improvement.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    quality = 1 / (np.sum(objectives, axis=1) + 1e-6)\n    scores = diversity * quality\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search\n    if n > 4:\n        # Probabilistic segment rotation\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        # Edge swapping with probability\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 26,
        "algorithm": "The algorithm selects promising solutions from an archive using a hybrid criterion combining Pareto dominance and objective diversity, then applies a novel local search that combines multi-segment inversion and edge insertion with probabilistic acceptance to generate high-quality neighbors while ensuring feasibility through objective-aware repair. The selection prioritizes non-dominated solutions with high diversity, while the local search emphasizes improving both objectives with a 70% chance of inversion and 40% acceptance probability for edge insertions, with additional repair mechanisms to maintain feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine Pareto dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                is_dominated[i] = True\n                break\n\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    scores = diversity[nondominated_indices]\n    selected_idx = np.random.choice(nondominated_indices, p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: multi-segment inversion with probabilistic acceptance\n    num_segments = np.random.randint(1, min(4, n//3))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        if np.random.rand() < 0.7:  # 70% chance to invert each segment\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion with probabilistic acceptance\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                candidate = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n                if len(np.unique(candidate)) == n:\n                    # Probabilistic acceptance based on objective improvement\n                    old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.4:\n                        new_solution = candidate\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.rand() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8214527310026325,
            0.9977229833602905
        ],
        "raw_score": [
            7.021686203983895,
            6.95510858448421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine Pareto dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                is_dominated[i] = True\n                break\n\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    scores = diversity[nondominated_indices]\n    selected_idx = np.random.choice(nondominated_indices, p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: multi-segment inversion with probabilistic acceptance\n    num_segments = np.random.randint(1, min(4, n//3))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        if np.random.rand() < 0.7:  # 70% chance to invert each segment\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion with probabilistic acceptance\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                candidate = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n                if len(np.unique(candidate)) == n:\n                    # Probabilistic acceptance based on objective improvement\n                    old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.4:\n                        new_solution = candidate\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.rand() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange with segment inversion. It prioritizes segment inversion when segments are non-overlapping, otherwise falls back to edge exchange, and ensures feasibility by checking for duplicates. The method balances exploration and exploitation by randomly selecting segments or edges while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here: random selection for simplicity, but can be enhanced)\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    c, d = sorted(np.random.choice(N, 2, replace=False))\n\n    # Ensure segments are non-overlapping or handle overlap\n    if a <= c <= b or a <= d <= b:\n        # If segments overlap, perform edge exchange\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment inversion\n        new_solution[a:b+1] = selected_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to edge exchange if inversion causes duplicates\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 27,
        "algorithm": "The algorithm selects a nondominated solution from the archive using Pareto dominance, then applies a hybrid operator that combines randomized node insertion with objective-aware edge exchanges prioritizing normalized improvements in both objectives, while ensuring feasibility through duplicate checks and missing-node replacement. The edge exchanges are limited to 2 per iteration for efficiency, and the selection prioritizes solutions with better combined normalized objective values.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        selected_solution = nondominated[np.random.randint(0, len(nondominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized node insertion + objective-aware edge exchange\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge exchange\n        for _ in range(2):  # Limit to 2 exchanges for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8669591196096789,
            0.35643470287323
        ],
        "raw_score": [
            6.6959726129438355,
            6.805759572520433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        selected_solution = nondominated[np.random.randint(0, len(nondominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized node insertion + objective-aware edge exchange\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge exchange\n        for _ in range(2):  # Limit to 2 exchanges for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from an archive based on a weighted combination of objective diversity and quality (prioritizing solutions with higher diversity and better quality), then applies a novel hybrid local search combining segment rotation, edge swapping, and probabilistic insertion to generate a neighbor solution while ensuring feasibility through a fallback 3-opt move when needed. The search is biased toward exploration (higher probabilities for rotation and insertion) but includes exploitation (edge swapping) to balance improvement.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    quality = 1 / (np.sum(objectives, axis=1) + 1e-6)\n    scores = diversity * quality\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search\n    if n > 4:\n        # Probabilistic segment rotation\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        # Edge swapping with probability\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 28,
        "algorithm": "The algorithm selects promising solutions from the archive using weighted Pareto dominance, then applies a hybrid local search combining segment reversal, edge crossover, and objective-aware insertion, while ensuring feasibility through a multi-phase repair mechanism that prioritizes objective trade-offs and maintains tour validity. The weighted Pareto selection and adaptive local search operators dynamically balance exploration and exploitation, with segment reversal and edge operations biased toward lower-cost objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with weighted Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    weights = np.random.dirichlet([1, 1])\n    weighted_scores = np.dot(normalized, weights)\n    nondominated = [i for i in range(len(archive)) if not any((objectives[i] > objectives[j]).all() for j in range(len(archive)) if i != j)]\n    if not nondominated:\n        nondominated = list(range(len(archive)))\n    selected_idx = np.random.choice(nondominated, p=np.array([weighted_scores[i] for i in nondominated])/sum(weighted_scores[nondominated]))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + probabilistic edge crossover\n    if n > 4:\n        # Segment reversal with objective bias\n        obj_weights = np.random.dirichlet([1, 1])\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            if np.random.rand() < obj_weights[0]:\n                new_solution[start:start+k] = segment[::-1]\n            else:\n                new_solution[start:start+k] = np.roll(segment, np.random.randint(1, k))\n\n        # Probabilistic edge crossover\n        if np.random.rand() < 0.6 and n > 3:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Objective-aware edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            cost1 = distance_matrix_1[new_solution[edge_start], new_solution[edge_end]]\n            cost2 = distance_matrix_2[new_solution[edge_start], new_solution[edge_end]]\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Multi-phase feasibility repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Objective-aware edge flip for duplicates\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                candidates = [i for i in range(n) if i not in new_solution]\n                if candidates:\n                    new_solution[idx] = np.random.choice(candidates)\n                else:\n                    # Fallback: random swap\n                    swap_idx = np.random.choice([i for i in range(n) if i != idx])\n                    new_solution[idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[idx]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7871990068804601,
            2.798714816570282
        ],
        "raw_score": [
            7.298392463202696,
            7.3735408059110945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with weighted Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    weights = np.random.dirichlet([1, 1])\n    weighted_scores = np.dot(normalized, weights)\n    nondominated = [i for i in range(len(archive)) if not any((objectives[i] > objectives[j]).all() for j in range(len(archive)) if i != j)]\n    if not nondominated:\n        nondominated = list(range(len(archive)))\n    selected_idx = np.random.choice(nondominated, p=np.array([weighted_scores[i] for i in nondominated])/sum(weighted_scores[nondominated]))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + probabilistic edge crossover\n    if n > 4:\n        # Segment reversal with objective bias\n        obj_weights = np.random.dirichlet([1, 1])\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            if np.random.rand() < obj_weights[0]:\n                new_solution[start:start+k] = segment[::-1]\n            else:\n                new_solution[start:start+k] = np.roll(segment, np.random.randint(1, k))\n\n        # Probabilistic edge crossover\n        if np.random.rand() < 0.6 and n > 3:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Objective-aware edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            cost1 = distance_matrix_1[new_solution[edge_start], new_solution[edge_end]]\n            cost2 = distance_matrix_2[new_solution[edge_start], new_solution[edge_end]]\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Multi-phase feasibility repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Objective-aware edge flip for duplicates\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                candidates = [i for i in range(n) if i not in new_solution]\n                if candidates:\n                    new_solution[idx] = np.random.choice(candidates)\n                else:\n                    # Fallback: random swap\n                    swap_idx = np.random.choice([i for i in range(n) if i != idx])\n                    new_solution[idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[idx]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 29,
        "algorithm": "This algorithm selects the most promising solution from the archive using a weighted combination of objectives (60% first objective, 40% second objective) and applies a hybrid local search combining adaptive segment reversal and dynamic node insertion, with a probabilistic repair mechanism to maintain feasibility. The method prioritizes the first objective while exploring diverse neighborhoods, ensuring valid TSP tours through intelligent random selection and repair.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective\n    def weighted_score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]  # Weighted combination of objectives\n\n    archive_sorted = sorted(archive, key=lambda x: weighted_score(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n > 3:\n        segment_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    if n > 4:\n        nodes_to_move = np.random.choice(n, size=min(3, n//3), replace=False)\n        for node in nodes_to_move:\n            pos = np.where(new_solution == node)[0][0]\n            new_pos = np.random.randint(0, n)\n            if pos != new_pos:\n                new_solution = np.insert(np.delete(new_solution, pos), new_pos, node)\n\n    # Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        duplicates = [x for x in new_solution if np.sum(new_solution == x) > 1]\n        for dup in duplicates:\n            if len(missing) > 0 and np.random.rand() < 0.7:  # 70% chance to repair\n                idx = np.where(new_solution == dup)[0][0]\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8886186352245127,
            0.26301681995391846
        ],
        "raw_score": [
            6.70704473489355,
            7.611341367939241
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective\n    def weighted_score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]  # Weighted combination of objectives\n\n    archive_sorted = sorted(archive, key=lambda x: weighted_score(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n > 3:\n        segment_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    if n > 4:\n        nodes_to_move = np.random.choice(n, size=min(3, n//3), replace=False)\n        for node in nodes_to_move:\n            pos = np.where(new_solution == node)[0][0]\n            new_pos = np.random.randint(0, n)\n            if pos != new_pos:\n                new_solution = np.insert(np.delete(new_solution, pos), new_pos, node)\n\n    # Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        duplicates = [x for x in new_solution if np.sum(new_solution == x) > 1]\n        for dup in duplicates:\n            if len(missing) > 0 and np.random.rand() < 0.7:  # 70% chance to repair\n                idx = np.where(new_solution == dup)[0][0]\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 30,
        "algorithm": "This algorithm selects a promising solution from the archive by weighting the objectives and applies a hybrid local search combining block relocation and edge exchange to generate a neighbor, ensuring feasibility through a repair mechanism. It prioritizes solutions with better objective values (weighted between 0.3 and 0.7) and uses dynamic block sizes and random insertions for diversification, while the edge exchange introduces further exploration. The repair mechanism ensures tour validity by handling duplicates and missing nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective value (higher weight to the better objective)\n    weights = np.random.uniform(0.3, 0.7)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: block relocation and edge exchange\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8542250663635953,
            0.2314712405204773
        ],
        "raw_score": [
            6.560534293366887,
            6.164607197818894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective value (higher weight to the better objective)\n    weights = np.random.uniform(0.3, 0.7)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: block relocation and edge exchange\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 31,
        "algorithm": "The algorithm first identifies nondominated solutions in the archive, then selects the most promising one based on the ratio of its objectives to the ideal point. It applies a hybrid local search combining node swaps, segment rotations, and edge insertions, prioritizing operators that improve the worse objective. The solution is repaired to ensure feasibility by replacing duplicates with missing nodes and verifying the tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution with highest potential for improvement\n    ideal = (min(obj[0] for (sol, obj) in archive), min(obj[1] for (sol, obj) in archive))\n    selected = max(nondominated, key=lambda x: max((x[1][0]-ideal[0])/ideal[0], (x[1][1]-ideal[1])/ideal[1]))\n    selected_solution = selected[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with objective-aware weighting\n    if n > 3:\n        # Determine which objective to prioritize\n        obj_ratio = (selected[1][0]-ideal[0])/(selected[1][1]-ideal[1]) if (selected[1][1]-ideal[1]) > 0 else float('inf')\n        if obj_ratio > 1:  # Prioritize first objective\n            # Perform node swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:  # Prioritize second objective\n            # Perform segment rotation\n            i = np.random.randint(0, n-2)\n            j = np.random.randint(i+1, n-1)\n            k = np.random.randint(j+1, n)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Additional operator: edge insertion\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Feasibility repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                if len(missing) > 0:\n                    new_solution[idx] = missing[0]\n                    missing = missing[1:]\n\n    # Verify tour structure\n    if len(np.unique(new_solution)) != n:\n        # If still not feasible, fall back to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7941910647742768,
            0.27661657333374023
        ],
        "raw_score": [
            6.741203407018178,
            8.231071789286746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution with highest potential for improvement\n    ideal = (min(obj[0] for (sol, obj) in archive), min(obj[1] for (sol, obj) in archive))\n    selected = max(nondominated, key=lambda x: max((x[1][0]-ideal[0])/ideal[0], (x[1][1]-ideal[1])/ideal[1]))\n    selected_solution = selected[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with objective-aware weighting\n    if n > 3:\n        # Determine which objective to prioritize\n        obj_ratio = (selected[1][0]-ideal[0])/(selected[1][1]-ideal[1]) if (selected[1][1]-ideal[1]) > 0 else float('inf')\n        if obj_ratio > 1:  # Prioritize first objective\n            # Perform node swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:  # Prioritize second objective\n            # Perform segment rotation\n            i = np.random.randint(0, n-2)\n            j = np.random.randint(i+1, n-1)\n            k = np.random.randint(j+1, n)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Additional operator: edge insertion\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Feasibility repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                if len(missing) > 0:\n                    new_solution[idx] = missing[0]\n                    missing = missing[1:]\n\n    # Verify tour structure\n    if len(np.unique(new_solution)) != n:\n        # If still not feasible, fall back to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from an archive based on a weighted combination of objective diversity and quality (prioritizing solutions with higher diversity and better quality), then applies a novel hybrid local search combining segment rotation, edge swapping, and probabilistic insertion to generate a neighbor solution while ensuring feasibility through a fallback 3-opt move when needed. The search is biased toward exploration (higher probabilities for rotation and insertion) but includes exploitation (edge swapping) to balance improvement.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    quality = 1 / (np.sum(objectives, axis=1) + 1e-6)\n    scores = diversity * quality\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search\n    if n > 4:\n        # Probabilistic segment rotation\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        # Edge swapping with probability\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n### **Heuristic Function: `select_neighbor`**\n```python\nimport numpy as np\nfrom typing import List, Tuple\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]]) -> np.ndarray:\n    # Step 1: Filter nondominated solutions\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive  # Fallback to all if none nondominated\n\n    # Step 2: Select a solution with objective-aware weighting\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    selected_sol, _ = nondominated[selected_idx]\n\n    # Step 3: Hybrid local search (node insertion + edge exchange)\n    tour = selected_sol.copy()\n    n = len(tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insertion + Edge Exchange\n    new_tour = np.concatenate([tour[:i], tour[j:], tour[i:j]])\n    new_tour = np.roll(new_tour, -np.random.randint(0, n))  # Random rotation\n\n    # Feasibility check\n    if len(np.unique(new_tour)) == n and len(new_tour) == n:\n        return new_tour\n    else:\n        return tour  # Fallback to original if invalid\n```\n\n**Key Features**:\n1. **Pareto-guided selection**: Prioritizes nondominated solutions with weighted randomness.\n2. **Hybrid operator**: Combines node insertion and edge exchange for exploration.\n3. **Feasibility check**: Ensures tours remain valid (no duplicates/missing nodes).\n4. **Fallback**: Reverts to original tour if repair fails.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 32,
        "algorithm": "The algorithm selects a solution from the archive based on Pareto diversity (high crowding distance) and applies a hybrid local search combining segment reversal and probabilistic edge insertion, ensuring feasibility through objective-aware repair and falling back to 3-opt if needed. It prioritizes solutions with high crowding distance to maintain diversity in the objective space while using a novel combination of moves to explore the solution space more effectively than standard approaches.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9620178974683407,
            0.19321191310882568
        ],
        "raw_score": [
            10.474873863632933,
            10.591316583367643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with high combined normalized improvement potential across both objectives (weighted equally), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor, ensuring feasibility by validating the tour structure and falling back to a simple swap if needed. The selection is based on normalized objectives to balance improvement across both spaces, while the hybrid operator explores the solution space more effectively than standard 2-opt.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    potential = normalized_objectives @ weights\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    if n > 3:\n        # Node insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if hybrid operator fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from an archive based on a weighted combination of objective diversity and quality (prioritizing solutions with higher diversity and better quality), then applies a novel hybrid local search combining segment rotation, edge swapping, and probabilistic insertion to generate a neighbor solution while ensuring feasibility through a fallback 3-opt move when needed. The search is biased toward exploration (higher probabilities for rotation and insertion) but includes exploitation (edge swapping) to balance improvement.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.linalg.norm(objectives - np.mean(objectives, axis=0), axis=1)\n    quality = 1 / (np.sum(objectives, axis=1) + 1e-6)\n    scores = diversity * quality\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search\n    if n > 4:\n        # Probabilistic segment rotation\n        if np.random.rand() < 0.7:\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        # Edge swapping with probability\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if abs(i-j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5 and n > 3:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start-1)%n, (edge_end+1)%n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n### **Heuristic Function: `select_neighbor`**\n```python\nimport numpy as np\nfrom typing import List, Tuple\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]]) -> np.ndarray:\n    # Step 1: Filter nondominated solutions\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive  # Fallback to all if none nondominated\n\n    # Step 2: Select a solution with objective-aware weighting\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    selected_sol, _ = nondominated[selected_idx]\n\n    # Step 3: Hybrid local search (node insertion + edge exchange)\n    tour = selected_sol.copy()\n    n = len(tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insertion + Edge Exchange\n    new_tour = np.concatenate([tour[:i], tour[j:], tour[i:j]])\n    new_tour = np.roll(new_tour, -np.random.randint(0, n))  # Random rotation\n\n    # Feasibility check\n    if len(np.unique(new_tour)) == n and len(new_tour) == n:\n        return new_tour\n    else:\n        return tour  # Fallback to original if invalid\n```\n\n**Key Features**:\n1. **Pareto-guided selection**: Prioritizes nondominated solutions with weighted randomness.\n2. **Hybrid operator**: Combines node insertion and edge exchange for exploration.\n3. **Feasibility check**: Ensures tours remain valid (no duplicates/missing nodes).\n4. **Fallback**: Reverts to original tour if repair fails.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 32,
        "algorithm": "The algorithm selects a solution from the archive based on Pareto diversity (high crowding distance) and applies a hybrid local search combining segment reversal and probabilistic edge insertion, ensuring feasibility through objective-aware repair and falling back to 3-opt if needed. It prioritizes solutions with high crowding distance to maintain diversity in the objective space while using a novel combination of moves to explore the solution space more effectively than standard approaches.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9620178974683407,
            0.19321191310882568
        ],
        "raw_score": [
            10.474873863632933,
            10.591316583367643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive based on Pareto diversity (high crowding distance) and applies a hybrid local search combining segment reversal and probabilistic edge insertion, ensuring feasibility through objective-aware repair and falling back to 3-opt if needed. It prioritizes solutions with high crowding distance to maintain diversity in the objective space while using a novel combination of moves to explore the solution space more effectively than standard approaches.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThis algorithm selects a promising solution from the archive by weighting the objectives and applies a hybrid local search combining block relocation and edge exchange to generate a neighbor, ensuring feasibility through a repair mechanism. It prioritizes solutions with better objective values (weighted between 0.3 and 0.7) and uses dynamic block sizes and random insertions for diversification, while the edge exchange introduces further exploration. The repair mechanism ensures tour validity by handling duplicates and missing nodes.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective value (higher weight to the better objective)\n    weights = np.random.uniform(0.3, 0.7)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: block relocation and edge exchange\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n### **Heuristic Function: `select_neighbor`**\n```python\nimport numpy as np\nfrom typing import List, Tuple\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]]) -> np.ndarray:\n    # Step 1: Filter nondominated solutions\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive  # Fallback to all if none nondominated\n\n    # Step 2: Select a solution with objective-aware weighting\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    selected_sol, _ = nondominated[selected_idx]\n\n    # Step 3: Hybrid local search (node insertion + edge exchange)\n    tour = selected_sol.copy()\n    n = len(tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insertion + Edge Exchange\n    new_tour = np.concatenate([tour[:i], tour[j:], tour[i:j]])\n    new_tour = np.roll(new_tour, -np.random.randint(0, n))  # Random rotation\n\n    # Feasibility check\n    if len(np.unique(new_tour)) == n and len(new_tour) == n:\n        return new_tour\n    else:\n        return tour  # Fallback to original if invalid\n```\n\n**Key Features**:\n1. **Pareto-guided selection**: Prioritizes nondominated solutions with weighted randomness.\n2. **Hybrid operator**: Combines node insertion and edge exchange for exploration.\n3. **Feasibility check**: Ensures tours remain valid (no duplicates/missing nodes).\n4. **Fallback**: Reverts to original tour if repair fails.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 33,
        "algorithm": "The algorithm selects a non-dominated solution from the archive (or a random one if none exist) and applies a hybrid local search combining dynamic block reversal and probabilistic node swaps, followed by a multi-phase repair mechanism to ensure feasibility. It prioritizes objective-aware swaps over random insertions and balances exploration (dynamic block sizes) with exploitation (probabilistic swaps), while dynamically adjusting block sizes to explore different neighborhood structures.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated[i] = True\n                break\n\n    candidates = [i for i in range(len(archive)) if not dominated[i]]\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (probabilistic swaps + dynamic block reversal)\n    if n > 4:\n        # Dynamic block reversal\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        new_solution[start:start + block_size] = new_solution[start:start + block_size][::-1]\n\n        # Probabilistic node swaps\n        for _ in range(np.random.randint(1, 3)):\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 3: Multi-phase repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Phase 1: Objective-aware swaps\n        for _ in range(5):\n            a, b = np.random.choice(n, 2, replace=False)\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.rand() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n        # Phase 2: Random insertions if still infeasible\n        if len(np.unique(new_solution)) != n:\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            for node in missing_nodes:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9350338798538467,
            0.3891436457633972
        ],
        "raw_score": [
            7.412706487535794,
            6.707895748651892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated[i] = True\n                break\n\n    candidates = [i for i in range(len(archive)) if not dominated[i]]\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (probabilistic swaps + dynamic block reversal)\n    if n > 4:\n        # Dynamic block reversal\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        new_solution[start:start + block_size] = new_solution[start:start + block_size][::-1]\n\n        # Probabilistic node swaps\n        for _ in range(np.random.randint(1, 3)):\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 3: Multi-phase repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Phase 1: Objective-aware swaps\n        for _ in range(5):\n            a, b = np.random.choice(n, 2, replace=False)\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.rand() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n        # Phase 2: Random insertions if still infeasible\n        if len(np.unique(new_solution)) != n:\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            for node in missing_nodes:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive based on Pareto diversity (high crowding distance) and applies a hybrid local search combining segment reversal and probabilistic edge insertion, ensuring feasibility through objective-aware repair and falling back to 3-opt if needed. It prioritizes solutions with high crowding distance to maintain diversity in the objective space while using a novel combination of moves to explore the solution space more effectively than standard approaches.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThis algorithm selects a promising solution from the archive by weighting the objectives and applies a hybrid local search combining block relocation and edge exchange to generate a neighbor, ensuring feasibility through a repair mechanism. It prioritizes solutions with better objective values (weighted between 0.3 and 0.7) and uses dynamic block sizes and random insertions for diversification, while the edge exchange introduces further exploration. The repair mechanism ensures tour validity by handling duplicates and missing nodes.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective value (higher weight to the better objective)\n    weights = np.random.uniform(0.3, 0.7)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: block relocation and edge exchange\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n### **Heuristic Function: `select_neighbor`**\n```python\nimport numpy as np\nfrom typing import List, Tuple\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]]) -> np.ndarray:\n    # Step 1: Filter nondominated solutions\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive  # Fallback to all if none nondominated\n\n    # Step 2: Select a solution with objective-aware weighting\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    selected_sol, _ = nondominated[selected_idx]\n\n    # Step 3: Hybrid local search (node insertion + edge exchange)\n    tour = selected_sol.copy()\n    n = len(tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insertion + Edge Exchange\n    new_tour = np.concatenate([tour[:i], tour[j:], tour[i:j]])\n    new_tour = np.roll(new_tour, -np.random.randint(0, n))  # Random rotation\n\n    # Feasibility check\n    if len(np.unique(new_tour)) == n and len(new_tour) == n:\n        return new_tour\n    else:\n        return tour  # Fallback to original if invalid\n```\n\n**Key Features**:\n1. **Pareto-guided selection**: Prioritizes nondominated solutions with weighted randomness.\n2. **Hybrid operator**: Combines node insertion and edge exchange for exploration.\n3. **Feasibility check**: Ensures tours remain valid (no duplicates/missing nodes).\n4. **Fallback**: Reverts to original tour if repair fails.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 34,
        "algorithm": "The algorithm combines nondominated solution selection with a multi-phase local search that alternates between probabilistic swaps, constrained edge insertions, and dynamic 4-opt moves, while using an objective-aware repair mechanism to maintain feasibility. It prioritizes solutions with balanced trade-offs between objectives and dynamically adapts its search strategy based on solution quality and phase selection. The hybrid repair mechanism ensures feasibility by reverting to a base solution if needed, while favoring improvements that maintain or improve the Pareto front.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with weighted probability\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-phase local search\n    if n > 4:\n        phase = np.random.randint(0, 3)\n\n        if phase == 0:  # Probabilistic node swaps\n            for _ in range(2):\n                i, j = np.random.choice(n, 2, replace=False)\n                if np.random.rand() < 0.7:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 1:  # Constrained edge insertions\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n        else:  # Dynamic k-opt (k=4)\n            points = sorted(np.random.choice(n, 4, replace=False))\n            a, b, c, d = points\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 3: Hybrid repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9582117304955626,
            0.6876171231269836
        ],
        "raw_score": [
            7.196180842197024,
            7.223250272432097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with weighted probability\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-phase local search\n    if n > 4:\n        phase = np.random.randint(0, 3)\n\n        if phase == 0:  # Probabilistic node swaps\n            for _ in range(2):\n                i, j = np.random.choice(n, 2, replace=False)\n                if np.random.rand() < 0.7:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 1:  # Constrained edge insertions\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n        else:  # Dynamic k-opt (k=4)\n            points = sorted(np.random.choice(n, 4, replace=False))\n            a, b, c, d = points\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 3: Hybrid repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        This algorithm selects a promising solution from the archive by weighting the objectives and applies a hybrid local search combining block relocation and edge exchange to generate a neighbor, ensuring feasibility through a repair mechanism. It prioritizes solutions with better objective values (weighted between 0.3 and 0.7) and uses dynamic block sizes and random insertions for diversification, while the edge exchange introduces further exploration. The repair mechanism ensures tour validity by handling duplicates and missing nodes.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective value (higher weight to the better objective)\n    weights = np.random.uniform(0.3, 0.7)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: block relocation and edge exchange\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 35,
        "algorithm": "The algorithm dynamically selects a solution from the archive using a weighted fitness function (40% first objective, 60% second objective with random variation) and applies a hybrid local search combining segment inversion and node reinsertion, followed by a swap-based repair to ensure feasibility. It also incorporates edge-specific diversification with probabilistic swaps to explore the solution space effectively. The method prioritizes the second objective while maintaining diversity through adaptive block sizes and probabilistic acceptance criteria.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic fitness-based selection\n    fitness_scores = []\n    for sol, obj in archive:\n        fitness = (0.4 * obj[0] + 0.6 * obj[1]) * np.random.uniform(0.8, 1.2)\n        fitness_scores.append(fitness)\n    selected_idx = np.argmin(fitness_scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and node reinsertion\n    if n > 4:\n        # Segment inversion\n        inv_start, inv_end = np.random.choice(n, 2, replace=False)\n        if inv_start > inv_end:\n            inv_start, inv_end = inv_end, inv_start\n        new_solution[inv_start:inv_end] = new_solution[inv_start:inv_end][::-1]\n\n        # Node reinsertion with probabilistic acceptance\n        if np.random.rand() < 0.6:\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility with swap-based repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        duplicates = unique[counts > 1]\n\n        for dup in duplicates:\n            dup_indices = np.where(new_solution == dup)[0]\n            for i in range(1, len(dup_indices)):\n                if len(missing) > 0:\n                    new_solution[dup_indices[i]] = missing[0]\n                    missing = missing[1:]\n\n    # Edge-specific diversification\n    if n > 3 and np.random.rand() < 0.4:\n        edge1, edge2 = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[edge1], new_solution[edge2] = new_solution[edge2], new_solution[edge1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7857790882498459,
            0.27931952476501465
        ],
        "raw_score": [
            6.982730901419128,
            5.440930877725275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic fitness-based selection\n    fitness_scores = []\n    for sol, obj in archive:\n        fitness = (0.4 * obj[0] + 0.6 * obj[1]) * np.random.uniform(0.8, 1.2)\n        fitness_scores.append(fitness)\n    selected_idx = np.argmin(fitness_scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and node reinsertion\n    if n > 4:\n        # Segment inversion\n        inv_start, inv_end = np.random.choice(n, 2, replace=False)\n        if inv_start > inv_end:\n            inv_start, inv_end = inv_end, inv_start\n        new_solution[inv_start:inv_end] = new_solution[inv_start:inv_end][::-1]\n\n        # Node reinsertion with probabilistic acceptance\n        if np.random.rand() < 0.6:\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility with swap-based repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        duplicates = unique[counts > 1]\n\n        for dup in duplicates:\n            dup_indices = np.where(new_solution == dup)[0]\n            for i in range(1, len(dup_indices)):\n                if len(missing) > 0:\n                    new_solution[dup_indices[i]] = missing[0]\n                    missing = missing[1:]\n\n    # Edge-specific diversification\n    if n > 3 and np.random.rand() < 0.4:\n        edge1, edge2 = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[edge1], new_solution[edge2] = new_solution[edge2], new_solution[edge1]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        This algorithm selects a promising solution from the archive by weighting the objectives and applies a hybrid local search combining block relocation and edge exchange to generate a neighbor, ensuring feasibility through a repair mechanism. It prioritizes solutions with better objective values (weighted between 0.3 and 0.7) and uses dynamic block sizes and random insertions for diversification, while the edge exchange introduces further exploration. The repair mechanism ensures tour validity by handling duplicates and missing nodes.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective value (higher weight to the better objective)\n    weights = np.random.uniform(0.3, 0.7)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: block relocation and edge exchange\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 36,
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with balanced objective values (weighted between 0.4 and 0.6) and applies a hybrid local search combining segment inversion and probabilistic edge exchanges, ensuring feasibility through a node validation and repair mechanism. It dynamically adjusts segment lengths and swap probabilities to explore the solution space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.uniform(0.4, 0.6)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        segment_length = np.random.randint(3, min(6, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution[start:start + segment_length] = segment[::-1]\n\n        if np.random.rand() < 0.6:\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9700281800182895,
            0.2160702347755432
        ],
        "raw_score": [
            6.790142251435691,
            6.522603093212192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.uniform(0.4, 0.6)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        segment_length = np.random.randint(3, min(6, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution[start:start + segment_length] = segment[::-1]\n\n        if np.random.rand() < 0.6:\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        This algorithm selects a promising solution from the archive by weighting the objectives and applies a hybrid local search combining block relocation and edge exchange to generate a neighbor, ensuring feasibility through a repair mechanism. It prioritizes solutions with better objective values (weighted between 0.3 and 0.7) and uses dynamic block sizes and random insertions for diversification, while the edge exchange introduces further exploration. The repair mechanism ensures tour validity by handling duplicates and missing nodes.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective value (higher weight to the better objective)\n    weights = np.random.uniform(0.3, 0.7)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: block relocation and edge exchange\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 36,
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with balanced objective values (weighted between 0.4 and 0.6) and applies a hybrid local search combining segment inversion and probabilistic edge exchanges, ensuring feasibility through a node validation and repair mechanism. It dynamically adjusts segment lengths and swap probabilities to explore the solution space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.uniform(0.4, 0.6)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        segment_length = np.random.randint(3, min(6, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution[start:start + segment_length] = segment[::-1]\n\n        if np.random.rand() < 0.6:\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9700281800182895,
            0.2160702347755432
        ],
        "raw_score": [
            6.790142251435691,
            6.522603093212192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.uniform(0.4, 0.6)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        segment_length = np.random.randint(3, min(6, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution[start:start + segment_length] = segment[::-1]\n\n        if np.random.rand() < 0.6:\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 3 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThis algorithm selects a promising solution from the archive by weighting the objectives and applies a hybrid local search combining block relocation and edge exchange to generate a neighbor, ensuring feasibility through a repair mechanism. It prioritizes solutions with better objective values (weighted between 0.3 and 0.7) and uses dynamic block sizes and random insertions for diversification, while the edge exchange introduces further exploration. The repair mechanism ensures tour validity by handling duplicates and missing nodes.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective value (higher weight to the better objective)\n    weights = np.random.uniform(0.3, 0.7)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: block relocation and edge exchange\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n### **Heuristic Function: `select_neighbor`**\n```python\nimport numpy as np\nfrom typing import List, Tuple\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]]) -> np.ndarray:\n    # Step 1: Filter nondominated solutions\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive  # Fallback to all if none nondominated\n\n    # Step 2: Select a solution with objective-aware weighting\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    selected_sol, _ = nondominated[selected_idx]\n\n    # Step 3: Hybrid local search (node insertion + edge exchange)\n    tour = selected_sol.copy()\n    n = len(tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insertion + Edge Exchange\n    new_tour = np.concatenate([tour[:i], tour[j:], tour[i:j]])\n    new_tour = np.roll(new_tour, -np.random.randint(0, n))  # Random rotation\n\n    # Feasibility check\n    if len(np.unique(new_tour)) == n and len(new_tour) == n:\n        return new_tour\n    else:\n        return tour  # Fallback to original if invalid\n```\n\n**Key Features**:\n1. **Pareto-guided selection**: Prioritizes nondominated solutions with weighted randomness.\n2. **Hybrid operator**: Combines node insertion and edge exchange for exploration.\n3. **Feasibility check**: Ensures tours remain valid (no duplicates/missing nodes).\n4. **Fallback**: Reverts to original tour if repair fails.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 37,
        "algorithm": "The algorithm first filters the archive to retain only Pareto-optimal solutions, then probabilistically selects one based on normalized objective values. It applies a hybrid local search combining block relocation, edge exchange, and segment rotation, guided by distance matrices to prioritize improvements in both objectives, while ensuring feasibility through a repair mechanism. The method balances exploration and exploitation through randomized yet objective-aware decisions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Filter nondominated solutions\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Step 2: Select solution with objective-aware weighting\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    selected_sol, _ = nondominated[selected_idx]\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Step 3: Hybrid local search (block relocation + edge exchange + segment rotation)\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange (guided by distance matrices)\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a]] < distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.904245604381151,
            0.331354022026062
        ],
        "raw_score": [
            7.221578556240548,
            7.0386990260038464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Filter nondominated solutions\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Step 2: Select solution with objective-aware weighting\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    selected_sol, _ = nondominated[selected_idx]\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Step 3: Hybrid local search (block relocation + edge exchange + segment rotation)\n    if n > 4:\n        # Block relocation\n        block_size = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - block_size)\n        block = new_solution[start:start + block_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + block_size:]])\n        insert_pos = np.random.randint(0, len(new_solution) - block_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n        # Edge exchange (guided by distance matrices)\n        a, b = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.5:\n            if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a]] < distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 3 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive based on Pareto diversity (high crowding distance) and applies a hybrid local search combining segment reversal and probabilistic edge insertion, ensuring feasibility through objective-aware repair and falling back to 3-opt if needed. It prioritizes solutions with high crowding distance to maintain diversity in the objective space while using a novel combination of moves to explore the solution space more effectively than standard approaches.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 38,
        "algorithm": "The algorithm combines Pareto-guided selection with a hybrid local search strategy, prioritizing nondominated solutions with high crowding distance and applying multi-segment inversion and probabilistic edge insertion to explore the solution space while ensuring feasibility through objective-aware repair and falling back to 3-opt when necessary. It balances both objectives with equal weighting and includes probabilistic acceptance of improvements to escape local optima. The selection process emphasizes diversity in the archive, while the local search operators target both small and large-scale improvements to the tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n                break\n\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        nondominated_objectives = objectives[nondominated_indices]\n        normalized_obj = (nondominated_objectives - nondominated_objectives.min(axis=0)) / (nondominated_objectives.max(axis=0) - nondominated_objectives.min(axis=0) + 1e-8)\n        crowding_dist = np.sum(normalized_obj, axis=1)\n        selected_idx = nondominated_indices[np.argmax(crowding_dist)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (multi-segment inversion + probabilistic edge insertion)\n    if n > 4:\n        # Multi-segment inversion\n        num_segments = np.random.randint(1, min(4, n//2))\n        segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n        segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n        for start, end in zip(segment_starts, segment_ends):\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.7:\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Calculate objective improvements\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                # Weighted improvement check\n                weight = 0.5  # Equal weight for both objectives\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or (weight * new_cost1 + (1-weight) * new_cost2 <= weight * old_cost1 + (1-weight) * old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7383660891871806,
            0.2816968560218811
        ],
        "raw_score": [
            8.050191117488936,
            8.073892623133398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n                break\n\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        nondominated_objectives = objectives[nondominated_indices]\n        normalized_obj = (nondominated_objectives - nondominated_objectives.min(axis=0)) / (nondominated_objectives.max(axis=0) - nondominated_objectives.min(axis=0) + 1e-8)\n        crowding_dist = np.sum(normalized_obj, axis=1)\n        selected_idx = nondominated_indices[np.argmax(crowding_dist)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (multi-segment inversion + probabilistic edge insertion)\n    if n > 4:\n        # Multi-segment inversion\n        num_segments = np.random.randint(1, min(4, n//2))\n        segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n        segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n        for start, end in zip(segment_starts, segment_ends):\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.7:\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Calculate objective improvements\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                # Weighted improvement check\n                weight = 0.5  # Equal weight for both objectives\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or (weight * new_cost1 + (1-weight) * new_cost2 <= weight * old_cost1 + (1-weight) * old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm combines nondominated solution selection with a multi-phase local search that alternates between probabilistic swaps, constrained edge insertions, and dynamic 4-opt moves, while using an objective-aware repair mechanism to maintain feasibility. It prioritizes solutions with balanced trade-offs between objectives and dynamically adapts its search strategy based on solution quality and phase selection. The hybrid repair mechanism ensures feasibility by reverting to a base solution if needed, while favoring improvements that maintain or improve the Pareto front.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with weighted probability\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    weights = np.array([(obj[0] + obj[1]) / (np.sum(obj) + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-phase local search\n    if n > 4:\n        phase = np.random.randint(0, 3)\n\n        if phase == 0:  # Probabilistic node swaps\n            for _ in range(2):\n                i, j = np.random.choice(n, 2, replace=False)\n                if np.random.rand() < 0.7:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 1:  # Constrained edge insertions\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n        else:  # Dynamic k-opt (k=4)\n            points = sorted(np.random.choice(n, 4, replace=False))\n            a, b, c, d = points\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 3: Hybrid repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive using Pareto dominance, then applies a hybrid operator that combines randomized node insertion with objective-aware edge exchanges prioritizing normalized improvements in both objectives, while ensuring feasibility through duplicate checks and missing-node replacement. The edge exchanges are limited to 2 per iteration for efficiency, and the selection prioritizes solutions with better combined normalized objective values.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        selected_solution = nondominated[np.random.randint(0, len(nondominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized node insertion + objective-aware edge exchange\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge exchange\n        for _ in range(2):  # Limit to 2 exchanges for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 39,
        "algorithm": "The algorithm combines Pareto dominance selection with a hybrid local search that alternates between segment reversals, insertions, and adaptive 3-opt moves, prioritizing solutions with balanced objective trade-offs and dynamically repairing infeasibilities while favoring improvements that maintain Pareto efficiency. It intelligently selects nondominated solutions based on objective balance and applies segment-based operators to explore the solution space, with a fallback to the original solution if feasibility is violated. The search is guided by objective-weighted selection and adaptive phase transitions to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Step 2: Select solution based on objective balance\n    weights = np.array([1.0 / (obj[0] * obj[1] + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Segment-based local search\n    if n > 3:\n        phase = np.random.randint(0, 3)\n\n        if phase == 0:  # Probabilistic segment reversal\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif phase == 1:  # Constrained segment insertion\n            segment_length = np.random.randint(2, min(4, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.arange(start, end))\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        else:  # Adaptive 3-opt\n            points = sorted(np.random.choice(n, 3, replace=False))\n            a, b, c = points\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 4: Pareto-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            temp_solution = new_solution.copy()\n            segment_length = np.random.randint(2, min(4, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            temp_solution[start:end] = temp_solution[start:end][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9020203366919755,
            0.33015531301498413
        ],
        "raw_score": [
            6.103658030630127,
            6.856896366748621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Step 2: Select solution based on objective balance\n    weights = np.array([1.0 / (obj[0] * obj[1] + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Segment-based local search\n    if n > 3:\n        phase = np.random.randint(0, 3)\n\n        if phase == 0:  # Probabilistic segment reversal\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif phase == 1:  # Constrained segment insertion\n            segment_length = np.random.randint(2, min(4, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.arange(start, end))\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        else:  # Adaptive 3-opt\n            points = sorted(np.random.choice(n, 3, replace=False))\n            a, b, c = points\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 4: Pareto-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            temp_solution = new_solution.copy()\n            segment_length = np.random.randint(2, min(4, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            temp_solution[start:end] = temp_solution[start:end][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive using Pareto dominance, then applies a hybrid operator that combines randomized node insertion with objective-aware edge exchanges prioritizing normalized improvements in both objectives, while ensuring feasibility through duplicate checks and missing-node replacement. The edge exchanges are limited to 2 per iteration for efficiency, and the selection prioritizes solutions with better combined normalized objective values.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        selected_solution = nondominated[np.random.randint(0, len(nondominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized node insertion + objective-aware edge exchange\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge exchange\n        for _ in range(2):  # Limit to 2 exchanges for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 40,
        "algorithm": "The algorithm selects a promising TSP tour from the archive by prioritizing solutions with balanced objective improvements, then applies a hybrid local search combining multi-segment crossover and objective-aware edge flips, while ensuring feasibility through a missing-node reinsertion mechanism. The method focuses on balancing trade-offs between objectives by preferring solutions where both costs are similarly improved, and uses randomized segment swaps and selective edge reversals to explore the search space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment crossover operator\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment1 = new_solution[a:b]\n        c, d = np.random.choice(n, 2, replace=False)\n        if c > d:\n            c, d = d, c\n        segment2 = new_solution[c:d]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]\n        ])\n\n        # Objective-aware edge flips\n        for _ in range(2):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Missing-node reinsertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7070289832216284,
            0.0992804765701294
        ],
        "raw_score": [
            7.374883770537505,
            7.453954402412746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment crossover operator\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment1 = new_solution[a:b]\n        c, d = np.random.choice(n, 2, replace=False)\n        if c > d:\n            c, d = d, c\n        segment2 = new_solution[c:d]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]\n        ])\n\n        # Objective-aware edge flips\n        for _ in range(2):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Missing-node reinsertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a nondominated solution from the archive using Pareto dominance, then applies a hybrid operator that combines randomized node insertion with objective-aware edge exchanges prioritizing normalized improvements in both objectives, while ensuring feasibility through duplicate checks and missing-node replacement. The edge exchanges are limited to 2 per iteration for efficiency, and the selection prioritizes solutions with better combined normalized objective values.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        selected_solution = nondominated[np.random.randint(0, len(nondominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized node insertion + objective-aware edge exchange\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge exchange\n        for _ in range(2):  # Limit to 2 exchanges for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 41,
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective score (prioritizing the first objective 60% of the time) and applies a segment-based local search with adaptive edge flipping and segment reinsertion. It ensures feasibility by validating node uniqueness and repairing duplicates, using a probabilistic approach to balance exploration and exploitation. The method avoids standard 2-opt by operating on segments and dynamically adjusting segment positions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    weights = [0.6, 0.4] if np.random.rand() < 0.7 else [0.4, 0.6]\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search\n    if n > 4:\n        # Split into segments and process\n        segment_size = max(2, n // 4)\n        segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n        # Process each segment with probability\n        for i in range(len(segments)):\n            if np.random.rand() < 0.7:\n                segment = segments[i]\n                # Adaptive edge flipping within segment\n                for _ in range(2):\n                    if len(segment) > 2:\n                        a, b = np.random.choice(len(segment), 2, replace=False)\n                        if a > b:\n                            a, b = b, a\n                        # Calculate potential improvement\n                        current_cost = (distance_matrix_1[segment[a-1], segment[a]] + distance_matrix_1[segment[b-1], segment[b]]) + \\\n                                      (distance_matrix_2[segment[a-1], segment[a]] + distance_matrix_2[segment[b-1], segment[b]])\n                        new_cost = (distance_matrix_1[segment[a-1], segment[b]] + distance_matrix_1[segment[b-1], segment[a]]) + \\\n                                   (distance_matrix_2[segment[a-1], segment[b]] + distance_matrix_2[segment[b-1], segment[a]])\n                        if new_cost < current_cost:\n                            segment[a], segment[b] = segment[b], segment[a]\n\n                # Reinsert segment with probability\n                if np.random.rand() < 0.5 and len(segments) > 1:\n                    segments.pop(i)\n                    new_pos = np.random.randint(0, len(segments))\n                    segments.insert(new_pos, segment)\n\n        # Reconstruct solution\n        new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7908293824970098,
            0.2916945219039917
        ],
        "raw_score": [
            7.70636212713062,
            8.067096679380668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score\n    weights = [0.6, 0.4] if np.random.rand() < 0.7 else [0.4, 0.6]\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search\n    if n > 4:\n        # Split into segments and process\n        segment_size = max(2, n // 4)\n        segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n        # Process each segment with probability\n        for i in range(len(segments)):\n            if np.random.rand() < 0.7:\n                segment = segments[i]\n                # Adaptive edge flipping within segment\n                for _ in range(2):\n                    if len(segment) > 2:\n                        a, b = np.random.choice(len(segment), 2, replace=False)\n                        if a > b:\n                            a, b = b, a\n                        # Calculate potential improvement\n                        current_cost = (distance_matrix_1[segment[a-1], segment[a]] + distance_matrix_1[segment[b-1], segment[b]]) + \\\n                                      (distance_matrix_2[segment[a-1], segment[a]] + distance_matrix_2[segment[b-1], segment[b]])\n                        new_cost = (distance_matrix_1[segment[a-1], segment[b]] + distance_matrix_1[segment[b-1], segment[a]]) + \\\n                                   (distance_matrix_2[segment[a-1], segment[b]] + distance_matrix_2[segment[b-1], segment[a]])\n                        if new_cost < current_cost:\n                            segment[a], segment[b] = segment[b], segment[a]\n\n                # Reinsert segment with probability\n                if np.random.rand() < 0.5 and len(segments) > 1:\n                    segments.pop(i)\n                    new_pos = np.random.randint(0, len(segments))\n                    segments.insert(new_pos, segment)\n\n        # Reconstruct solution\n        new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a nondominated solution from the archive using Pareto dominance, then applies a hybrid operator that combines randomized node insertion with objective-aware edge exchanges prioritizing normalized improvements in both objectives, while ensuring feasibility through duplicate checks and missing-node replacement. The edge exchanges are limited to 2 per iteration for efficiency, and the selection prioritizes solutions with better combined normalized objective values.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        selected_solution = nondominated[np.random.randint(0, len(nondominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized node insertion + objective-aware edge exchange\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge exchange\n        for _ in range(2):  # Limit to 2 exchanges for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 42,
        "algorithm": "The algorithm selects a promising solution from the archive using crowding-distance-based selection, then applies a hybrid operator combining randomized segment reversal with objective-aware node swaps to generate a neighbor solution, prioritizing edges that improve the combined normalized objectives while ensuring feasibility through a greedy repair mechanism. The selection is based on the solution's potential for improvement in the objective space, while the hybrid operator explores local changes by reversing segments and swapping nodes that show promise in reducing the normalized combined objective values.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        range_m = objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m]\n        if range_m == 0:\n            continue\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / range_m\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = solutions[selected_idx].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized segment reversal + objective-aware node swap\n    if n > 3:\n        # Random segment reversal\n        start, end = np.sort(np.random.choice(n, 2, replace=False))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Objective-aware node swap\n        for _ in range(3):  # 3 swaps for more exploration\n            i, j = np.random.choice(n, 2, replace=False)\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Greedy repair for feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7253291496294323,
            0.4415245056152344
        ],
        "raw_score": [
            8.843611640150076,
            7.034406115004237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        range_m = objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m]\n        if range_m == 0:\n            continue\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / range_m\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = solutions[selected_idx].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized segment reversal + objective-aware node swap\n    if n > 3:\n        # Random segment reversal\n        start, end = np.sort(np.random.choice(n, 2, replace=False))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Objective-aware node swap\n        for _ in range(3):  # 3 swaps for more exploration\n            i, j = np.random.choice(n, 2, replace=False)\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Greedy repair for feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 3 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive using Pareto dominance, then applies a hybrid operator that combines randomized node insertion with objective-aware edge exchanges prioritizing normalized improvements in both objectives, while ensuring feasibility through duplicate checks and missing-node replacement. The edge exchanges are limited to 2 per iteration for efficiency, and the selection prioritizes solutions with better combined normalized objective values.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        selected_solution = nondominated[np.random.randint(0, len(nondominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized node insertion + objective-aware edge exchange\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge exchange\n        for _ in range(2):  # Limit to 2 exchanges for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 43,
        "algorithm": "The algorithm selects a Pareto-nondominated solution from the archive (prioritizing those with better combined normalized objectives) and applies a hybrid operator: first reversing a random segment to introduce diversity, then performing up to 3 edge exchanges between nodes that promise normalized improvement in both objectives. It ensures feasibility by checking for duplicates and repairing the solution if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8614783025625103,
            1.445907711982727
        ],
        "raw_score": [
            5.904728924174375,
            5.861094091687337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 4 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive based on Pareto diversity (high crowding distance) and applies a hybrid local search combining segment reversal and probabilistic edge insertion, ensuring feasibility through objective-aware repair and falling back to 3-opt if needed. It prioritizes solutions with high crowding distance to maintain diversity in the objective space while using a novel combination of moves to explore the solution space more effectively than standard approaches.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive by prioritizing those with balanced objective values (weighted between 0.4 and 0.6) and applies a hybrid local search combining segment inversion and probabilistic edge exchanges, ensuring feasibility through a node validation and repair mechanism. It dynamically adjusts segment lengths and swap probabilities to explore the solution space while maintaining tour validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.uniform(0.4, 0.6)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        segment_length = np.random.randint(3, min(6, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution[start:start + segment_length] = segment[::-1]\n\n        if np.random.rand() < 0.6:\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 44,
        "algorithm": "The algorithm selects a nondominated solution from the archive by prioritizing balanced objective values (using weighted normalization) and applies a hybrid local search combining segment inversion and probabilistic edge exchanges to generate a neighbor solution, ensuring feasibility through dynamic node validation and repair. It emphasizes balanced solutions and uses randomized segment operations with probabilistic edge swaps to explore the search space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    weighted_scores = weights * normalized_obj[:, 0] + (1 - weights) * normalized_obj[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion + probabilistic edge exchange\n    if n > 4:\n        # Segment inversion\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start + segment_length] = new_solution[start:start + segment_length][::-1]\n\n        # Probabilistic edge exchange\n        if np.random.rand() < 0.7 and n > 3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if abs(a - b) > 1 and abs(a - b) < n - 1:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7480797111735049,
            0.2302526831626892
        ],
        "raw_score": [
            6.429847331205791,
            6.7505486745178915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    weighted_scores = weights * normalized_obj[:, 0] + (1 - weights) * normalized_obj[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion + probabilistic edge exchange\n    if n > 4:\n        # Segment inversion\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start + segment_length] = new_solution[start:start + segment_length][::-1]\n\n        # Probabilistic edge exchange\n        if np.random.rand() < 0.7 and n > 3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if abs(a - b) > 1 and abs(a - b) < n - 1:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a Pareto-nondominated solution from the archive (prioritizing those with better combined normalized objectives) and applies a hybrid operator: first reversing a random segment to introduce diversity, then performing up to 3 edge exchanges between nodes that promise normalized improvement in both objectives. It ensures feasibility by checking for duplicates and repairing the solution if needed.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 45,
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid of Pareto dominance and objective diversity, then applies a novel local search combining dynamic segment reversal and multi-objective-aware node relocation, prioritizing edges with normalized improvement in both objectives while ensuring feasibility through a greedy repair mechanism. The selection favors non-dominated solutions with high diversity, and the local search dynamically adjusts segment sizes and prioritizes relocations that improve normalized objective values.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize nondominated solutions with high diversity\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values and high diversity\n        diversity_scores = []\n        for sol, obj in nondominated:\n            diversity = 0\n            for other_sol, other_obj in nondominated:\n                diversity += np.sqrt((obj[0] - other_obj[0])**2 + (obj[1] - other_obj[1])**2)\n            diversity_scores.append(diversity)\n        selected_idx = np.argmax(diversity_scores)\n        selected_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal based on solution quality\n    segment_size = max(2, int(np.random.uniform(0.1, 0.3) * n))\n    i = np.random.randint(0, n - segment_size + 1)\n    j = i + segment_size - 1\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective-aware node relocation\n    for _ in range(3):\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find the best insertion point based on normalized objectives\n        best_pos = -1\n        best_norm = float('inf')\n        for pos in range(n):\n            if pos == node_idx or pos == node_idx - 1:\n                continue\n            # Calculate current and new objectives\n            if node_idx > 0:\n                prev_node = new_solution[node_idx - 1]\n            else:\n                prev_node = new_solution[-1]\n            if node_idx < n - 1:\n                next_node = new_solution[node_idx + 1]\n            else:\n                next_node = new_solution[0]\n\n            current_obj1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            current_obj2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            if pos > 0:\n                prev_pos = new_solution[pos - 1]\n            else:\n                prev_pos = new_solution[-1]\n            next_pos = new_solution[pos]\n\n            new_obj1 = distance_matrix_1[prev_pos, node] + distance_matrix_1[node, next_pos]\n            new_obj2 = distance_matrix_2[prev_pos, node] + distance_matrix_2[node, next_pos]\n\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n\n            if norm_new < best_norm:\n                best_norm = norm_new\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform relocation\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility (greedy repair)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                # Replace duplicate with the closest missing node in terms of objectives\n                if len(missing) > 0:\n                    best_missing = missing[0]\n                    min_norm = float('inf')\n                    for m in missing:\n                        norm = (distance_matrix_1[node, m] + distance_matrix_2[node, m]) / 2\n                        if norm < min_norm:\n                            min_norm = norm\n                            best_missing = m\n                    new_solution[idx] = best_missing\n                    missing = np.delete(missing, np.where(missing == best_missing)[0])\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7905641835140677,
            1.9226025342941284
        ],
        "raw_score": [
            6.8053104643406535,
            7.149476465263349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize nondominated solutions with high diversity\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values and high diversity\n        diversity_scores = []\n        for sol, obj in nondominated:\n            diversity = 0\n            for other_sol, other_obj in nondominated:\n                diversity += np.sqrt((obj[0] - other_obj[0])**2 + (obj[1] - other_obj[1])**2)\n            diversity_scores.append(diversity)\n        selected_idx = np.argmax(diversity_scores)\n        selected_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal based on solution quality\n    segment_size = max(2, int(np.random.uniform(0.1, 0.3) * n))\n    i = np.random.randint(0, n - segment_size + 1)\n    j = i + segment_size - 1\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective-aware node relocation\n    for _ in range(3):\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find the best insertion point based on normalized objectives\n        best_pos = -1\n        best_norm = float('inf')\n        for pos in range(n):\n            if pos == node_idx or pos == node_idx - 1:\n                continue\n            # Calculate current and new objectives\n            if node_idx > 0:\n                prev_node = new_solution[node_idx - 1]\n            else:\n                prev_node = new_solution[-1]\n            if node_idx < n - 1:\n                next_node = new_solution[node_idx + 1]\n            else:\n                next_node = new_solution[0]\n\n            current_obj1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            current_obj2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            if pos > 0:\n                prev_pos = new_solution[pos - 1]\n            else:\n                prev_pos = new_solution[-1]\n            next_pos = new_solution[pos]\n\n            new_obj1 = distance_matrix_1[prev_pos, node] + distance_matrix_1[node, next_pos]\n            new_obj2 = distance_matrix_2[prev_pos, node] + distance_matrix_2[node, next_pos]\n\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n\n            if norm_new < best_norm:\n                best_norm = norm_new\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform relocation\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility (greedy repair)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                # Replace duplicate with the closest missing node in terms of objectives\n                if len(missing) > 0:\n                    best_missing = missing[0]\n                    min_norm = float('inf')\n                    for m in missing:\n                        norm = (distance_matrix_1[node, m] + distance_matrix_2[node, m]) / 2\n                        if norm < min_norm:\n                            min_norm = norm\n                            best_missing = m\n                    new_solution[idx] = best_missing\n                    missing = np.delete(missing, np.where(missing == best_missing)[0])\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a Pareto-nondominated solution from the archive (prioritizing those with better combined normalized objectives) and applies a hybrid operator: first reversing a random segment to introduce diversity, then performing up to 3 edge exchanges between nodes that promise normalized improvement in both objectives. It ensures feasibility by checking for duplicates and repairing the solution if needed.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 46,
        "algorithm": "The algorithm selects a promising solution from the archive based on a hybrid fitness metric combining normalized objective values and solution diversity, then applies a novel \"objective-aware node chain shift\" operator that intelligently shifts segments of nodes between promising insertion points while considering both objectives, ensuring feasibility through a lightweight repair mechanism that prioritizes the least disruptive changes. The selection favors solutions with lower combined objective values and higher diversity, while the local search operator evaluates potential shifts based on normalized improvements in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize solutions with good combined objective and diversity\n    archive_sorted = sorted(archive, key=lambda x: (sum(x[1]) / 2) - (np.max(x[0]) - np.min(x[0])) * 0.1)\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node chain shift\n    if n > 3:\n        # Select a chain of nodes to shift\n        chain_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Find best insertion point considering both objectives\n        best_pos = start\n        best_score = float('inf')\n\n        for pos in range(n - chain_length + 1):\n            if pos == start:\n                continue\n\n            # Calculate potential new objectives\n            temp_solution = np.concatenate([new_solution[:pos], chain, new_solution[pos:start], new_solution[start+chain_length:]])\n            obj1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            obj2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            # Normalized score\n            total_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            score = (obj1/total_obj1 + obj2/total_obj2) / 2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Apply the best shift\n        new_solution = np.concatenate([new_solution[:best_pos], chain, new_solution[best_pos:start], new_solution[start+chain_length:]])\n\n    # Lightweight repair if duplicates exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                if len(missing) > 0:\n                    new_solution[idx] = missing[0]\n                    missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.39068403332055157,
            0.7112562656402588
        ],
        "raw_score": [
            6.6978618344377505,
            6.888541386347295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize solutions with good combined objective and diversity\n    archive_sorted = sorted(archive, key=lambda x: (sum(x[1]) / 2) - (np.max(x[0]) - np.min(x[0])) * 0.1)\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node chain shift\n    if n > 3:\n        # Select a chain of nodes to shift\n        chain_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Find best insertion point considering both objectives\n        best_pos = start\n        best_score = float('inf')\n\n        for pos in range(n - chain_length + 1):\n            if pos == start:\n                continue\n\n            # Calculate potential new objectives\n            temp_solution = np.concatenate([new_solution[:pos], chain, new_solution[pos:start], new_solution[start+chain_length:]])\n            obj1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            obj2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            # Normalized score\n            total_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            score = (obj1/total_obj1 + obj2/total_obj2) / 2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Apply the best shift\n        new_solution = np.concatenate([new_solution[:best_pos], chain, new_solution[best_pos:start], new_solution[start+chain_length:]])\n\n    # Lightweight repair if duplicates exist\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                if len(missing) > 0:\n                    new_solution[idx] = missing[0]\n                    missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a Pareto-nondominated solution from the archive (prioritizing those with better combined normalized objectives) and applies a hybrid operator: first reversing a random segment to introduce diversity, then performing up to 3 edge exchanges between nodes that promise normalized improvement in both objectives. It ensures feasibility by checking for duplicates and repairing the solution if needed.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 47,
        "algorithm": "The algorithm selects the best solution from the archive based on normalized combined objectives, then applies a hybrid operator combining segment insertion and objective-aware edge swaps to generate a neighbor solution while ensuring feasibility through a repair mechanism that guarantees all nodes are included exactly once. The method prioritizes solutions with better combined performance and uses a novel local search strategy that balances exploration and exploitation across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined normalized objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment insertion + objective-aware edge swaps\n    if n > 3:\n        # Novel segment insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        # Objective-aware edge swaps\n        for _ in range(3):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8272049346500685,
            0.2105872631072998
        ],
        "raw_score": [
            6.339957559032184,
            6.625324252806442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined normalized objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment insertion + objective-aware edge swaps\n    if n > 3:\n        # Novel segment insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        # Objective-aware edge swaps\n        for _ in range(3):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility repair\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a Pareto-nondominated solution from the archive (prioritizing those with better combined normalized objectives) and applies a hybrid operator: first reversing a random segment to introduce diversity, then performing up to 3 edge exchanges between nodes that promise normalized improvement in both objectives. It ensures feasibility by checking for duplicates and repairing the solution if needed.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 48,
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted sum of objectives (60% weight for the first objective, 40% for the second), then applies a segment insertion operator followed by a limited objective-aware edge exchange (2 operations max) prioritizing the objective with higher relative improvement (threshold of 5%). It ensures feasibility by repairing duplicates, replacing them with missing nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted sum of objectives\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment insertion operator\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        segment = new_solution[i:j].copy()\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        # Objective-aware edge exchange (prioritize objective with higher relative improvement)\n        for _ in range(2):  # Limit to 2 operations\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Calculate relative improvements\n            rel_improv1 = (current_obj1 - new_obj1) / current_obj1 if current_obj1 != 0 else 0\n            rel_improv2 = (current_obj2 - new_obj2) / current_obj2 if current_obj2 != 0 else 0\n\n            if rel_improv1 > rel_improv2 and rel_improv1 > 0.05:  # Threshold for objective 1\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif rel_improv2 > rel_improv1 and rel_improv2 > 0.05:  # Threshold for objective 2\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8031283573974434,
            0.1561204195022583
        ],
        "raw_score": [
            8.964035255346213,
            8.705240905356447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted sum of objectives\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment insertion operator\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        segment = new_solution[i:j].copy()\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        # Objective-aware edge exchange (prioritize objective with higher relative improvement)\n        for _ in range(2):  # Limit to 2 operations\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Calculate relative improvements\n            rel_improv1 = (current_obj1 - new_obj1) / current_obj1 if current_obj1 != 0 else 0\n            rel_improv2 = (current_obj2 - new_obj2) / current_obj2 if current_obj2 != 0 else 0\n\n            if rel_improv1 > rel_improv2 and rel_improv1 > 0.05:  # Threshold for objective 1\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif rel_improv2 > rel_improv1 and rel_improv2 > 0.05:  # Threshold for objective 2\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 4 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a Pareto-nondominated solution from the archive (prioritizing those with better combined normalized objectives) and applies a hybrid operator: first reversing a random segment to introduce diversity, then performing up to 3 edge exchanges between nodes that promise normalized improvement in both objectives. It ensures feasibility by checking for duplicates and repairing the solution if needed.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a nondominated solution from the archive using Pareto dominance, then applies a hybrid operator that combines randomized node insertion with objective-aware edge exchanges prioritizing normalized improvements in both objectives, while ensuring feasibility through duplicate checks and missing-node replacement. The edge exchanges are limited to 2 per iteration for efficiency, and the selection prioritizes solutions with better combined normalized objective values.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        selected_solution = nondominated[np.random.randint(0, len(nondominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: randomized node insertion + objective-aware edge exchange\n    if n > 3:\n        # Randomly select a node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Objective-aware edge exchange\n        for _ in range(2):  # Limit to 2 exchanges for efficiency\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (based on combined objective value) and applies a hybrid local search combining random node swaps and segment rotation to generate a neighbor, ensuring feasibility by repairing duplicates through a missing-node replacement mechanism. It prioritizes solutions with lower combined costs while using randomized operations to explore the search space, with a focus on maintaining tour validity through explicit checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node swaps and segment rotation\n    if n > 3:\n        # Perform node swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Perform segment rotation\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(j+1, n)\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (prioritizing lower-cost solutions) and applies a hybrid local search combining random segment reversal and edge insertion to generate a feasible neighbor solution. It ensures feasibility by repairing duplicates, though this could be improved. The approach balances exploration and exploitation by randomizing segment selection and insertion points, though it lacks explicit diversity control.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with lower costs (better solutions)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (avoiding duplicates)\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Insert segment between a and b\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined self-reflection with actionable insights:\n\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 49,
        "algorithm": "The algorithm selects a nondominated solution from the archive (prioritizing those with better combined normalized objectives) and applies a hybrid local search combining segment reversal, objective-aware edge exchanges (limited to 3 operations), and randomized node insertions (limited to 2 operations). It ensures feasibility by repairing duplicate nodes and balances exploration and exploitation through randomized operations while favoring segments that promise improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance and combined normalized objective\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange + randomized node insertion\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomized node insertion\n        for _ in range(2):  # Limit to 2 operations\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6792294139876652,
            0.34790903329849243
        ],
        "raw_score": [
            6.854684732520349,
            7.019205323243407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution based on Pareto dominance and combined normalized objective\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Prioritize solutions with better combined normalized objective values\n        nondominated_sorted = sorted(nondominated, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_solution = nondominated_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: segment reversal + objective-aware edge exchange + randomized node insertion\n    if n > 3:\n        # Random segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge exchange\n        for _ in range(3):  # Limit to 3 operations\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate current and new objective values\n            current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            # Normalize objectives\n            total_obj1 = sum([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            total_obj2 = sum([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            norm_current = (current_obj1 / total_obj1 + current_obj2 / total_obj2) / 2\n            norm_new = (new_obj1 / total_obj1 + new_obj2 / total_obj2) / 2\n            if norm_new < norm_current:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomized node insertion\n        for _ in range(2):  # Limit to 2 operations\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 4 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by reverting to a 2-opt move if invalid. It prioritizes randomness in segment selection and edge insertion while maintaining tour validity through uniqueness checks. The algorithm balances exploration (random selection) and exploitation (local improvement) to navigate the bi-objective TSP landscape.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high edge diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        edge_start = np.random.randint(0, n - 1)\n        edge_end = (edge_start + 1) % n\n        insert_pos = np.random.randint(0, n - 1)\n\n        if insert_pos != edge_start and insert_pos != edge_end:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array([new_solution[edge_start], new_solution[edge_end]]),\n                np.delete(new_solution, [edge_start, edge_end])\n            ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic 2-opt move if hybrid move is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive based on Pareto diversity (high crowding distance) and applies a hybrid local search combining segment reversal and probabilistic edge insertion, ensuring feasibility through objective-aware repair and falling back to 3-opt if needed. It prioritizes solutions with high crowding distance to maintain diversity in the objective space while using a novel combination of moves to explore the solution space more effectively than standard approaches.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high crowding distance (Pareto diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment reversal + probabilistic edge insertion)\n    if n > 4:\n        # Segment reversal\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.rand() < 0.5:\n            edge_start = np.random.randint(0, n - 1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n - 1)\n\n            if insert_pos not in [edge_start, (edge_start - 1) % n, (edge_end + 1) % n, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Step 3: Objective-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Check if the move improves both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Fallback to 3-opt if repair fails\n    if len(np.unique(new_solution)) != n:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j + 1] = new_solution[i:j + 1][::-1]\n        new_solution[j:k + 1] = new_solution[j:k + 1][::-1]\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive by prioritizing those with balanced objective values (weighted between 0.4 and 0.6) and applies a hybrid local search combining segment inversion and probabilistic edge exchanges, ensuring feasibility through a node validation and repair mechanism. It dynamically adjusts segment lengths and swap probabilities to explore the solution space while maintaining tour validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.uniform(0.4, 0.6)\n    archive_sorted = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        segment_length = np.random.randint(3, min(6, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution[start:start + segment_length] = segment[::-1]\n\n        if np.random.rand() < 0.6:\n            a, b = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.7:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n                unique_nodes = np.unique(new_solution)\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 50,
        "algorithm": "The algorithm selects a nondominated solution from the archive using Pareto dominance and weighted objective trade-offs, then applies a hybrid local search combining segment inversion, probabilistic edge exchanges, and node insertion while ensuring feasibility through objective-aware validation and repair. It prioritizes solutions with balanced objectives and uses randomized operations with different probabilities to explore the search space, with a fallback to objective-aware repairs when feasibility is violated. The method balances exploration and exploitation by combining multiple local search operators while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with balanced objective weighting\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.4, 0.6)\n    weighted_obj = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    nondominated_indices = [i for i in range(len(archive)) if not any(\n        (objectives[i, 0] > objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]) or\n        (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] > objectives[j, 1])\n        for j in range(len(archive)) if j != i\n    )]\n    if not nondominated_indices:\n        selected_idx = np.argmin(weighted_obj)\n    else:\n        selected_idx = np.random.choice(nondominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment inversion + probabilistic edge exchange + node insertion)\n    if n > 4:\n        # Segment inversion\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge exchange\n        if np.random.rand() < 0.5:\n            a, b = np.random.choice(n, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Node insertion\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n - 1)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Step 3: Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair: prefer moves that improve both objectives\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.900125731141294,
            0.5052226185798645
        ],
        "raw_score": [
            6.841082851121813,
            6.953713278498072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with balanced objective weighting\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.4, 0.6)\n    weighted_obj = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    nondominated_indices = [i for i in range(len(archive)) if not any(\n        (objectives[i, 0] > objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]) or\n        (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] > objectives[j, 1])\n        for j in range(len(archive)) if j != i\n    )]\n    if not nondominated_indices:\n        selected_idx = np.argmin(weighted_obj)\n    else:\n        selected_idx = np.random.choice(nondominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search (segment inversion + probabilistic edge exchange + node insertion)\n    if n > 4:\n        # Segment inversion\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n - 1)\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Probabilistic edge exchange\n        if np.random.rand() < 0.5:\n            a, b = np.random.choice(n, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Node insertion\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n - 1)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Step 3: Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair: prefer moves that improve both objectives\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j + 1] = temp_solution[i:j + 1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising TSP tour from the archive by prioritizing solutions with balanced objective improvements, then applies a hybrid local search combining multi-segment crossover and objective-aware edge flips, while ensuring feasibility through a missing-node reinsertion mechanism. The method focuses on balancing trade-offs between objectives by preferring solutions where both costs are similarly improved, and uses randomized segment swaps and selective edge reversals to explore the search space while maintaining tour validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment crossover operator\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment1 = new_solution[a:b]\n        c, d = np.random.choice(n, 2, replace=False)\n        if c > d:\n            c, d = d, c\n        segment2 = new_solution[c:d]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]\n        ])\n\n        # Objective-aware edge flips\n        for _ in range(2):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Missing-node reinsertion\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        all_nodes = np.arange(n)\n        missing = np.setdiff1d(all_nodes, new_solution)\n        for idx, node in enumerate(new_solution):\n            if np.sum(new_solution == node) > 1:\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm combines Pareto dominance selection with a hybrid local search that alternates between segment reversals, insertions, and adaptive 3-opt moves, prioritizing solutions with balanced objective trade-offs and dynamically repairing infeasibilities while favoring improvements that maintain Pareto efficiency. It intelligently selects nondominated solutions based on objective balance and applies segment-based operators to explore the solution space, with a fallback to the original solution if feasibility is violated. The search is guided by objective-weighted selection and adaptive phase transitions to balance exploration and exploitation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Step 2: Select solution based on objective balance\n    weights = np.array([1.0 / (obj[0] * obj[1] + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Segment-based local search\n    if n > 3:\n        phase = np.random.randint(0, 3)\n\n        if phase == 0:  # Probabilistic segment reversal\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif phase == 1:  # Constrained segment insertion\n            segment_length = np.random.randint(2, min(4, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.arange(start, end))\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        else:  # Adaptive 3-opt\n            points = sorted(np.random.choice(n, 3, replace=False))\n            a, b, c = points\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 4: Pareto-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            temp_solution = new_solution.copy()\n            segment_length = np.random.randint(2, min(4, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            temp_solution[start:end] = temp_solution[start:end][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 51,
        "algorithm": "The algorithm combines Pareto-aware selection with a dynamic hybrid local search that alternates between objective-weighted segment reversals, constrained node relocations, and adaptive edge exchanges, prioritizing solutions with balanced objectives while ensuring feasibility through multi-phase edge reinsertions and adaptive repairs. It selects solutions probabilistically based on normalized objective balance and applies randomized perturbations tailored to the current phase, with feasibility checks and repairs to maintain valid tours. The approach emphasizes exploration of the Pareto front through weighted objective considerations and segment-based operations while dynamically adapting the search strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution based on normalized objective balance\n    normalized_objs = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / (sum(o[0] for _, o in archive) + 1e-9),\n                    obj[1] / (sum(o[1] for _, o in archive) + 1e-9))\n        normalized_objs.append((sol, norm_obj))\n\n    weights = [1.0 / (abs(norm_obj[0] - norm_obj[1]) + 1e-9) for _, norm_obj in normalized_objs]\n    selected_idx = np.random.choice(len(normalized_objs), p=np.array(weights)/sum(weights))\n    base_solution = normalized_objs[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Dynamic hybrid local search\n    phase = np.random.randint(0, 3)\n\n    if phase == 0:  # Objective-weighted segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        obj1_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        obj2_cost = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        if obj1_cost > obj2_cost:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    elif phase == 1:  # Constrained node relocation\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Multi-phase edge reinsertion\n        for _ in range(2):\n            i = np.random.randint(0, n-2)\n            j = np.random.randint(i+1, n-1)\n            k = np.random.randint(j+1, n)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n            temp_solution[j:k] = temp_solution[j:k][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n\n    else:  # Adaptive edge exchange\n        for _ in range(3):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9087923534136226,
            3.213014543056488
        ],
        "raw_score": [
            6.795909993937712,
            6.813080410110312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution based on normalized objective balance\n    normalized_objs = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / (sum(o[0] for _, o in archive) + 1e-9),\n                    obj[1] / (sum(o[1] for _, o in archive) + 1e-9))\n        normalized_objs.append((sol, norm_obj))\n\n    weights = [1.0 / (abs(norm_obj[0] - norm_obj[1]) + 1e-9) for _, norm_obj in normalized_objs]\n    selected_idx = np.random.choice(len(normalized_objs), p=np.array(weights)/sum(weights))\n    base_solution = normalized_objs[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Dynamic hybrid local search\n    phase = np.random.randint(0, 3)\n\n    if phase == 0:  # Objective-weighted segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        obj1_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        obj2_cost = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        if obj1_cost > obj2_cost:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    elif phase == 1:  # Constrained node relocation\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Multi-phase edge reinsertion\n        for _ in range(2):\n            i = np.random.randint(0, n-2)\n            j = np.random.randint(i+1, n-1)\n            k = np.random.randint(j+1, n)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n            temp_solution[j:k] = temp_solution[j:k][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n\n    else:  # Adaptive edge exchange\n        for _ in range(3):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm combines Pareto-guided selection with a novel local search strategy that uses multi-segment inversion and edge insertion, prioritizing solutions with high crowding distance in the archive while ensuring feasibility through objective-guided repair. It balances exploration (random segment manipulation) and exploitation (objective improvement checks) to generate high-quality neighbors in the bi-objective TSP.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-guided solution selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_starts = sorted(np.random.choice(n, num_segments, replace=False))\n    segment_ends = [min(s + np.random.randint(1, n//2), n-1) for s in segment_starts]\n\n    for start, end in zip(segment_starts, segment_ends):\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion from distant segments\n    if n > 4:\n        for _ in range(np.random.randint(1, 3)):\n            edge_start = np.random.randint(0, n-1)\n            edge_end = (edge_start + 1) % n\n            insert_pos = np.random.randint(0, n-1)\n\n            if insert_pos not in [edge_start, edge_end]:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    np.array([new_solution[edge_start], new_solution[edge_end]]),\n                    np.delete(new_solution, [edge_start, edge_end])\n                ])\n\n    # Feasibility repair\n    if len(np.unique(new_solution)) != n:\n        # Objective-guided repair: prefer moves that improve both objectives\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                # Evaluate improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.3:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm combines Pareto dominance selection with a hybrid local search that alternates between segment reversals, insertions, and adaptive 3-opt moves, prioritizing solutions with balanced objective trade-offs and dynamically repairing infeasibilities while favoring improvements that maintain Pareto efficiency. It intelligently selects nondominated solutions based on objective balance and applies segment-based operators to explore the solution space, with a fallback to the original solution if feasibility is violated. The search is guided by objective-weighted selection and adaptive phase transitions to balance exploration and exploitation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solution with Pareto dominance\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Step 2: Select solution based on objective balance\n    weights = np.array([1.0 / (obj[0] * obj[1] + 1e-9) for _, obj in nondominated])\n    selected_idx = np.random.choice(len(nondominated), p=weights/np.sum(weights))\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Segment-based local search\n    if n > 3:\n        phase = np.random.randint(0, 3)\n\n        if phase == 0:  # Probabilistic segment reversal\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif phase == 1:  # Constrained segment insertion\n            segment_length = np.random.randint(2, min(4, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.arange(start, end))\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        else:  # Adaptive 3-opt\n            points = sorted(np.random.choice(n, 3, replace=False))\n            a, b, c = points\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 4: Pareto-aware feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            temp_solution = new_solution.copy()\n            segment_length = np.random.randint(2, min(4, n))\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            temp_solution[start:end] = temp_solution[start:end][::-1]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### **Refined Self-Reflection**\n- **Keywords**: *Nondominated heuristics, hybrid operators, objective-aware weighting, feasibility checks.*\n- **Advice**: Prioritize nondominated solutions with hybrid operators (e.g., node insertion + edge exchange) and normalized objective weighting to balance trade-offs.\n- **Avoid**: Random selection without Pareto guidance or overly complex repairs that break feasibility.\n- **Explanation**: Dominated heuristics risk premature convergence; hybrid operators must balance creativity and feasibility while leveraging multi-objective awareness for sustained improvement.\n\n*(100 words, step-by-step reasoning integrated.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 52,
        "algorithm": "The algorithm selects promising solutions from the archive using a Pareto-aware weighted random selection based on normalized objective trade-offs, then applies a hybrid local search combining probabilistic segment swapping and constrained edge reinsertion with dynamic segment sizes. It ensures feasibility through adaptive repairs that prioritize Pareto improvements or random swaps, falling back to the original solution if needed. The method balances exploration and exploitation by dynamically adjusting segment sizes and using probabilistic moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution based on balanced objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1.0 / (normalized_obj[:, 0] * normalized_obj[:, 1] + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search with dynamic segment size\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Probabilistic node swapping\n        if np.random.random() < 0.5:\n            new_solution[start:end] = np.random.permutation(new_solution[start:end])\n        else:\n            # Constrained edge reinsertion\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.arange(start, end))\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Adaptive feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            temp_solution = new_solution.copy()\n            swap_indices = np.random.choice(n, 2, replace=False)\n            temp_solution[swap_indices[0]], temp_solution[swap_indices[1]] = temp_solution[swap_indices[1]], temp_solution[swap_indices[0]]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6931326936514675,
            0.323350727558136
        ],
        "raw_score": [
            8.100953599695607,
            7.035397181523006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution based on balanced objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1.0 / (normalized_obj[:, 0] * normalized_obj[:, 1] + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search with dynamic segment size\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Probabilistic node swapping\n        if np.random.random() < 0.5:\n            new_solution[start:end] = np.random.permutation(new_solution[start:end])\n        else:\n            # Constrained edge reinsertion\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.arange(start, end))\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Adaptive feasibility repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(3):\n            temp_solution = new_solution.copy()\n            swap_indices = np.random.choice(n, 2, replace=False)\n            temp_solution[swap_indices[0]], temp_solution[swap_indices[1]] = temp_solution[swap_indices[1]], temp_solution[swap_indices[0]]\n\n            if len(np.unique(temp_solution)) == n:\n                old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or np.random.random() < 0.2:\n                    new_solution = temp_solution\n                    break\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    }
]