[
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n\n    # Hybrid local search: edge swap + segment reversal\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge swap (2-opt-like)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment reversal (novel operator)\n        if b - a > 2:\n            c = np.random.randint(a+1, b)\n            new_solution[a:c] = new_solution[a:c][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            5.692783799934242,
            6.250821588805908
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice favoring lower objectives\n    weights = np.array([1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with multi-objective segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for trivial cases\n\n    # Step 1: Random edge swap (2-opt-like but with objective-aware selection)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1  # Ensure we don't create a degenerate tour\n\n    # Evaluate the swap in both objectives\n    def evaluate_swap(sol, i, j):\n        pre_i = sol[i-1] if i > 0 else sol[-1]\n        post_i = sol[i+1] if i < n-1 else sol[0]\n        pre_j = sol[j-1] if j > 0 else sol[-1]\n        post_j = sol[j+1] if j < n-1 else sol[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n        # New edges after swap\n        new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n        return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n    delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n    # Accept the swap if it improves at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n    else:\n        # Step 2: Multi-objective segment inversion (novel operator)\n        # Select a segment based on objective diversity\n        segment_size = min(3, n // 2)\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            # Original edges\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            # New edges after inversion\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        inv_delta1, inv_delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        # Accept inversion if it improves both objectives or one significantly\n        if (inv_delta1 < 0 and inv_delta2 < 0) or (inv_delta1 < -0.1 * delta1 or inv_delta2 < -0.1 * delta2):\n            new_solution[start:start+segment_size] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.350686397753774,
            6.472525333812347
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random selection based on normalized objective values, favoring solutions with balanced objectives, then applies a multi-segment inversion operator with adaptive segment sizes determined by the potential improvement in both objective spaces. The operator iteratively inverts segments of the tour to reduce costs in both spaces while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = 1 / (1 + np.sum(normalized, axis=1))  # Prefer solutions with balanced objectives\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Multi-segment inversion with adaptive segment sizes\n    for _ in range(5):  # Reduced iterations for computational efficiency\n        # Determine segment sizes based on objective improvement potential\n        segments = []\n        for _ in range(3):  # Generate 3 candidate segments\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[a:b]\n            # Calculate objective improvement if inverted\n            original_cost = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))) + \\\n                           sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n            inverted_cost = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + \\\n                           sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segments.append((a, b, original_cost - inverted_cost))\n\n        # Select segment with highest improvement potential\n        segments.sort(key=lambda x: x[2], reverse=True)\n        a, b, _ = segments[0]\n\n        # Apply inversion\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Feasibility check\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            6.617105714349662,
            6.555918881687816
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive by prioritizing those with lower objective values, then applies a hybrid local search combining 3-opt and edge insertion to explore diverse neighborhoods while ensuring feasibility. The algorithm favors solutions with better combined objectives and uses weighted random selection to balance exploration and exploitation. The local search modifies the tour by reversing segments and reinserting nodes, promoting diversity in the neighborhood.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct edges to modify\n    edges = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(edges)\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Edge insertion: randomly remove a node and reinsert it\n    remove_pos = np.random.randint(0, n)\n    node_to_insert = new_solution[remove_pos]\n    new_solution = np.delete(new_solution, remove_pos)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.898571945341784,
            6.675233968408497
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random selection based on the inverse of the sum of objectives (prioritizing solutions with lower total cost), then applies a modified 3-opt local search by randomly selecting three edges, rearranging segments in a non-standard way (either keeping or reversing one segment), and ensuring the solution remains valid (no duplicates). This hybrid approach combines probabilistic selection with a creative edge-recombination strategy to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Randomly select a solution with probability proportional to its Pareto dominance\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Simple heuristic\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (modified 3-opt with adaptive edge selection)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    edges = np.random.choice(n, size=3, replace=False)\n    edges.sort()\n\n    # Extract the three segments\n    a, b, c = edges\n    seg1 = new_solution[:a]\n    seg2 = new_solution[a:b]\n    seg3 = new_solution[b:c]\n    seg4 = new_solution[c:]\n\n    # Recombine segments in a new order (modified 3-opt)\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([seg1, seg3, seg2, seg4])\n    else:\n        new_order = np.concatenate([seg1, seg3[::-1], seg2, seg4])\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    return new_solution\n\n",
        "score": [
            6.737422017237954,
            6.81557627061559
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high objective diversity, then applies a hybrid local search combining adaptive segment inversions guided by objective gradients, ensuring feasibility through permutation checks and dynamic segment size adjustments. It prioritizes segments with higher cumulative cost for inversion and occasionally expands segment sizes to explore larger neighborhoods, with a 30% chance of expanding segments to balance exploration and exploitation. The solution remains feasible by verifying unique node visits after each operation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(norm_objectives, axis=1)\n    weights = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search with adaptive segment inversion\n    for _ in range(10):\n        # Randomly select segments\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Compute objective gradients for segments\n        def compute_segment_cost(sol, start, end):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            return cost1, cost2\n\n        seg1_cost = compute_segment_cost(new_solution, a, b)\n        seg2_cost = compute_segment_cost(new_solution, c, d)\n\n        # Invert the segment with higher cost\n        if sum(seg1_cost) > sum(seg2_cost):\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Adaptive segment size adjustment\n        if np.random.rand() < 0.3:  # 30% chance to expand segments\n            new_a = max(0, a - np.random.randint(1, 3))\n            new_b = min(n, b + np.random.randint(1, 3))\n            new_solution[new_a:new_b] = new_solution[new_a:new_b][::-1]\n\n        # Feasibility check\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            6.723299197151084,
            7.199738638153561
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high objective diversity using a novel selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)  # Range of objectives\n    weights = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 2: Multi-objective adaptive segment insertion (novel operator)\n    # Select two non-overlapping segments based on objective gradients\n    segment_size = max(2, n // 4)\n    start1, start2 = np.random.choice(n - segment_size, 2, replace=False)\n    if start1 > start2:\n        start1, start2 = start2, start1\n\n    segment1 = new_solution[start1:start1+segment_size]\n    segment2 = new_solution[start2:start2+segment_size]\n\n    # Evaluate segments in both objectives\n    def evaluate_segment(sol, start, size):\n        pre = sol[start-1] if start > 0 else sol[-1]\n        post = sol[start+size] if start+size < n else sol[0]\n        cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n        cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n        return (cost1, cost2)\n\n    cost1_seg1, cost2_seg1 = evaluate_segment(new_solution, start1, segment_size)\n    cost1_seg2, cost2_seg2 = evaluate_segment(new_solution, start2, segment_size)\n\n    # Insert the better segment into the position of the worse one\n    if (cost1_seg1 + cost2_seg1) > (cost1_seg2 + cost2_seg2):\n        # Remove segment1 and insert segment2 at its position\n        new_solution = np.concatenate([\n            new_solution[:start1],\n            segment2,\n            new_solution[start1+segment_size:]\n        ])\n        # Adjust indices for insertion\n        if start2 > start1:\n            start2 += segment_size - len(segment2)\n        # Insert segment1 at segment2's original position\n        new_solution = np.concatenate([\n            new_solution[:start2],\n            segment1,\n            new_solution[start2+segment_size:]\n        ])\n    else:\n        # Remove segment2 and insert segment1 at its position\n        new_solution = np.concatenate([\n            new_solution[:start2],\n            segment1,\n            new_solution[start2+segment_size:]\n        ])\n        # Adjust indices for insertion\n        if start1 > start2:\n            start1 += segment_size - len(segment1)\n        # Insert segment2 at segment1's original position\n        new_solution = np.concatenate([\n            new_solution[:start1],\n            segment2,\n            new_solution[start1+segment_size:]\n        ])\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Repair by reinserting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Trim to original length\n        return new_solution\n\n",
        "score": [
            7.75570708012035,
            7.18155875665307
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower objective values preferred)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt + segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments are distinct\n    if a == c and b == d:\n        return new_solution\n\n    # Apply 2-opt between segments\n    if a < c and b < d:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Apply segment inversion\n    elif a < c and c < b and b < d:\n        new_solution[a:c] = new_solution[a:c][::-1]\n        new_solution[b:d] = new_solution[b:d][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.174185419602587,
            7.513302776359469
        ]
    }
]