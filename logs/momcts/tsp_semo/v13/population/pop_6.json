[
    {
        "algorithm": "The algorithm selects the solution with the lowest combined cost from the archive, then applies a hybrid local search combining segment reversal and edge swaps to generate a new neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses novel segment reversal to explore the solution space beyond standard edge swaps. The selection and operators ensure valid tours by maintaining node uniqueness and completeness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal (novel operator)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a random edge swap (standard operator)\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9453093012944958,
            0.1820637583732605
        ],
        "raw_score": [
            6.180186675512935,
            6.63654462139858
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (favoring lower-cost solutions but allowing some diversity) and applies a cross-segment swap operator, randomly exchanging two non-overlapping segments of the tour to generate a neighbor solution while ensuring feasibility. The selection prioritizes exploitation of good solutions but balances it with exploration by occasionally choosing from the middle of the archive. The cross-segment swap is a novel local search operator that disrupts larger tour structures compared to standard edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_threshold = min(2 * len(sorted_archive) // 3, len(sorted_archive) - 1)\n    selected_solution = random.choice(sorted_archive[:selection_threshold])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-segment swap: select two non-overlapping segments and swap them\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create new solution by swapping segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end+1:seg2_start],\n        seg1,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.837455409186324,
            0.1816069483757019
        ],
        "raw_score": [
            6.500691332763455,
            6.600301261577352
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a random solution from the archive, applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor, and ensures feasibility by checking for duplicates. The algorithm prioritizes diversity and non-dominance implicitly by random selection, while the local search explores the solution space creatively by reversing segments and reinserting edges at random positions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_end = (edge_start + 1) % n\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[edge_end]\n\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:edge_start], new_solution[edge_end+1:]])\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node1)\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node2)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8700755886195684,
            0.21495270729064941
        ],
        "raw_score": [
            7.227454476992637,
            6.950987236943185
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top third of the archive (sorted by combined objective cost), then applies a hybrid local search: either randomly reinserting an edge or reversing a segment of the tour, ensuring feasibility by maintaining a valid TSP path. The selection prioritizes solutions with lower total cost, while the local search explores diverse neighborhood structures to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: randomly choose between edge insertion or segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it in a different position\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7593220728994624,
            0.19668710231781006
        ],
        "raw_score": [
            5.831905830795691,
            5.995319237568243
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the top 20% of the archive (sorted by normalized objective sums) and applies a hybrid local search, randomly choosing between edge swaps (60% probability) and a novel node insertion strategy (40% probability) to generate feasible neighbor solutions. Edge swaps exchange two random edges, while node insertion removes a node and reinserts it at a random position, ensuring tour validity. The selection prioritizes solutions with better combined normalized objectives, while the local search diversifies exploration to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        normalized_archive = archive\n    else:\n        normalized_archive = [(sol, (obj[0]/max_obj1, obj[1]/max_obj2)) for sol, obj in archive]\n    sorted_archive = sorted(normalized_archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge swap or novel node insertion\n    if random.random() < 0.6:\n        # Edge swap: swap two random edges\n        i = random.randint(0, n - 2)\n        j = random.randint(0, n - 2)\n        if i != j:\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n    else:\n        # Novel node insertion: remove a node and insert it in a different position\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.819648273754423,
            0.22441494464874268
        ],
        "raw_score": [
            6.13544825475205,
            6.491666412397946
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high variance in objectives, performs a 3-opt local search with adaptive segment selection (reversing segments with probability based on objective variance), and ensures feasibility by falling back to 2-opt if needed. The selection prioritizes diverse solutions, while the local search adaptively explores neighborhoods to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform 3-opt local search with adaptive segment selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct segments\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Reverse segments with probability based on objective variance\n    obj_var = variances[selected_idx]\n    prob = min(0.8, obj_var / (max(variances) + 1e-6))\n\n    if np.random.rand() < prob:\n        # Reverse segment between a and b\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Reverse segment between b and c\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.736362064959752,
            0.23038655519485474
        ],
        "raw_score": [
            10.748378350680534,
            8.971911085473389
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing low-cost solutions and applies a hybrid local search combining segment reversal (randomly reversing a tour segment) and objective-aware edge swapping (swapping edges while ensuring at least one objective improves, reverting if both worsen significantly). The selection favors solutions with better combined objective values, and the local search balances exploration (segment reversal) and exploitation (edge swapping) to improve the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (low cost and high diversity)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = random.choice(sorted_archive[:max(1, len(sorted_archive) // 3)])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: segment reversal with objective-aware edge swapping\n    if random.random() < 0.5:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware edge swapping: swap edges that improve at least one objective\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a != b:\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[a-1]][new_solution[a]] + distance_matrix_1[new_solution[b-1]][new_solution[b]]\n            old_cost2 = distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]]\n\n            # Swap the edges\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            new_cost1 = distance_matrix_1[new_solution[a-1]][new_solution[a]] + distance_matrix_1[new_solution[b-1]][new_solution[b]]\n            new_cost2 = distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]]\n\n            # Revert if both objectives worsen significantly\n            if (new_cost1 > old_cost1 and new_cost2 > old_cost2) and (new_cost1 > 1.1 * old_cost1 or new_cost2 > 1.1 * old_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8149456813807384,
            0.3695242404937744
        ],
        "raw_score": [
            6.2928063882478416,
            5.604687846887915
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid selection criterion combining Pareto dominance and crowding distance, then applies a novel local search operator that combines node swapping (70% probability) with probabilistic segment inversion (60% probability for inversion when selected). The operator ensures feasibility by maintaining a valid TSP tour structure, with adaptive segment lengths for inversion. The selection prioritizes solutions with higher crowding distance, while the local search balances exploration (node swapping) and exploitation (segment inversion) for multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def is_dominated(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    def crowding_distance(solutions):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        fronts = []\n        for s in solutions:\n            dominated = False\n            for f in fronts:\n                if is_dominated(s[1], f[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                fronts.append(s)\n        if not fronts:\n            return [1.0] * len(solutions)\n        distances = [0.0] * len(fronts)\n        for i in range(len(fronts[0][1])):\n            fronts.sort(key=lambda x: x[1][i])\n            distances[0] = distances[-1] = float('inf')\n            for j in range(1, len(fronts)-1):\n                distances[j] += (fronts[j+1][1][i] - fronts[j-1][1][i]) / (fronts[-1][1][i] - fronts[0][1][i] + 1e-10)\n        return distances\n\n    solutions = [(s[0], s[1]) for s in archive]\n    distances = crowding_distance(solutions)\n    selected_idx = np.argmax(distances)\n    selected_solution = solutions[selected_idx][0].copy()\n\n    # Novel local search operator: combined node swapping with probabilistic segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:  # Higher probability for node swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Probabilistic segment inversion with adaptive length\n        seg_length = min(3, n-1) if n < 6 else random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n        if random.random() < 0.6:  # Higher probability for inversion\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7664847145344611,
            0.31943249702453613
        ],
        "raw_score": [
            8.825979525406362,
            8.730047566640955
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with high crowding distance, then applies a novel 3-opt* local search that randomly breaks the tour into segments and intelligently reconnects them with either reversed or cyclically permuted segments to explore diverse neighborhoods while ensuring feasibility. The selection prioritizes solutions that balance exploration (via crowding distance) and exploitation (via non-dominance), while the local search diversifies the search space beyond standard 2-opt moves by incorporating segment reversal and cyclic permutations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a hybrid selection: prioritize non-dominated solutions with good crowding distance\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] > archive[j][1][1]) or \\\n                   (archive[i][1][0] > archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]):\n                    dominated[i] = True\n                    break\n\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated:\n        non_dominated = range(len(archive))\n\n    # Calculate crowding distance for non-dominated solutions\n    crowding_distances = np.zeros(len(non_dominated))\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort([archive[i][1][m] for i in non_dominated])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            if archive[non_dominated[sorted_idx[i+1]]][1][m] == archive[non_dominated[sorted_idx[i-1]]][1][m]:\n                continue\n            crowding_distances[sorted_idx[i]] += (archive[non_dominated[sorted_idx[i+1]]][1][m] - archive[non_dominated[sorted_idx[i-1]]][1][m]) / \\\n                                                (max(archive[non_dominated[sorted_idx[-1]]][1][m], archive[non_dominated[sorted_idx[0]]][1][m]) - \\\n                                                 min(archive[non_dominated[sorted_idx[-1]]][1][m], archive[non_dominated[sorted_idx[0]]][1][m]))\n\n    # Select solution with highest crowding distance among non-dominated\n    if len(non_dominated) > 1:\n        selected_idx = non_dominated[np.argmax(crowding_distances)]\n    else:\n        selected_idx = non_dominated[0]\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply 3-opt* local search (novel hybrid operator)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to break\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments with novel strategy\n    # Option 1: Reverse middle segment and insert\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    # Option 2: Cyclic permutation of segments\n    else:\n        new_order = np.concatenate([segment1, segment2, segment4, segment3])\n\n    # Ensure solution remains valid (no duplicates)\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7584977375321207,
            0.33584320545196533
        ],
        "raw_score": [
            7.357450376210846,
            7.795799022357624
        ]
    }
]