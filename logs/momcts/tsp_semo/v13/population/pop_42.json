[
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower combined objectives) and applies a dynamic, objective-aware local search combining segment inversions and edge swaps, evaluating improvements in both objectives to ensure feasibility while balancing exploration and exploitation. It adaptively selects segment sizes and accepts inversions or swaps that show significant improvements in either objective, ensuring valid TSP tours through permutation checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size\n    segment_size = max(2, min(5, n // 4))\n\n    # Objective-aware segment inversion\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(3):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # New edges after inversion\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement\n        if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.1 * abs(best_improvement[0]) or delta2 < -0.1 * abs(best_improvement[1])):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, segment_size)\n\n    # Apply the best found inversion\n    if best_segment is not None:\n        start, size = best_segment\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Edge swap with objective awareness\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    # Evaluate swap\n    pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n    pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n    orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n    new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n    new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.80145785411436,
            5.7754796233164205
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower objectives) and applies a hybrid local search combining adaptive segment inversions (with dynamic segment sizes) and edge swaps, evaluating improvements in both objective spaces while ensuring feasibility. It balances exploration/exploitation through adaptive segment sizing and operator selection based on recent performance, favoring operators that improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and recent improvements\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]\n\n    # Hybrid local search with adaptive operator selection\n    for _ in range(2):\n        # Adaptive segment inversion\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))\n            continue\n\n        # Edge swap if inversion didn't help\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        def evaluate_swap(sol, i, j):\n            pre_i = sol[i-1] if i > 0 else sol[-1]\n            post_i = sol[i+1] if i < n-1 else sol[0]\n            pre_j = sol[j-1] if j > 0 else sol[-1]\n            post_j = sol[j+1] if j < n-1 else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n            orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n            new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n            new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n\n    return new_solution\n\n",
        "score": [
            5.650655791934891,
            5.828830062644275
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding distance, then applies a hybrid local search combining adaptive partial permutations and dynamic node reinsertions. It prioritizes balanced improvements in both objectives by evaluating segment flips and node insertions based on their combined cost reduction, while maintaining feasibility through permutation validation and insertion point selection. The segment size and number of iterations are dynamically adjusted to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance to select a diverse solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on historical improvements\n    segment_size = max(2, min(n // 2, 5))\n\n    # Objective-aware partial permutation with dynamic segment size\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Evaluate partial permutation\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[end] if end < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, new_solution[start]] + distance_matrix_1[new_solution[end-1], post]\n        orig_cost2 = distance_matrix_2[pre, new_solution[start]] + distance_matrix_2[new_solution[end-1], post]\n\n        # New edges after partial permutation\n        new_cost1 = distance_matrix_1[pre, new_solution[end-1]] + distance_matrix_1[new_solution[start], post]\n        new_cost2 = distance_matrix_2[pre, new_solution[end-1]] + distance_matrix_2[new_solution[start], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement (prioritize balanced improvements)\n        if (delta1 < 0 and delta2 < 0) or (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, end)\n\n    # Apply the best found partial permutation\n    if best_segment is not None:\n        start, end = best_segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node reinsertion based on improvement history\n    for _ in range(2):\n        remove_pos = np.random.randint(0, n)\n        node_to_insert = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Find best insertion point considering both objectives\n        best_insert_pos = -1\n        best_insert_cost = (np.inf, np.inf)\n\n        for i in range(n-1):\n            pre = new_solution[i-1] if i > 0 else new_solution[-1]\n            post = new_solution[i]\n\n            cost1 = distance_matrix_1[pre, node_to_insert] + distance_matrix_1[node_to_insert, post] - distance_matrix_1[pre, post]\n            cost2 = distance_matrix_2[pre, node_to_insert] + distance_matrix_2[node_to_insert, post] - distance_matrix_2[pre, post]\n\n            if (cost1 + cost2 < best_insert_cost[0] + best_insert_cost[1]) or (cost1 < 0 and cost2 < 0):\n                best_insert_pos = i\n                best_insert_cost = (cost1, cost2)\n\n        if best_insert_pos != -1:\n            new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.942471123541795,
            5.451263069957333
        ]
    },
    {
        "algorithm": "The algorithm selects a solution with the highest crowding distance from the archive, then applies a hybrid local search combining adaptive edge swaps (prioritizing weighted improvements) and dynamic node relocations (using a weighted cost function with 60% emphasis on the first objective and 40% on the second). It ensures feasibility through permutation validation and validates the solution before returning it.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance to select a diverse solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive edge swap with weighted cost function\n    best_improvement = (0, 0)\n    best_swap = None\n\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Original edges\n        pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[i], post_i] + distance_matrix_1[pre_j, new_solution[j]] + distance_matrix_1[new_solution[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[i], post_i] + distance_matrix_2[pre_j, new_solution[j]] + distance_matrix_2[new_solution[j], post_j]\n\n        # New edges after swap\n        new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[j], post_i] + distance_matrix_1[pre_j, new_solution[i]] + distance_matrix_1[new_solution[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[j], post_i] + distance_matrix_2[pre_j, new_solution[i]] + distance_matrix_2[new_solution[i], post_j]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Weighted improvement metric\n        weighted_improvement = 0.6 * delta1 + 0.4 * delta2\n\n        if weighted_improvement < best_improvement[0] + best_improvement[1]:\n            best_improvement = (delta1, delta2)\n            best_swap = (i, j)\n\n    # Apply the best found swap\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic node relocation based on weighted cost\n    for _ in range(3):\n        remove_pos = np.random.randint(0, n)\n        node_to_insert = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Find best insertion point considering weighted cost\n        best_insert_pos = -1\n        best_weighted_cost = np.inf\n\n        for i in range(n-1):\n            pre = new_solution[i-1] if i > 0 else new_solution[-1]\n            post = new_solution[i]\n\n            cost1 = distance_matrix_1[pre, node_to_insert] + distance_matrix_1[node_to_insert, post] - distance_matrix_1[pre, post]\n            cost2 = distance_matrix_2[pre, node_to_insert] + distance_matrix_2[node_to_insert, post] - distance_matrix_2[pre, post]\n\n            weighted_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if weighted_cost < best_weighted_cost:\n                best_insert_pos = i\n                best_weighted_cost = weighted_cost\n\n        if best_insert_pos != -1:\n            new_solution = np.insert(new_solution, best_insert_pos, node_to_insert)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.515656602499867,
            7.647935406704582
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding distance, then applies a hybrid local search combining objective-aware edge swaps and dynamic segment inversions, with segment sizes adjusted based on historical improvement rates to balance exploration and exploitation while maintaining feasibility. Edge swaps prioritize simultaneous improvements in both objectives, while dynamic segment inversion adapts to past performance, ensuring valid TSP tours through validation checks. The method balances global and local search by dynamically adjusting exploration intensity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for selection\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n    crowding_distances = np.zeros(n)\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_nodes = len(base_solution)\n    improvement_history = {1: [], 2: []}  # Track improvement rates for each objective\n\n    # Hybrid operator: edge swaps + dynamic segment inversion\n    for _ in range(3):  # Reduced iterations for efficiency\n        # Phase 1: Objective-aware edge swaps\n        best_improvement = 0\n        best_swap = None\n\n        for i in range(n_nodes):\n            for j in range(i+2, n_nodes):\n                if j == (i+1) % n_nodes:\n                    continue\n\n                # Current edges\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n_nodes]\n\n                # Original cost\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                # Swapped cost\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n            # Record improvement\n            improvement_history[1].append(orig_cost1 - new_cost1)\n            improvement_history[2].append(orig_cost2 - new_cost2)\n\n        # Phase 2: Dynamic segment inversion\n        if improvement_history[1] and improvement_history[2]:\n            # Calculate average improvement rates\n            avg_improvement1 = np.mean(improvement_history[1])\n            avg_improvement2 = np.mean(improvement_history[2])\n\n            # Determine segment size inversely proportional to improvement rates\n            segment_size = max(2, min(n_nodes//2, int(1 / (0.1 + avg_improvement1 + avg_improvement2))))\n\n            # Select random segment\n            a = np.random.randint(0, n_nodes - segment_size)\n            b = a + segment_size\n\n            # Invert the segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n_nodes:\n        # Fallback to simple inversion if invalid\n        a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.242994893163757,
            5.674527708525447
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding distance, then applies a hybrid local search combining objective-aware edge swaps and dynamic segment inversions, with segment sizes adjusted based on historical improvement rates to balance exploration and exploitation while maintaining feasibility through validation checks. The method prioritizes solutions with high crowding distances, performs edge swaps to improve both objectives, and dynamically adjusts segment sizes for inversion based on past improvement rates.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for selection\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n    crowding_distances = np.zeros(n)\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_nodes = len(base_solution)\n    improvement_history = {1: [], 2: []}  # Track improvement rates for each objective\n\n    # Hybrid operator: edge swaps + dynamic segment inversion\n    for _ in range(3):\n        # Phase 1: Objective-aware edge swaps\n        best_improvement = (0, 0)\n        best_swap = None\n\n        for i in range(n_nodes):\n            for j in range(i+2, n_nodes):\n                if j == (i+1) % n_nodes:\n                    continue\n\n                # Current edges\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n_nodes]\n\n                # Original cost\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                # Swapped cost\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                delta1 = new_cost1 - orig_cost1\n                delta2 = new_cost2 - orig_cost2\n\n                if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n                    best_improvement = (delta1, delta2)\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n            # Record improvement\n            improvement_history[1].append(best_improvement[0])\n            improvement_history[2].append(best_improvement[1])\n\n        # Phase 2: Dynamic segment inversion\n        if improvement_history[1] and improvement_history[2]:\n            # Calculate average improvement rates\n            avg_improvement1 = np.mean(improvement_history[1])\n            avg_improvement2 = np.mean(improvement_history[2])\n\n            # Determine segment size inversely proportional to improvement rates\n            segment_size = max(2, min(n_nodes//2, int(1 / (0.1 + avg_improvement1 + avg_improvement2))))\n\n            # Select random segment\n            a = np.random.randint(0, n_nodes - segment_size)\n            b = a + segment_size\n\n            # Invert the segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n_nodes:\n        # Fallback to simple inversion if invalid\n        a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.317917230148229,
            5.553051946632512
        ]
    },
    {
        "algorithm": "The algorithm combines crowding-distance-aware selection with a two-phase local search: objective-aware reinsertion (prioritizing balanced improvements in both objectives) followed by dynamic segment inversion (adjusting segment sizes based on historical improvements). It ensures feasibility through validation checks and falls back to the original solution if invalid. The approach balances exploration (reinsertion) and exploitation (dynamic inversion) while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high crowding distance (promising diversity)\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        front = objectives.copy()\n        distances = np.zeros(len(front))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(front[:, m])\n            front = front[sorted_idx]\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(front)-1):\n                distances[sorted_idx[i]] += (front[sorted_idx[i+1], m] - front[sorted_idx[i-1], m]) / (front[-1, m] - front[0, m] + 1e-6)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Objective-aware reinsertion phase\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Extract segment\n        segment = new_solution[i:i+1]\n        remaining = np.delete(new_solution, i)\n\n        # Find best insertion point\n        best_pos = -1\n        best_delta = (float('inf'), float('inf'))\n\n        for pos in range(len(remaining)):\n            candidate = np.insert(remaining, pos, segment[0])\n            delta1 = (distance_matrix_1[candidate[pos-1], candidate[pos]] +\n                      distance_matrix_1[candidate[pos], candidate[(pos+1)%n]]) - \\\n                     (distance_matrix_1[candidate[pos-1], candidate[pos+1]] if pos < len(remaining) else 0)\n            delta2 = (distance_matrix_2[candidate[pos-1], candidate[pos]] +\n                      distance_matrix_2[candidate[pos], candidate[(pos+1)%n]]) - \\\n                     (distance_matrix_2[candidate[pos-1], candidate[pos+1]] if pos < len(remaining) else 0)\n\n            if (delta1 < best_delta[0] and delta2 < best_delta[1]) or \\\n               (delta1 < 0 and delta2 < best_delta[1]) or \\\n               (delta2 < 0 and delta1 < best_delta[0]):\n                best_pos = pos\n                best_delta = (delta1, delta2)\n\n        if best_pos != -1:\n            new_solution = np.insert(remaining, best_pos, segment[0])\n\n    # Dynamic segment inversion phase\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]\n\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.428849168632321,
            7.777106879904732
        ]
    },
    {
        "algorithm": "The algorithm combines crowding-distance-aware selection with a multi-phase hybrid operator: it first performs objective-aware edge swaps targeting both objectives, then dynamically relocates segments based on historical improvement rates, and finally adaptively reinserts nodes prioritizing positions that minimize combined objective costs, while ensuring feasibility through permutation validation. The selection prioritizes solutions with high crowding distances, and the local search phases progressively refine the tour by balancing exploration of both objectives through dynamic operator adjustments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding-distance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (np.max(objectives[:, i]) - np.min(objectives[:, i]) + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Calculate historical improvement rates\n    objective_history = np.array([obj for _, obj in archive])\n    improvement_rates = np.std(objective_history, axis=0)\n\n    # Objective-aware edge swaps\n    for _ in range(max(2, n // 4)):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n        new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_rates[0] and delta2 < -0.1 * improvement_rates[1]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment relocation\n    segment_size = max(3, min(7, n // 3))\n    segment_size = max(2, int(segment_size * (1 / (1 + improvement_rates[0]) + 1 / (1 + improvement_rates[1]))))\n\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    pre_orig = new_solution[start-1] if start > 0 else new_solution[-1]\n    post_orig = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_orig, segment[0]] + distance_matrix_1[segment[-1], post_orig]\n    orig_cost2 = distance_matrix_2[pre_orig, segment[0]] + distance_matrix_2[segment[-1], post_orig]\n\n    new_pos = np.random.randint(0, n - segment_size)\n    if new_pos == start:\n        new_pos = (new_pos + segment_size) % (n - segment_size)\n\n    pre_new = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n    post_new = new_solution[new_pos] if new_pos < n-segment_size else new_solution[0]\n\n    new_cost1 = distance_matrix_1[pre_new, segment[0]] + distance_matrix_1[segment[-1], post_new]\n    new_cost2 = distance_matrix_2[pre_new, segment[0]] + distance_matrix_2[segment[-1], post_new]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_rates[0] and delta2 < -0.1 * improvement_rates[1]):\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Adaptive node reinsertion\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n\n    if node_pos == 0:\n        new_solution = np.concatenate([new_solution[1:], [node]])\n    else:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(n-1):\n        pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        post = new_solution[pos]\n\n        cost1 = distance_matrix_1[pre, node] + distance_matrix_1[node, post] - distance_matrix_1[pre, post]\n        cost2 = distance_matrix_2[pre, node] + distance_matrix_2[node, post] - distance_matrix_2[pre, post]\n\n        combined_cost = cost1 + cost2\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.599360067497951,
            5.46212053483933
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n\n    # Hybrid local search: edge swap + segment reversal\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge swap (2-opt-like)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment reversal (novel operator)\n        if b - a > 2:\n            c = np.random.randint(a+1, b)\n            new_solution[a:c] = new_solution[a:c][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            5.692783799934242,
            6.250821588805908
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions from the archive using normalized objective values, then applies a hybrid local search with adaptive segment reversals, dynamic edge swaps, and probabilistic node reinsertions, adjusting segment sizes and swap probabilities based on historical improvement rates while ensuring feasibility through permutation validation. The method prioritizes solutions with balanced objectives and dynamically refines search parameters to improve tour quality across both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = np.sum(normalized, axis=1) / (np.sum(normalized) + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    improvement_history = []\n    max_history = 5\n\n    def adaptive_size(current_size, improvement_rate):\n        if improvement_rate > 0.7:\n            return min(current_size + 1, n // 2)\n        elif improvement_rate < 0.3:\n            return max(current_size - 1, 2)\n        return current_size\n\n    phases = [\n        ('segment_reversal', max(4, n // 3)),\n        ('dynamic_swap', 2),\n        ('probabilistic_reinsertion', max(1, n // 5))\n    ]\n\n    for phase, size in phases:\n        if phase == 'segment_reversal':\n            improvement_rate = np.mean(improvement_history[-max_history:]) if improvement_history else 0.5\n            size = adaptive_size(size, improvement_rate)\n            start = np.random.randint(0, n - size)\n            segment = new_solution[start:start+size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+size] if start+size < n else new_solution[0]\n\n            orig_cost = (distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post] +\n                         distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post])\n            new_cost = (distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post] +\n                        distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post])\n\n            if new_cost < orig_cost * 0.9:\n                new_solution[start:start+size] = new_solution[start:start+size][::-1]\n                improvement_history.append(1)\n            else:\n                improvement_history.append(0)\n\n        elif phase == 'dynamic_swap':\n            for _ in range(size):\n                i, j = np.random.choice(n, 2, replace=False)\n                pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n                post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n                pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n                post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n                orig_cost = (distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j] +\n                             distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j])\n                new_cost = (distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j] +\n                            distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j])\n\n                if new_cost < orig_cost * 0.95:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 'probabilistic_reinsertion':\n            for _ in range(size):\n                node_pos = np.random.randint(0, n)\n                node = new_solution[node_pos]\n\n                if node_pos == 0:\n                    new_solution = np.concatenate([new_solution[1:], [node]])\n                else:\n                    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n                best_pos = 0\n                best_cost = float('inf')\n\n                for pos in range(n-1):\n                    pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                    post = new_solution[pos]\n\n                    cost = (distance_matrix_1[pre, node] + distance_matrix_1[node, post] -\n                            distance_matrix_1[pre, post] +\n                            distance_matrix_2[pre, node] + distance_matrix_2[node, post] -\n                            distance_matrix_2[pre, post])\n\n                    if cost < best_cost and np.random.random() < 0.7:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.520534700023768,
            5.715891452346204
        ]
    }
]