[
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n\n    # Hybrid local search: edge swap + segment reversal\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge swap (2-opt-like)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment reversal (novel operator)\n        if b - a > 2:\n            c = np.random.randint(a+1, b)\n            new_solution[a:c] = new_solution[a:c][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            5.692783799934242,
            6.250821588805908
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower combined objectives) and applies a dynamic, objective-aware local search combining segment inversions and edge swaps, evaluating improvements in both objectives to ensure feasibility while balancing exploration and exploitation. It adaptively selects segment sizes and accepts inversions or swaps that show significant improvements in either objective, ensuring valid TSP tours through permutation checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size\n    segment_size = max(2, min(5, n // 4))\n\n    # Objective-aware segment inversion\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(3):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # New edges after inversion\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement\n        if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.1 * abs(best_improvement[0]) or delta2 < -0.1 * abs(best_improvement[1])):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, segment_size)\n\n    # Apply the best found inversion\n    if best_segment is not None:\n        start, size = best_segment\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Edge swap with objective awareness\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    # Evaluate swap\n    pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n    pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n    orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n    new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n    new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.80145785411436,
            5.7754796233164205
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions from the archive using objective balance scores, then applies a multi-phase perturbation strategy combining large-scale segment inversions, fine-grained edge swaps, and adaptive node reinsertions, prioritizing cost reduction in both objective spaces while ensuring feasibility through permutation validation. It dynamically adjusts operator sizes based on problem scale and includes a fallback mechanism for invalid permutations. The approach balances exploration (via randomness) and exploitation (via cost-based acceptance) to navigate the multi-objective search space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = 1 / (1 + np.sum(normalized, axis=1))\n    selected_idx = np.random.choice(len(archive), p=balance_scores/np.sum(balance_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-phase perturbation strategy\n    phases = [\n        ('inversion', max(2, min(5, n // 3))),\n        ('swap', 2),\n        ('reinsertion', max(1, n // 5))\n    ]\n\n    for phase, size in phases:\n        if phase == 'inversion':\n            # Large-scale segment inversion\n            start = np.random.randint(0, n - size)\n            segment = new_solution[start:start+size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+size] if start+size < n else new_solution[0]\n\n            orig_cost = (distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post] +\n                         distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post])\n            new_cost = (distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post] +\n                        distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post])\n\n            if new_cost < orig_cost:\n                new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n        elif phase == 'swap':\n            # Fine-grained edge swap\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i == j:\n                continue\n\n            pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            orig_cost = (distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j] +\n                         distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j])\n            new_cost = (distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j] +\n                        distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j])\n\n            if new_cost < orig_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 'reinsertion':\n            # Adaptive node reinsertion\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n\n            # Remove node\n            if node_pos == 0:\n                new_solution = np.concatenate([new_solution[1:], [node]])\n            else:\n                new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n            # Reinsert at best position\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                post = new_solution[pos]\n\n                cost = (distance_matrix_1[pre, node] + distance_matrix_1[node, post] -\n                        distance_matrix_1[pre, post] +\n                        distance_matrix_2[pre, node] + distance_matrix_2[node, post] -\n                        distance_matrix_2[pre, post])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if permutation is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.794191786896182,
            6.215533785519753
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using weighted random selection based on combined objectives, then applies a hybrid local search alternating between adaptive segment inversions (with dynamically adjusted segment sizes) and edge swaps to generate a neighbor solution, prioritizing operators that improve both objectives while maintaining feasibility. The segment size adapts based on problem size and recent improvements, and the algorithm tracks improvements to further refine the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on combined objectives\n    weights = np.array([1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and recent improvements\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]  # Track recent improvements in both objectives\n\n    # Hybrid local search\n    for _ in range(2):  # Alternate between operators\n        # Adaptive segment inversion\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))  # Adjust segment size\n            continue\n\n        # Edge swap if inversion didn't help\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        def evaluate_swap(sol, i, j):\n            pre_i = sol[i-1] if i > 0 else sol[-1]\n            post_i = sol[i+1] if i < n-1 else sol[0]\n            pre_j = sol[j-1] if j > 0 else sol[-1]\n            post_j = sol[j+1] if j < n-1 else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n            orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n            new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n            new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n\n    return new_solution\n\n",
        "score": [
            6.352968607347413,
            5.926654127021358
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive segment inversions and objective-aware edge swaps, dynamically adjusting segment sizes and prioritizing balanced improvements in both objectives while ensuring feasibility through permutation validation checks. It first selects a solution with lower objectives, then performs multiple segment inversions and edge swaps, accepting changes that improve either objective or show significant relative improvements, with fallback to the original solution if feasibility is violated. The segment size is dynamically determined based on problem size, and improvements are prioritized when they benefit both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: (sum(x[1]), max(x[1])))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.6, 0.3, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and objective diversity\n    segment_size = max(2, min(6, n // 3))\n\n    # Multi-objective adaptive segment inversion\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(5):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # New edges after inversion\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement (prioritize balanced improvements)\n        if (delta1 < 0 and delta2 < 0) or (delta1 < best_improvement[0] and delta2 < best_improvement[1]):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, segment_size)\n\n    # Apply the best found inversion\n    if best_segment is not None:\n        start, size = best_segment\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Objective-aware edge swap with dynamic selection\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        # Evaluate swap\n        pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n        new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Accept if improves either objective significantly\n        if (delta1 < 0 or delta2 < 0) or (delta1 < -0.05 * abs(orig_cost1) or delta2 < -0.05 * abs(orig_cost2)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.815343913824185,
            6.1389347284360785
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive segment selection with multi-objective-aware insertion heuristics, dynamically adjusting segment sizes based on improvement potential and strategically placing segments to simultaneously improve both objectives by analyzing trade-offs between distance matrices, while ensuring feasibility through permutation checks. It prioritizes solutions near the Pareto front and uses a weighted acceptance criterion to balance improvements in both objectives, with segment sizes adjusted based on recent performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with adaptive weighting favoring solutions near the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        pareto_front = []\n        for i, obj in enumerate(objectives):\n            dominated = False\n            for other in objectives:\n                if np.all(other <= obj) and np.any(other < obj):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(i)\n        if pareto_front:\n            selected_idx = np.random.choice(pareto_front)\n        else:\n            selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on recent improvements\n    segment_size = min(3, max(2, n // 5))\n    max_attempts = 5\n    best_delta1, best_delta2 = 0, 0\n    best_solution = new_solution.copy()\n\n    for attempt in range(max_attempts):\n        # Select random segment\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate segment removal\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # Find best insertion point for objective-balanced placement\n        best_pos = -1\n        best_value = float('inf')\n\n        for pos in range(n - segment_size + 1):\n            if pos >= start and pos <= start + segment_size - 1:\n                continue  # Skip current position\n\n            pre_new = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            post_new = new_solution[pos] if pos < n else new_solution[0]\n\n            # Calculate new costs\n            new_cost1 = distance_matrix_1[pre_new, segment[0]] + distance_matrix_1[segment[-1], post_new]\n            new_cost2 = distance_matrix_2[pre_new, segment[0]] + distance_matrix_2[segment[-1], post_new]\n\n            # Objective-balanced insertion evaluation\n            delta1 = new_cost1 - orig_cost1\n            delta2 = new_cost2 - orig_cost2\n            value = delta1 + delta2  # Simple sum for balanced improvement\n\n            if value < best_value:\n                best_value = value\n                best_pos = pos\n\n        if best_pos != -1 and best_value < -0.1 * (best_delta1 + best_delta2):\n            # Apply the insertion\n            temp_solution = np.delete(new_solution, slice(start, start+segment_size))\n            temp_solution = np.insert(temp_solution, best_pos, segment)\n\n            # Verify validity\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution.copy()\n                best_delta1, best_delta2 = best_value, best_value\n                best_solution = new_solution.copy()\n\n        # Adjust segment size based on recent improvements\n        if attempt > 0 and best_value >= 0:\n            segment_size = max(2, segment_size - 1)\n\n    return best_solution\n\n",
        "score": [
            6.541822262107865,
            6.0985840420962125
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice favoring lower objectives\n    weights = np.array([1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with multi-objective segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for trivial cases\n\n    # Step 1: Random edge swap (2-opt-like but with objective-aware selection)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1  # Ensure we don't create a degenerate tour\n\n    # Evaluate the swap in both objectives\n    def evaluate_swap(sol, i, j):\n        pre_i = sol[i-1] if i > 0 else sol[-1]\n        post_i = sol[i+1] if i < n-1 else sol[0]\n        pre_j = sol[j-1] if j > 0 else sol[-1]\n        post_j = sol[j+1] if j < n-1 else sol[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n        # New edges after swap\n        new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n        return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n    delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n    # Accept the swap if it improves at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n    else:\n        # Step 2: Multi-objective segment inversion (novel operator)\n        # Select a segment based on objective diversity\n        segment_size = min(3, n // 2)\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            # Original edges\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            # New edges after inversion\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        inv_delta1, inv_delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        # Accept inversion if it improves both objectives or one significantly\n        if (inv_delta1 < 0 and inv_delta2 < 0) or (inv_delta1 < -0.1 * delta1 or inv_delta2 < -0.1 * delta2):\n            new_solution[start:start+segment_size] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.350686397753774,
            6.472525333812347
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weighted selection based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1.0 / (1 + norm_obj[:, 0] + norm_obj[:, 1])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and improvement history\n    segment_size = max(2, min(5, n // 4))\n\n    # Hybrid local search: edge swap with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    def evaluate_swap(sol, i, j):\n        pre_i = sol[i-1] if i > 0 else sol[-1]\n        post_i = sol[i+1] if i < n-1 else sol[0]\n        pre_j = sol[j-1] if j > 0 else sol[-1]\n        post_j = sol[j+1] if j < n-1 else sol[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n        new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n        return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n    delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Multi-objective segment inversion with dynamic size adjustment\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        inv_delta1, inv_delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (inv_delta1 < 0 and inv_delta2 < 0) or (inv_delta1 < -0.2 * delta1 or inv_delta2 < -0.2 * delta2):\n            new_solution[start:start+segment_size] = segment[::-1]\n            segment_size = min(segment_size + 1, n // 2)  # Increase segment size if successful\n        else:\n            segment_size = max(2, segment_size - 1)  # Decrease segment size if unsuccessful\n\n    return new_solution\n\n",
        "score": [
            6.2773713446520905,
            6.484180850022769
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on objective diversity, then applies a hybrid local search combining adaptive segment relocations and objective-aware edge swaps. It dynamically adjusts segment sizes based on problem size and objective variance, prioritizing moves that improve at least one objective while ensuring feasibility through permutation checks. The method balances exploration and exploitation by evaluating multiple random segments and adaptively accepting moves that meet relaxed improvement thresholds.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritizing diversity)\n    archive_sorted = sorted(archive, key=lambda x: (sum(x[1]), np.std(x[1])))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)), p=[0.5, 0.3, 0.15, 0.04, 0.01] if len(archive_sorted) >= 5 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on problem size and objective variance\n    segment_size = max(3, min(7, n // 3))\n    objective_variance = np.std([sum(obj) for _, obj in archive])\n    segment_size = max(2, int(segment_size * (1 + 0.2 * objective_variance)))\n\n    # Objective-aware segment relocation\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(5):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate relocation to different position\n        new_pos = np.random.randint(0, n - segment_size)\n        if new_pos == start:\n            continue\n\n        # Original edges\n        pre_orig = new_solution[start-1] if start > 0 else new_solution[-1]\n        post_orig = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # New edges after relocation\n        pre_new = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n        post_new = new_solution[new_pos] if new_pos < n-segment_size else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre_orig, segment[0]] + distance_matrix_1[segment[-1], post_orig]\n        orig_cost2 = distance_matrix_2[pre_orig, segment[0]] + distance_matrix_2[segment[-1], post_orig]\n\n        new_cost1 = distance_matrix_1[pre_new, segment[0]] + distance_matrix_1[segment[-1], post_new]\n        new_cost2 = distance_matrix_2[pre_new, segment[0]] + distance_matrix_2[segment[-1], post_new]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement\n        if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.2 * abs(best_improvement[0]) or delta2 < -0.2 * abs(best_improvement[1])):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, new_pos, segment_size)\n\n    # Apply the best found relocation\n    if best_segment is not None:\n        start, new_pos, size = best_segment\n        segment = new_solution[start:start+size]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+size:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Objective-aware edge swap with adaptive acceptance\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    # Evaluate swap\n    pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n    pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n    orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n    new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n    new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    # Adaptive acceptance threshold\n    acceptance_threshold = 0.1 * (np.mean([obj[0] for _, obj in archive]) + np.mean([obj[1] for _, obj in archive]))\n    if (delta1 < acceptance_threshold or delta2 < acceptance_threshold) and (delta1 < 0 or delta2 < 0):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.492833289628182,
            6.195740167692045
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random selection based on normalized objective values, favoring solutions with balanced objectives, then applies a multi-segment inversion operator with adaptive segment sizes determined by the potential improvement in both objective spaces. The operator iteratively inverts segments of the tour to reduce costs in both spaces while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = 1 / (1 + np.sum(normalized, axis=1))  # Prefer solutions with balanced objectives\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Multi-segment inversion with adaptive segment sizes\n    for _ in range(5):  # Reduced iterations for computational efficiency\n        # Determine segment sizes based on objective improvement potential\n        segments = []\n        for _ in range(3):  # Generate 3 candidate segments\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[a:b]\n            # Calculate objective improvement if inverted\n            original_cost = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))) + \\\n                           sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n            inverted_cost = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + \\\n                           sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segments.append((a, b, original_cost - inverted_cost))\n\n        # Select segment with highest improvement potential\n        segments.sort(key=lambda x: x[2], reverse=True)\n        a, b, _ = segments[0]\n\n        # Apply inversion\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Feasibility check\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            6.617105714349662,
            6.555918881687816
        ]
    }
]