[
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower combined objectives) and applies a dynamic, objective-aware local search combining segment inversions and edge swaps, evaluating improvements in both objectives to ensure feasibility while balancing exploration and exploitation. It adaptively selects segment sizes and accepts inversions or swaps that show significant improvements in either objective, ensuring valid TSP tours through permutation checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size\n    segment_size = max(2, min(5, n // 4))\n\n    # Objective-aware segment inversion\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(3):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # New edges after inversion\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement\n        if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.1 * abs(best_improvement[0]) or delta2 < -0.1 * abs(best_improvement[1])):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, segment_size)\n\n    # Apply the best found inversion\n    if best_segment is not None:\n        start, size = best_segment\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Edge swap with objective awareness\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    # Evaluate swap\n    pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n    pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n    orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n    new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n    new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.80145785411436,
            5.7754796233164205
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower objectives) and applies a hybrid local search combining adaptive segment inversions (with dynamic segment sizes) and edge swaps, evaluating improvements in both objective spaces while ensuring feasibility. It balances exploration/exploitation through adaptive segment sizing and operator selection based on recent performance, favoring operators that improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and recent improvements\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]\n\n    # Hybrid local search with adaptive operator selection\n    for _ in range(2):\n        # Adaptive segment inversion\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))\n            continue\n\n        # Edge swap if inversion didn't help\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        def evaluate_swap(sol, i, j):\n            pre_i = sol[i-1] if i > 0 else sol[-1]\n            post_i = sol[i+1] if i < n-1 else sol[0]\n            pre_j = sol[j-1] if j > 0 else sol[-1]\n            post_j = sol[j+1] if j < n-1 else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n            orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n            new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n            new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n\n    return new_solution\n\n",
        "score": [
            5.650655791934891,
            5.828830062644275
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions from the archive using normalized objective values, then applies a hybrid local search with adaptive segment reversals, dynamic edge swaps, and probabilistic node reinsertions, adjusting segment sizes and swap probabilities based on historical improvement rates while ensuring feasibility through permutation validation. The method prioritizes solutions with balanced objectives and dynamically refines search parameters to improve tour quality across both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = np.sum(normalized, axis=1) / (np.sum(normalized) + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    improvement_history = []\n    max_history = 5\n\n    def adaptive_size(current_size, improvement_rate):\n        if improvement_rate > 0.7:\n            return min(current_size + 1, n // 2)\n        elif improvement_rate < 0.3:\n            return max(current_size - 1, 2)\n        return current_size\n\n    phases = [\n        ('segment_reversal', max(4, n // 3)),\n        ('dynamic_swap', 2),\n        ('probabilistic_reinsertion', max(1, n // 5))\n    ]\n\n    for phase, size in phases:\n        if phase == 'segment_reversal':\n            improvement_rate = np.mean(improvement_history[-max_history:]) if improvement_history else 0.5\n            size = adaptive_size(size, improvement_rate)\n            start = np.random.randint(0, n - size)\n            segment = new_solution[start:start+size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+size] if start+size < n else new_solution[0]\n\n            orig_cost = (distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post] +\n                         distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post])\n            new_cost = (distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post] +\n                        distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post])\n\n            if new_cost < orig_cost * 0.9:\n                new_solution[start:start+size] = new_solution[start:start+size][::-1]\n                improvement_history.append(1)\n            else:\n                improvement_history.append(0)\n\n        elif phase == 'dynamic_swap':\n            for _ in range(size):\n                i, j = np.random.choice(n, 2, replace=False)\n                pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n                post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n                pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n                post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n                orig_cost = (distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j] +\n                             distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j])\n                new_cost = (distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j] +\n                            distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j])\n\n                if new_cost < orig_cost * 0.95:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 'probabilistic_reinsertion':\n            for _ in range(size):\n                node_pos = np.random.randint(0, n)\n                node = new_solution[node_pos]\n\n                if node_pos == 0:\n                    new_solution = np.concatenate([new_solution[1:], [node]])\n                else:\n                    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n                best_pos = 0\n                best_cost = float('inf')\n\n                for pos in range(n-1):\n                    pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                    post = new_solution[pos]\n\n                    cost = (distance_matrix_1[pre, node] + distance_matrix_1[node, post] -\n                            distance_matrix_1[pre, post] +\n                            distance_matrix_2[pre, node] + distance_matrix_2[node, post] -\n                            distance_matrix_2[pre, post])\n\n                    if cost < best_cost and np.random.random() < 0.7:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.520534700023768,
            5.715891452346204
        ]
    },
    {
        "algorithm": "The algorithm implements an adaptive, multi-objective hybrid local search that combines objective-aware segment inversions and dynamic edge swaps, prioritizing solutions with lower combined objectives while ensuring feasibility through permutation checks. It selects promising solutions from the archive based on their combined objective values and applies adaptive segment sizes and operator selection to balance exploration and exploitation. The algorithm evaluates both inversion and swap operations based on their impact on both objectives, accepting improvements for either or both objectives while dynamically adjusting segment sizes based on recent improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and recent improvements\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]\n\n    # Hybrid local search with adaptive operator selection\n    for _ in range(2):\n        # Objective-aware segment inversion\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))\n            continue\n\n        # Dynamic edge swap with objective awareness\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        def evaluate_swap(sol, i, j):\n            pre_i = sol[i-1] if i > 0 else sol[-1]\n            post_i = sol[i+1] if i < n-1 else sol[0]\n            pre_j = sol[j-1] if j > 0 else sol[-1]\n            post_j = sol[j+1] if j < n-1 else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n            orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n            new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n            new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n\n    return new_solution\n\n",
        "score": [
            6.020947409662447,
            5.805900902272896
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n\n    # Hybrid local search: edge swap + segment reversal\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge swap (2-opt-like)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment reversal (novel operator)\n        if b - a > 2:\n            c = np.random.randint(a+1, b)\n            new_solution[a:c] = new_solution[a:c][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            5.692783799934242,
            6.250821588805908
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions from the archive using objective balance scores, then applies a multi-phase perturbation strategy combining large-scale segment inversions, fine-grained edge swaps, and adaptive node reinsertions, prioritizing cost reduction in both objective spaces while ensuring feasibility through permutation validation. It dynamically adjusts operator sizes based on problem scale and includes a fallback mechanism for invalid permutations. The approach balances exploration (via randomness) and exploitation (via cost-based acceptance) to navigate the multi-objective search space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = 1 / (1 + np.sum(normalized, axis=1))\n    selected_idx = np.random.choice(len(archive), p=balance_scores/np.sum(balance_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-phase perturbation strategy\n    phases = [\n        ('inversion', max(2, min(5, n // 3))),\n        ('swap', 2),\n        ('reinsertion', max(1, n // 5))\n    ]\n\n    for phase, size in phases:\n        if phase == 'inversion':\n            # Large-scale segment inversion\n            start = np.random.randint(0, n - size)\n            segment = new_solution[start:start+size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+size] if start+size < n else new_solution[0]\n\n            orig_cost = (distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post] +\n                         distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post])\n            new_cost = (distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post] +\n                        distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post])\n\n            if new_cost < orig_cost:\n                new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n        elif phase == 'swap':\n            # Fine-grained edge swap\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i == j:\n                continue\n\n            pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            orig_cost = (distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j] +\n                         distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j])\n            new_cost = (distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j] +\n                        distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j])\n\n            if new_cost < orig_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 'reinsertion':\n            # Adaptive node reinsertion\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n\n            # Remove node\n            if node_pos == 0:\n                new_solution = np.concatenate([new_solution[1:], [node]])\n            else:\n                new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n            # Reinsert at best position\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                post = new_solution[pos]\n\n                cost = (distance_matrix_1[pre, node] + distance_matrix_1[node, post] -\n                        distance_matrix_1[pre, post] +\n                        distance_matrix_2[pre, node] + distance_matrix_2[node, post] -\n                        distance_matrix_2[pre, post])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if permutation is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.794191786896182,
            6.215533785519753
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive segment inversions and objective-aware edge swaps, dynamically adjusting segment sizes and prioritizing balanced improvements in both objectives while ensuring feasibility through permutation validation checks. It first selects a solution with lower objectives, then performs multiple segment inversions and edge swaps, accepting changes that improve either objective or show significant relative improvements, with fallback to the original solution if feasibility is violated. The segment size is dynamically determined based on problem size, and improvements are prioritized when they benefit both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: (sum(x[1]), max(x[1])))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.6, 0.3, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and objective diversity\n    segment_size = max(2, min(6, n // 3))\n\n    # Multi-objective adaptive segment inversion\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(5):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # New edges after inversion\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement (prioritize balanced improvements)\n        if (delta1 < 0 and delta2 < 0) or (delta1 < best_improvement[0] and delta2 < best_improvement[1]):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, segment_size)\n\n    # Apply the best found inversion\n    if best_segment is not None:\n        start, size = best_segment\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Objective-aware edge swap with dynamic selection\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        # Evaluate swap\n        pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n        new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Accept if improves either objective significantly\n        if (delta1 < 0 or delta2 < 0) or (delta1 < -0.05 * abs(orig_cost1) or delta2 < -0.05 * abs(orig_cost2)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.815343913824185,
            6.1389347284360785
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions from the archive using objective balance scores, then applies a multi-phase perturbation strategy combining adaptive segment inversions, fine-grained edge swaps with objective-aware selection, and dynamic node reinsertions\u2014dynamically adjusting operator sizes based on problem scale while ensuring feasibility through permutation validation. It prioritizes cost reduction in both objectives by favoring inversions and swaps that improve edge connections, and uses reinsertions to fine-tune local arrangements. The solution is validated and corrected if infeasible.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = 1 / (1 + np.sum(normalized, axis=1))\n    selected_idx = np.random.choice(len(archive), p=balance_scores/np.sum(balance_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    phases = [\n        ('inversion', max(3, min(7, n // 2))),\n        ('swap', 3),\n        ('reinsertion', max(2, n // 4))\n    ]\n\n    for phase, size in phases:\n        if phase == 'inversion':\n            start = np.random.randint(0, n - size)\n            segment = new_solution[start:start+size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+size] if start+size < n else new_solution[0]\n\n            orig_cost = (distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post] +\n                         distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post])\n            new_cost = (distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post] +\n                        distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post])\n\n            if new_cost < orig_cost * 0.95:\n                new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n        elif phase == 'swap':\n            candidates = np.random.choice(n, min(size * 2, n), replace=False)\n            for i in candidates:\n                j = np.random.choice(n)\n                if i == j:\n                    continue\n\n                pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n                post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n                pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n                post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n                orig_cost = (distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j] +\n                             distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j])\n                new_cost = (distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j] +\n                            distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j])\n\n                if new_cost < orig_cost * 0.98:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 'reinsertion':\n            for _ in range(size):\n                node_pos = np.random.randint(0, n)\n                node = new_solution[node_pos]\n\n                if node_pos == 0:\n                    new_solution = np.concatenate([new_solution[1:], [node]])\n                else:\n                    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n                best_pos = 0\n                best_cost = float('inf')\n\n                for pos in range(n-1):\n                    pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                    post = new_solution[pos]\n\n                    cost = (distance_matrix_1[pre, node] + distance_matrix_1[node, post] -\n                            distance_matrix_1[pre, post] +\n                            distance_matrix_2[pre, node] + distance_matrix_2[node, post] -\n                            distance_matrix_2[pre, post])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.833899709751081,
            6.113195371843601
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions from the archive (prioritizing those with more balanced objective values) and applies a hybrid local search combining adaptive segment inversions, fine-grained edge swaps, and intelligent node reinsertions. It dynamically adjusts segment sizes and evaluates moves in both objectives, ensuring feasibility through permutation checks and a fallback mechanism. The search balances exploration (random segment/edge selection) with exploitation (objective-aware acceptance) across multiple improvement phases to thoroughly explore the neighborhood while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select balanced solution with objective-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = 1 / (1 + np.sum(normalized, axis=1))\n    selected_idx = np.random.choice(len(archive), p=balance_scores/np.sum(balance_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem scale and past improvements\n    segment_size = max(2, min(5, n // 4))\n\n    # Hybrid local search with multiple improvement phases\n    for phase in range(3):\n        # Phase 1: Adaptive segment inversion\n        best_improvement = (0, 0)\n        best_segment = None\n\n        for _ in range(3):  # Try multiple random segments\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n\n            # Evaluate inversion in both objectives\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n            # Original edges\n            orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n            orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n            # New edges after inversion\n            new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n            new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n            delta1 = new_cost1 - orig_cost1\n            delta2 = new_cost2 - orig_cost2\n\n            # Track best improvement\n            if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.1 * abs(best_improvement[0]) or delta2 < -0.1 * abs(best_improvement[1])):\n                best_improvement = (delta1, delta2)\n                best_segment = (start, segment_size)\n\n        # Apply the best found inversion if beneficial\n        if best_segment is not None and (best_improvement[0] < 0 or best_improvement[1] < 0):\n            start, size = best_segment\n            new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n        # Phase 2: Fine-grained edge swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        # Evaluate swap in both objectives\n        pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n        new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Phase 3: Intelligent node reinsertion\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Remove node\n        if node_pos == 0:\n            new_solution = np.concatenate([new_solution[1:], [node]])\n        else:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Reinsert at best position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            post = new_solution[pos]\n\n            cost1 = distance_matrix_1[pre, node] + distance_matrix_1[node, post] - distance_matrix_1[pre, post]\n            cost2 = distance_matrix_2[pre, node] + distance_matrix_2[node, post] - distance_matrix_2[pre, post]\n\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if permutation is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.066577083596545,
            5.818362849962149
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive using objective balance scores, then applies a hybrid local search combining adaptive segment inversions, objective-aware edge swaps, and dynamic node reinsertions, with segment sizes dynamically adjusted to improve both objectives while ensuring feasibility. The method prioritizes inversions and swaps that significantly reduce costs, and reinsertions fine-tune local arrangements, with feasibility checks and corrections to maintain valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    balance_scores = 1 / (1 + np.sum(normalized, axis=1))\n    selected_idx = np.random.choice(len(archive), p=balance_scores/np.sum(balance_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem scale and past improvements\n    segment_size = max(2, min(7, n // 3))\n\n    # Multi-phase perturbation strategy\n    phases = [\n        ('inversion', segment_size),\n        ('swap', 3),\n        ('reinsertion', max(1, n // 5))\n    ]\n\n    for phase, size in phases:\n        if phase == 'inversion':\n            # Adaptive segment inversion\n            start = np.random.randint(0, n - size)\n            segment = new_solution[start:start+size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+size] if start+size < n else new_solution[0]\n\n            # Evaluate inversion in both objectives\n            orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n            orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n            new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n            new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n            delta1 = new_cost1 - orig_cost1\n            delta2 = new_cost2 - orig_cost2\n\n            # Accept if improves both objectives or one significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * abs(orig_cost1) or delta2 < -0.1 * abs(orig_cost2)):\n                new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n        elif phase == 'swap':\n            # Objective-aware edge swap\n            candidates = np.random.choice(n, min(size * 2, n), replace=False)\n            for i in candidates:\n                j = np.random.choice(n)\n                if i == j:\n                    continue\n\n                pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n                post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n                pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n                post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n                orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n                orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n                new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n                new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n                delta1 = new_cost1 - orig_cost1\n                delta2 = new_cost2 - orig_cost2\n\n                if delta1 < 0 or delta2 < 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif phase == 'reinsertion':\n            # Dynamic node reinsertion\n            for _ in range(size):\n                node_pos = np.random.randint(0, n)\n                node = new_solution[node_pos]\n\n                # Remove node\n                if node_pos == 0:\n                    new_solution = np.concatenate([new_solution[1:], [node]])\n                else:\n                    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n                # Find best insertion position\n                best_pos = 0\n                best_cost = float('inf')\n\n                for pos in range(n-1):\n                    pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                    post = new_solution[pos]\n\n                    cost = (distance_matrix_1[pre, node] + distance_matrix_1[node, post] - distance_matrix_1[pre, post] +\n                            distance_matrix_2[pre, node] + distance_matrix_2[node, post] - distance_matrix_2[pre, post])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.825711758506487,
            6.194110549892471
        ]
    }
]