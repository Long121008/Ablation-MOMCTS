[
    {
        "algorithm": "The algorithm selects the solution with the lowest combined cost from the archive, then applies a hybrid local search combining segment reversal and edge swaps to generate a new neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses novel segment reversal to explore the solution space beyond standard edge swaps. The selection and operators ensure valid tours by maintaining node uniqueness and completeness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal (novel operator)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a random edge swap (standard operator)\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9453093012944958,
            0.1820637583732605
        ],
        "raw_score": [
            6.180186675512935,
            6.63654462139858
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (favoring lower-cost solutions but allowing some diversity) and applies a cross-segment swap operator, randomly exchanging two non-overlapping segments of the tour to generate a neighbor solution while ensuring feasibility. The selection prioritizes exploitation of good solutions but balances it with exploration by occasionally choosing from the middle of the archive. The cross-segment swap is a novel local search operator that disrupts larger tour structures compared to standard edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_threshold = min(2 * len(sorted_archive) // 3, len(sorted_archive) - 1)\n    selected_solution = random.choice(sorted_archive[:selection_threshold])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-segment swap: select two non-overlapping segments and swap them\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create new solution by swapping segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end+1:seg2_start],\n        seg1,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.837455409186324,
            0.1816069483757019
        ],
        "raw_score": [
            6.500691332763455,
            6.600301261577352
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a random solution from the archive, applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor, and ensures feasibility by checking for duplicates. The algorithm prioritizes diversity and non-dominance implicitly by random selection, while the local search explores the solution space creatively by reversing segments and reinserting edges at random positions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_end = (edge_start + 1) % n\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[edge_end]\n\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:edge_start], new_solution[edge_end+1:]])\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node1)\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node2)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8700755886195684,
            0.21495270729064941
        ],
        "raw_score": [
            7.227454476992637,
            6.950987236943185
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the lowest combined cost (sum of both objectives), then applies a hybrid local search combining segment reversal and a novel node insertion to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses random segment reversal and node insertion to explore the search space, maintaining validity by checking for duplicate nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine segment reversal with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a novel node insertion (insert a node from a random position to another)\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8447560499453636,
            0.19697046279907227
        ],
        "raw_score": [
            6.450616079700156,
            6.332469275271153
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive using weighted random sampling based on normalized objective values, then applies a hybrid local search combining adaptive segment reversal and probabilistic edge swaps to generate a feasible neighbor solution, prioritizing solutions with lower combined costs while ensuring the tour remains valid. The selection weights favor solutions with better normalized objectives, and the local search adaptively adjusts segment length and swap probability based on problem size.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection with weighted random sampling\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (1 + np.sum(normalized_costs, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with probabilistic length\n    if n > 3:\n        seg_length = min(random.randint(2, n//2), n-2)\n        start = random.randint(0, n-seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Probabilistic edge swaps with adaptive intensity\n    swap_prob = 0.3 if n > 20 else 0.5\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility validation\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8918576688915671,
            0.22738558053970337
        ],
        "raw_score": [
            6.745697351573674,
            6.870386781264237
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weighted selection based on normalized objective values\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to [0, 1] range\n    max_obj1 = max(obj[0] for obj in objectives) if any(obj[0] for obj in objectives) else 1\n    max_obj2 = max(obj[1] for obj in objectives) if any(obj[1] for obj in objectives) else 1\n    normalized = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n\n    # Calculate weights based on combined potential (inverse of normalized values)\n    weights = [1/(1 + obj1 + obj2) for obj1, obj2 in normalized]\n    total_weight = sum(weights)\n    probabilities = [w/total_weight for w in weights]\n\n    # Select a solution using weighted random choice\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: probabilistic combination of segment reversal and cross-segment swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine operator selection based on relative objective improvement potential\n    obj1_improvement = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj2_improvement = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    if random.random() < 0.7:  # 70% chance of segment reversal\n        if n > 3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # 30% chance of cross-segment swap\n        if n > 4:\n            # Select two non-overlapping segments\n            split1 = random.randint(1, n-3)\n            split2 = random.randint(split1+1, n-2)\n            # Swap the two segments\n            segment1 = new_solution[:split1]\n            segment2 = new_solution[split1:split2]\n            segment3 = new_solution[split2:]\n            new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Validate the solution remains feasible\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9111867797829649,
            0.22890198230743408
        ],
        "raw_score": [
            6.640226332160937,
            6.430528959596512
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top third of the archive (sorted by combined objective cost), then applies a hybrid local search: either randomly reinserting an edge or reversing a segment of the tour, ensuring feasibility by maintaining a valid TSP path. The selection prioritizes solutions with lower total cost, while the local search explores diverse neighborhood structures to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: randomly choose between edge insertion or segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it in a different position\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7593220728994624,
            0.19668710231781006
        ],
        "raw_score": [
            5.831905830795691,
            5.995319237568243
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive biased toward lower combined objective values, then applies a hybrid local search operator that combines edge swapping (70% chance) with dynamic segment reversal (30% chance) to generate a neighbor solution, ensuring feasibility through validation. Edge swaps prioritize local improvements, while segment reversals explore larger-scale structural changes, with segment length dynamically adjusted to balance exploration and exploitation. The solution is validated to maintain tour validity (no skipped or revisited nodes).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined potential\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    combined_potential = [obj1 + obj2 for obj1, obj2 in objectives]\n    selected_idx = np.argmin(combined_potential)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvements\n    obj1_improvement = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj2_improvement = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Hybrid operator selection\n    if random.random() < 0.7:  # 70% chance for edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for dynamic segment reversal\n        segment_length = min(n // 3, 5)  # Dynamic segment size\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Validate solution\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8337942541032157,
            0.20343399047851562
        ],
        "raw_score": [
            6.445252940186686,
            6.345121603879532
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.mean([np.linalg.norm(sol - other) for other in solutions]) for sol in solutions]\n    selection_scores = [obj[0] * 0.5 + obj[1] * 0.3 + div * 0.2 for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with controlled disruption\n    if n > 3:\n        k = random.randint(1, min(3, n//2))  # Limit rotation to small segments\n        new_solution = np.roll(new_solution, k)\n\n    # Edge insertion with feasibility check\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (i + j) // 2 if i < j else (i + j + 1) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Validate feasibility\n    if len(set(new_solution)) != len(new_solution):\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9092558547377287,
            2.49730521440506
        ],
        "raw_score": [
            5.720869650024556,
            7.851523467482659
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from an archive using weighted sampling (favoring solutions with lower total improvement) and applies a hybrid local search operator: cross-segment relocation (70% chance) or probabilistic segment reversal (30% chance), with dynamic segment selection based on objective values and feasibility checks. The method balances exploration and exploitation by prioritizing solutions with higher potential improvement and dynamically adjusting operator probabilities.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights for weighted sampling based on potential improvement\n    objectives = [obj for _, obj in archive]\n    total_improvement = [obj[0] + obj[1] for obj in objectives]\n    weights = [1.0 / (1.0 + imp) for imp in total_improvement]  # Higher weight for lower improvement\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current objective values\n    obj1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Probabilistic operator selection based on objective values\n    if random.random() < 0.7:  # 70% chance for cross-segment relocation\n        if n > 3:\n            # Select two non-adjacent segments\n            a, b = sorted(random.sample(range(n-1), 2))\n            while b - a <= 1:  # Ensure segments are not adjacent\n                a, b = sorted(random.sample(range(n-1), 2))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:]\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1])\n    else:  # 30% chance for probabilistic segment reversal\n        if n > 3:\n            a, b = sorted(random.sample(range(n), 2))\n            # Reverse with probability inversely proportional to segment length\n            if random.random() < (1.0 / (b - a + 1)):\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Feasibility validation\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9013178989514996,
            0.24505531787872314
        ],
        "raw_score": [
            6.8913459349031845,
            6.680964110819106
        ]
    }
]