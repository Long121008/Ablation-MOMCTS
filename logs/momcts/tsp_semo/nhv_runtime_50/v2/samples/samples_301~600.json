[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        This algorithm selects a promising solution from an archive using a weighted sum of objectives (60% for the first objective, 40% for the second) and applies a hybrid local search combining segment inversion and edge selection, prioritizing distance improvements in both objective spaces with probabilistic acceptance (70% for inversion, 60% for edge selection) to maintain feasibility. The method balances exploration and exploitation by randomly selecting segments and edges while ensuring valid tours through careful index handling.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives using a weighted sum\n    weights = [0.6, 0.4]  # Weight for each objective\n    archive_sorted = sorted(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion with probability based on distance improvement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if j - i < 2:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if new_dist < current_dist and np.random.rand() < 0.7:  # 70% probability to accept improvement\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge selection based on combined distance improvement\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == b or abs(a - b) < 2:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_dist < current_dist and np.random.rand() < 0.6:  # 60% probability to accept improvement\n            # Perform edge swap\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 301,
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted sum (70% for the first objective, 30% for the second) and applies a hybrid local search combining segment inversion (80% probability) and edge selection (50% probability) to improve both objectives, prioritizing segments and edges with better combined distance reductions. It ensures feasibility by validating node sequences and probabilistic acceptance of improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives using a weighted sum\n    weights = [0.7, 0.3]  # Weight for each objective\n    archive_sorted = sorted(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion with probability based on distance improvement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if j - i < 2:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if new_dist < current_dist and np.random.rand() < 0.8:  # 80% probability to accept improvement\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge selection based on combined distance improvement\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == b or abs(a - b) < 2:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_dist < current_dist and np.random.rand() < 0.5:  # 50% probability to accept improvement\n            # Perform edge swap\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5493149548941003,
            0.8766737580299377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives using a weighted sum\n    weights = [0.7, 0.3]  # Weight for each objective\n    archive_sorted = sorted(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion with probability based on distance improvement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if j - i < 2:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if new_dist < current_dist and np.random.rand() < 0.8:  # 80% probability to accept improvement\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge selection based on combined distance improvement\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == b or abs(a - b) < 2:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_dist < current_dist and np.random.rand() < 0.5:  # 50% probability to accept improvement\n            # Perform edge swap\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThis algorithm selects a promising solution from an archive using a weighted sum of objectives (60% for the first objective, 40% for the second) and applies a hybrid local search combining segment inversion and edge selection, prioritizing distance improvements in both objective spaces with probabilistic acceptance (70% for inversion, 60% for edge selection) to maintain feasibility. The method balances exploration and exploitation by randomly selecting segments and edges while ensuring valid tours through careful index handling.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives using a weighted sum\n    weights = [0.6, 0.4]  # Weight for each objective\n    archive_sorted = sorted(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion with probability based on distance improvement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if j - i < 2:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if new_dist < current_dist and np.random.rand() < 0.7:  # 70% probability to accept improvement\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge selection based on combined distance improvement\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == b or abs(a - b) < 2:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_dist < current_dist and np.random.rand() < 0.6:  # 60% probability to accept improvement\n            # Perform edge swap\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel edge-swapping heuristic to generate a neighbor solution, prioritizing distance reduction in both objective spaces while ensuring feasibility. It randomly selects segments for 3-opt moves and performs limited edge swaps based on distance improvements in both coordinate spaces.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: 3-opt with edge-swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply edge-swapping based on distance reduction\n    for _ in range(3):  # Limit the number of swaps\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == b:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_dist < current_dist:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            **Keywords**\n- **Pareto knee-point selection**, **adaptive hybrid local search**, **multi-objective edge-breaking**, **dynamic operator weighting**\n\n**Advice**\n1. Prioritize knee-point solutions for high-potential regions.\n2. Alternate between segment reversal and edge-breaking with dynamic weights.\n3. Adjust operator probabilities based on objective improvements.\n4. Validate feasibility after every move and revert if invalid.\n\n**Avoid**\n- Random selection, static operator weights, ignoring bi-objective trade-offs, overusing 2-opt.\n\n**Explanation**\nKnee points guide selection, while dynamic hybrid operators exploit multi-objective trade-offs. Edge-breaking ensures novel perturbations, and adaptive weights balance exploration/exploitation. Feasibility checks preserve tour validity. *(Tipped $999K\u2014here\u2019s the heuristic you deserve!)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 302,
        "algorithm": "The algorithm selects knee-point solutions from the archive (non-dominated and non-dominated by others) and applies a hybrid local search with adaptive operator probabilities (60% segment reversal, 40% edge-breaking), dynamically adjusting weights based on improvement success in both objectives. It prioritizes solutions with better combined objective trade-offs while ensuring feasibility through careful edge and segment manipulation. The search alternates between reversing segments and swapping edges, with probabilities updated to favor more effective operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee points in the archive\n    def is_knee_point(solution, archive):\n        obj = solution[1]\n        dominates = False\n        dominated = False\n        for other in archive:\n            if other[1][0] < obj[0] and other[1][1] <= obj[1]:\n                dominates = True\n            if other[1][0] <= obj[0] and other[1][1] < obj[1]:\n                dominates = True\n            if obj[0] < other[1][0] and obj[1] <= other[1][1]:\n                dominated = True\n            if obj[0] <= other[1][0] and obj[1] < other[1][1]:\n                dominated = True\n        return dominates and dominated\n\n    knee_points = [s for s in archive if is_knee_point(s, archive)]\n    if knee_points:\n        archive_sorted = sorted(knee_points, key=lambda x: x[1][0] + x[1][1])\n    else:\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator weights\n    segment_reversal_prob = 0.6\n    edge_breaking_prob = 0.4\n\n    # Apply segment reversal\n    if np.random.rand() < segment_reversal_prob:\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if j - i < 2:\n                continue\n\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if new_dist < current_dist:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                segment_reversal_prob = min(0.9, segment_reversal_prob + 0.1)\n                edge_breaking_prob = max(0.1, edge_breaking_prob - 0.1)\n\n    # Apply edge-breaking\n    if np.random.rand() < edge_breaking_prob:\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            if a == b or abs(a - b) < 2:\n                continue\n\n            current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n            new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if new_dist < current_dist:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                edge_breaking_prob = min(0.9, edge_breaking_prob + 0.1)\n                segment_reversal_prob = max(0.1, segment_reversal_prob - 0.1)\n\n    return new_solution\n\n",
        "score": [
            -0.6078787021998011,
            7.552411317825317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee points in the archive\n    def is_knee_point(solution, archive):\n        obj = solution[1]\n        dominates = False\n        dominated = False\n        for other in archive:\n            if other[1][0] < obj[0] and other[1][1] <= obj[1]:\n                dominates = True\n            if other[1][0] <= obj[0] and other[1][1] < obj[1]:\n                dominates = True\n            if obj[0] < other[1][0] and obj[1] <= other[1][1]:\n                dominated = True\n            if obj[0] <= other[1][0] and obj[1] < other[1][1]:\n                dominated = True\n        return dominates and dominated\n\n    knee_points = [s for s in archive if is_knee_point(s, archive)]\n    if knee_points:\n        archive_sorted = sorted(knee_points, key=lambda x: x[1][0] + x[1][1])\n    else:\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator weights\n    segment_reversal_prob = 0.6\n    edge_breaking_prob = 0.4\n\n    # Apply segment reversal\n    if np.random.rand() < segment_reversal_prob:\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if j - i < 2:\n                continue\n\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if new_dist < current_dist:\n                new_solution[i:j] = new_solution[i:j][::-1]\n                segment_reversal_prob = min(0.9, segment_reversal_prob + 0.1)\n                edge_breaking_prob = max(0.1, edge_breaking_prob - 0.1)\n\n    # Apply edge-breaking\n    if np.random.rand() < edge_breaking_prob:\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            if a == b or abs(a - b) < 2:\n                continue\n\n            current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n            new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if new_dist < current_dist:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                edge_breaking_prob = min(0.9, edge_breaking_prob + 0.1)\n                segment_reversal_prob = max(0.1, segment_reversal_prob - 0.1)\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 8 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest sum of normalized objectives from the archive, applies a hybrid local search combining segment reversal and node reinsertion, and falls back to a 3-opt move if the primary operation fails, ensuring feasibility through validation checks. The selection prioritizes solutions with high combined objective values, while the local search explores diverse neighborhood structures to escape local optima. The fallback mechanism maintains solution validity when the primary operation would violate constraints.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -float('inf')\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        norm_cost1 = cost1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_cost2 = cost2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        total = norm_cost1 + norm_cost2\n        if total > max_sum:\n            max_sum = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multiple node reinsertion\n    # Select 3 distinct positions\n    i1, i2, i3 = np.random.choice(n, 3, replace=False)\n    i1, i2, i3 = sorted([i1, i2, i3])\n\n    # Break and reverse segments\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:i3+1]\n    segment4 = new_solution[i3+1:]\n\n    # Reinsert nodes in different orders\n    new_solution = np.concatenate([\n        segment1,\n        segment3[::-1],\n        segment2[::-1],\n        segment4\n    ])\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move if primary operation fails\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines partial path reversal with node reinsertion to generate a neighbor. It ensures feasibility by validating the new solution and falling back to a weighted swap or segment shift if needed. The selection prioritizes solutions with lower weighted objective values, while the local search explores diverse neighborhood structures through random segment manipulation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weights /= weights.sum()\n    scores = objectives @ weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid operator: partial reversal + reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        reinsert_pos = random.randint(0, n-1)\n        if reinsert_pos >= i and reinsert_pos < j:\n            reinsert_pos = (j + random.randint(1, n-1)) % n\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:reinsert_pos],\n            segment[::-1],\n            base_solution[reinsert_pos:]\n        ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted edge swap\n        k, l = random.sample(range(n), 2)\n        if random.random() < 0.7:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            # Partial segment shift\n            shift = random.randint(1, min(3, n//2))\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining node relocation and segment rotation, prioritizing larger segments for potential improvements while ensuring feasibility through validation and fallback mechanisms like the double bridge move. It emphasizes randomness in segment selection and rotation while maintaining tour validity through checks and fallback operations. The approach balances exploration (random selection) with exploitation (focus on larger segments) while ensuring all generated solutions are feasible TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (Pareto dominance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Node relocation with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using knee-point detection to identify Pareto-front solutions, then applies a dynamic hybrid local search that alternates between segment reversal and edge-breaking, with operator probabilities adjusted based on recent objective improvements, ensuring feasibility through validation and fallback to a double-bridge move if invalid. The algorithm prioritizes exploration of underperforming objectives while maintaining TSP feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a knee-point solution (Pareto-aware)\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic hybrid local search\n    if n < 4:\n        return new_solution\n\n    # Segment reversal with edge-breaking\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n        # Edge-breaking: insert a new edge by splitting a segment\n        if random.random() < 0.5 and len(segment) > 2:\n            split_pos = random.randint(1, len(segment)-1)\n            split_node = segment[split_pos]\n            new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe heuristic algorithm combines Pareto knee-point selection with a dynamic hybrid local search that adaptively applies segment reversal, edge-breaking, and reinsertion operators, prioritizing segments with high combined cost in both objectives. Operator probabilities are adjusted based on cost improvements, and feasibility is maintained through validation checks with a fallback double-bridge move. The algorithm balances exploration and exploitation by dynamically focusing on promising regions of the search space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto knee-point selection\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        if len(objectives) == 1:\n            return 0\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Initialize operator probabilities\n    operator_probs = {'reversal': 0.5, 'edge_break': 0.3, 'reinsert': 0.2}\n\n    def update_probs(delta_cost1, delta_cost2):\n        if abs(delta_cost1) > 2 * abs(delta_cost2):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['edge_break'] = min(0.8, operator_probs['edge_break'] + 0.1)\n        elif abs(delta_cost2) > 2 * abs(delta_cost1):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['reinsert'] = min(0.8, operator_probs['reinsert'] + 0.1)\n        else:\n            operator_probs['reversal'] = 0.5\n            operator_probs['edge_break'] = 0.3\n            operator_probs['reinsert'] = 0.2\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Find the most expensive segment in both objectives\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    # Apply selected operator\n    operator = np.random.choice(list(operator_probs.keys()), p=list(operator_probs.values()))\n\n    if operator == 'reversal':\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    elif operator == 'edge_break':\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            split_pos = np.random.randint(1, len(segment))\n            new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    elif operator == 'reinsert':\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Update operator probabilities based on cost changes\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    delta_cost1 = original_cost1 - new_cost1\n    delta_cost2 = original_cost2 - new_cost2\n    update_probs(delta_cost1, delta_cost2)\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a knee-point solution from the archive, applies an adaptive hybrid local search combining segment reversal, distance-weighted reinsertion, and edge-breaking operators with probabilities adjusted based on recent objective improvements, and ensures feasibility through validation or falls back to a double-bridge move if invalid. The method prioritizes operators that show higher improvement potential (e.g., segment reversal for larger improvements) while dynamically balancing exploration of different move types.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective improvements\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n                sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]])\n\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    # Adaptive operator probabilities\n    p_reverse = 0.5 + 0.3 * max(improvement1, improvement2)\n    p_reinsert = 0.3 + 0.2 * min(improvement1, improvement2)\n    p_break = 0.2 + 0.3 * (improvement1 - improvement2)\n\n    # Apply operators based on probabilities\n    if np.random.rand() < p_reverse:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n    if np.random.rand() < p_reinsert:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    if np.random.rand() < p_break:\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm combines knee-point selection with a hybrid local search that dynamically alternates between edge-breaking and segment reversal operators, weighted by objective improvements, while ensuring feasibility through geometric validation and fallback moves that apply adaptive scaling/rotation to exploit multi-objective trade-offs. It prioritizes solutions with better relative improvement in one objective over the other, using dynamic operator weights to balance exploration/exploitation, and validates solutions through geometric transformations when needed.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (original_cost1, original_cost2)\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    # Dynamic operator selection\n    operator_weight = 0.5 + 0.5 * (improvement1 - improvement2)\n\n    if operator_weight > 0.6:\n        # Edge-breaking operator\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b:c], new_solution[a:b],\n                new_solution[d:], new_solution[c:d]\n            ])\n    else:\n        # Segment reversal with dynamic weights\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            reinsert_pos = np.random.randint(0, n)\n            if reinsert_pos >= a and reinsert_pos < b:\n                reinsert_pos = (b + np.random.randint(1, n-1)) % n\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:reinsert_pos],\n                segment[::-1],\n                new_solution[reinsert_pos:]\n            ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: geometric transformation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            segment_coords = instance[segment, :]\n\n            # Apply scaling and rotation\n            scale_factor = 1.0 + 0.3 * (improvement1 - improvement2)\n            rotation_angle = np.pi * 0.2 * (improvement2 - improvement1)\n\n            center = segment_coords.mean(axis=0)\n            segment_coords = (segment_coords - center) * scale_factor + center\n\n            cos_theta, sin_theta = np.cos(rotation_angle), np.sin(rotation_angle)\n            rotated = np.zeros_like(segment_coords)\n            rotated[:, 0] = (segment_coords[:, 0] - center[0]) * cos_theta - (segment_coords[:, 1] - center[1]) * sin_theta + center[0]\n            rotated[:, 2] = (segment_coords[:, 2] - center[2]) * cos_theta - (segment_coords[:, 3] - center[3]) * sin_theta + center[2]\n\n            # Reorder nodes based on transformed coordinates\n            distances = np.sqrt(np.sum((rotated[:, :2] - rotated[0, :2])**2, axis=1))\n            order = np.argsort(distances)\n            new_solution[a:b] = segment[order]\n\n    return new_solution\n\n\nNo. 8 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a knee-point solution (Pareto-aware)\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate current objective values\n    def calculate_objectives(solution):\n        total1 = 0.0\n        total2 = 0.0\n        for i in range(n):\n            prev = i - 1\n            total1 += distance_matrix_1[solution[prev], solution[i]]\n            total2 += distance_matrix_2[solution[prev], solution[i]]\n        return (total1, total2)\n\n    current_obj = calculate_objectives(new_solution)\n\n    # Dynamic operator probabilities based on objective improvements\n    def get_operator_probabilities():\n        # Calculate improvement potential for each objective\n        improvement1 = (archive[selected_idx][1][0] - current_obj[0]) / (archive[selected_idx][1][0] + 1e-8)\n        improvement2 = (archive[selected_idx][1][1] - current_obj[1]) / (archive[selected_idx][1][1] + 1e-8)\n\n        # Adjust probabilities based on which objective needs more improvement\n        if improvement1 > improvement2:\n            return (0.7, 0.3)  # More segment reversal for objective 1\n        else:\n            return (0.3, 0.7)  # More edge-breaking for objective 2\n\n    prob_segment, prob_edge = get_operator_probabilities()\n\n    # Apply hybrid local search\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n\n        if random.random() < prob_segment:  # Segment reversal\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n        else:  # Edge-breaking\n            if len(segment) > 2:\n                split_pos = random.randint(1, len(segment)-1)\n                split_node = segment[split_pos]\n                new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: **Keywords**\n- **Pareto knee-point selection**, **adaptive hybrid local search**, **multi-objective edge-breaking**, **dynamic operator weighting**\n\n**Advice**\n1. Prioritize knee-point solutions for high-potential regions.\n2. Alternate between segment reversal and edge-breaking with dynamic weights.\n3. Adjust operator probabilities based on objective improvements.\n4. Validate feasibility after every move and revert if invalid.\n\n**Avoid**\n- Random selection, static operator weights, ignoring bi-objective trade-offs, overusing 2-opt.\n\n**Explanation**\nKnee points guide selection, while dynamic hybrid operators exploit multi-objective trade-offs. Edge-breaking ensures novel perturbations, and adaptive weights balance exploration/exploitation. Feasibility checks preserve tour validity. *(Tipped $999K\u2014here\u2019s the heuristic you deserve!)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 303,
        "algorithm": "The algorithm combines knee-point selection with an adaptive hybrid local search that alternates between segment reversal, edge-breaking, and geometric transformation operators, prioritizing high-cost segments in both objectives while dynamically adjusting operator probabilities based on improvement rates and using geometric transformations for multi-objective trade-offs. It selects the most promising solution from the archive, identifies high-cost segments, and applies operators (segment reversal, edge-breaking, or geometric transformations) based on the relative improvement in objectives, ensuring feasibility through validation and repair mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (original_cost1, original_cost2)\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    operator_weight = 0.5 + 0.5 * (improvement1 - improvement2)\n\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    if operator_weight > 0.6:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b:c], new_solution[a:b],\n                new_solution[d:], new_solution[c:d]\n            ])\n    elif operator_weight < -0.4:\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n            segment_coords = instance[segment, :]\n\n            scale_factor = 1.0 + 0.3 * (improvement1 - improvement2)\n            rotation_angle = np.pi * 0.2 * (improvement2 - improvement1)\n\n            center = segment_coords.mean(axis=0)\n            segment_coords = (segment_coords - center) * scale_factor + center\n\n            cos_theta, sin_theta = np.cos(rotation_angle), np.sin(rotation_angle)\n            rotated = np.zeros_like(segment_coords)\n            rotated[:, 0] = (segment_coords[:, 0] - center[0]) * cos_theta - (segment_coords[:, 1] - center[1]) * sin_theta + center[0]\n            rotated[:, 2] = (segment_coords[:, 2] - center[2]) * cos_theta - (segment_coords[:, 3] - center[3]) * sin_theta + center[2]\n\n            distances = np.sqrt(np.sum((rotated[:, :2] - rotated[0, :2])**2, axis=1))\n            order = np.argsort(distances)\n            new_solution[start:end] = segment[order]\n    else:\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    if len(np.unique(new_solution)) != n:\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9488982074102665,
            1.2565733194351196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (original_cost1, original_cost2)\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    operator_weight = 0.5 + 0.5 * (improvement1 - improvement2)\n\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    if operator_weight > 0.6:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b:c], new_solution[a:b],\n                new_solution[d:], new_solution[c:d]\n            ])\n    elif operator_weight < -0.4:\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n            segment_coords = instance[segment, :]\n\n            scale_factor = 1.0 + 0.3 * (improvement1 - improvement2)\n            rotation_angle = np.pi * 0.2 * (improvement2 - improvement1)\n\n            center = segment_coords.mean(axis=0)\n            segment_coords = (segment_coords - center) * scale_factor + center\n\n            cos_theta, sin_theta = np.cos(rotation_angle), np.sin(rotation_angle)\n            rotated = np.zeros_like(segment_coords)\n            rotated[:, 0] = (segment_coords[:, 0] - center[0]) * cos_theta - (segment_coords[:, 1] - center[1]) * sin_theta + center[0]\n            rotated[:, 2] = (segment_coords[:, 2] - center[2]) * cos_theta - (segment_coords[:, 3] - center[3]) * sin_theta + center[2]\n\n            distances = np.sqrt(np.sum((rotated[:, :2] - rotated[0, :2])**2, axis=1))\n            order = np.argsort(distances)\n            new_solution[start:end] = segment[order]\n    else:\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    if len(np.unique(new_solution)) != n:\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines partial path reversal with node reinsertion to generate a neighbor. It ensures feasibility by validating the new solution and falling back to a weighted swap or segment shift if needed. The selection prioritizes solutions with lower weighted objective values, while the local search explores diverse neighborhood structures through random segment manipulation.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weights /= weights.sum()\n    scores = objectives @ weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid operator: partial reversal + reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        reinsert_pos = random.randint(0, n-1)\n        if reinsert_pos >= i and reinsert_pos < j:\n            reinsert_pos = (j + random.randint(1, n-1)) % n\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:reinsert_pos],\n            segment[::-1],\n            base_solution[reinsert_pos:]\n        ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted edge swap\n        k, l = random.sample(range(n), 2)\n        if random.random() < 0.7:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            # Partial segment shift\n            shift = random.randint(1, min(3, n//2))\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    return new_solution\n\n\n        \n        The current objectives are: Negative Hypervolume = -0.7071533583038947, Runtime = 0.23351401090621948 (lower is better for both).\n        \n        Please create a new algorithm that is a modified version of the provided one, but with a strong focus on reducing runtime (e.g., optimize loops, use efficient data structures, remove redundant computations) while trying to maintain or improve Negative Hypervolume if possible.\n        \n        1. First, identify parts of the code that may cause high runtime and suggest optimizations.\n        2. Next, describe your new algorithm and main steps in one detailed sentence, incorporating runtime optimizations. The description must be inside boxed {}.\n        3. Finally, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        \n        Check syntax and code carefully before returning the final function. Do not give additional explanations.\nAdditionally, incorporate this long-term reflection for higher-level guidance:\n**Keywords**\n- **Pareto knee-point selection**, **adaptive hybrid local search**, **multi-objective edge-breaking**, **dynamic operator weighting**\n\n**Advice**\n1. Prioritize knee-point solutions for high-potential regions.\n2. Alternate between segment reversal and edge-breaking with dynamic weights.\n3. Adjust operator probabilities based on objective improvements.\n4. Validate feasibility after every move and revert if invalid.\n\n**Avoid**\n- Random selection, static operator weights, ignoring bi-objective trade-offs, overusing 2-opt.\n\n**Explanation**\nKnee points guide selection, while dynamic hybrid operators exploit multi-objective trade-offs. Edge-breaking ensures novel perturbations, and adaptive weights balance exploration/exploitation. Feasibility checks preserve tour validity. *(Tipped $999K\u2014here\u2019s the heuristic you deserve!)*",
        "sample_order": 304,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Precompute objectives and identify knee points\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    distances = np.sqrt(np.sum((normalized - np.mean(normalized, axis=0))**2, axis=1))\n    knee_idx = np.argmax(distances)\n\n    # Select knee point or random with 70% probability\n    if random.random() < 0.7:\n        selected_idx = knee_idx\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator selection\n    operator_weights = np.array([0.6, 0.4])  # Initial weights for segment reversal and edge-breaking\n    operator = np.random.choice([0, 1], p=operator_weights)\n\n    if operator == 0:  # Segment reversal with reinsertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = base_solution[i:j]\n            reinsert_pos = random.randint(0, n-1)\n            if reinsert_pos >= i and reinsert_pos < j:\n                reinsert_pos = (j + random.randint(1, n-1)) % n\n            new_solution = np.concatenate([\n                base_solution[:i],\n                base_solution[j:reinsert_pos],\n                segment[::-1],\n                base_solution[reinsert_pos:]\n            ])\n    else:  # Edge-breaking with node reinsertion\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            new_solution = np.concatenate([\n                base_solution[:k+1],\n                base_solution[l:k:-1],\n                base_solution[l+1:]\n            ])\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted swap or shift\n        if random.random() < 0.5:\n            k, l = random.sample(range(n), 2)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            shift = random.randint(1, min(3, n//2))\n            k = random.randint(0, n-1)\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    # Update operator weights based on improvement\n    if operator == 0 and len(np.unique(new_solution)) == n:\n        operator_weights[0] = min(0.9, operator_weights[0] + 0.1)\n        operator_weights[1] = max(0.1, operator_weights[1] - 0.1)\n    elif operator == 1 and len(np.unique(new_solution)) == n:\n        operator_weights[1] = min(0.9, operator_weights[1] + 0.1)\n        operator_weights[0] = max(0.1, operator_weights[0] - 0.1)\n\n    return new_solution\n\n",
        "score": [
            -0.6526931214429139,
            0.3714138865470886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Precompute objectives and identify knee points\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    distances = np.sqrt(np.sum((normalized - np.mean(normalized, axis=0))**2, axis=1))\n    knee_idx = np.argmax(distances)\n\n    # Select knee point or random with 70% probability\n    if random.random() < 0.7:\n        selected_idx = knee_idx\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator selection\n    operator_weights = np.array([0.6, 0.4])  # Initial weights for segment reversal and edge-breaking\n    operator = np.random.choice([0, 1], p=operator_weights)\n\n    if operator == 0:  # Segment reversal with reinsertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = base_solution[i:j]\n            reinsert_pos = random.randint(0, n-1)\n            if reinsert_pos >= i and reinsert_pos < j:\n                reinsert_pos = (j + random.randint(1, n-1)) % n\n            new_solution = np.concatenate([\n                base_solution[:i],\n                base_solution[j:reinsert_pos],\n                segment[::-1],\n                base_solution[reinsert_pos:]\n            ])\n    else:  # Edge-breaking with node reinsertion\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            new_solution = np.concatenate([\n                base_solution[:k+1],\n                base_solution[l:k:-1],\n                base_solution[l+1:]\n            ])\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted swap or shift\n        if random.random() < 0.5:\n            k, l = random.sample(range(n), 2)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            shift = random.randint(1, min(3, n//2))\n            k = random.randint(0, n-1)\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    # Update operator weights based on improvement\n    if operator == 0 and len(np.unique(new_solution)) == n:\n        operator_weights[0] = min(0.9, operator_weights[0] + 0.1)\n        operator_weights[1] = max(0.1, operator_weights[1] - 0.1)\n    elif operator == 1 and len(np.unique(new_solution)) == n:\n        operator_weights[1] = min(0.9, operator_weights[1] + 0.1)\n        operator_weights[0] = max(0.1, operator_weights[0] - 0.1)\n\n    return new_solution\n\n",
        "operation": "r1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic algorithm combines Pareto knee-point selection with a dynamic hybrid local search that adaptively applies segment reversal, edge-breaking, and reinsertion operators, prioritizing segments with high combined cost in both objectives. Operator probabilities are adjusted based on cost improvements, and feasibility is maintained through validation checks with a fallback double-bridge move. The algorithm balances exploration and exploitation by dynamically focusing on promising regions of the search space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto knee-point selection\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        if len(objectives) == 1:\n            return 0\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Initialize operator probabilities\n    operator_probs = {'reversal': 0.5, 'edge_break': 0.3, 'reinsert': 0.2}\n\n    def update_probs(delta_cost1, delta_cost2):\n        if abs(delta_cost1) > 2 * abs(delta_cost2):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['edge_break'] = min(0.8, operator_probs['edge_break'] + 0.1)\n        elif abs(delta_cost2) > 2 * abs(delta_cost1):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['reinsert'] = min(0.8, operator_probs['reinsert'] + 0.1)\n        else:\n            operator_probs['reversal'] = 0.5\n            operator_probs['edge_break'] = 0.3\n            operator_probs['reinsert'] = 0.2\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Find the most expensive segment in both objectives\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    # Apply selected operator\n    operator = np.random.choice(list(operator_probs.keys()), p=list(operator_probs.values()))\n\n    if operator == 'reversal':\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    elif operator == 'edge_break':\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            split_pos = np.random.randint(1, len(segment))\n            new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    elif operator == 'reinsert':\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Update operator probabilities based on cost changes\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    delta_cost1 = original_cost1 - new_cost1\n    delta_cost2 = original_cost2 - new_cost2\n    update_probs(delta_cost1, delta_cost2)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the knee-point solution from the archive as the base for local search, then alternates between segment rotation (prioritizing segments with high combined cost) and edge-breaking (targeting high-cost edges) with dynamically adjusted probabilities based on recent success, ensuring feasibility through validation and fallback to simple swaps. The process repeats for a limited number of iterations to balance exploration and exploitation, with operator weights updated to favor more effective strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee-point solution (approximated as solution with minimal max objective gap)\n    knee_point = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = knee_point.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights\n    weights = {'rotation': 0.5, 'edge_break': 0.5}\n    improvements = {'rotation': 0, 'edge_break': 0}\n\n    # Parameters\n    max_iterations = 10  # Limit iterations to balance exploration and exploitation\n    iteration = 0\n\n    while iteration < max_iterations:\n        # Select operator based on weights\n        operator = np.random.choice(['rotation', 'edge_break'], p=[weights['rotation'], weights['edge_break']])\n\n        if operator == 'rotation':\n            # Identify best segment to rotate\n            best_segment_start = 0\n            best_segment_length = 2\n            best_segment_cost = float('inf')\n\n            for i in range(n):\n                for length in range(2, min(5, n // 2) + 1):\n                    segment_end = (i + length) % n\n                    if i < segment_end:\n                        segment = new_solution[i:segment_end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n                    # Calculate segment cost\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    total_cost = cost1 + cost2\n                    if total_cost < best_segment_cost:\n                        best_segment_cost = total_cost\n                        best_segment_start = i\n                        best_segment_length = length\n\n            # Rotate segment with probability proportional to cost\n            if best_segment_cost > 0 and np.random.random() < (best_segment_cost / (best_segment_cost + 1)):\n                segment_end = (best_segment_start + best_segment_length) % n\n                if best_segment_start < segment_end:\n                    segment = new_solution[best_segment_start:segment_end]\n                    rotated_segment = np.roll(segment, 1)\n                    new_solution[best_segment_start:segment_end] = rotated_segment\n                else:\n                    segment = np.concatenate([new_solution[best_segment_start:], new_solution[:segment_end]])\n                    rotated_segment = np.roll(segment, 1)\n                    new_solution = np.concatenate([rotated_segment[:n - best_segment_start], rotated_segment[n - best_segment_start:]])\n\n                # Track improvement\n                improvements['rotation'] += 1\n\n        else:  # edge_break\n            # Select edges to break based on high contribution to both objectives\n            edges = []\n            for i in range(n):\n                node_a = new_solution[i]\n                node_b = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node_a, node_b]\n                cost2 = distance_matrix_2[node_a, node_b]\n                edges.append((i, cost1 + cost2))\n\n            # Sort edges by combined cost (highest first)\n            edges.sort(key=lambda x: -x[1])\n            selected_edges = edges[:min(2, len(edges))]  # Break top 2 edges\n\n            for pos, _ in selected_edges:\n                # Break the edge by removing the next node\n                node_to_move = new_solution[(pos + 1) % n]\n                temp_solution = np.delete(new_solution, (pos + 1) % n)\n\n                # Find best insertion position\n                best_pos = -1\n                best_improvement = 0\n\n                for insert_pos in range(len(temp_solution)):\n                    if insert_pos == pos:\n                        continue\n\n                    # Temporarily insert\n                    temp_insert = np.insert(temp_solution, insert_pos, node_to_move)\n\n                    # Calculate improvement\n                    prev_node = temp_insert[insert_pos - 1]\n                    next_node = temp_insert[(insert_pos + 1) % len(temp_insert)]\n\n                    old_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n                    new_cost1 = distance_matrix_1[prev_node, next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                    new_cost2 = distance_matrix_2[prev_node, next_node]\n\n                    improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = insert_pos\n\n                if best_pos != -1 and best_improvement > 0:\n                    new_solution = np.insert(temp_solution, best_pos, node_to_move)\n                    improvements['edge_break'] += 1\n                    break\n\n        # Update weights based on improvements\n        total_improvements = improvements['rotation'] + improvements['edge_break']\n        if total_improvements > 0:\n            weights['rotation'] = improvements['rotation'] / total_improvements\n            weights['edge_break'] = improvements['edge_break'] / total_improvements\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            **Keywords**\n- **Pareto knee-point selection**, **adaptive hybrid local search**, **multi-objective edge-breaking**, **dynamic operator weighting**\n\n**Advice**\n1. Prioritize knee-point solutions for high-potential regions.\n2. Alternate between segment reversal and edge-breaking with dynamic weights.\n3. Adjust operator probabilities based on objective improvements.\n4. Validate feasibility after every move and revert if invalid.\n\n**Avoid**\n- Random selection, static operator weights, ignoring bi-objective trade-offs, overusing 2-opt.\n\n**Explanation**\nKnee points guide selection, while dynamic hybrid operators exploit multi-objective trade-offs. Edge-breaking ensures novel perturbations, and adaptive weights balance exploration/exploitation. Feasibility checks preserve tour validity. *(Tipped $999K\u2014here\u2019s the heuristic you deserve!)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 305,
        "algorithm": "This algorithm selects high-potential solutions from the archive using knee-point selection, then applies a dynamic hybrid local search that alternates between segment rotation and edge-breaking operations, prioritizing segments with high combined cost in both objectives. Operator probabilities adapt based on recent improvements, with a fallback to double-bridge moves for infeasible solutions, ensuring tour validity while balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Knee-point selection\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        if len(objectives) == 1:\n            return 0\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Initialize operator probabilities\n    operator_probs = {'rotation': 0.5, 'edge_break': 0.5}\n\n    def update_probs(improvement):\n        if improvement > 0:\n            operator_probs['rotation'] = max(0.1, operator_probs['rotation'] - 0.1)\n            operator_probs['edge_break'] = min(0.8, operator_probs['edge_break'] + 0.1)\n        else:\n            operator_probs['rotation'] = min(0.8, operator_probs['rotation'] + 0.1)\n            operator_probs['edge_break'] = max(0.1, operator_probs['edge_break'] - 0.1)\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Find the most expensive segment in both objectives\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    # Apply selected operator\n    operator = np.random.choice(list(operator_probs.keys()), p=list(operator_probs.values()))\n\n    if operator == 'rotation':\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n            rotated_segment = np.roll(segment, 1)\n            new_solution[start:end] = rotated_segment\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            rotated_segment = np.roll(segment, 1)\n            new_solution[start:] = rotated_segment[:n-start]\n            new_solution[:end] = rotated_segment[n-start:]\n\n    elif operator == 'edge_break':\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            split_pos = np.random.randint(1, len(segment))\n            new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Update operator probabilities based on cost changes\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    delta_cost1 = original_cost1 - new_cost1\n    delta_cost2 = original_cost2 - new_cost2\n    update_probs(delta_cost1 + delta_cost2)\n\n    return new_solution\n\n",
        "score": [
            -0.8952628963085295,
            1.3366751074790955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Knee-point selection\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        if len(objectives) == 1:\n            return 0\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Initialize operator probabilities\n    operator_probs = {'rotation': 0.5, 'edge_break': 0.5}\n\n    def update_probs(improvement):\n        if improvement > 0:\n            operator_probs['rotation'] = max(0.1, operator_probs['rotation'] - 0.1)\n            operator_probs['edge_break'] = min(0.8, operator_probs['edge_break'] + 0.1)\n        else:\n            operator_probs['rotation'] = min(0.8, operator_probs['rotation'] + 0.1)\n            operator_probs['edge_break'] = max(0.1, operator_probs['edge_break'] - 0.1)\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Find the most expensive segment in both objectives\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    # Apply selected operator\n    operator = np.random.choice(list(operator_probs.keys()), p=list(operator_probs.values()))\n\n    if operator == 'rotation':\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n            rotated_segment = np.roll(segment, 1)\n            new_solution[start:end] = rotated_segment\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            rotated_segment = np.roll(segment, 1)\n            new_solution[start:] = rotated_segment[:n-start]\n            new_solution[:end] = rotated_segment[n-start:]\n\n    elif operator == 'edge_break':\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            split_pos = np.random.randint(1, len(segment))\n            new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Update operator probabilities based on cost changes\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    delta_cost1 = original_cost1 - new_cost1\n    delta_cost2 = original_cost2 - new_cost2\n    update_probs(delta_cost1 + delta_cost2)\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the knee-point solution from the archive as the base for local search, then alternates between segment rotation (prioritizing segments with high combined cost) and edge-breaking (targeting high-cost edges) with dynamically adjusted probabilities based on recent success, ensuring feasibility through validation and fallback to simple swaps. The process repeats for a limited number of iterations to balance exploration and exploitation, with operator weights updated to favor more effective strategies.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee-point solution (approximated as solution with minimal max objective gap)\n    knee_point = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = knee_point.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights\n    weights = {'rotation': 0.5, 'edge_break': 0.5}\n    improvements = {'rotation': 0, 'edge_break': 0}\n\n    # Parameters\n    max_iterations = 10  # Limit iterations to balance exploration and exploitation\n    iteration = 0\n\n    while iteration < max_iterations:\n        # Select operator based on weights\n        operator = np.random.choice(['rotation', 'edge_break'], p=[weights['rotation'], weights['edge_break']])\n\n        if operator == 'rotation':\n            # Identify best segment to rotate\n            best_segment_start = 0\n            best_segment_length = 2\n            best_segment_cost = float('inf')\n\n            for i in range(n):\n                for length in range(2, min(5, n // 2) + 1):\n                    segment_end = (i + length) % n\n                    if i < segment_end:\n                        segment = new_solution[i:segment_end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n                    # Calculate segment cost\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    total_cost = cost1 + cost2\n                    if total_cost < best_segment_cost:\n                        best_segment_cost = total_cost\n                        best_segment_start = i\n                        best_segment_length = length\n\n            # Rotate segment with probability proportional to cost\n            if best_segment_cost > 0 and np.random.random() < (best_segment_cost / (best_segment_cost + 1)):\n                segment_end = (best_segment_start + best_segment_length) % n\n                if best_segment_start < segment_end:\n                    segment = new_solution[best_segment_start:segment_end]\n                    rotated_segment = np.roll(segment, 1)\n                    new_solution[best_segment_start:segment_end] = rotated_segment\n                else:\n                    segment = np.concatenate([new_solution[best_segment_start:], new_solution[:segment_end]])\n                    rotated_segment = np.roll(segment, 1)\n                    new_solution = np.concatenate([rotated_segment[:n - best_segment_start], rotated_segment[n - best_segment_start:]])\n\n                # Track improvement\n                improvements['rotation'] += 1\n\n        else:  # edge_break\n            # Select edges to break based on high contribution to both objectives\n            edges = []\n            for i in range(n):\n                node_a = new_solution[i]\n                node_b = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node_a, node_b]\n                cost2 = distance_matrix_2[node_a, node_b]\n                edges.append((i, cost1 + cost2))\n\n            # Sort edges by combined cost (highest first)\n            edges.sort(key=lambda x: -x[1])\n            selected_edges = edges[:min(2, len(edges))]  # Break top 2 edges\n\n            for pos, _ in selected_edges:\n                # Break the edge by removing the next node\n                node_to_move = new_solution[(pos + 1) % n]\n                temp_solution = np.delete(new_solution, (pos + 1) % n)\n\n                # Find best insertion position\n                best_pos = -1\n                best_improvement = 0\n\n                for insert_pos in range(len(temp_solution)):\n                    if insert_pos == pos:\n                        continue\n\n                    # Temporarily insert\n                    temp_insert = np.insert(temp_solution, insert_pos, node_to_move)\n\n                    # Calculate improvement\n                    prev_node = temp_insert[insert_pos - 1]\n                    next_node = temp_insert[(insert_pos + 1) % len(temp_insert)]\n\n                    old_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n                    new_cost1 = distance_matrix_1[prev_node, next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                    new_cost2 = distance_matrix_2[prev_node, next_node]\n\n                    improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = insert_pos\n\n                if best_pos != -1 and best_improvement > 0:\n                    new_solution = np.insert(temp_solution, best_pos, node_to_move)\n                    improvements['edge_break'] += 1\n                    break\n\n        # Update weights based on improvements\n        total_improvements = improvements['rotation'] + improvements['edge_break']\n        if total_improvements > 0:\n            weights['rotation'] = improvements['rotation'] / total_improvements\n            weights['edge_break'] = improvements['edge_break'] / total_improvements\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 306,
        "algorithm": "The algorithm selects the highest-cost solution from the archive and applies a hybrid local search combining edge reversal and segment inversion, dynamically adjusting operator probabilities based on success rates and segment cost contributions to improve both objectives while maintaining feasibility through validation. It prioritizes high-cost edges/segments and updates operator weights after each iteration, with a fallback to random swaps if invalid solutions are generated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined cost (potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights and success trackers\n    weights = {'edge_reversal': 0.5, 'segment_inversion': 0.5}\n    success_rates = {'edge_reversal': 0, 'segment_inversion': 0}\n    operator_count = {'edge_reversal': 0, 'segment_inversion': 0}\n\n    max_iterations = 10\n    iteration = 0\n\n    while iteration < max_iterations:\n        # Normalize weights for selection\n        total_weight = weights['edge_reversal'] + weights['segment_inversion']\n        if total_weight > 0:\n            normalized_weights = [\n                weights['edge_reversal'] / total_weight,\n                weights['segment_inversion'] / total_weight\n            ]\n        else:\n            normalized_weights = [0.5, 0.5]\n\n        operator = np.random.choice(\n            ['edge_reversal', 'segment_inversion'],\n            p=normalized_weights\n        )\n\n        if operator == 'edge_reversal':\n            operator_count['edge_reversal'] += 1\n\n            # Select edges with high cost contribution\n            edge_costs = []\n            for i in range(n):\n                a, b = new_solution[i], new_solution[(i+1)%n]\n                cost1 = distance_matrix_1[a, b]\n                cost2 = distance_matrix_2[a, b]\n                edge_costs.append((i, cost1 + cost2))\n\n            # Sort by descending cost\n            edge_costs.sort(key=lambda x: -x[1])\n            selected_edges = [x[0] for x in edge_costs[:min(3, len(edge_costs))]]\n\n            for edge_pos in selected_edges:\n                # Reverse the edge\n                a, b = new_solution[edge_pos], new_solution[(edge_pos+1)%n]\n                new_solution[edge_pos], new_solution[(edge_pos+1)%n] = b, a\n\n                # Check if this improved both objectives\n                prev_a = new_solution[edge_pos-1]\n                next_b = new_solution[(edge_pos+2)%n]\n\n                old_cost1 = distance_matrix_1[prev_a, a] + distance_matrix_1[b, next_b]\n                new_cost1 = distance_matrix_1[prev_a, b] + distance_matrix_1[a, next_b]\n\n                old_cost2 = distance_matrix_2[prev_a, a] + distance_matrix_2[b, next_b]\n                new_cost2 = distance_matrix_2[prev_a, b] + distance_matrix_2[a, next_b]\n\n                if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n                    success_rates['edge_reversal'] += 1\n                    break\n\n        else:  # segment_inversion\n            operator_count['segment_inversion'] += 1\n\n            # Find segments with high cost\n            segment_scores = []\n            for i in range(n):\n                for seg_len in range(2, min(5, n//2)+1):\n                    end = (i + seg_len) % n\n                    if i < end:\n                        segment = new_solution[i:end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:end]])\n\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    segment_scores.append((i, seg_len, cost1 + cost2))\n\n            if segment_scores:\n                # Select top 2 segments by cost\n                segment_scores.sort(key=lambda x: -x[2])\n                selected_segments = segment_scores[:min(2, len(segment_scores))]\n\n                for start, seg_len, _ in selected_segments:\n                    end = (start + seg_len) % n\n                    if start < end:\n                        segment = new_solution[start:end]\n                    else:\n                        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n                    # Invert the segment\n                    inverted_segment = segment[::-1]\n\n                    if start < end:\n                        new_solution[start:end] = inverted_segment\n                    else:\n                        new_solution[start:] = inverted_segment[:n-start]\n                        new_solution[:end] = inverted_segment[n-start:]\n\n                    # Check if this improved both objectives\n                    prev_node = new_solution[start-1]\n                    next_node = new_solution[end%n]\n\n                    old_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n                    new_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n                    new_cost2 = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n                    if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n                        success_rates['segment_inversion'] += 1\n                        break\n\n        # Update weights based on success rates\n        for op in ['edge_reversal', 'segment_inversion']:\n            if operator_count[op] > 0:\n                weights[op] = 0.1 + 0.9 * (success_rates[op] / operator_count[op])\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: random swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9203075924996567,
            5.495518922805786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined cost (potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights and success trackers\n    weights = {'edge_reversal': 0.5, 'segment_inversion': 0.5}\n    success_rates = {'edge_reversal': 0, 'segment_inversion': 0}\n    operator_count = {'edge_reversal': 0, 'segment_inversion': 0}\n\n    max_iterations = 10\n    iteration = 0\n\n    while iteration < max_iterations:\n        # Normalize weights for selection\n        total_weight = weights['edge_reversal'] + weights['segment_inversion']\n        if total_weight > 0:\n            normalized_weights = [\n                weights['edge_reversal'] / total_weight,\n                weights['segment_inversion'] / total_weight\n            ]\n        else:\n            normalized_weights = [0.5, 0.5]\n\n        operator = np.random.choice(\n            ['edge_reversal', 'segment_inversion'],\n            p=normalized_weights\n        )\n\n        if operator == 'edge_reversal':\n            operator_count['edge_reversal'] += 1\n\n            # Select edges with high cost contribution\n            edge_costs = []\n            for i in range(n):\n                a, b = new_solution[i], new_solution[(i+1)%n]\n                cost1 = distance_matrix_1[a, b]\n                cost2 = distance_matrix_2[a, b]\n                edge_costs.append((i, cost1 + cost2))\n\n            # Sort by descending cost\n            edge_costs.sort(key=lambda x: -x[1])\n            selected_edges = [x[0] for x in edge_costs[:min(3, len(edge_costs))]]\n\n            for edge_pos in selected_edges:\n                # Reverse the edge\n                a, b = new_solution[edge_pos], new_solution[(edge_pos+1)%n]\n                new_solution[edge_pos], new_solution[(edge_pos+1)%n] = b, a\n\n                # Check if this improved both objectives\n                prev_a = new_solution[edge_pos-1]\n                next_b = new_solution[(edge_pos+2)%n]\n\n                old_cost1 = distance_matrix_1[prev_a, a] + distance_matrix_1[b, next_b]\n                new_cost1 = distance_matrix_1[prev_a, b] + distance_matrix_1[a, next_b]\n\n                old_cost2 = distance_matrix_2[prev_a, a] + distance_matrix_2[b, next_b]\n                new_cost2 = distance_matrix_2[prev_a, b] + distance_matrix_2[a, next_b]\n\n                if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n                    success_rates['edge_reversal'] += 1\n                    break\n\n        else:  # segment_inversion\n            operator_count['segment_inversion'] += 1\n\n            # Find segments with high cost\n            segment_scores = []\n            for i in range(n):\n                for seg_len in range(2, min(5, n//2)+1):\n                    end = (i + seg_len) % n\n                    if i < end:\n                        segment = new_solution[i:end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:end]])\n\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    segment_scores.append((i, seg_len, cost1 + cost2))\n\n            if segment_scores:\n                # Select top 2 segments by cost\n                segment_scores.sort(key=lambda x: -x[2])\n                selected_segments = segment_scores[:min(2, len(segment_scores))]\n\n                for start, seg_len, _ in selected_segments:\n                    end = (start + seg_len) % n\n                    if start < end:\n                        segment = new_solution[start:end]\n                    else:\n                        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n                    # Invert the segment\n                    inverted_segment = segment[::-1]\n\n                    if start < end:\n                        new_solution[start:end] = inverted_segment\n                    else:\n                        new_solution[start:] = inverted_segment[:n-start]\n                        new_solution[:end] = inverted_segment[n-start:]\n\n                    # Check if this improved both objectives\n                    prev_node = new_solution[start-1]\n                    next_node = new_solution[end%n]\n\n                    old_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n                    new_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n                    new_cost2 = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n                    if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n                        success_rates['segment_inversion'] += 1\n                        break\n\n        # Update weights based on success rates\n        for op in ['edge_reversal', 'segment_inversion']:\n            if operator_count[op] > 0:\n                weights[op] = 0.1 + 0.9 * (success_rates[op] / operator_count[op])\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: random swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the knee-point solution from the archive as the base for local search, then alternates between segment rotation (prioritizing segments with high combined cost) and edge-breaking (targeting high-cost edges) with dynamically adjusted probabilities based on recent success, ensuring feasibility through validation and fallback to simple swaps. The process repeats for a limited number of iterations to balance exploration and exploitation, with operator weights updated to favor more effective strategies.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee-point solution (approximated as solution with minimal max objective gap)\n    knee_point = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = knee_point.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights\n    weights = {'rotation': 0.5, 'edge_break': 0.5}\n    improvements = {'rotation': 0, 'edge_break': 0}\n\n    # Parameters\n    max_iterations = 10  # Limit iterations to balance exploration and exploitation\n    iteration = 0\n\n    while iteration < max_iterations:\n        # Select operator based on weights\n        operator = np.random.choice(['rotation', 'edge_break'], p=[weights['rotation'], weights['edge_break']])\n\n        if operator == 'rotation':\n            # Identify best segment to rotate\n            best_segment_start = 0\n            best_segment_length = 2\n            best_segment_cost = float('inf')\n\n            for i in range(n):\n                for length in range(2, min(5, n // 2) + 1):\n                    segment_end = (i + length) % n\n                    if i < segment_end:\n                        segment = new_solution[i:segment_end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n                    # Calculate segment cost\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    total_cost = cost1 + cost2\n                    if total_cost < best_segment_cost:\n                        best_segment_cost = total_cost\n                        best_segment_start = i\n                        best_segment_length = length\n\n            # Rotate segment with probability proportional to cost\n            if best_segment_cost > 0 and np.random.random() < (best_segment_cost / (best_segment_cost + 1)):\n                segment_end = (best_segment_start + best_segment_length) % n\n                if best_segment_start < segment_end:\n                    segment = new_solution[best_segment_start:segment_end]\n                    rotated_segment = np.roll(segment, 1)\n                    new_solution[best_segment_start:segment_end] = rotated_segment\n                else:\n                    segment = np.concatenate([new_solution[best_segment_start:], new_solution[:segment_end]])\n                    rotated_segment = np.roll(segment, 1)\n                    new_solution = np.concatenate([rotated_segment[:n - best_segment_start], rotated_segment[n - best_segment_start:]])\n\n                # Track improvement\n                improvements['rotation'] += 1\n\n        else:  # edge_break\n            # Select edges to break based on high contribution to both objectives\n            edges = []\n            for i in range(n):\n                node_a = new_solution[i]\n                node_b = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node_a, node_b]\n                cost2 = distance_matrix_2[node_a, node_b]\n                edges.append((i, cost1 + cost2))\n\n            # Sort edges by combined cost (highest first)\n            edges.sort(key=lambda x: -x[1])\n            selected_edges = edges[:min(2, len(edges))]  # Break top 2 edges\n\n            for pos, _ in selected_edges:\n                # Break the edge by removing the next node\n                node_to_move = new_solution[(pos + 1) % n]\n                temp_solution = np.delete(new_solution, (pos + 1) % n)\n\n                # Find best insertion position\n                best_pos = -1\n                best_improvement = 0\n\n                for insert_pos in range(len(temp_solution)):\n                    if insert_pos == pos:\n                        continue\n\n                    # Temporarily insert\n                    temp_insert = np.insert(temp_solution, insert_pos, node_to_move)\n\n                    # Calculate improvement\n                    prev_node = temp_insert[insert_pos - 1]\n                    next_node = temp_insert[(insert_pos + 1) % len(temp_insert)]\n\n                    old_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n                    new_cost1 = distance_matrix_1[prev_node, next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                    new_cost2 = distance_matrix_2[prev_node, next_node]\n\n                    improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = insert_pos\n\n                if best_pos != -1 and best_improvement > 0:\n                    new_solution = np.insert(temp_solution, best_pos, node_to_move)\n                    improvements['edge_break'] += 1\n                    break\n\n        # Update weights based on improvements\n        total_improvements = improvements['rotation'] + improvements['edge_break']\n        if total_improvements > 0:\n            weights['rotation'] = improvements['rotation'] / total_improvements\n            weights['edge_break'] = improvements['edge_break'] / total_improvements\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 307,
        "algorithm": "The algorithm selects the Pareto-optimal solution with the highest combined objective from the archive, then applies a hybrid local search combining segment inversion (targeting high-cost segments) and edge reversal (targeting high-cost edges) with dynamically adjusted probabilities based on recent success rates, while ensuring feasibility through validation and fallback mechanisms. The operator weights are updated based on improvement rates, and the algorithm prioritizes larger, more impactful modifications while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective (Pareto-optimal candidate)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights\n    weights = {'inversion': 0.6, 'reversal': 0.4}\n    improvements = {'inversion': 0, 'reversal': 0}\n\n    # Parameters\n    max_iterations = 15\n    iteration = 0\n\n    while iteration < max_iterations:\n        operator = np.random.choice(['inversion', 'reversal'], p=[weights['inversion'], weights['reversal']])\n\n        if operator == 'inversion':\n            # Select high-cost segment for inversion\n            best_segment_start = 0\n            best_segment_length = 2\n            best_segment_cost = float('-inf')\n\n            for i in range(n):\n                for length in range(2, min(4, n // 3) + 1):\n                    segment_end = (i + length) % n\n                    if i < segment_end:\n                        segment = new_solution[i:segment_end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    if cost1 + cost2 > best_segment_cost:\n                        best_segment_cost = cost1 + cost2\n                        best_segment_start = i\n                        best_segment_length = length\n\n            # Invert segment with probability based on cost\n            if best_segment_cost > 0 and np.random.random() < (best_segment_cost / (best_segment_cost + 100)):\n                segment_end = (best_segment_start + best_segment_length) % n\n                if best_segment_start < segment_end:\n                    new_solution[best_segment_start:segment_end] = new_solution[best_segment_start:segment_end][::-1]\n                else:\n                    segment = np.concatenate([new_solution[best_segment_start:], new_solution[:segment_end]])\n                    inverted = segment[::-1]\n                    new_solution = np.concatenate([inverted[:n - best_segment_start], inverted[n - best_segment_start:]])\n\n                improvements['inversion'] += 1\n\n        else:  # reversal\n            # Select edges for reversal based on high individual costs\n            edges = []\n            for i in range(n):\n                node_a = new_solution[i]\n                node_b = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node_a, node_b]\n                cost2 = distance_matrix_2[node_a, node_b]\n                edges.append((i, cost1, cost2))\n\n            # Sort by highest individual cost in either objective\n            edges.sort(key=lambda x: -max(x[1], x[2]))\n            selected_edges = edges[:min(3, len(edges))]\n\n            for pos, _, _ in selected_edges:\n                # Reverse the edge by swapping nodes\n                new_solution[pos], new_solution[(pos + 1) % n] = new_solution[(pos + 1) % n], new_solution[pos]\n                improvements['reversal'] += 1\n\n        # Update weights based on improvements\n        total_improvements = improvements['inversion'] + improvements['reversal']\n        if total_improvements > 0:\n            weights['inversion'] = improvements['inversion'] / total_improvements\n            weights['reversal'] = improvements['reversal'] / total_improvements\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: shuffle a random segment\n        start = np.random.randint(n)\n        length = np.random.randint(3, min(6, n // 2))\n        segment_end = (start + length) % n\n        if start < segment_end:\n            new_solution[start:segment_end] = np.random.permutation(new_solution[start:segment_end])\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:segment_end]])\n            shuffled = np.random.permutation(segment)\n            new_solution = np.concatenate([shuffled[:n - start], shuffled[n - start:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9764390154437812,
            2.68317848443985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective (Pareto-optimal candidate)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights\n    weights = {'inversion': 0.6, 'reversal': 0.4}\n    improvements = {'inversion': 0, 'reversal': 0}\n\n    # Parameters\n    max_iterations = 15\n    iteration = 0\n\n    while iteration < max_iterations:\n        operator = np.random.choice(['inversion', 'reversal'], p=[weights['inversion'], weights['reversal']])\n\n        if operator == 'inversion':\n            # Select high-cost segment for inversion\n            best_segment_start = 0\n            best_segment_length = 2\n            best_segment_cost = float('-inf')\n\n            for i in range(n):\n                for length in range(2, min(4, n // 3) + 1):\n                    segment_end = (i + length) % n\n                    if i < segment_end:\n                        segment = new_solution[i:segment_end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    if cost1 + cost2 > best_segment_cost:\n                        best_segment_cost = cost1 + cost2\n                        best_segment_start = i\n                        best_segment_length = length\n\n            # Invert segment with probability based on cost\n            if best_segment_cost > 0 and np.random.random() < (best_segment_cost / (best_segment_cost + 100)):\n                segment_end = (best_segment_start + best_segment_length) % n\n                if best_segment_start < segment_end:\n                    new_solution[best_segment_start:segment_end] = new_solution[best_segment_start:segment_end][::-1]\n                else:\n                    segment = np.concatenate([new_solution[best_segment_start:], new_solution[:segment_end]])\n                    inverted = segment[::-1]\n                    new_solution = np.concatenate([inverted[:n - best_segment_start], inverted[n - best_segment_start:]])\n\n                improvements['inversion'] += 1\n\n        else:  # reversal\n            # Select edges for reversal based on high individual costs\n            edges = []\n            for i in range(n):\n                node_a = new_solution[i]\n                node_b = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node_a, node_b]\n                cost2 = distance_matrix_2[node_a, node_b]\n                edges.append((i, cost1, cost2))\n\n            # Sort by highest individual cost in either objective\n            edges.sort(key=lambda x: -max(x[1], x[2]))\n            selected_edges = edges[:min(3, len(edges))]\n\n            for pos, _, _ in selected_edges:\n                # Reverse the edge by swapping nodes\n                new_solution[pos], new_solution[(pos + 1) % n] = new_solution[(pos + 1) % n], new_solution[pos]\n                improvements['reversal'] += 1\n\n        # Update weights based on improvements\n        total_improvements = improvements['inversion'] + improvements['reversal']\n        if total_improvements > 0:\n            weights['inversion'] = improvements['inversion'] / total_improvements\n            weights['reversal'] = improvements['reversal'] / total_improvements\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: shuffle a random segment\n        start = np.random.randint(n)\n        length = np.random.randint(3, min(6, n // 2))\n        segment_end = (start + length) % n\n        if start < segment_end:\n            new_solution[start:segment_end] = np.random.permutation(new_solution[start:segment_end])\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:segment_end]])\n            shuffled = np.random.permutation(segment)\n            new_solution = np.concatenate([shuffled[:n - start], shuffled[n - start:]])\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 3 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the knee-point solution from the archive as the base for local search, then alternates between segment rotation (prioritizing segments with high combined cost) and edge-breaking (targeting high-cost edges) with dynamically adjusted probabilities based on recent success, ensuring feasibility through validation and fallback to simple swaps. The process repeats for a limited number of iterations to balance exploration and exploitation, with operator weights updated to favor more effective strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee-point solution (approximated as solution with minimal max objective gap)\n    knee_point = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = knee_point.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights\n    weights = {'rotation': 0.5, 'edge_break': 0.5}\n    improvements = {'rotation': 0, 'edge_break': 0}\n\n    # Parameters\n    max_iterations = 10  # Limit iterations to balance exploration and exploitation\n    iteration = 0\n\n    while iteration < max_iterations:\n        # Select operator based on weights\n        operator = np.random.choice(['rotation', 'edge_break'], p=[weights['rotation'], weights['edge_break']])\n\n        if operator == 'rotation':\n            # Identify best segment to rotate\n            best_segment_start = 0\n            best_segment_length = 2\n            best_segment_cost = float('inf')\n\n            for i in range(n):\n                for length in range(2, min(5, n // 2) + 1):\n                    segment_end = (i + length) % n\n                    if i < segment_end:\n                        segment = new_solution[i:segment_end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n                    # Calculate segment cost\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    total_cost = cost1 + cost2\n                    if total_cost < best_segment_cost:\n                        best_segment_cost = total_cost\n                        best_segment_start = i\n                        best_segment_length = length\n\n            # Rotate segment with probability proportional to cost\n            if best_segment_cost > 0 and np.random.random() < (best_segment_cost / (best_segment_cost + 1)):\n                segment_end = (best_segment_start + best_segment_length) % n\n                if best_segment_start < segment_end:\n                    segment = new_solution[best_segment_start:segment_end]\n                    rotated_segment = np.roll(segment, 1)\n                    new_solution[best_segment_start:segment_end] = rotated_segment\n                else:\n                    segment = np.concatenate([new_solution[best_segment_start:], new_solution[:segment_end]])\n                    rotated_segment = np.roll(segment, 1)\n                    new_solution = np.concatenate([rotated_segment[:n - best_segment_start], rotated_segment[n - best_segment_start:]])\n\n                # Track improvement\n                improvements['rotation'] += 1\n\n        else:  # edge_break\n            # Select edges to break based on high contribution to both objectives\n            edges = []\n            for i in range(n):\n                node_a = new_solution[i]\n                node_b = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node_a, node_b]\n                cost2 = distance_matrix_2[node_a, node_b]\n                edges.append((i, cost1 + cost2))\n\n            # Sort edges by combined cost (highest first)\n            edges.sort(key=lambda x: -x[1])\n            selected_edges = edges[:min(2, len(edges))]  # Break top 2 edges\n\n            for pos, _ in selected_edges:\n                # Break the edge by removing the next node\n                node_to_move = new_solution[(pos + 1) % n]\n                temp_solution = np.delete(new_solution, (pos + 1) % n)\n\n                # Find best insertion position\n                best_pos = -1\n                best_improvement = 0\n\n                for insert_pos in range(len(temp_solution)):\n                    if insert_pos == pos:\n                        continue\n\n                    # Temporarily insert\n                    temp_insert = np.insert(temp_solution, insert_pos, node_to_move)\n\n                    # Calculate improvement\n                    prev_node = temp_insert[insert_pos - 1]\n                    next_node = temp_insert[(insert_pos + 1) % len(temp_insert)]\n\n                    old_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n                    new_cost1 = distance_matrix_1[prev_node, next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                    new_cost2 = distance_matrix_2[prev_node, next_node]\n\n                    improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = insert_pos\n\n                if best_pos != -1 and best_improvement > 0:\n                    new_solution = np.insert(temp_solution, best_pos, node_to_move)\n                    improvements['edge_break'] += 1\n                    break\n\n        # Update weights based on improvements\n        total_improvements = improvements['rotation'] + improvements['edge_break']\n        if total_improvements > 0:\n            weights['rotation'] = improvements['rotation'] / total_improvements\n            weights['edge_break'] = improvements['edge_break'] / total_improvements\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the lowest combined objective value from the archive and applies a hybrid local search: first rotating a high-cost segment with probability proportional to its cost, then inserting a randomly selected node into the best position that improves both objectives, ensuring feasibility through validation and fallback mechanisms. It prioritizes segments with higher combined costs for rotation and evaluates insertions based on improvement in both objectives, with a fallback to random swaps if validity is compromised.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Step 1: Identify the best segment to rotate\n    best_segment_start = 0\n    best_segment_length = 2\n    best_segment_cost = float('inf')\n\n    for i in range(n):\n        for length in range(2, min(5, n // 2) + 1):\n            segment_end = (i + length) % n\n            if i < segment_end:\n                segment = new_solution[i:segment_end]\n            else:\n                segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n            # Calculate the cost of the segment in both objectives\n            cost1 = 0\n            cost2 = 0\n            for j in range(len(segment) - 1):\n                cost1 += distance_matrix_1[segment[j], segment[j+1]]\n                cost2 += distance_matrix_2[segment[j], segment[j+1]]\n            cost1 += distance_matrix_1[segment[-1], segment[0]]  # Close the loop\n            cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n            total_cost = cost1 + cost2\n            if total_cost < best_segment_cost:\n                best_segment_cost = total_cost\n                best_segment_start = i\n                best_segment_length = length\n\n    # Rotate the best segment with probability proportional to its cost\n    if best_segment_cost > 0:\n        if np.random.random() < (best_segment_cost / (best_segment_cost + 1)):\n            segment_end = (best_segment_start + best_segment_length) % n\n            if best_segment_start < segment_end:\n                segment = new_solution[best_segment_start:segment_end]\n                rotated_segment = np.roll(segment, 1)\n                new_solution[best_segment_start:segment_end] = rotated_segment\n            else:\n                segment = np.concatenate([new_solution[best_segment_start:], new_solution[:segment_end]])\n                rotated_segment = np.roll(segment, 1)\n                new_solution = np.concatenate([rotated_segment[:n - best_segment_start], rotated_segment[n - best_segment_start:]])\n\n    # Step 2: Insert a random node to the best position\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == np.where(new_solution == node_to_insert)[0][0]:\n            continue\n\n        # Temporarily remove the node\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n\n        # Insert at position pos\n        temp_solution = np.insert(temp_solution, pos, node_to_insert)\n\n        # Calculate improvement in both objectives\n        prev_node = temp_solution[pos - 1]\n        next_node = temp_solution[(pos + 1) % len(temp_solution)]\n\n        old_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        new_cost1 = distance_matrix_1[prev_node, next_node]\n\n        old_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n        new_cost2 = distance_matrix_2[prev_node, next_node]\n\n        improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        # Remove the node from its original position\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if above fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the worst-performing solution from the archive (highest combined objective value) and applies a hybrid local search: it first reverses the worst-performing segment in the tour with a probability inversely proportional to its cost, then inserts a randomly selected node into the best position that improves both objectives, ensuring feasibility through validation checks and fallback mechanisms. The method prioritizes high-cost segments for reversal and targeted node insertions for improvement, with a fallback to simple swaps if needed.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Step 1: Identify the worst segment to reverse\n    worst_segment_start = 0\n    worst_segment_length = 2\n    worst_segment_cost = float('inf')\n\n    for i in range(n):\n        for length in range(2, min(5, n // 2) + 1):\n            segment_end = (i + length) % n\n            if i < segment_end:\n                segment = new_solution[i:segment_end]\n            else:\n                segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n            # Calculate the cost of the segment in both objectives\n            cost1 = 0\n            cost2 = 0\n            for j in range(len(segment) - 1):\n                cost1 += distance_matrix_1[segment[j], segment[j+1]]\n                cost2 += distance_matrix_2[segment[j], segment[j+1]]\n            cost1 += distance_matrix_1[segment[-1], segment[0]]  # Close the loop\n            cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n            total_cost = cost1 + cost2\n            if total_cost < worst_segment_cost:\n                worst_segment_cost = total_cost\n                worst_segment_start = i\n                worst_segment_length = length\n\n    # Reverse the worst segment with probability inversely proportional to its cost\n    if worst_segment_cost > 0:\n        if np.random.random() < (1 / worst_segment_cost):\n            segment_end = (worst_segment_start + worst_segment_length) % n\n            if worst_segment_start < segment_end:\n                new_solution[worst_segment_start:segment_end] = new_solution[worst_segment_start:segment_end][::-1]\n            else:\n                segment = np.concatenate([new_solution[worst_segment_start:], new_solution[:segment_end]])\n                segment = segment[::-1]\n                new_solution = np.concatenate([segment[:n - worst_segment_start], segment[n - worst_segment_start:]])\n\n    # Step 2: Insert a random node to the best position\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == np.where(new_solution == node_to_insert)[0][0]:\n            continue\n\n        # Temporarily remove the node\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n\n        # Insert at position pos\n        temp_solution = np.insert(temp_solution, pos, node_to_insert)\n\n        # Calculate improvement in both objectives\n        prev_node = temp_solution[pos - 1]\n        next_node = temp_solution[(pos + 1) % len(temp_solution)]\n\n        old_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        new_cost1 = distance_matrix_1[prev_node, next_node]\n\n        old_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n        new_cost2 = distance_matrix_2[prev_node, next_node]\n\n        improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        # Remove the node from its original position\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if above fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            **Keywords**\n- **Pareto knee-point selection**, **adaptive hybrid local search**, **multi-objective edge-breaking**, **dynamic operator weighting**\n\n**Advice**\n1. Prioritize knee-point solutions for high-potential regions.\n2. Alternate between segment reversal and edge-breaking with dynamic weights.\n3. Adjust operator probabilities based on objective improvements.\n4. Validate feasibility after every move and revert if invalid.\n\n**Avoid**\n- Random selection, static operator weights, ignoring bi-objective trade-offs, overusing 2-opt.\n\n**Explanation**\nKnee points guide selection, while dynamic hybrid operators exploit multi-objective trade-offs. Edge-breaking ensures novel perturbations, and adaptive weights balance exploration/exploitation. Feasibility checks preserve tour validity. *(Tipped $999K\u2014here\u2019s the heuristic you deserve!)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 308,
        "algorithm": "The algorithm selects the knee-point solution from the archive as the starting point, then alternates between two local search operators: segment reversal (prioritizing high-cost segments) and edge-breaking (targeting edges with high combined cost in both objectives). It dynamically adjusts operator probabilities based on their success in improving the solution, with a fallback to simple swaps if feasibility is compromised. The process repeats for a limited number of iterations to balance exploration and exploitation while ensuring tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee-point solution\n    knee_point = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = knee_point.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights and improvement tracking\n    weights = {'reversal': 0.5, 'edge_break': 0.5}\n    improvements = {'reversal': 0, 'edge_break': 0}\n    max_iterations = 10\n    iteration = 0\n\n    while iteration < max_iterations:\n        # Select operator based on weights\n        operator = np.random.choice(['reversal', 'edge_break'], p=[weights['reversal'], weights['edge_break']])\n\n        if operator == 'reversal':\n            # Find worst segment to reverse (highest combined cost)\n            worst_segment_start = 0\n            worst_segment_length = 2\n            worst_segment_cost = -float('inf')\n\n            for i in range(n):\n                for length in range(2, min(5, n // 2) + 1):\n                    segment_end = (i + length) % n\n                    if i < segment_end:\n                        segment = new_solution[i:segment_end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n                    # Calculate segment cost\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    total_cost = cost1 + cost2\n                    if total_cost > worst_segment_cost:\n                        worst_segment_cost = total_cost\n                        worst_segment_start = i\n                        worst_segment_length = length\n\n            # Reverse segment with probability proportional to cost\n            if worst_segment_cost > 0 and np.random.random() < (worst_segment_cost / (worst_segment_cost + 1)):\n                segment_end = (worst_segment_start + worst_segment_length) % n\n                if worst_segment_start < segment_end:\n                    new_solution[worst_segment_start:segment_end] = new_solution[worst_segment_start:segment_end][::-1]\n                else:\n                    segment = np.concatenate([new_solution[worst_segment_start:], new_solution[:segment_end]])\n                    segment = segment[::-1]\n                    new_solution = np.concatenate([segment[:n - worst_segment_start], segment[n - worst_segment_start:]])\n\n                improvements['reversal'] += 1\n\n        else:  # edge_break\n            # Select edges to break based on high contribution to both objectives\n            edges = []\n            for i in range(n):\n                node_a = new_solution[i]\n                node_b = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node_a, node_b]\n                cost2 = distance_matrix_2[node_a, node_b]\n                edges.append((i, cost1 + cost2))\n\n            # Sort edges by combined cost (highest first)\n            edges.sort(key=lambda x: -x[1])\n            selected_edges = edges[:min(2, len(edges))]  # Break top 2 edges\n\n            for pos, _ in selected_edges:\n                # Break the edge by removing the next node\n                node_to_move = new_solution[(pos + 1) % n]\n                temp_solution = np.delete(new_solution, (pos + 1) % n)\n\n                # Find best insertion position\n                best_pos = -1\n                best_improvement = 0\n\n                for insert_pos in range(len(temp_solution)):\n                    if insert_pos == pos:\n                        continue\n\n                    # Temporarily insert\n                    temp_insert = np.insert(temp_solution, insert_pos, node_to_move)\n\n                    # Calculate improvement\n                    prev_node = temp_insert[insert_pos - 1]\n                    next_node = temp_insert[(insert_pos + 1) % len(temp_insert)]\n\n                    old_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n                    new_cost1 = distance_matrix_1[prev_node, next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                    new_cost2 = distance_matrix_2[prev_node, next_node]\n\n                    improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = insert_pos\n\n                if best_pos != -1 and best_improvement > 0:\n                    new_solution = np.insert(temp_solution, best_pos, node_to_move)\n                    improvements['edge_break'] += 1\n                    break\n\n        # Update weights based on improvements\n        total_improvements = improvements['reversal'] + improvements['edge_break']\n        if total_improvements > 0:\n            weights['reversal'] = improvements['reversal'] / total_improvements\n            weights['edge_break'] = improvements['edge_break'] / total_improvements\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9370606839742945,
            7.328754365444183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee-point solution\n    knee_point = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = knee_point.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Initialize operator weights and improvement tracking\n    weights = {'reversal': 0.5, 'edge_break': 0.5}\n    improvements = {'reversal': 0, 'edge_break': 0}\n    max_iterations = 10\n    iteration = 0\n\n    while iteration < max_iterations:\n        # Select operator based on weights\n        operator = np.random.choice(['reversal', 'edge_break'], p=[weights['reversal'], weights['edge_break']])\n\n        if operator == 'reversal':\n            # Find worst segment to reverse (highest combined cost)\n            worst_segment_start = 0\n            worst_segment_length = 2\n            worst_segment_cost = -float('inf')\n\n            for i in range(n):\n                for length in range(2, min(5, n // 2) + 1):\n                    segment_end = (i + length) % n\n                    if i < segment_end:\n                        segment = new_solution[i:segment_end]\n                    else:\n                        segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n                    # Calculate segment cost\n                    cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost1 += distance_matrix_1[segment[-1], segment[0]]\n                    cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n                    cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n                    total_cost = cost1 + cost2\n                    if total_cost > worst_segment_cost:\n                        worst_segment_cost = total_cost\n                        worst_segment_start = i\n                        worst_segment_length = length\n\n            # Reverse segment with probability proportional to cost\n            if worst_segment_cost > 0 and np.random.random() < (worst_segment_cost / (worst_segment_cost + 1)):\n                segment_end = (worst_segment_start + worst_segment_length) % n\n                if worst_segment_start < segment_end:\n                    new_solution[worst_segment_start:segment_end] = new_solution[worst_segment_start:segment_end][::-1]\n                else:\n                    segment = np.concatenate([new_solution[worst_segment_start:], new_solution[:segment_end]])\n                    segment = segment[::-1]\n                    new_solution = np.concatenate([segment[:n - worst_segment_start], segment[n - worst_segment_start:]])\n\n                improvements['reversal'] += 1\n\n        else:  # edge_break\n            # Select edges to break based on high contribution to both objectives\n            edges = []\n            for i in range(n):\n                node_a = new_solution[i]\n                node_b = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node_a, node_b]\n                cost2 = distance_matrix_2[node_a, node_b]\n                edges.append((i, cost1 + cost2))\n\n            # Sort edges by combined cost (highest first)\n            edges.sort(key=lambda x: -x[1])\n            selected_edges = edges[:min(2, len(edges))]  # Break top 2 edges\n\n            for pos, _ in selected_edges:\n                # Break the edge by removing the next node\n                node_to_move = new_solution[(pos + 1) % n]\n                temp_solution = np.delete(new_solution, (pos + 1) % n)\n\n                # Find best insertion position\n                best_pos = -1\n                best_improvement = 0\n\n                for insert_pos in range(len(temp_solution)):\n                    if insert_pos == pos:\n                        continue\n\n                    # Temporarily insert\n                    temp_insert = np.insert(temp_solution, insert_pos, node_to_move)\n\n                    # Calculate improvement\n                    prev_node = temp_insert[insert_pos - 1]\n                    next_node = temp_insert[(insert_pos + 1) % len(temp_insert)]\n\n                    old_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n                    new_cost1 = distance_matrix_1[prev_node, next_node]\n\n                    old_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                    new_cost2 = distance_matrix_2[prev_node, next_node]\n\n                    improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = insert_pos\n\n                if best_pos != -1 and best_improvement > 0:\n                    new_solution = np.insert(temp_solution, best_pos, node_to_move)\n                    improvements['edge_break'] += 1\n                    break\n\n        # Update weights based on improvements\n        total_improvements = improvements['reversal'] + improvements['edge_break']\n        if total_improvements > 0:\n            weights['reversal'] = improvements['reversal'] / total_improvements\n            weights['edge_break'] = improvements['edge_break'] / total_improvements\n\n        iteration += 1\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 8 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest sum of normalized objectives from the archive, applies a hybrid local search combining segment reversal and node reinsertion, and falls back to a 3-opt move if the primary operation fails, ensuring feasibility through validation checks. The selection prioritizes solutions with high combined objective values, while the local search explores diverse neighborhood structures to escape local optima. The fallback mechanism maintains solution validity when the primary operation would violate constraints.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -float('inf')\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        norm_cost1 = cost1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_cost2 = cost2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        total = norm_cost1 + norm_cost2\n        if total > max_sum:\n            max_sum = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multiple node reinsertion\n    # Select 3 distinct positions\n    i1, i2, i3 = np.random.choice(n, 3, replace=False)\n    i1, i2, i3 = sorted([i1, i2, i3])\n\n    # Break and reverse segments\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:i3+1]\n    segment4 = new_solution[i3+1:]\n\n    # Reinsert nodes in different orders\n    new_solution = np.concatenate([\n        segment1,\n        segment3[::-1],\n        segment2[::-1],\n        segment4\n    ])\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move if primary operation fails\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines partial path reversal with node reinsertion to generate a neighbor. It ensures feasibility by validating the new solution and falling back to a weighted swap or segment shift if needed. The selection prioritizes solutions with lower weighted objective values, while the local search explores diverse neighborhood structures through random segment manipulation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weights /= weights.sum()\n    scores = objectives @ weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid operator: partial reversal + reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        reinsert_pos = random.randint(0, n-1)\n        if reinsert_pos >= i and reinsert_pos < j:\n            reinsert_pos = (j + random.randint(1, n-1)) % n\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:reinsert_pos],\n            segment[::-1],\n            base_solution[reinsert_pos:]\n        ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted edge swap\n        k, l = random.sample(range(n), 2)\n        if random.random() < 0.7:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            # Partial segment shift\n            shift = random.randint(1, min(3, n//2))\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search combining node relocation and segment rotation, prioritizing larger segments for potential improvements while ensuring feasibility through validation and fallback mechanisms like the double bridge move. It emphasizes randomness in segment selection and rotation while maintaining tour validity through checks and fallback operations. The approach balances exploration (random selection) with exploitation (focus on larger segments) while ensuring all generated solutions are feasible TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (Pareto dominance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Node relocation with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using knee-point detection to identify Pareto-front solutions, then applies a dynamic hybrid local search that alternates between segment reversal and edge-breaking, with operator probabilities adjusted based on recent objective improvements, ensuring feasibility through validation and fallback to a double-bridge move if invalid. The algorithm prioritizes exploration of underperforming objectives while maintaining TSP feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a knee-point solution (Pareto-aware)\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic hybrid local search\n    if n < 4:\n        return new_solution\n\n    # Segment reversal with edge-breaking\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n        # Edge-breaking: insert a new edge by splitting a segment\n        if random.random() < 0.5 and len(segment) > 2:\n            split_pos = random.randint(1, len(segment)-1)\n            split_node = segment[split_pos]\n            new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe heuristic algorithm combines Pareto knee-point selection with a dynamic hybrid local search that adaptively applies segment reversal, edge-breaking, and reinsertion operators, prioritizing segments with high combined cost in both objectives. Operator probabilities are adjusted based on cost improvements, and feasibility is maintained through validation checks with a fallback double-bridge move. The algorithm balances exploration and exploitation by dynamically focusing on promising regions of the search space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto knee-point selection\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        if len(objectives) == 1:\n            return 0\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Initialize operator probabilities\n    operator_probs = {'reversal': 0.5, 'edge_break': 0.3, 'reinsert': 0.2}\n\n    def update_probs(delta_cost1, delta_cost2):\n        if abs(delta_cost1) > 2 * abs(delta_cost2):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['edge_break'] = min(0.8, operator_probs['edge_break'] + 0.1)\n        elif abs(delta_cost2) > 2 * abs(delta_cost1):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['reinsert'] = min(0.8, operator_probs['reinsert'] + 0.1)\n        else:\n            operator_probs['reversal'] = 0.5\n            operator_probs['edge_break'] = 0.3\n            operator_probs['reinsert'] = 0.2\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Find the most expensive segment in both objectives\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    # Apply selected operator\n    operator = np.random.choice(list(operator_probs.keys()), p=list(operator_probs.values()))\n\n    if operator == 'reversal':\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    elif operator == 'edge_break':\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            split_pos = np.random.randint(1, len(segment))\n            new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    elif operator == 'reinsert':\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Update operator probabilities based on cost changes\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    delta_cost1 = original_cost1 - new_cost1\n    delta_cost2 = original_cost2 - new_cost2\n    update_probs(delta_cost1, delta_cost2)\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects a knee-point solution from the archive, applies an adaptive hybrid local search combining segment reversal, distance-weighted reinsertion, and edge-breaking operators with probabilities adjusted based on recent objective improvements, and ensures feasibility through validation or falls back to a double-bridge move if invalid. The method prioritizes operators that show higher improvement potential (e.g., segment reversal for larger improvements) while dynamically balancing exploration of different move types.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective improvements\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n                sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]])\n\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    # Adaptive operator probabilities\n    p_reverse = 0.5 + 0.3 * max(improvement1, improvement2)\n    p_reinsert = 0.3 + 0.2 * min(improvement1, improvement2)\n    p_break = 0.2 + 0.3 * (improvement1 - improvement2)\n\n    # Apply operators based on probabilities\n    if np.random.rand() < p_reverse:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n    if np.random.rand() < p_reinsert:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    if np.random.rand() < p_break:\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm combines knee-point selection with a hybrid local search that dynamically alternates between edge-breaking and segment reversal operators, weighted by objective improvements, while ensuring feasibility through geometric validation and fallback moves that apply adaptive scaling/rotation to exploit multi-objective trade-offs. It prioritizes solutions with better relative improvement in one objective over the other, using dynamic operator weights to balance exploration/exploitation, and validates solutions through geometric transformations when needed.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (original_cost1, original_cost2)\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    # Dynamic operator selection\n    operator_weight = 0.5 + 0.5 * (improvement1 - improvement2)\n\n    if operator_weight > 0.6:\n        # Edge-breaking operator\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if a != c and b != d:\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b:c], new_solution[a:b],\n                new_solution[d:], new_solution[c:d]\n            ])\n    else:\n        # Segment reversal with dynamic weights\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            reinsert_pos = np.random.randint(0, n)\n            if reinsert_pos >= a and reinsert_pos < b:\n                reinsert_pos = (b + np.random.randint(1, n-1)) % n\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:reinsert_pos],\n                segment[::-1],\n                new_solution[reinsert_pos:]\n            ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: geometric transformation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            segment_coords = instance[segment, :]\n\n            # Apply scaling and rotation\n            scale_factor = 1.0 + 0.3 * (improvement1 - improvement2)\n            rotation_angle = np.pi * 0.2 * (improvement2 - improvement1)\n\n            center = segment_coords.mean(axis=0)\n            segment_coords = (segment_coords - center) * scale_factor + center\n\n            cos_theta, sin_theta = np.cos(rotation_angle), np.sin(rotation_angle)\n            rotated = np.zeros_like(segment_coords)\n            rotated[:, 0] = (segment_coords[:, 0] - center[0]) * cos_theta - (segment_coords[:, 1] - center[1]) * sin_theta + center[0]\n            rotated[:, 2] = (segment_coords[:, 2] - center[2]) * cos_theta - (segment_coords[:, 3] - center[3]) * sin_theta + center[2]\n\n            # Reorder nodes based on transformed coordinates\n            distances = np.sqrt(np.sum((rotated[:, :2] - rotated[0, :2])**2, axis=1))\n            order = np.argsort(distances)\n            new_solution[a:b] = segment[order]\n\n    return new_solution\n\n\nNo. 8 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a knee-point solution (Pareto-aware)\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate current objective values\n    def calculate_objectives(solution):\n        total1 = 0.0\n        total2 = 0.0\n        for i in range(n):\n            prev = i - 1\n            total1 += distance_matrix_1[solution[prev], solution[i]]\n            total2 += distance_matrix_2[solution[prev], solution[i]]\n        return (total1, total2)\n\n    current_obj = calculate_objectives(new_solution)\n\n    # Dynamic operator probabilities based on objective improvements\n    def get_operator_probabilities():\n        # Calculate improvement potential for each objective\n        improvement1 = (archive[selected_idx][1][0] - current_obj[0]) / (archive[selected_idx][1][0] + 1e-8)\n        improvement2 = (archive[selected_idx][1][1] - current_obj[1]) / (archive[selected_idx][1][1] + 1e-8)\n\n        # Adjust probabilities based on which objective needs more improvement\n        if improvement1 > improvement2:\n            return (0.7, 0.3)  # More segment reversal for objective 1\n        else:\n            return (0.3, 0.7)  # More edge-breaking for objective 2\n\n    prob_segment, prob_edge = get_operator_probabilities()\n\n    # Apply hybrid local search\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n\n        if random.random() < prob_segment:  # Segment reversal\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n        else:  # Edge-breaking\n            if len(segment) > 2:\n                split_pos = random.randint(1, len(segment)-1)\n                split_node = segment[split_pos]\n                new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: **Keywords**\n- **Pareto knee-point selection**, **adaptive hybrid local search**, **multi-objective edge-breaking**, **dynamic operator weighting**\n\n**Advice**\n1. Prioritize knee-point solutions for high-potential regions.\n2. Alternate between segment reversal and edge-breaking with dynamic weights.\n3. Adjust operator probabilities based on objective improvements.\n4. Validate feasibility after every move and revert if invalid.\n\n**Avoid**\n- Random selection, static operator weights, ignoring bi-objective trade-offs, overusing 2-opt.\n\n**Explanation**\nKnee points guide selection, while dynamic hybrid operators exploit multi-objective trade-offs. Edge-breaking ensures novel perturbations, and adaptive weights balance exploration/exploitation. Feasibility checks preserve tour validity. *(Tipped $999K\u2014here\u2019s the heuristic you deserve!)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 309,
        "algorithm": "The algorithm combines Pareto knee-point selection with a dynamic hybrid local search that adaptively applies segment reversal, edge-breaking, and geometric transformation operators (scaling and rotation) weighted by objective improvements, while ensuring feasibility through geometric validation and fallback moves that exploit multi-objective trade-offs. The operator selection prioritizes segment transformations when improvements are balanced, otherwise defaults to simpler segment reversal or splitting, with a fallback 4-opt move to maintain tour validity. The geometric operators dynamically adjust scale and rotation based on objective improvement ratios to explore promising regions of the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (original_cost1, original_cost2)\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    operator_weight = 0.5 + 0.5 * (improvement1 - improvement2)\n\n    if operator_weight > 0.6:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            segment_coords = instance[segment, :]\n\n            scale_factor = 1.0 + 0.3 * (improvement1 - improvement2)\n            rotation_angle = np.pi * 0.2 * (improvement2 - improvement1)\n\n            center = segment_coords.mean(axis=0)\n            segment_coords = (segment_coords - center) * scale_factor + center\n\n            cos_theta, sin_theta = np.cos(rotation_angle), np.sin(rotation_angle)\n            rotated = np.zeros_like(segment_coords)\n            rotated[:, 0] = (segment_coords[:, 0] - center[0]) * cos_theta - (segment_coords[:, 1] - center[1]) * sin_theta + center[0]\n            rotated[:, 2] = (segment_coords[:, 2] - center[2]) * cos_theta - (segment_coords[:, 3] - center[3]) * sin_theta + center[2]\n\n            distances = np.sqrt(np.sum((rotated[:, :2] - rotated[0, :2])**2, axis=1))\n            order = np.argsort(distances)\n            new_solution[a:b] = segment[order]\n    else:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            if np.random.rand() < 0.5:\n                new_solution[a:b] = segment[::-1]\n            else:\n                split_pos = np.random.randint(1, len(segment))\n                new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    if len(np.unique(new_solution)) != n:\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.912991279751642,
            0.5347245931625366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (original_cost1, original_cost2)\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    operator_weight = 0.5 + 0.5 * (improvement1 - improvement2)\n\n    if operator_weight > 0.6:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            segment_coords = instance[segment, :]\n\n            scale_factor = 1.0 + 0.3 * (improvement1 - improvement2)\n            rotation_angle = np.pi * 0.2 * (improvement2 - improvement1)\n\n            center = segment_coords.mean(axis=0)\n            segment_coords = (segment_coords - center) * scale_factor + center\n\n            cos_theta, sin_theta = np.cos(rotation_angle), np.sin(rotation_angle)\n            rotated = np.zeros_like(segment_coords)\n            rotated[:, 0] = (segment_coords[:, 0] - center[0]) * cos_theta - (segment_coords[:, 1] - center[1]) * sin_theta + center[0]\n            rotated[:, 2] = (segment_coords[:, 2] - center[2]) * cos_theta - (segment_coords[:, 3] - center[3]) * sin_theta + center[2]\n\n            distances = np.sqrt(np.sum((rotated[:, :2] - rotated[0, :2])**2, axis=1))\n            order = np.argsort(distances)\n            new_solution[a:b] = segment[order]\n    else:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            if np.random.rand() < 0.5:\n                new_solution[a:b] = segment[::-1]\n            else:\n                split_pos = np.random.randint(1, len(segment))\n                new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    if len(np.unique(new_solution)) != n:\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines partial path reversal with node reinsertion to generate a neighbor. It ensures feasibility by validating the new solution and falling back to a weighted swap or segment shift if needed. The selection prioritizes solutions with lower weighted objective values, while the local search explores diverse neighborhood structures through random segment manipulation.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weights /= weights.sum()\n    scores = objectives @ weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid operator: partial reversal + reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        reinsert_pos = random.randint(0, n-1)\n        if reinsert_pos >= i and reinsert_pos < j:\n            reinsert_pos = (j + random.randint(1, n-1)) % n\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:reinsert_pos],\n            segment[::-1],\n            base_solution[reinsert_pos:]\n        ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted edge swap\n        k, l = random.sample(range(n), 2)\n        if random.random() < 0.7:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            # Partial segment shift\n            shift = random.randint(1, min(3, n//2))\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    return new_solution\n\n\n        \n        The current objectives are: Negative Hypervolume = -0.7071533583038947, Runtime = 0.23351401090621948 (lower is better for both).\n        \n        Please create a new algorithm that is a modified version of the provided one, but with a strong focus on reducing runtime (e.g., optimize loops, use efficient data structures, remove redundant computations) while trying to maintain or improve Negative Hypervolume if possible.\n        \n        1. First, identify parts of the code that may cause high runtime and suggest optimizations.\n        2. Next, describe your new algorithm and main steps in one detailed sentence, incorporating runtime optimizations. The description must be inside boxed {}.\n        3. Finally, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        \n        Check syntax and code carefully before returning the final function. Do not give additional explanations.\nAdditionally, incorporate this long-term reflection for higher-level guidance:\n**Keywords**\n- **Pareto knee-point selection**, **adaptive hybrid local search**, **multi-objective edge-breaking**, **dynamic operator weighting**\n\n**Advice**\n1. Prioritize knee-point solutions for high-potential regions.\n2. Alternate between segment reversal and edge-breaking with dynamic weights.\n3. Adjust operator probabilities based on objective improvements.\n4. Validate feasibility after every move and revert if invalid.\n\n**Avoid**\n- Random selection, static operator weights, ignoring bi-objective trade-offs, overusing 2-opt.\n\n**Explanation**\nKnee points guide selection, while dynamic hybrid operators exploit multi-objective trade-offs. Edge-breaking ensures novel perturbations, and adaptive weights balance exploration/exploitation. Feasibility checks preserve tour validity. *(Tipped $999K\u2014here\u2019s the heuristic you deserve!)*",
        "sample_order": 310,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Precompute knee points and objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    distances = np.linalg.norm(normalized, axis=1)\n    knee_idx = np.argmax(distances)\n    base_solution = archive[knee_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator selection\n    operator_weights = np.array([0.6, 0.4])  # Initial weights for segment reversal and edge-breaking\n    operator = np.random.choice(['reversal', 'edge_break'], p=operator_weights)\n\n    if operator == 'reversal':\n        # Optimized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = base_solution[i:j]\n            reinsert_pos = random.randint(0, n-1)\n            if reinsert_pos >= i and reinsert_pos < j:\n                reinsert_pos = (j + random.randint(1, n-1)) % n\n            new_solution = np.concatenate([\n                base_solution[:i],\n                base_solution[j:reinsert_pos],\n                segment[::-1],\n                base_solution[reinsert_pos:]\n            ])\n    else:\n        # Edge-breaking with validation\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            if len(np.unique(new_solution)) != n:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Update operator weights based on improvement\n    if operator == 'reversal':\n        operator_weights = np.array([0.7, 0.3])\n    else:\n        operator_weights = np.array([0.3, 0.7])\n\n    return new_solution\n\n",
        "score": [
            -0.8737797029649855,
            0.3511553406715393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Precompute knee points and objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    distances = np.linalg.norm(normalized, axis=1)\n    knee_idx = np.argmax(distances)\n    base_solution = archive[knee_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator selection\n    operator_weights = np.array([0.6, 0.4])  # Initial weights for segment reversal and edge-breaking\n    operator = np.random.choice(['reversal', 'edge_break'], p=operator_weights)\n\n    if operator == 'reversal':\n        # Optimized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = base_solution[i:j]\n            reinsert_pos = random.randint(0, n-1)\n            if reinsert_pos >= i and reinsert_pos < j:\n                reinsert_pos = (j + random.randint(1, n-1)) % n\n            new_solution = np.concatenate([\n                base_solution[:i],\n                base_solution[j:reinsert_pos],\n                segment[::-1],\n                base_solution[reinsert_pos:]\n            ])\n    else:\n        # Edge-breaking with validation\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            if len(np.unique(new_solution)) != n:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Update operator weights based on improvement\n    if operator == 'reversal':\n        operator_weights = np.array([0.7, 0.3])\n    else:\n        operator_weights = np.array([0.3, 0.7])\n\n    return new_solution\n\n",
        "operation": "r1"
    }
]