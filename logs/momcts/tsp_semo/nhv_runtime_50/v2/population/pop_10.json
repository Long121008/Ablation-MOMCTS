[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (70% average cost, 30% maximum cost) and applies a hybrid local search that combines path reversal (with probability based on segment distance) and adaptive segment swapping (smaller segments with lower probability). It ensures feasibility through fallback mechanisms (3-opt and random segment shuffles) if uniqueness is violated. The method prioritizes diversity and adaptive exploration to navigate the bi-objective TSP landscape efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_scores = [0.7 * (obj[0] + obj[1]) + 0.3 * max(obj[0], obj[1]) for _, obj in archive]\n    base_solution = archive[np.argmax(weighted_scores)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on distance metrics\n    i1, i2 = np.random.choice(n, 2, replace=False)\n    if i1 > i2:\n        i1, i2 = i2, i1\n\n    # Calculate segment distances in both objective spaces\n    def segment_distance(solution, start, end, matrix1, matrix2):\n        d1 = sum(matrix1[solution[i], solution[i+1]] for i in range(start, end))\n        d2 = sum(matrix2[solution[i], solution[i+1]] for i in range(start, end))\n        return d1 + d2\n\n    current_dist = segment_distance(new_solution, i1, i2, distance_matrix_1, distance_matrix_2)\n\n    # Try path reversal with probability based on segment distance\n    if np.random.random() < 0.7 or current_dist > np.mean([segment_distance(new_solution, i, i+1, distance_matrix_1, distance_matrix_2) for i in range(n-1)]):\n        new_solution[i1:i2+1] = new_solution[i1:i2+1][::-1]\n\n    # Adaptive segment swapping\n    if np.random.random() < 0.4:\n        swap_size = min(3, n // 4)\n        pos1, pos2 = np.random.choice(n - swap_size, 2, replace=False)\n        segment1 = new_solution[pos1:pos1+swap_size]\n        segment2 = new_solution[pos2:pos2+swap_size]\n        new_solution[pos1:pos1+swap_size] = segment2\n        new_solution[pos2:pos2+swap_size] = segment1\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Advanced fallback: 3-opt local search\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1]\n        segment3 = new_solution[j+1:k+1]\n        segment4 = new_solution[k+1:]\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Last resort: random shuffle of a segment\n        segment_size = max(2, n // 5)\n        pos = np.random.randint(0, n - segment_size + 1)\n        new_solution[pos:pos+segment_size] = np.random.permutation(new_solution[pos:pos+segment_size])\n\n    return new_solution\n\n",
        "score": [
            -0.9454238497222858,
            0.3994055390357971
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest sum of normalized objectives from the archive, applies a hybrid local search combining segment reversal and node reinsertion, and falls back to a 3-opt move if the primary operation fails, ensuring feasibility through validation checks. The selection prioritizes solutions with high combined objective values, while the local search explores diverse neighborhood structures to escape local optima. The fallback mechanism maintains solution validity when the primary operation would violate constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_sum = -float('inf')\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        norm_cost1 = cost1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_cost2 = cost2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        total = norm_cost1 + norm_cost2\n        if total > max_sum:\n            max_sum = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multiple node reinsertion\n    # Select 3 distinct positions\n    i1, i2, i3 = np.random.choice(n, 3, replace=False)\n    i1, i2, i3 = sorted([i1, i2, i3])\n\n    # Break and reverse segments\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:i3+1]\n    segment4 = new_solution[i3+1:]\n\n    # Reinsert nodes in different orders\n    new_solution = np.concatenate([\n        segment1,\n        segment3[::-1],\n        segment2[::-1],\n        segment4\n    ])\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move if primary operation fails\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.0048094662706575,
            1.2336682081222534
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective cost from the archive and applies a hybrid local search operator that randomly relocates a segment of the tour to a new position, ensuring feasibility by maintaining a valid TSP tour structure. The method prioritizes solutions with higher total cost to focus on promising regions of the search space, while the segment relocation strategy introduces diversity by disrupting and reinserting sub-tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge insertion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Remove the segment\n    if start < end:\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        new_solution = np.concatenate([new_solution[end:start], new_solution[start:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8550530386352858,
            0.4085387587547302
        ]
    },
    {
        "algorithm": "The heuristic selects the highest-scoring solution from the archive (sum of both objectives) and applies a hybrid local search that randomly breaks and reverses segments of the tour to explore diverse neighborhoods while ensuring feasibility through validation checks. It prioritizes solutions with combined higher costs to focus improvement efforts and uses a fallback swap if the reinsertion fails. The algorithm balances exploration and exploitation by combining edge manipulation with node reinsertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct edges to break\n    i1, i2 = np.random.choice(n, 2, replace=False)\n    if i1 > i2:\n        i1, i2 = i2, i1\n\n    # Break the edges and reinsert nodes\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:]\n\n    # Combine segments with nodes reinserted\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reinsertion fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9429277113147808,
            0.4586946964263916
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge insertion and segment reversal, ensuring feasibility by validating the new solution. It prioritizes larger segments for reversal/insertion to maximize improvement potential, with a fallback to simple swaps if needed. The method balances exploration (random selection) with exploitation (targeted segment operations) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        new_solution = np.concatenate([base_solution[:i], segment[::-1], base_solution[j:]])\n\n    # Segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = base_solution[a:b]\n        new_solution = np.concatenate([base_solution[:a], segment[::-1], base_solution[b:]])\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if above fails\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8760701871960721,
            0.44710928201675415
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined cost from the archive (prioritizing less optimal solutions for improvement) and applies a hybrid local search combining edge exchange (reversing a segment between two random nodes) and node insertion (relocating a node to the best position based on reduced total distance in both objective spaces). The method ensures feasibility by maintaining a valid TSP tour throughout the operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost = -1\n    selected_solution = None\n    for sol, (cost1, cost2) in archive:\n        total_cost = cost1 + cost2\n        if total_cost > max_cost:\n            max_cost = total_cost\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: apply a combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == j:\n        j = (j + 1) % n\n\n    # Reverse the segment between i and j to explore different paths\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion (move a random node to a better position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n\n    # Find the best insertion point for the node in both objective spaces\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Remove node from current position and insert at pos\n        temp_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        temp_solution = np.insert(temp_solution, pos, node)\n\n        # Calculate the change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n\n        new_cost1 = distance_matrix_1[temp_solution[pos-1], node] + distance_matrix_1[node, temp_solution[(pos+1)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[pos-1], node] + distance_matrix_2[node, temp_solution[(pos+1)%n]]\n\n        improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9148601407625312,
            1.1084784865379333
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel edge-swapping heuristic to generate a neighbor solution, prioritizing distance reduction in both objective spaces while ensuring feasibility. It randomly selects segments for 3-opt moves and performs limited edge swaps based on distance improvements in both coordinate spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: 3-opt with edge-swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply edge-swapping based on distance reduction\n    for _ in range(3):  # Limit the number of swaps\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == b:\n            continue\n\n        # Calculate current and potential new distances\n        current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_dist < current_dist:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7480362928678657,
            0.5066812634468079
        ]
    },
    {
        "algorithm": "The algorithm prioritizes high-cost solutions from the archive, identifies the most expensive segment in the tour using both objective-specific distance matrices, and reverses that segment to generate a neighbor solution while ensuring feasibility through validation checks and fallback mechanisms. It adaptively selects segment lengths and balances exploration/exploitation by leveraging multi-objective guidance, focusing on segments with potential improvement in either or both objectives. The fallback mechanism handles infeasibility by randomly swapping nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate the total cost of the current segment in both objectives\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment) - 1):\n            cost1 += distance_matrix_1[segment[i], segment[i+1]]\n            cost2 += distance_matrix_2[segment[i], segment[i+1]]\n        if len(segment) > 1:\n            cost1 += distance_matrix_1[segment[-1], segment[0]]\n            cost2 += distance_matrix_2[segment[-1], segment[0]]\n        return cost1, cost2\n\n    # Find the most expensive segment to reverse\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(5, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    # Reverse the selected segment\n    start = best_start\n    length = best_length\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    reversed_segment = segment[::-1]\n\n    if start < end:\n        new_solution[start:end] = reversed_segment\n    else:\n        new_solution[:end] = reversed_segment[:end]\n        new_solution[end:start] = reversed_segment[end:]\n\n    # Validate the solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback: randomly swap two nodes if the reversal causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8561046575066339,
            0.9213894605636597
        ]
    },
    {
        "algorithm": "The algorithm selects the highest-cost solution from the archive (sum of both objectives) and applies a hybrid local search alternating between segment reversal and edge-breaking, prioritizing moves that improve at least one objective while ensuring feasibility through validation checks. It intelligently reverts worsening moves and falls back to simple swaps if needed. The selection of segments and insertion points is random but validated against both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the highest-cost solution for improvement\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Alternate between segment reversal and edge-breaking\n    if random.random() < 0.5:\n        # Segment reversal with objective-aware selection\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n\n            # Objective-aware validation\n            original_cost1 = sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            original_cost2 = sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            # Revert if both objectives worsen\n            if new_cost1 > original_cost1 and new_cost2 > original_cost2:\n                new_solution = selected_solution.copy()\n    else:\n        # Edge-breaking with objective-aware insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Break and reinsert segment\n            segment = new_solution[i:j]\n            remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.insert(remaining, insert_pos, segment)\n\n            # Objective-aware validation\n            original_cost1 = sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            original_cost2 = sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            # Revert if both objectives worsen\n            if new_cost1 > original_cost1 and new_cost2 > original_cost2:\n                new_solution = selected_solution.copy()\n\n    # Final validation check\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if above fails\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8007889918136013,
            0.5371711850166321
        ]
    }
]