[
    {
        "algorithm": "The algorithm selects the solution with the highest sum of normalized objectives from the archive, applies a hybrid local search combining segment reversal and node reinsertion, and falls back to a 3-opt move if the primary operation fails, ensuring feasibility through validation checks. The selection prioritizes solutions with high combined objective values, while the local search explores diverse neighborhood structures to escape local optima. The fallback mechanism maintains solution validity when the primary operation would violate constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -float('inf')\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        norm_cost1 = cost1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_cost2 = cost2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        total = norm_cost1 + norm_cost2\n        if total > max_sum:\n            max_sum = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multiple node reinsertion\n    # Select 3 distinct positions\n    i1, i2, i3 = np.random.choice(n, 3, replace=False)\n    i1, i2, i3 = sorted([i1, i2, i3])\n\n    # Break and reverse segments\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:i3+1]\n    segment4 = new_solution[i3+1:]\n\n    # Reinsert nodes in different orders\n    new_solution = np.concatenate([\n        segment1,\n        segment3[::-1],\n        segment2[::-1],\n        segment4\n    ])\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move if primary operation fails\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.0048094662706575,
            1.2336682081222534
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines partial path reversal with node reinsertion to generate a neighbor. It ensures feasibility by validating the new solution and falling back to a weighted swap or segment shift if needed. The selection prioritizes solutions with lower weighted objective values, while the local search explores diverse neighborhood structures through random segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weights /= weights.sum()\n    scores = objectives @ weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid operator: partial reversal + reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        reinsert_pos = random.randint(0, n-1)\n        if reinsert_pos >= i and reinsert_pos < j:\n            reinsert_pos = (j + random.randint(1, n-1)) % n\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:reinsert_pos],\n            segment[::-1],\n            base_solution[reinsert_pos:]\n        ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted edge swap\n        k, l = random.sample(range(n), 2)\n        if random.random() < 0.7:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            # Partial segment shift\n            shift = random.randint(1, min(3, n//2))\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7071533583038947,
            0.23351401090621948
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining node relocation and segment rotation, prioritizing larger segments for potential improvements while ensuring feasibility through validation and fallback mechanisms like the double bridge move. It emphasizes randomness in segment selection and rotation while maintaining tour validity through checks and fallback operations. The approach balances exploration (random selection) with exploitation (focus on larger segments) while ensuring all generated solutions are feasible TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (Pareto dominance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Node relocation with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.885361404984967,
            0.24587023258209229
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using knee-point detection to identify Pareto-front solutions, then applies a dynamic hybrid local search that alternates between segment reversal and edge-breaking, with operator probabilities adjusted based on recent objective improvements, ensuring feasibility through validation and fallback to a double-bridge move if invalid. The algorithm prioritizes exploration of underperforming objectives while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a knee-point solution (Pareto-aware)\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic hybrid local search\n    if n < 4:\n        return new_solution\n\n    # Segment reversal with edge-breaking\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n        # Edge-breaking: insert a new edge by splitting a segment\n        if random.random() < 0.5 and len(segment) > 2:\n            split_pos = random.randint(1, len(segment)-1)\n            split_node = segment[split_pos]\n            new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9795087266408445,
            0.3194284439086914
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective score (prioritizing the first objective) and applies a hybrid local search combining segment inversion and node insertion, with adaptive segment size selection and fallback mechanisms to ensure feasibility. It balances exploration (random selection) and exploitation (weighted scoring) while maintaining valid TSP tours through validation and a fallback triple bridge move. The weights (0.6, 0.4) emphasize the first objective, and the segment size is dynamically adjusted (between 2 and n/3) to adapt to problem scale.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    weights = [0.6, 0.4]  # More weight on first objective\n    scores = [sum(w * obj for w, obj in zip(weights, solution[1])) for solution in archive]\n    selected_idx = scores.index(min(scores)) if random.random() < 0.7 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(n//3, random.randint(1, n//2)))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size\n\n    # Segment inversion\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Node insertion with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: triple bridge move\n        p, q, r, s, t = sorted(random.sample(range(n), 5))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[s+1:t+1], new_solution[t+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.5965761725340388,
            0.2391446828842163
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (70% average cost, 30% maximum cost) and applies a hybrid local search that combines path reversal (with probability based on segment distance) and adaptive segment swapping (smaller segments with lower probability). It ensures feasibility through fallback mechanisms (3-opt and random segment shuffles) if uniqueness is violated. The method prioritizes diversity and adaptive exploration to navigate the bi-objective TSP landscape efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_scores = [0.7 * (obj[0] + obj[1]) + 0.3 * max(obj[0], obj[1]) for _, obj in archive]\n    base_solution = archive[np.argmax(weighted_scores)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on distance metrics\n    i1, i2 = np.random.choice(n, 2, replace=False)\n    if i1 > i2:\n        i1, i2 = i2, i1\n\n    # Calculate segment distances in both objective spaces\n    def segment_distance(solution, start, end, matrix1, matrix2):\n        d1 = sum(matrix1[solution[i], solution[i+1]] for i in range(start, end))\n        d2 = sum(matrix2[solution[i], solution[i+1]] for i in range(start, end))\n        return d1 + d2\n\n    current_dist = segment_distance(new_solution, i1, i2, distance_matrix_1, distance_matrix_2)\n\n    # Try path reversal with probability based on segment distance\n    if np.random.random() < 0.7 or current_dist > np.mean([segment_distance(new_solution, i, i+1, distance_matrix_1, distance_matrix_2) for i in range(n-1)]):\n        new_solution[i1:i2+1] = new_solution[i1:i2+1][::-1]\n\n    # Adaptive segment swapping\n    if np.random.random() < 0.4:\n        swap_size = min(3, n // 4)\n        pos1, pos2 = np.random.choice(n - swap_size, 2, replace=False)\n        segment1 = new_solution[pos1:pos1+swap_size]\n        segment2 = new_solution[pos2:pos2+swap_size]\n        new_solution[pos1:pos1+swap_size] = segment2\n        new_solution[pos2:pos2+swap_size] = segment1\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Advanced fallback: 3-opt local search\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1]\n        segment3 = new_solution[j+1:k+1]\n        segment4 = new_solution[k+1:]\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Last resort: random shuffle of a segment\n        segment_size = max(2, n // 5)\n        pos = np.random.randint(0, n - segment_size + 1)\n        new_solution[pos:pos+segment_size] = np.random.permutation(new_solution[pos:pos+segment_size])\n\n    return new_solution\n\n",
        "score": [
            -0.9454238497222858,
            0.3994055390357971
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (60% for the first objective, 40% for the second) and applies a hybrid local search: 70% chance of segment relocation (moving a random segment to a new position) and 30% chance of edge swapping (swapping high-cost nodes identified by their edge contributions to both objectives). The selection prioritizes solutions with better combined objective values, while the local search intelligently explores the solution space by targeting high-cost segments or nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Combine edge swapping and segment relocation\n    if np.random.rand() < 0.7:  # 70% chance for segment relocation\n        # Segment relocation\n        start = np.random.randint(0, n)\n        length = np.random.randint(3, min(7, n // 2))\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        if start < end:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n        else:\n            new_solution = np.concatenate([new_solution[end:start], new_solution[start:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:\n        # Edge swapping with high-cost nodes\n        # Calculate node costs based on edge contributions\n        node_costs = np.zeros(n)\n        for i in range(n):\n            prev = i - 1\n            next_node = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[prev], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[next_node]]\n            cost2 = distance_matrix_2[new_solution[prev], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[next_node]]\n            node_costs[i] = cost1 + cost2\n\n        # Select high-cost nodes for swapping\n        high_cost_nodes = np.argsort(node_costs)[-min(3, n//2):]\n        i, j = np.random.choice(high_cost_nodes, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9475014135226745,
            0.476529598236084
        ]
    },
    {
        "algorithm": "The heuristic selects the highest-scoring solution from the archive (sum of both objectives) and applies a hybrid local search that randomly breaks and reverses segments of the tour to explore diverse neighborhoods while ensuring feasibility through validation checks. It prioritizes solutions with combined higher costs to focus improvement efforts and uses a fallback swap if the reinsertion fails. The algorithm balances exploration and exploitation by combining edge manipulation with node reinsertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct edges to break\n    i1, i2 = np.random.choice(n, 2, replace=False)\n    if i1 > i2:\n        i1, i2 = i2, i1\n\n    # Break the edges and reinsert nodes\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:]\n\n    # Combine segments with nodes reinserted\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reinsertion fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9429277113147808,
            0.4586946964263916
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective cost from the archive and applies a hybrid local search operator that randomly relocates a segment of the tour to a new position, ensuring feasibility by maintaining a valid TSP tour structure. The method prioritizes solutions with higher total cost to focus on promising regions of the search space, while the segment relocation strategy introduces diversity by disrupting and reinserting sub-tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge insertion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Remove the segment\n    if start < end:\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        new_solution = np.concatenate([new_solution[end:start], new_solution[start:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8550530386352858,
            0.4085387587547302
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge insertion and segment reversal, ensuring feasibility by validating the new solution. It prioritizes larger segments for reversal/insertion to maximize improvement potential, with a fallback to simple swaps if needed. The method balances exploration (random selection) with exploitation (targeted segment operations) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        new_solution = np.concatenate([base_solution[:i], segment[::-1], base_solution[j:]])\n\n    # Segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = base_solution[a:b]\n        new_solution = np.concatenate([base_solution[:a], segment[::-1], base_solution[b:]])\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if above fails\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8760701871960721,
            0.44710928201675415
        ]
    }
]