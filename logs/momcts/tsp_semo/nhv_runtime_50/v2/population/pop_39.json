[
    {
        "algorithm": "The algorithm selects the solution with the highest sum of normalized objectives from the archive, applies a hybrid local search combining segment reversal and node reinsertion, and falls back to a 3-opt move if the primary operation fails, ensuring feasibility through validation checks. The selection prioritizes solutions with high combined objective values, while the local search explores diverse neighborhood structures to escape local optima. The fallback mechanism maintains solution validity when the primary operation would violate constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -float('inf')\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        norm_cost1 = cost1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_cost2 = cost2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        total = norm_cost1 + norm_cost2\n        if total > max_sum:\n            max_sum = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multiple node reinsertion\n    # Select 3 distinct positions\n    i1, i2, i3 = np.random.choice(n, 3, replace=False)\n    i1, i2, i3 = sorted([i1, i2, i3])\n\n    # Break and reverse segments\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:i3+1]\n    segment4 = new_solution[i3+1:]\n\n    # Reinsert nodes in different orders\n    new_solution = np.concatenate([\n        segment1,\n        segment3[::-1],\n        segment2[::-1],\n        segment4\n    ])\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move if primary operation fails\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.0048094662706575,
            1.2336682081222534
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines partial path reversal with node reinsertion to generate a neighbor. It ensures feasibility by validating the new solution and falling back to a weighted swap or segment shift if needed. The selection prioritizes solutions with lower weighted objective values, while the local search explores diverse neighborhood structures through random segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weights /= weights.sum()\n    scores = objectives @ weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid operator: partial reversal + reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        reinsert_pos = random.randint(0, n-1)\n        if reinsert_pos >= i and reinsert_pos < j:\n            reinsert_pos = (j + random.randint(1, n-1)) % n\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:reinsert_pos],\n            segment[::-1],\n            base_solution[reinsert_pos:]\n        ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted edge swap\n        k, l = random.sample(range(n), 2)\n        if random.random() < 0.7:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            # Partial segment shift\n            shift = random.randint(1, min(3, n//2))\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7071533583038947,
            0.23351401090621948
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining node relocation and segment rotation, prioritizing larger segments for potential improvements while ensuring feasibility through validation and fallback mechanisms like the double bridge move. It emphasizes randomness in segment selection and rotation while maintaining tour validity through checks and fallback operations. The approach balances exploration (random selection) with exploitation (focus on larger segments) while ensuring all generated solutions are feasible TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (Pareto dominance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Node relocation with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.885361404984967,
            0.24587023258209229
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using knee-point detection to identify Pareto-front solutions, then applies a dynamic hybrid local search that alternates between segment reversal and edge-breaking, with operator probabilities adjusted based on recent objective improvements, ensuring feasibility through validation and fallback to a double-bridge move if invalid. The algorithm prioritizes exploration of underperforming objectives while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a knee-point solution (Pareto-aware)\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic hybrid local search\n    if n < 4:\n        return new_solution\n\n    # Segment reversal with edge-breaking\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n        # Edge-breaking: insert a new edge by splitting a segment\n        if random.random() < 0.5 and len(segment) > 2:\n            split_pos = random.randint(1, len(segment)-1)\n            split_node = segment[split_pos]\n            new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9795087266408445,
            0.3194284439086914
        ]
    },
    {
        "algorithm": "The heuristic algorithm combines Pareto knee-point selection with a dynamic hybrid local search that adaptively applies segment reversal, edge-breaking, and reinsertion operators, prioritizing segments with high combined cost in both objectives. Operator probabilities are adjusted based on cost improvements, and feasibility is maintained through validation checks with a fallback double-bridge move. The algorithm balances exploration and exploitation by dynamically focusing on promising regions of the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto knee-point selection\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        if len(objectives) == 1:\n            return 0\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Initialize operator probabilities\n    operator_probs = {'reversal': 0.5, 'edge_break': 0.3, 'reinsert': 0.2}\n\n    def update_probs(delta_cost1, delta_cost2):\n        if abs(delta_cost1) > 2 * abs(delta_cost2):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['edge_break'] = min(0.8, operator_probs['edge_break'] + 0.1)\n        elif abs(delta_cost2) > 2 * abs(delta_cost1):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['reinsert'] = min(0.8, operator_probs['reinsert'] + 0.1)\n        else:\n            operator_probs['reversal'] = 0.5\n            operator_probs['edge_break'] = 0.3\n            operator_probs['reinsert'] = 0.2\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Find the most expensive segment in both objectives\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    # Apply selected operator\n    operator = np.random.choice(list(operator_probs.keys()), p=list(operator_probs.values()))\n\n    if operator == 'reversal':\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    elif operator == 'edge_break':\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            split_pos = np.random.randint(1, len(segment))\n            new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    elif operator == 'reinsert':\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Update operator probabilities based on cost changes\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    delta_cost1 = original_cost1 - new_cost1\n    delta_cost2 = original_cost2 - new_cost2\n    update_probs(delta_cost1, delta_cost2)\n\n    return new_solution\n\n",
        "score": [
            -1.0100062046089116,
            1.3371556997299194
        ]
    },
    {
        "algorithm": "The algorithm selects a knee-point solution from the archive, applies an adaptive hybrid local search combining segment reversal, distance-weighted reinsertion, and edge-breaking operators with probabilities adjusted based on recent objective improvements, and ensures feasibility through validation or falls back to a double-bridge move if invalid. The method prioritizes operators that show higher improvement potential (e.g., segment reversal for larger improvements) while dynamically balancing exploration of different move types.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective improvements\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n                sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]])\n\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    # Adaptive operator probabilities\n    p_reverse = 0.5 + 0.3 * max(improvement1, improvement2)\n    p_reinsert = 0.3 + 0.2 * min(improvement1, improvement2)\n    p_break = 0.2 + 0.3 * (improvement1 - improvement2)\n\n    # Apply operators based on probabilities\n    if np.random.rand() < p_reverse:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n    if np.random.rand() < p_reinsert:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    if np.random.rand() < p_break:\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9952013831204587,
            0.43374723196029663
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective score (prioritizing the first objective) and applies a hybrid local search combining segment inversion and node insertion, with adaptive segment size selection and fallback mechanisms to ensure feasibility. It balances exploration (random selection) and exploitation (weighted scoring) while maintaining valid TSP tours through validation and a fallback triple bridge move. The weights (0.6, 0.4) emphasize the first objective, and the segment size is dynamically adjusted (between 2 and n/3) to adapt to problem scale.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    weights = [0.6, 0.4]  # More weight on first objective\n    scores = [sum(w * obj for w, obj in zip(weights, solution[1])) for solution in archive]\n    selected_idx = scores.index(min(scores)) if random.random() < 0.7 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(n//3, random.randint(1, n//2)))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size\n\n    # Segment inversion\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Node insertion with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: triple bridge move\n        p, q, r, s, t = sorted(random.sample(range(n), 5))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[s+1:t+1], new_solution[t+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.5965761725340388,
            0.2391446828842163
        ]
    },
    {
        "algorithm": "The algorithm selects the worst-performing solution from the archive (highest combined objective value) and applies a hybrid local search: it first reverses the worst-performing segment in the tour with a probability inversely proportional to its cost, then inserts a randomly selected node into the best position that improves both objectives, ensuring feasibility through validation checks and fallback mechanisms. The method prioritizes high-cost segments for reversal and targeted node insertions for improvement, with a fallback to simple swaps if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Step 1: Identify the worst segment to reverse\n    worst_segment_start = 0\n    worst_segment_length = 2\n    worst_segment_cost = float('inf')\n\n    for i in range(n):\n        for length in range(2, min(5, n // 2) + 1):\n            segment_end = (i + length) % n\n            if i < segment_end:\n                segment = new_solution[i:segment_end]\n            else:\n                segment = np.concatenate([new_solution[i:], new_solution[:segment_end]])\n\n            # Calculate the cost of the segment in both objectives\n            cost1 = 0\n            cost2 = 0\n            for j in range(len(segment) - 1):\n                cost1 += distance_matrix_1[segment[j], segment[j+1]]\n                cost2 += distance_matrix_2[segment[j], segment[j+1]]\n            cost1 += distance_matrix_1[segment[-1], segment[0]]  # Close the loop\n            cost2 += distance_matrix_2[segment[-1], segment[0]]\n\n            total_cost = cost1 + cost2\n            if total_cost < worst_segment_cost:\n                worst_segment_cost = total_cost\n                worst_segment_start = i\n                worst_segment_length = length\n\n    # Reverse the worst segment with probability inversely proportional to its cost\n    if worst_segment_cost > 0:\n        if np.random.random() < (1 / worst_segment_cost):\n            segment_end = (worst_segment_start + worst_segment_length) % n\n            if worst_segment_start < segment_end:\n                new_solution[worst_segment_start:segment_end] = new_solution[worst_segment_start:segment_end][::-1]\n            else:\n                segment = np.concatenate([new_solution[worst_segment_start:], new_solution[:segment_end]])\n                segment = segment[::-1]\n                new_solution = np.concatenate([segment[:n - worst_segment_start], segment[n - worst_segment_start:]])\n\n    # Step 2: Insert a random node to the best position\n    node_to_insert = np.random.choice(new_solution)\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == np.where(new_solution == node_to_insert)[0][0]:\n            continue\n\n        # Temporarily remove the node\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n\n        # Insert at position pos\n        temp_solution = np.insert(temp_solution, pos, node_to_insert)\n\n        # Calculate improvement in both objectives\n        prev_node = temp_solution[pos - 1]\n        next_node = temp_solution[(pos + 1) % len(temp_solution)]\n\n        old_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        new_cost1 = distance_matrix_1[prev_node, next_node]\n\n        old_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n        new_cost2 = distance_matrix_2[prev_node, next_node]\n\n        improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        # Remove the node from its original position\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if above fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0025640243115461,
            2.070936441421509
        ]
    },
    {
        "algorithm": "The algorithm selects a knee-point solution from the archive (a promising trade-off between objectives) and applies a dynamic hybrid local search combining segment reversal, edge-breaking, and node reinsertion, with operator probabilities adjusted based on recent improvements, while ensuring feasibility through validation and fallback mechanisms like the double bridge move. The operator weights prioritize reversal (0.5), followed by edge-breaking (0.3) and reinsertion (0.2), with a fallback to the double bridge move if feasibility is violated. The solution is represented as a TSP tour, and the algorithm ensures no node is skipped or revisited.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select knee-point solution\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    operator_weights = [0.5, 0.3, 0.2]  # [reversal, edge-breaking, reinsertion]\n\n    # Segment reversal\n    if random.random() < operator_weights[0]:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n    # Edge-breaking\n    elif random.random() < operator_weights[1]:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            split_pos = random.randint(1, len(new_solution[a:b])-1)\n            split_node = new_solution[a+split_pos]\n            new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Node reinsertion\n    else:\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8105685826696782,
            0.3678407073020935
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto knee-point selection with a dynamic, multi-phase local search that alternates between bi-objective edge-breaking, adaptive segment inversion, triple-segment rotation, and bi-objective-aware edge swaps, using weighted operator selection based on recent improvement ratios and ensuring feasibility through a multi-stage fallback mechanism. It prioritizes knee-point solutions for exploration and adapts operator weights based on simulated improvement checks, with edge-breaking and segment inversion receiving higher initial weights.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto knee-point selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    knee_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[knee_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Bi-objective improvement tracking\n    last_improvements = [1.0, 1.0]  # Initialize with equal weights\n\n    # Dynamic operator selection weights\n    operator_weights = [0.4, 0.3, 0.2, 0.1]  # edge_break, segment_invert, triple_rotate, edge_swap\n\n    # Phase 1: Bi-objective edge-breaking\n    if random.random() < operator_weights[0]:\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        # Update weights based on improvement\n        if random.random() < 0.3:  # Simulate improvement check\n            last_improvements[0] *= 1.1\n            operator_weights[0] = min(0.6, operator_weights[0] * 1.1)\n\n    # Phase 2: Adaptive segment inversion\n    elif random.random() < operator_weights[1]:\n        segment_size = max(2, min(n//3, random.randint(1, n//2)))\n        a = random.randint(0, n - segment_size)\n        b = a + segment_size\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        if random.random() < 0.3:  # Simulate improvement check\n            last_improvements[1] *= 1.1\n            operator_weights[1] = min(0.5, operator_weights[1] * 1.1)\n\n    # Phase 3: Triple-segment rotation\n    elif random.random() < operator_weights[2]:\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution = np.concatenate([\n            new_solution[:a], new_solution[b:c], new_solution[a:b],\n            new_solution[c:], new_solution[c:b], new_solution[b:c]\n        ])\n\n    # Phase 4: Bi-objective edge swap\n    else:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility validation and fallback\n    if len(np.unique(new_solution)) != n:\n        # Multi-stage fallback\n        if n >= 5:\n            # Triple bridge move\n            p, q, r, s, t = sorted(random.sample(range(n), 5))\n            new_solution = np.concatenate([\n                new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n                new_solution[r+1:s+1], new_solution[s+1:t+1], new_solution[t+1:]\n            ])\n        else:\n            # Simple swap fallback\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Normalize operator weights\n    total = sum(operator_weights)\n    operator_weights = [w/total for w in operator_weights]\n\n    return new_solution\n\n",
        "score": [
            -0.9928194279234791,
            0.44651901721954346
        ]
    }
]