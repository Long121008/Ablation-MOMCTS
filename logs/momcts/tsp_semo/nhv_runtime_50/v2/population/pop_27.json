[
    {
        "algorithm": "The algorithm selects the solution with the highest sum of normalized objectives from the archive, applies a hybrid local search combining segment reversal and node reinsertion, and falls back to a 3-opt move if the primary operation fails, ensuring feasibility through validation checks. The selection prioritizes solutions with high combined objective values, while the local search explores diverse neighborhood structures to escape local optima. The fallback mechanism maintains solution validity when the primary operation would violate constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -float('inf')\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        norm_cost1 = cost1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_cost2 = cost2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        total = norm_cost1 + norm_cost2\n        if total > max_sum:\n            max_sum = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multiple node reinsertion\n    # Select 3 distinct positions\n    i1, i2, i3 = np.random.choice(n, 3, replace=False)\n    i1, i2, i3 = sorted([i1, i2, i3])\n\n    # Break and reverse segments\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:i3+1]\n    segment4 = new_solution[i3+1:]\n\n    # Reinsert nodes in different orders\n    new_solution = np.concatenate([\n        segment1,\n        segment3[::-1],\n        segment2[::-1],\n        segment4\n    ])\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move if primary operation fails\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.0048094662706575,
            1.2336682081222534
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines partial path reversal with node reinsertion to generate a neighbor. It ensures feasibility by validating the new solution and falling back to a weighted swap or segment shift if needed. The selection prioritizes solutions with lower weighted objective values, while the local search explores diverse neighborhood structures through random segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weights /= weights.sum()\n    scores = objectives @ weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid operator: partial reversal + reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        reinsert_pos = random.randint(0, n-1)\n        if reinsert_pos >= i and reinsert_pos < j:\n            reinsert_pos = (j + random.randint(1, n-1)) % n\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:reinsert_pos],\n            segment[::-1],\n            base_solution[reinsert_pos:]\n        ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted edge swap\n        k, l = random.sample(range(n), 2)\n        if random.random() < 0.7:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            # Partial segment shift\n            shift = random.randint(1, min(3, n//2))\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7071533583038947,
            0.23351401090621948
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining node relocation and segment rotation, prioritizing larger segments for potential improvements while ensuring feasibility through validation and fallback mechanisms like the double bridge move. It emphasizes randomness in segment selection and rotation while maintaining tour validity through checks and fallback operations. The approach balances exploration (random selection) with exploitation (focus on larger segments) while ensuring all generated solutions are feasible TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (Pareto dominance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Node relocation with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.885361404984967,
            0.24587023258209229
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using knee-point detection to identify Pareto-front solutions, then applies a dynamic hybrid local search that alternates between segment reversal and edge-breaking, with operator probabilities adjusted based on recent objective improvements, ensuring feasibility through validation and fallback to a double-bridge move if invalid. The algorithm prioritizes exploration of underperforming objectives while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a knee-point solution (Pareto-aware)\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic hybrid local search\n    if n < 4:\n        return new_solution\n\n    # Segment reversal with edge-breaking\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n        # Edge-breaking: insert a new edge by splitting a segment\n        if random.random() < 0.5 and len(segment) > 2:\n            split_pos = random.randint(1, len(segment)-1)\n            split_node = segment[split_pos]\n            new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9795087266408445,
            0.3194284439086914
        ]
    },
    {
        "algorithm": "The heuristic algorithm combines Pareto knee-point selection with a dynamic hybrid local search that adaptively applies segment reversal, edge-breaking, and reinsertion operators, prioritizing segments with high combined cost in both objectives. Operator probabilities are adjusted based on cost improvements, and feasibility is maintained through validation checks with a fallback double-bridge move. The algorithm balances exploration and exploitation by dynamically focusing on promising regions of the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto knee-point selection\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        if len(objectives) == 1:\n            return 0\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Initialize operator probabilities\n    operator_probs = {'reversal': 0.5, 'edge_break': 0.3, 'reinsert': 0.2}\n\n    def update_probs(delta_cost1, delta_cost2):\n        if abs(delta_cost1) > 2 * abs(delta_cost2):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['edge_break'] = min(0.8, operator_probs['edge_break'] + 0.1)\n        elif abs(delta_cost2) > 2 * abs(delta_cost1):\n            operator_probs['reversal'] = max(0.1, operator_probs['reversal'] - 0.1)\n            operator_probs['reinsert'] = min(0.8, operator_probs['reinsert'] + 0.1)\n        else:\n            operator_probs['reversal'] = 0.5\n            operator_probs['edge_break'] = 0.3\n            operator_probs['reinsert'] = 0.2\n\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Find the most expensive segment in both objectives\n    def segment_cost(start, length):\n        end = (start + length) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(len(segment)):\n            next_idx = (i + 1) % len(segment)\n            cost1 += distance_matrix_1[segment[i], segment[next_idx]]\n            cost2 += distance_matrix_2[segment[i], segment[next_idx]]\n        return cost1, cost2\n\n    max_cost = -1\n    best_start = 0\n    best_length = 2\n    for length in range(2, min(6, n // 2)):\n        for start in range(n):\n            cost1, cost2 = segment_cost(start, length)\n            total_cost = cost1 + cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                best_start = start\n                best_length = length\n\n    # Apply selected operator\n    operator = np.random.choice(list(operator_probs.keys()), p=list(operator_probs.values()))\n\n    if operator == 'reversal':\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    elif operator == 'edge_break':\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            split_pos = np.random.randint(1, len(segment))\n            new_solution = np.concatenate([new_solution[:a], segment[:split_pos], segment[split_pos:], new_solution[b:]])\n\n    elif operator == 'reinsert':\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Update operator probabilities based on cost changes\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    delta_cost1 = original_cost1 - new_cost1\n    delta_cost2 = original_cost2 - new_cost2\n    update_probs(delta_cost1, delta_cost2)\n\n    return new_solution\n\n",
        "score": [
            -1.0100062046089116,
            1.3371556997299194
        ]
    },
    {
        "algorithm": "The algorithm selects a knee-point solution from the archive, applies an adaptive hybrid local search combining segment reversal, distance-weighted reinsertion, and edge-breaking operators with probabilities adjusted based on recent objective improvements, and ensures feasibility through validation or falls back to a double-bridge move if invalid. The method prioritizes operators that show higher improvement potential (e.g., segment reversal for larger improvements) while dynamically balancing exploration of different move types.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective improvements\n    prev_obj = archive[selected_idx][1]\n    curr_obj = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n                sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]])\n\n    improvement1 = (prev_obj[0] - curr_obj[0]) / (prev_obj[0] + 1e-8)\n    improvement2 = (prev_obj[1] - curr_obj[1]) / (prev_obj[1] + 1e-8)\n\n    # Adaptive operator probabilities\n    p_reverse = 0.5 + 0.3 * max(improvement1, improvement2)\n    p_reinsert = 0.3 + 0.2 * min(improvement1, improvement2)\n    p_break = 0.2 + 0.3 * (improvement1 - improvement2)\n\n    # Apply operators based on probabilities\n    if np.random.rand() < p_reverse:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n    if np.random.rand() < p_reinsert:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    if np.random.rand() < p_break:\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9952013831204587,
            0.43374723196029663
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective score (prioritizing the first objective) and applies a hybrid local search combining segment inversion and node insertion, with adaptive segment size selection and fallback mechanisms to ensure feasibility. It balances exploration (random selection) and exploitation (weighted scoring) while maintaining valid TSP tours through validation and a fallback triple bridge move. The weights (0.6, 0.4) emphasize the first objective, and the segment size is dynamically adjusted (between 2 and n/3) to adapt to problem scale.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    weights = [0.6, 0.4]  # More weight on first objective\n    scores = [sum(w * obj for w, obj in zip(weights, solution[1])) for solution in archive]\n    selected_idx = scores.index(min(scores)) if random.random() < 0.7 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(n//3, random.randint(1, n//2)))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size\n\n    # Segment inversion\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Node insertion with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: triple bridge move\n        p, q, r, s, t = sorted(random.sample(range(n), 5))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[s+1:t+1], new_solution[t+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.5965761725340388,
            0.2391446828842163
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on normalized weighted costs, then applies a hybrid local search that alternates between an edge-swapping operator with lookahead (60% chance) and a segment insertion operator (40% chance), prioritizing edges/segments with higher weighted costs while ensuring feasibility. It falls back to a weighted random swap if needed, using node degrees to guide the swap. The weighted objectives dynamically adjust based on relative costs, balancing improvements in both spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized weighted cost\n    max_cost = -float('inf')\n    selected_solution = None\n    for sol, (cost1, cost2) in archive:\n        normalized_cost = (cost1 - np.min([c[1][0] for c in archive])) / (np.max([c[1][0] for c in archive]) - np.min([c[1][0] for c in archive])) + \\\n                         (cost2 - np.min([c[1][1] for c in archive])) / (np.max([c[1][1] for c in archive]) - np.min([c[1][1] for c in archive]))\n        if normalized_cost > max_cost:\n            max_cost = normalized_cost\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative costs with normalization\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    weight1 = total_cost1 / (total_cost1 + total_cost2) if (total_cost1 + total_cost2) > 0 else 0.5\n    weight2 = 1 - weight1\n\n    # Decide operator based on weighted objectives\n    if random.random() < 0.6:  # 60% chance for edge-swapping with lookahead\n        # Select edges with high weighted cost\n        edge_costs = []\n        for i in range(n):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            edge_costs.append(weight1 * cost1 + weight2 * cost2)\n\n        if edge_costs:\n            worst_edge = np.argmax(edge_costs)\n            # Perform edge-swapping with lookahead\n            a, b = new_solution[worst_edge], new_solution[(worst_edge+1)%n]\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(n):\n                if i == worst_edge or i == (worst_edge+1)%n or i == (worst_edge-1)%n:\n                    continue\n                # Try swapping with node i\n                temp = new_solution.copy()\n                temp[worst_edge], temp[i] = temp[i], temp[worst_edge]\n                # Calculate new cost with lookahead\n                temp_cost = sum(distance_matrix_1[temp[j], temp[(j+1)%n]] for j in range(n)) * weight1 + \\\n                           sum(distance_matrix_2[temp[j], temp[(j+1)%n]] for j in range(n)) * weight2\n                if temp_cost < best_cost:\n                    best_cost = temp_cost\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution[worst_edge], new_solution[best_pos] = new_solution[best_pos], new_solution[worst_edge]\n    else:  # 40% chance for segment insertion\n        # Select high-cost segment and insert elsewhere\n        segment_costs = []\n        for i in range(n):\n            for j in range(i+2, min(i+n-1, i+6)):  # Max segment size 5\n                segment = new_solution[i:j] if i < j else np.concatenate([new_solution[i:], new_solution[:j]])\n                cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))) * weight1 + \\\n                       sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))) * weight2\n                segment_costs.append((cost, i, j))\n\n        if segment_costs:\n            worst_segment = max(segment_costs, key=lambda x: x[0])\n            i, j = worst_segment[1], worst_segment[2]\n            if i < j:\n                segment = new_solution[i:j]\n                # Remove segment and find best insertion point\n                temp_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n                best_pos = -1\n                best_cost = float('inf')\n                for pos in range(len(temp_solution)):\n                    # Try inserting segment at position pos\n                    new_temp = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n                    temp_cost = sum(distance_matrix_1[new_temp[k], new_temp[(k+1)%n]] for k in range(n)) * weight1 + \\\n                               sum(distance_matrix_2[new_temp[k], new_temp[(k+1)%n]] for k in range(n)) * weight2\n                    if temp_cost < best_cost:\n                        best_cost = temp_cost\n                        best_pos = pos\n                if best_pos != -1:\n                    new_solution = np.concatenate([temp_solution[:best_pos], segment, temp_solution[best_pos:]])\n            else:\n                segment = np.concatenate([new_solution[i:], new_solution[:j]])\n                temp_solution = np.concatenate([new_solution[j:i]])\n                best_pos = -1\n                best_cost = float('inf')\n                for pos in range(len(temp_solution)):\n                    new_temp = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n                    temp_cost = sum(distance_matrix_1[new_temp[k], new_temp[(k+1)%n]] for k in range(n)) * weight1 + \\\n                               sum(distance_matrix_2[new_temp[k], new_temp[(k+1)%n]] for k in range(n)) * weight2\n                    if temp_cost < best_cost:\n                        best_cost = temp_cost\n                        best_pos = pos\n                if best_pos != -1:\n                    new_solution = np.concatenate([temp_solution[:best_pos], segment, temp_solution[best_pos:]])\n\n    # Fallback to weighted random swap if above fails\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n        k, l = random.sample(range(n), 2)\n        # Weighted random swap based on node degrees\n        degree1_k = sum(distance_matrix_1[k] > 0)\n        degree1_l = sum(distance_matrix_1[l] > 0)\n        degree2_k = sum(distance_matrix_2[k] > 0)\n        degree2_l = sum(distance_matrix_2[l] > 0)\n        if (weight1 * (degree1_k + degree1_l) + weight2 * (degree2_k + degree2_l)) > random.random():\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.9879915104852854,
            11.923007309436798
        ]
    },
    {
        "algorithm": "This heuristic combines Pareto knee-point selection with a dynamic hybrid local search that adaptively applies segment reversal, edge-breaking, and reinsertion operators, prioritizing high-cost segments/nodes in both objectives while maintaining feasibility through multi-stage validation and fallback mechanisms. The operator probabilities are adjusted based on objective improvement, and the algorithm emphasizes distance-weighted selection to focus on the most promising regions of the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto knee-point selection\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate current objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Dynamic operator probabilities based on objective improvement\n    improvement1 = original_cost1 / (archive[selected_idx][1][0] + 1e-8)\n    improvement2 = original_cost2 / (archive[selected_idx][1][1] + 1e-8)\n\n    p_reverse = 0.5 + 0.3 * max(improvement1, improvement2)\n    p_break = 0.3 + 0.2 * min(improvement1, improvement2)\n    p_reinsert = 0.2 + 0.3 * abs(improvement1 - improvement2)\n\n    # Segment reversal with distance-weighted selection\n    if np.random.rand() < p_reverse:\n        # Select segment with highest combined distance in both objectives\n        max_cost = -1\n        best_start = 0\n        best_length = 2\n        for length in range(2, min(6, n//2)):\n            for start in range(n):\n                segment = new_solution[start:start+length] if start+length < n else np.concatenate([new_solution[start:], new_solution[:start+length-n]])\n                cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%length]] for i in range(length))\n                cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%length]] for i in range(length))\n                total_cost = cost1 + cost2\n                if total_cost > max_cost:\n                    max_cost = total_cost\n                    best_start = start\n                    best_length = length\n\n        start = best_start\n        length = best_length\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    # Distance-weighted edge-breaking\n    if np.random.rand() < p_break:\n        # Select edges with highest combined distance in both objectives\n        max_edge_cost = -1\n        best_edge = (0, 1)\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if cost1 + cost2 > max_edge_cost:\n                max_edge_cost = cost1 + cost2\n                best_edge = (i, j)\n\n        i, j = best_edge\n        if j - i > 1:\n            segment = new_solution[i:j]\n            split_pos = np.random.randint(1, len(segment))\n            new_solution = np.concatenate([new_solution[:i], segment[:split_pos], segment[split_pos:], new_solution[j:]])\n\n    # Objective-aware reinsertion\n    if np.random.rand() < p_reinsert:\n        # Select node with highest combined distance in both objectives\n        max_node_cost = -1\n        best_node = 0\n        for i in range(n):\n            prev = (i - 1) % n\n            next = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[prev], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[next]]\n            cost2 = distance_matrix_2[new_solution[prev], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[next]]\n            if cost1 + cost2 > max_node_cost:\n                max_node_cost = cost1 + cost2\n                best_node = i\n\n        i = best_node\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Multi-stage feasibility validation\n    if len(np.unique(new_solution)) != n:\n        # First fallback: double bridge move\n        p, q, r, s = sorted(np.random.choice(n, 4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n        if len(np.unique(new_solution)) != n:\n            # Second fallback: random swap\n            k, l = np.random.choice(n, 2, replace=False)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n            if len(np.unique(new_solution)) != n:\n                # Final fallback: reset to base solution\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9756702314278806,
            1.2406156659126282
        ]
    },
    {
        "algorithm": "The algorithm selects a knee-point solution from the archive (a promising trade-off between objectives) and applies a dynamic hybrid local search combining segment reversal, edge-breaking, and node reinsertion, with operator probabilities adjusted based on recent improvements, while ensuring feasibility through validation and fallback mechanisms like the double bridge move. The operator weights prioritize reversal (0.5), followed by edge-breaking (0.3) and reinsertion (0.2), with a fallback to the double bridge move if feasibility is violated. The solution is represented as a TSP tour, and the algorithm ensures no node is skipped or revisited.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select knee-point solution\n    def knee_point(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.sqrt(np.sum((normalized - (normalized.min(axis=0) + normalized.max(axis=0))) ** 2, axis=1))\n        return np.argmin(distances)\n\n    selected_idx = knee_point(archive)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    operator_weights = [0.5, 0.3, 0.2]  # [reversal, edge-breaking, reinsertion]\n\n    # Segment reversal\n    if random.random() < operator_weights[0]:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n    # Edge-breaking\n    elif random.random() < operator_weights[1]:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            split_pos = random.randint(1, len(new_solution[a:b])-1)\n            split_node = new_solution[a+split_pos]\n            new_solution = np.concatenate([new_solution[:a+split_pos], [split_node], new_solution[a+split_pos:]])\n\n    # Node reinsertion\n    else:\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8105685826696782,
            0.3678407073020935
        ]
    }
]